// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    // SequencedDatumType
    //

    const SequencedDatumType::SimpleDatum_optional& SequencedDatumType::
    SimpleDatum () const
    {
      return this->SimpleDatum_;
    }

    SequencedDatumType::SimpleDatum_optional& SequencedDatumType::
    SimpleDatum ()
    {
      return this->SimpleDatum_;
    }

    void SequencedDatumType::
    SimpleDatum (const SimpleDatum_type& x)
    {
      this->SimpleDatum_.set (x);
    }

    void SequencedDatumType::
    SimpleDatum (const SimpleDatum_optional& x)
    {
      this->SimpleDatum_ = x;
    }

    void SequencedDatumType::
    SimpleDatum (::std::unique_ptr< SimpleDatum_type > x)
    {
      this->SimpleDatum_.set (std::move (x));
    }

    const SequencedDatumType::CompoundDatum_optional& SequencedDatumType::
    CompoundDatum () const
    {
      return this->CompoundDatum_;
    }

    SequencedDatumType::CompoundDatum_optional& SequencedDatumType::
    CompoundDatum ()
    {
      return this->CompoundDatum_;
    }

    void SequencedDatumType::
    CompoundDatum (const CompoundDatum_type& x)
    {
      this->CompoundDatum_.set (x);
    }

    void SequencedDatumType::
    CompoundDatum (const CompoundDatum_optional& x)
    {
      this->CompoundDatum_ = x;
    }

    void SequencedDatumType::
    CompoundDatum (::std::unique_ptr< CompoundDatum_type > x)
    {
      this->CompoundDatum_.set (std::move (x));
    }

    const SequencedDatumType::SequenceNumber_type& SequencedDatumType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    SequencedDatumType::SequenceNumber_type& SequencedDatumType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void SequencedDatumType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void SequencedDatumType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // CompoundDatumType
    //

    const CompoundDatumType::Datum_sequence& CompoundDatumType::
    Datum () const
    {
      return this->Datum_;
    }

    CompoundDatumType::Datum_sequence& CompoundDatumType::
    Datum ()
    {
      return this->Datum_;
    }

    void CompoundDatumType::
    Datum (const Datum_sequence& s)
    {
      this->Datum_ = s;
    }

    const CompoundDatumType::ReducedDatum_optional& CompoundDatumType::
    ReducedDatum () const
    {
      return this->ReducedDatum_;
    }

    CompoundDatumType::ReducedDatum_optional& CompoundDatumType::
    ReducedDatum ()
    {
      return this->ReducedDatum_;
    }

    void CompoundDatumType::
    ReducedDatum (const ReducedDatum_type& x)
    {
      this->ReducedDatum_.set (x);
    }

    void CompoundDatumType::
    ReducedDatum (const ReducedDatum_optional& x)
    {
      this->ReducedDatum_ = x;
    }

    void CompoundDatumType::
    ReducedDatum (::std::unique_ptr< ReducedDatum_type > x)
    {
      this->ReducedDatum_.set (std::move (x));
    }

    const CompoundDatumType::n_type& CompoundDatumType::
    n () const
    {
      return this->n_.get ();
    }

    CompoundDatumType::n_type& CompoundDatumType::
    n ()
    {
      return this->n_.get ();
    }

    void CompoundDatumType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CompoundDatumType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DatumWithPrecedenceType
    //

    const DatumWithPrecedenceType::SimpleDatum_optional& DatumWithPrecedenceType::
    SimpleDatum () const
    {
      return this->SimpleDatum_;
    }

    DatumWithPrecedenceType::SimpleDatum_optional& DatumWithPrecedenceType::
    SimpleDatum ()
    {
      return this->SimpleDatum_;
    }

    void DatumWithPrecedenceType::
    SimpleDatum (const SimpleDatum_type& x)
    {
      this->SimpleDatum_.set (x);
    }

    void DatumWithPrecedenceType::
    SimpleDatum (const SimpleDatum_optional& x)
    {
      this->SimpleDatum_ = x;
    }

    void DatumWithPrecedenceType::
    SimpleDatum (::std::unique_ptr< SimpleDatum_type > x)
    {
      this->SimpleDatum_.set (std::move (x));
    }

    const DatumWithPrecedenceType::NominalDatumFeature_optional& DatumWithPrecedenceType::
    NominalDatumFeature () const
    {
      return this->NominalDatumFeature_;
    }

    DatumWithPrecedenceType::NominalDatumFeature_optional& DatumWithPrecedenceType::
    NominalDatumFeature ()
    {
      return this->NominalDatumFeature_;
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (const NominalDatumFeature_type& x)
    {
      this->NominalDatumFeature_.set (x);
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (const NominalDatumFeature_optional& x)
    {
      this->NominalDatumFeature_ = x;
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (::std::unique_ptr< NominalDatumFeature_type > x)
    {
      this->NominalDatumFeature_.set (std::move (x));
    }

    const DatumWithPrecedenceType::MeasuredDatumFeature_optional& DatumWithPrecedenceType::
    MeasuredDatumFeature () const
    {
      return this->MeasuredDatumFeature_;
    }

    DatumWithPrecedenceType::MeasuredDatumFeature_optional& DatumWithPrecedenceType::
    MeasuredDatumFeature ()
    {
      return this->MeasuredDatumFeature_;
    }

    void DatumWithPrecedenceType::
    MeasuredDatumFeature (const MeasuredDatumFeature_type& x)
    {
      this->MeasuredDatumFeature_.set (x);
    }

    void DatumWithPrecedenceType::
    MeasuredDatumFeature (const MeasuredDatumFeature_optional& x)
    {
      this->MeasuredDatumFeature_ = x;
    }

    void DatumWithPrecedenceType::
    MeasuredDatumFeature (::std::unique_ptr< MeasuredDatumFeature_type > x)
    {
      this->MeasuredDatumFeature_.set (std::move (x));
    }

    const DatumWithPrecedenceType::CompoundDatum_optional& DatumWithPrecedenceType::
    CompoundDatum () const
    {
      return this->CompoundDatum_;
    }

    DatumWithPrecedenceType::CompoundDatum_optional& DatumWithPrecedenceType::
    CompoundDatum ()
    {
      return this->CompoundDatum_;
    }

    void DatumWithPrecedenceType::
    CompoundDatum (const CompoundDatum_type& x)
    {
      this->CompoundDatum_.set (x);
    }

    void DatumWithPrecedenceType::
    CompoundDatum (const CompoundDatum_optional& x)
    {
      this->CompoundDatum_ = x;
    }

    void DatumWithPrecedenceType::
    CompoundDatum (::std::unique_ptr< CompoundDatum_type > x)
    {
      this->CompoundDatum_.set (std::move (x));
    }

    const DatumWithPrecedenceType::Precedence_type& DatumWithPrecedenceType::
    Precedence () const
    {
      return this->Precedence_.get ();
    }

    DatumWithPrecedenceType::Precedence_type& DatumWithPrecedenceType::
    Precedence ()
    {
      return this->Precedence_.get ();
    }

    void DatumWithPrecedenceType::
    Precedence (const Precedence_type& x)
    {
      this->Precedence_.set (x);
    }

    void DatumWithPrecedenceType::
    Precedence (::std::unique_ptr< Precedence_type > x)
    {
      this->Precedence_.set (std::move (x));
    }


    // DatumType
    //

    const DatumType::DatumDefinitionId_type& DatumType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    DatumType::DatumDefinitionId_type& DatumType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void DatumType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void DatumType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }

    const DatumType::MaterialModifier_type& DatumType::
    MaterialModifier () const
    {
      return this->MaterialModifier_.get ();
    }

    DatumType::MaterialModifier_type& DatumType::
    MaterialModifier ()
    {
      return this->MaterialModifier_.get ();
    }

    void DatumType::
    MaterialModifier (const MaterialModifier_type& x)
    {
      this->MaterialModifier_.set (x);
    }

    void DatumType::
    MaterialModifier (::std::unique_ptr< MaterialModifier_type > x)
    {
      this->MaterialModifier_.set (std::move (x));
    }

    const DatumType::SizeCharacteristicDefinitionId_optional& DatumType::
    SizeCharacteristicDefinitionId () const
    {
      return this->SizeCharacteristicDefinitionId_;
    }

    DatumType::SizeCharacteristicDefinitionId_optional& DatumType::
    SizeCharacteristicDefinitionId ()
    {
      return this->SizeCharacteristicDefinitionId_;
    }

    void DatumType::
    SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x)
    {
      this->SizeCharacteristicDefinitionId_.set (x);
    }

    void DatumType::
    SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x)
    {
      this->SizeCharacteristicDefinitionId_ = x;
    }

    void DatumType::
    SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > x)
    {
      this->SizeCharacteristicDefinitionId_.set (std::move (x));
    }

    const DatumType::ReferencedComponent_type& DatumType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    DatumType::ReferencedComponent_type& DatumType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void DatumType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void DatumType::
    ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (std::move (x));
    }

    const DatumType::SubstituteFeatureAlgorithm_optional& DatumType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    DatumType::SubstituteFeatureAlgorithm_optional& DatumType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void DatumType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void DatumType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void DatumType::
    SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (std::move (x));
    }

    const DatumType::DatumFeatureSimulatorModifier_optional& DatumType::
    DatumFeatureSimulatorModifier () const
    {
      return this->DatumFeatureSimulatorModifier_;
    }

    DatumType::DatumFeatureSimulatorModifier_optional& DatumType::
    DatumFeatureSimulatorModifier ()
    {
      return this->DatumFeatureSimulatorModifier_;
    }

    void DatumType::
    DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_type& x)
    {
      this->DatumFeatureSimulatorModifier_.set (x);
    }

    void DatumType::
    DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_optional& x)
    {
      this->DatumFeatureSimulatorModifier_ = x;
    }

    void DatumType::
    DatumFeatureSimulatorModifier (::std::unique_ptr< DatumFeatureSimulatorModifier_type > x)
    {
      this->DatumFeatureSimulatorModifier_.set (std::move (x));
    }

    const DatumType::DatumTranslation_optional& DatumType::
    DatumTranslation () const
    {
      return this->DatumTranslation_;
    }

    DatumType::DatumTranslation_optional& DatumType::
    DatumTranslation ()
    {
      return this->DatumTranslation_;
    }

    void DatumType::
    DatumTranslation (const DatumTranslation_type& x)
    {
      this->DatumTranslation_.set (x);
    }

    void DatumType::
    DatumTranslation (const DatumTranslation_optional& x)
    {
      this->DatumTranslation_ = x;
    }

    void DatumType::
    DatumTranslation (::std::unique_ptr< DatumTranslation_type > x)
    {
      this->DatumTranslation_.set (std::move (x));
    }

    const DatumType::DegreesOfFreedom_optional& DatumType::
    DegreesOfFreedom () const
    {
      return this->DegreesOfFreedom_;
    }

    DatumType::DegreesOfFreedom_optional& DatumType::
    DegreesOfFreedom ()
    {
      return this->DegreesOfFreedom_;
    }

    void DatumType::
    DegreesOfFreedom (const DegreesOfFreedom_type& x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    void DatumType::
    DegreesOfFreedom (const DegreesOfFreedom_optional& x)
    {
      this->DegreesOfFreedom_ = x;
    }

    void DatumType::
    DegreesOfFreedom (::std::unique_ptr< DegreesOfFreedom_type > x)
    {
      this->DegreesOfFreedom_.set (std::move (x));
    }

    const DatumType::ProjectedDatum_optional& DatumType::
    ProjectedDatum () const
    {
      return this->ProjectedDatum_;
    }

    DatumType::ProjectedDatum_optional& DatumType::
    ProjectedDatum ()
    {
      return this->ProjectedDatum_;
    }

    void DatumType::
    ProjectedDatum (const ProjectedDatum_type& x)
    {
      this->ProjectedDatum_.set (x);
    }

    void DatumType::
    ProjectedDatum (const ProjectedDatum_optional& x)
    {
      this->ProjectedDatum_ = x;
    }

    void DatumType::
    ProjectedDatum (::std::unique_ptr< ProjectedDatum_type > x)
    {
      this->ProjectedDatum_.set (std::move (x));
    }

    const DatumType::DiameterModifier_optional& DatumType::
    DiameterModifier () const
    {
      return this->DiameterModifier_;
    }

    DatumType::DiameterModifier_optional& DatumType::
    DiameterModifier ()
    {
      return this->DiameterModifier_;
    }

    void DatumType::
    DiameterModifier (const DiameterModifier_type& x)
    {
      this->DiameterModifier_.set (x);
    }

    void DatumType::
    DiameterModifier (const DiameterModifier_optional& x)
    {
      this->DiameterModifier_ = x;
    }

    void DatumType::
    DiameterModifier (::std::unique_ptr< DiameterModifier_type > x)
    {
      this->DiameterModifier_.set (std::move (x));
    }

    const DatumType::SectionModifier_optional& DatumType::
    SectionModifier () const
    {
      return this->SectionModifier_;
    }

    DatumType::SectionModifier_optional& DatumType::
    SectionModifier ()
    {
      return this->SectionModifier_;
    }

    void DatumType::
    SectionModifier (const SectionModifier_type& x)
    {
      this->SectionModifier_.set (x);
    }

    void DatumType::
    SectionModifier (const SectionModifier_optional& x)
    {
      this->SectionModifier_ = x;
    }

    void DatumType::
    SectionModifier (::std::unique_ptr< SectionModifier_type > x)
    {
      this->SectionModifier_.set (std::move (x));
    }

    const DatumType::ContactingFeature_optional& DatumType::
    ContactingFeature () const
    {
      return this->ContactingFeature_;
    }

    DatumType::ContactingFeature_optional& DatumType::
    ContactingFeature ()
    {
      return this->ContactingFeature_;
    }

    void DatumType::
    ContactingFeature (const ContactingFeature_type& x)
    {
      this->ContactingFeature_.set (x);
    }

    void DatumType::
    ContactingFeature (const ContactingFeature_optional& x)
    {
      this->ContactingFeature_ = x;
    }

    const DatumType::DistanceVariable_optional& DatumType::
    DistanceVariable () const
    {
      return this->DistanceVariable_;
    }

    DatumType::DistanceVariable_optional& DatumType::
    DistanceVariable ()
    {
      return this->DistanceVariable_;
    }

    void DatumType::
    DistanceVariable (const DistanceVariable_type& x)
    {
      this->DistanceVariable_.set (x);
    }

    void DatumType::
    DistanceVariable (const DistanceVariable_optional& x)
    {
      this->DistanceVariable_ = x;
    }

    const DatumType::DatumFixed_optional& DatumType::
    DatumFixed () const
    {
      return this->DatumFixed_;
    }

    DatumType::DatumFixed_optional& DatumType::
    DatumFixed ()
    {
      return this->DatumFixed_;
    }

    void DatumType::
    DatumFixed (const DatumFixed_type& x)
    {
      this->DatumFixed_.set (x);
    }

    void DatumType::
    DatumFixed (const DatumFixed_optional& x)
    {
      this->DatumFixed_ = x;
    }

    const DatumType::ReducedDatum_optional& DatumType::
    ReducedDatum () const
    {
      return this->ReducedDatum_;
    }

    DatumType::ReducedDatum_optional& DatumType::
    ReducedDatum ()
    {
      return this->ReducedDatum_;
    }

    void DatumType::
    ReducedDatum (const ReducedDatum_type& x)
    {
      this->ReducedDatum_.set (x);
    }

    void DatumType::
    ReducedDatum (const ReducedDatum_optional& x)
    {
      this->ReducedDatum_ = x;
    }

    void DatumType::
    ReducedDatum (::std::unique_ptr< ReducedDatum_type > x)
    {
      this->ReducedDatum_.set (std::move (x));
    }

    const DatumType::ConstrainOrientation_optional& DatumType::
    ConstrainOrientation () const
    {
      return this->ConstrainOrientation_;
    }

    DatumType::ConstrainOrientation_optional& DatumType::
    ConstrainOrientation ()
    {
      return this->ConstrainOrientation_;
    }

    void DatumType::
    ConstrainOrientation (const ConstrainOrientation_type& x)
    {
      this->ConstrainOrientation_.set (x);
    }

    void DatumType::
    ConstrainOrientation (const ConstrainOrientation_optional& x)
    {
      this->ConstrainOrientation_ = x;
    }

    const DatumType::ConstrainSubsequent_optional& DatumType::
    ConstrainSubsequent () const
    {
      return this->ConstrainSubsequent_;
    }

    DatumType::ConstrainSubsequent_optional& DatumType::
    ConstrainSubsequent ()
    {
      return this->ConstrainSubsequent_;
    }

    void DatumType::
    ConstrainSubsequent (const ConstrainSubsequent_type& x)
    {
      this->ConstrainSubsequent_.set (x);
    }

    void DatumType::
    ConstrainSubsequent (const ConstrainSubsequent_optional& x)
    {
      this->ConstrainSubsequent_ = x;
    }

    const DatumType::Attributes_optional& DatumType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumType::Attributes_optional& DatumType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // DatumTranslationType
    //

    const DatumTranslationType::DatumTranslationAllowed_type& DatumTranslationType::
    DatumTranslationAllowed () const
    {
      return this->DatumTranslationAllowed_.get ();
    }

    DatumTranslationType::DatumTranslationAllowed_type& DatumTranslationType::
    DatumTranslationAllowed ()
    {
      return this->DatumTranslationAllowed_.get ();
    }

    void DatumTranslationType::
    DatumTranslationAllowed (const DatumTranslationAllowed_type& x)
    {
      this->DatumTranslationAllowed_.set (x);
    }


    // DatumFeatureBaseType
    //

    const DatumFeatureBaseType::FeatureNominalId_type& DatumFeatureBaseType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_.get ();
    }

    DatumFeatureBaseType::FeatureNominalId_type& DatumFeatureBaseType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_.get ();
    }

    void DatumFeatureBaseType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void DatumFeatureBaseType::
    FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (std::move (x));
    }


    // MeasuredDatumFeatureType
    //

    const MeasuredDatumFeatureType::MaterialModifier_type& MeasuredDatumFeatureType::
    MaterialModifier () const
    {
      return this->MaterialModifier_.get ();
    }

    MeasuredDatumFeatureType::MaterialModifier_type& MeasuredDatumFeatureType::
    MaterialModifier ()
    {
      return this->MaterialModifier_.get ();
    }

    void MeasuredDatumFeatureType::
    MaterialModifier (const MaterialModifier_type& x)
    {
      this->MaterialModifier_.set (x);
    }

    void MeasuredDatumFeatureType::
    MaterialModifier (::std::unique_ptr< MaterialModifier_type > x)
    {
      this->MaterialModifier_.set (std::move (x));
    }

    const MeasuredDatumFeatureType::SubstituteFeatureAlgorithm_optional& MeasuredDatumFeatureType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    MeasuredDatumFeatureType::SubstituteFeatureAlgorithm_optional& MeasuredDatumFeatureType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void MeasuredDatumFeatureType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void MeasuredDatumFeatureType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void MeasuredDatumFeatureType::
    SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (std::move (x));
    }


    // NominalDatumFeatureType
    //


    // DatumFeatureSimulatorModifierType
    //

    const DatumFeatureSimulatorModifierType::LinearSize_optional& DatumFeatureSimulatorModifierType::
    LinearSize () const
    {
      return this->LinearSize_;
    }

    DatumFeatureSimulatorModifierType::LinearSize_optional& DatumFeatureSimulatorModifierType::
    LinearSize ()
    {
      return this->LinearSize_;
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (const LinearSize_type& x)
    {
      this->LinearSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (const LinearSize_optional& x)
    {
      this->LinearSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (::std::unique_ptr< LinearSize_type > x)
    {
      this->LinearSize_.set (std::move (x));
    }

    const DatumFeatureSimulatorModifierType::DiametricalSize_optional& DatumFeatureSimulatorModifierType::
    DiametricalSize () const
    {
      return this->DiametricalSize_;
    }

    DatumFeatureSimulatorModifierType::DiametricalSize_optional& DatumFeatureSimulatorModifierType::
    DiametricalSize ()
    {
      return this->DiametricalSize_;
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (const DiametricalSize_type& x)
    {
      this->DiametricalSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (const DiametricalSize_optional& x)
    {
      this->DiametricalSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (::std::unique_ptr< DiametricalSize_type > x)
    {
      this->DiametricalSize_.set (std::move (x));
    }

    const DatumFeatureSimulatorModifierType::BasicSize_optional& DatumFeatureSimulatorModifierType::
    BasicSize () const
    {
      return this->BasicSize_;
    }

    DatumFeatureSimulatorModifierType::BasicSize_optional& DatumFeatureSimulatorModifierType::
    BasicSize ()
    {
      return this->BasicSize_;
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (const BasicSize_type& x)
    {
      this->BasicSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (const BasicSize_optional& x)
    {
      this->BasicSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (::std::unique_ptr< BasicSize_type > x)
    {
      this->BasicSize_.set (std::move (x));
    }

    const DatumFeatureSimulatorModifierType::BasicSize_type& DatumFeatureSimulatorModifierType::
    BasicSize_default_value ()
    {
      return BasicSize_default_value_;
    }


    // DatumsType
    //

    const DatumsType::Datum_sequence& DatumsType::
    Datum () const
    {
      return this->Datum_;
    }

    DatumsType::Datum_sequence& DatumsType::
    Datum ()
    {
      return this->Datum_;
    }

    void DatumsType::
    Datum (const Datum_sequence& s)
    {
      this->Datum_ = s;
    }

    const DatumsType::n_type& DatumsType::
    n () const
    {
      return this->n_.get ();
    }

    DatumsType::n_type& DatumsType::
    n ()
    {
      return this->n_.get ();
    }

    void DatumsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DatumsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DatumReferenceFrameType
    //

    const DatumReferenceFrameType::Attributes_optional& DatumReferenceFrameType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumReferenceFrameType::Attributes_optional& DatumReferenceFrameType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumReferenceFrameType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumReferenceFrameType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumReferenceFrameType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const DatumReferenceFrameType::Datums_optional& DatumReferenceFrameType::
    Datums () const
    {
      return this->Datums_;
    }

    DatumReferenceFrameType::Datums_optional& DatumReferenceFrameType::
    Datums ()
    {
      return this->Datums_;
    }

    void DatumReferenceFrameType::
    Datums (const Datums_type& x)
    {
      this->Datums_.set (x);
    }

    void DatumReferenceFrameType::
    Datums (const Datums_optional& x)
    {
      this->Datums_ = x;
    }

    void DatumReferenceFrameType::
    Datums (::std::unique_ptr< Datums_type > x)
    {
      this->Datums_.set (std::move (x));
    }

    const DatumReferenceFrameType::Name_optional& DatumReferenceFrameType::
    Name () const
    {
      return this->Name_;
    }

    DatumReferenceFrameType::Name_optional& DatumReferenceFrameType::
    Name ()
    {
      return this->Name_;
    }

    void DatumReferenceFrameType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DatumReferenceFrameType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void DatumReferenceFrameType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const DatumReferenceFrameType::Description_optional& DatumReferenceFrameType::
    Description () const
    {
      return this->Description_;
    }

    DatumReferenceFrameType::Description_optional& DatumReferenceFrameType::
    Description ()
    {
      return this->Description_;
    }

    void DatumReferenceFrameType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DatumReferenceFrameType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DatumReferenceFrameType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const DatumReferenceFrameType::CoordinateSystemId_optional& DatumReferenceFrameType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    DatumReferenceFrameType::CoordinateSystemId_optional& DatumReferenceFrameType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }

    const DatumReferenceFrameType::id_type& DatumReferenceFrameType::
    id () const
    {
      return this->id_.get ();
    }

    DatumReferenceFrameType::id_type& DatumReferenceFrameType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumReferenceFrameType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumReferenceFrameType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // DegreeOfFreedomEnumType
    //

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DegreeOfFreedomEnumType_literals_[v])
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const DegreeOfFreedomEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DegreeOfFreedomEnumType& DegreeOfFreedomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DegreeOfFreedomEnumType_literals_[v]);

      return *this;
    }


    // ISODegreeOfFreedomEnumType
    //

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ISODegreeOfFreedomEnumType_literals_[v])
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ISODegreeOfFreedomEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ISODegreeOfFreedomEnumType& ISODegreeOfFreedomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ISODegreeOfFreedomEnumType_literals_[v]);

      return *this;
    }


    // IntersectionPlaneEnumType
    //

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_IntersectionPlaneEnumType_literals_[v])
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const IntersectionPlaneEnumType& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    IntersectionPlaneEnumType& IntersectionPlaneEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_IntersectionPlaneEnumType_literals_[v]);

      return *this;
    }


    // IntersectionPlaneType
    //

    const IntersectionPlaneType::IntersectionPlaneEnum_type& IntersectionPlaneType::
    IntersectionPlaneEnum () const
    {
      return this->IntersectionPlaneEnum_.get ();
    }

    IntersectionPlaneType::IntersectionPlaneEnum_type& IntersectionPlaneType::
    IntersectionPlaneEnum ()
    {
      return this->IntersectionPlaneEnum_.get ();
    }

    void IntersectionPlaneType::
    IntersectionPlaneEnum (const IntersectionPlaneEnum_type& x)
    {
      this->IntersectionPlaneEnum_.set (x);
    }

    void IntersectionPlaneType::
    IntersectionPlaneEnum (::std::unique_ptr< IntersectionPlaneEnum_type > x)
    {
      this->IntersectionPlaneEnum_.set (std::move (x));
    }

    const IntersectionPlaneType::DatumDefinitionId_type& IntersectionPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    IntersectionPlaneType::DatumDefinitionId_type& IntersectionPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void IntersectionPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void IntersectionPlaneType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }


    // ModifyingPlaneEnumType
    //

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ModifyingPlaneEnumType_literals_[v])
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ModifyingPlaneEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ModifyingPlaneEnumType& ModifyingPlaneEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ModifyingPlaneEnumType_literals_[v]);

      return *this;
    }


    // DirectionFeatureType
    //

    const DirectionFeatureType::DirectionFeatureEnum_type& DirectionFeatureType::
    DirectionFeatureEnum () const
    {
      return this->DirectionFeatureEnum_.get ();
    }

    DirectionFeatureType::DirectionFeatureEnum_type& DirectionFeatureType::
    DirectionFeatureEnum ()
    {
      return this->DirectionFeatureEnum_.get ();
    }

    void DirectionFeatureType::
    DirectionFeatureEnum (const DirectionFeatureEnum_type& x)
    {
      this->DirectionFeatureEnum_.set (x);
    }

    void DirectionFeatureType::
    DirectionFeatureEnum (::std::unique_ptr< DirectionFeatureEnum_type > x)
    {
      this->DirectionFeatureEnum_.set (std::move (x));
    }

    const DirectionFeatureType::DatumDefinitionId_type& DirectionFeatureType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    DirectionFeatureType::DatumDefinitionId_type& DirectionFeatureType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void DirectionFeatureType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void DirectionFeatureType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }


    // CollectionPlaneType
    //

    const CollectionPlaneType::CollectionPlaneEnum_type& CollectionPlaneType::
    CollectionPlaneEnum () const
    {
      return this->CollectionPlaneEnum_.get ();
    }

    CollectionPlaneType::CollectionPlaneEnum_type& CollectionPlaneType::
    CollectionPlaneEnum ()
    {
      return this->CollectionPlaneEnum_.get ();
    }

    void CollectionPlaneType::
    CollectionPlaneEnum (const CollectionPlaneEnum_type& x)
    {
      this->CollectionPlaneEnum_.set (x);
    }

    void CollectionPlaneType::
    CollectionPlaneEnum (::std::unique_ptr< CollectionPlaneEnum_type > x)
    {
      this->CollectionPlaneEnum_.set (std::move (x));
    }

    const CollectionPlaneType::DatumDefinitionId_type& CollectionPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    CollectionPlaneType::DatumDefinitionId_type& CollectionPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void CollectionPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void CollectionPlaneType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }


    // OrientationPlaneType
    //

    const OrientationPlaneType::OrientationPlaneEnum_type& OrientationPlaneType::
    OrientationPlaneEnum () const
    {
      return this->OrientationPlaneEnum_.get ();
    }

    OrientationPlaneType::OrientationPlaneEnum_type& OrientationPlaneType::
    OrientationPlaneEnum ()
    {
      return this->OrientationPlaneEnum_.get ();
    }

    void OrientationPlaneType::
    OrientationPlaneEnum (const OrientationPlaneEnum_type& x)
    {
      this->OrientationPlaneEnum_.set (x);
    }

    void OrientationPlaneType::
    OrientationPlaneEnum (::std::unique_ptr< OrientationPlaneEnum_type > x)
    {
      this->OrientationPlaneEnum_.set (std::move (x));
    }

    const OrientationPlaneType::DatumDefinitionId_type& OrientationPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    OrientationPlaneType::DatumDefinitionId_type& OrientationPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void OrientationPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void OrientationPlaneType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }


    // ReducedDatumEnumType
    //

    ReducedDatumEnumType::
    ReducedDatumEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ReducedDatumEnumType_literals_[v])
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ReducedDatumEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ReducedDatumEnumType& ReducedDatumEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ReducedDatumEnumType_literals_[v]);

      return *this;
    }


    // DegreesOfFreedomType
    //

    const DegreesOfFreedomType::DegreeOfFreedom_sequence& DegreesOfFreedomType::
    DegreeOfFreedom () const
    {
      return this->DegreeOfFreedom_;
    }

    DegreesOfFreedomType::DegreeOfFreedom_sequence& DegreesOfFreedomType::
    DegreeOfFreedom ()
    {
      return this->DegreeOfFreedom_;
    }

    void DegreesOfFreedomType::
    DegreeOfFreedom (const DegreeOfFreedom_sequence& s)
    {
      this->DegreeOfFreedom_ = s;
    }

    const DegreesOfFreedomType::ISODegreeOfFreedom_sequence& DegreesOfFreedomType::
    ISODegreeOfFreedom () const
    {
      return this->ISODegreeOfFreedom_;
    }

    DegreesOfFreedomType::ISODegreeOfFreedom_sequence& DegreesOfFreedomType::
    ISODegreeOfFreedom ()
    {
      return this->ISODegreeOfFreedom_;
    }

    void DegreesOfFreedomType::
    ISODegreeOfFreedom (const ISODegreeOfFreedom_sequence& s)
    {
      this->ISODegreeOfFreedom_ = s;
    }

    const DegreesOfFreedomType::n_type& DegreesOfFreedomType::
    n () const
    {
      return this->n_.get ();
    }

    DegreesOfFreedomType::n_type& DegreesOfFreedomType::
    n ()
    {
      return this->n_.get ();
    }

    void DegreesOfFreedomType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DegreesOfFreedomType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DiameterModifierEnumType
    //

    DiameterModifierEnumType::
    DiameterModifierEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DiameterModifierEnumType_literals_[v])
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const DiameterModifierEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DiameterModifierEnumType& DiameterModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DiameterModifierEnumType_literals_[v]);

      return *this;
    }


    // SectionModifierEnumType
    //

    SectionModifierEnumType::
    SectionModifierEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SectionModifierEnumType_literals_[v])
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const SectionModifierEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SectionModifierEnumType& SectionModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SectionModifierEnumType_literals_[v]);

      return *this;
    }


    // PointWithNormalBaseType
    //

    const PointWithNormalBaseType::Point_type& PointWithNormalBaseType::
    Point () const
    {
      return this->Point_.get ();
    }

    PointWithNormalBaseType::Point_type& PointWithNormalBaseType::
    Point ()
    {
      return this->Point_.get ();
    }

    void PointWithNormalBaseType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void PointWithNormalBaseType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }

    const PointWithNormalBaseType::Normal_optional& PointWithNormalBaseType::
    Normal () const
    {
      return this->Normal_;
    }

    PointWithNormalBaseType::Normal_optional& PointWithNormalBaseType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointWithNormalBaseType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointWithNormalBaseType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointWithNormalBaseType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PointWithNormalBaseType::id_type& PointWithNormalBaseType::
    id () const
    {
      return this->id_.get ();
    }

    PointWithNormalBaseType::id_type& PointWithNormalBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void PointWithNormalBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PointWithNormalBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // MeasuredPointWithNormalBaseType
    //

    const MeasuredPointWithNormalBaseType::Point_type& MeasuredPointWithNormalBaseType::
    Point () const
    {
      return this->Point_.get ();
    }

    MeasuredPointWithNormalBaseType::Point_type& MeasuredPointWithNormalBaseType::
    Point ()
    {
      return this->Point_.get ();
    }

    void MeasuredPointWithNormalBaseType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void MeasuredPointWithNormalBaseType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }

    const MeasuredPointWithNormalBaseType::Normal_optional& MeasuredPointWithNormalBaseType::
    Normal () const
    {
      return this->Normal_;
    }

    MeasuredPointWithNormalBaseType::Normal_optional& MeasuredPointWithNormalBaseType::
    Normal ()
    {
      return this->Normal_;
    }

    void MeasuredPointWithNormalBaseType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void MeasuredPointWithNormalBaseType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void MeasuredPointWithNormalBaseType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const MeasuredPointWithNormalBaseType::id_type& MeasuredPointWithNormalBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasuredPointWithNormalBaseType::id_type& MeasuredPointWithNormalBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasuredPointWithNormalBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasuredPointWithNormalBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // MeasurePointNominalType
    //

    const MeasurePointNominalType::MeasurementDeviceId_optional& MeasurePointNominalType::
    MeasurementDeviceId () const
    {
      return this->MeasurementDeviceId_;
    }

    MeasurePointNominalType::MeasurementDeviceId_optional& MeasurePointNominalType::
    MeasurementDeviceId ()
    {
      return this->MeasurementDeviceId_;
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (const MeasurementDeviceId_type& x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (const MeasurementDeviceId_optional& x)
    {
      this->MeasurementDeviceId_ = x;
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > x)
    {
      this->MeasurementDeviceId_.set (std::move (x));
    }

    const MeasurePointNominalType::SensorId_optional& MeasurePointNominalType::
    SensorId () const
    {
      return this->SensorId_;
    }

    MeasurePointNominalType::SensorId_optional& MeasurePointNominalType::
    SensorId ()
    {
      return this->SensorId_;
    }

    void MeasurePointNominalType::
    SensorId (const SensorId_type& x)
    {
      this->SensorId_.set (x);
    }

    void MeasurePointNominalType::
    SensorId (const SensorId_optional& x)
    {
      this->SensorId_ = x;
    }

    void MeasurePointNominalType::
    SensorId (::std::unique_ptr< SensorId_type > x)
    {
      this->SensorId_.set (std::move (x));
    }

    const MeasurePointNominalType::TipId_optional& MeasurePointNominalType::
    TipId () const
    {
      return this->TipId_;
    }

    MeasurePointNominalType::TipId_optional& MeasurePointNominalType::
    TipId ()
    {
      return this->TipId_;
    }

    void MeasurePointNominalType::
    TipId (const TipId_type& x)
    {
      this->TipId_.set (x);
    }

    void MeasurePointNominalType::
    TipId (const TipId_optional& x)
    {
      this->TipId_ = x;
    }

    void MeasurePointNominalType::
    TipId (::std::unique_ptr< TipId_type > x)
    {
      this->TipId_.set (std::move (x));
    }


    // MovableDatumTargetDirectionType
    //

    const MovableDatumTargetDirectionType::DatumTargetTranslationDirection_type& MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection () const
    {
      return this->DatumTargetTranslationDirection_.get ();
    }

    MovableDatumTargetDirectionType::DatumTargetTranslationDirection_type& MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection ()
    {
      return this->DatumTargetTranslationDirection_.get ();
    }

    void MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection (const DatumTargetTranslationDirection_type& x)
    {
      this->DatumTargetTranslationDirection_.set (x);
    }

    void MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection (::std::unique_ptr< DatumTargetTranslationDirection_type > x)
    {
      this->DatumTargetTranslationDirection_.set (std::move (x));
    }


    // DefiningPointNominalType
    //

    const DefiningPointNominalType::SequenceNumber_type& DefiningPointNominalType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    DefiningPointNominalType::SequenceNumber_type& DefiningPointNominalType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void DefiningPointNominalType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void DefiningPointNominalType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // DefiningPointMeasurementType
    //

    const DefiningPointMeasurementType::SequenceNumber_type& DefiningPointMeasurementType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    DefiningPointMeasurementType::SequenceNumber_type& DefiningPointMeasurementType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void DefiningPointMeasurementType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void DefiningPointMeasurementType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // TransformListType
    //

    const TransformListType::Transform_sequence& TransformListType::
    Transform () const
    {
      return this->Transform_;
    }

    TransformListType::Transform_sequence& TransformListType::
    Transform ()
    {
      return this->Transform_;
    }

    void TransformListType::
    Transform (const Transform_sequence& s)
    {
      this->Transform_ = s;
    }

    const TransformListType::n_type& TransformListType::
    n () const
    {
      return this->n_.get ();
    }

    TransformListType::n_type& TransformListType::
    n ()
    {
      return this->n_.get ();
    }

    void TransformListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TransformListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TransformInstanceType
    //

    const TransformInstanceType::Attributes_optional& TransformInstanceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TransformInstanceType::Attributes_optional& TransformInstanceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TransformInstanceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TransformInstanceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TransformInstanceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const TransformInstanceType::Name_optional& TransformInstanceType::
    Name () const
    {
      return this->Name_;
    }

    TransformInstanceType::Name_optional& TransformInstanceType::
    Name ()
    {
      return this->Name_;
    }

    void TransformInstanceType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void TransformInstanceType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void TransformInstanceType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const TransformInstanceType::id_type& TransformInstanceType::
    id () const
    {
      return this->id_.get ();
    }

    TransformInstanceType::id_type& TransformInstanceType::
    id ()
    {
      return this->id_.get ();
    }

    void TransformInstanceType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void TransformInstanceType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // LinearCoordinateDirectionEnumType
    //

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_LinearCoordinateDirectionEnumType_literals_[v])
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const LinearCoordinateDirectionEnumType& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    LinearCoordinateDirectionEnumType& LinearCoordinateDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_LinearCoordinateDirectionEnumType_literals_[v]);

      return *this;
    }


    // AngularCoordinateDirectionEnumType
    //

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AngularCoordinateDirectionEnumType_literals_[v])
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const AngularCoordinateDirectionEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AngularCoordinateDirectionEnumType& AngularCoordinateDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AngularCoordinateDirectionEnumType_literals_[v]);

      return *this;
    }


    // SubstituteFeatureAlgorithmEnumType
    //

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SubstituteFeatureAlgorithmEnumType_literals_[v])
    {
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const SubstituteFeatureAlgorithmEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SubstituteFeatureAlgorithmEnumType& SubstituteFeatureAlgorithmEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SubstituteFeatureAlgorithmEnumType_literals_[v]);

      return *this;
    }


    // SubstituteFeatureAlgorithmType
    //

    const SubstituteFeatureAlgorithmType::Attributes_optional& SubstituteFeatureAlgorithmType::
    Attributes () const
    {
      return this->Attributes_;
    }

    SubstituteFeatureAlgorithmType::Attributes_optional& SubstituteFeatureAlgorithmType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void SubstituteFeatureAlgorithmType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void SubstituteFeatureAlgorithmType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void SubstituteFeatureAlgorithmType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const SubstituteFeatureAlgorithmType::SubstituteFeatureAlgorithmEnum_optional& SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmEnum () const
    {
      return this->SubstituteFeatureAlgorithmEnum_;
    }

    SubstituteFeatureAlgorithmType::SubstituteFeatureAlgorithmEnum_optional& SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmEnum ()
    {
      return this->SubstituteFeatureAlgorithmEnum_;
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmEnum (const SubstituteFeatureAlgorithmEnum_type& x)
    {
      this->SubstituteFeatureAlgorithmEnum_.set (x);
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmEnum (const SubstituteFeatureAlgorithmEnum_optional& x)
    {
      this->SubstituteFeatureAlgorithmEnum_ = x;
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmEnum (::std::unique_ptr< SubstituteFeatureAlgorithmEnum_type > x)
    {
      this->SubstituteFeatureAlgorithmEnum_.set (std::move (x));
    }

    const SubstituteFeatureAlgorithmType::SubstituteFeatureAlgorithmId_optional& SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmId () const
    {
      return this->SubstituteFeatureAlgorithmId_;
    }

    SubstituteFeatureAlgorithmType::SubstituteFeatureAlgorithmId_optional& SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmId ()
    {
      return this->SubstituteFeatureAlgorithmId_;
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmId (const SubstituteFeatureAlgorithmId_type& x)
    {
      this->SubstituteFeatureAlgorithmId_.set (x);
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmId (const SubstituteFeatureAlgorithmId_optional& x)
    {
      this->SubstituteFeatureAlgorithmId_ = x;
    }

    void SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmId (::std::unique_ptr< SubstituteFeatureAlgorithmId_type > x)
    {
      this->SubstituteFeatureAlgorithmId_.set (std::move (x));
    }

    const SubstituteFeatureAlgorithmType::OtherSubstituteFeatureAlgorithm_optional& SubstituteFeatureAlgorithmType::
    OtherSubstituteFeatureAlgorithm () const
    {
      return this->OtherSubstituteFeatureAlgorithm_;
    }

    SubstituteFeatureAlgorithmType::OtherSubstituteFeatureAlgorithm_optional& SubstituteFeatureAlgorithmType::
    OtherSubstituteFeatureAlgorithm ()
    {
      return this->OtherSubstituteFeatureAlgorithm_;
    }

    void SubstituteFeatureAlgorithmType::
    OtherSubstituteFeatureAlgorithm (const OtherSubstituteFeatureAlgorithm_type& x)
    {
      this->OtherSubstituteFeatureAlgorithm_.set (x);
    }

    void SubstituteFeatureAlgorithmType::
    OtherSubstituteFeatureAlgorithm (const OtherSubstituteFeatureAlgorithm_optional& x)
    {
      this->OtherSubstituteFeatureAlgorithm_ = x;
    }

    void SubstituteFeatureAlgorithmType::
    OtherSubstituteFeatureAlgorithm (::std::unique_ptr< OtherSubstituteFeatureAlgorithm_type > x)
    {
      this->OtherSubstituteFeatureAlgorithm_.set (std::move (x));
    }


    // MaterialModifierEnumType
    //

    MaterialModifierEnumType::
    MaterialModifierEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MaterialModifierEnumType_literals_[v])
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const MaterialModifierEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MaterialModifierEnumType& MaterialModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MaterialModifierEnumType_literals_[v]);

      return *this;
    }


    // PrecedenceEnumType
    //

    PrecedenceEnumType::
    PrecedenceEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_PrecedenceEnumType_literals_[v])
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const PrecedenceEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    PrecedenceEnumType& PrecedenceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_PrecedenceEnumType_literals_[v]);

      return *this;
    }


    // PrecedenceType
    //

    const PrecedenceType::PrecedenceEnum_optional& PrecedenceType::
    PrecedenceEnum () const
    {
      return this->PrecedenceEnum_;
    }

    PrecedenceType::PrecedenceEnum_optional& PrecedenceType::
    PrecedenceEnum ()
    {
      return this->PrecedenceEnum_;
    }

    void PrecedenceType::
    PrecedenceEnum (const PrecedenceEnum_type& x)
    {
      this->PrecedenceEnum_.set (x);
    }

    void PrecedenceType::
    PrecedenceEnum (const PrecedenceEnum_optional& x)
    {
      this->PrecedenceEnum_ = x;
    }

    void PrecedenceType::
    PrecedenceEnum (::std::unique_ptr< PrecedenceEnum_type > x)
    {
      this->PrecedenceEnum_.set (std::move (x));
    }

    const PrecedenceType::OtherPrecedence_optional& PrecedenceType::
    OtherPrecedence () const
    {
      return this->OtherPrecedence_;
    }

    PrecedenceType::OtherPrecedence_optional& PrecedenceType::
    OtherPrecedence ()
    {
      return this->OtherPrecedence_;
    }

    void PrecedenceType::
    OtherPrecedence (const OtherPrecedence_type& x)
    {
      this->OtherPrecedence_.set (x);
    }

    void PrecedenceType::
    OtherPrecedence (const OtherPrecedence_optional& x)
    {
      this->OtherPrecedence_ = x;
    }

    void PrecedenceType::
    OtherPrecedence (::std::unique_ptr< OtherPrecedence_type > x)
    {
      this->OtherPrecedence_.set (std::move (x));
    }


    // ReferencedComponentEnumType
    //

    ReferencedComponentEnumType::
    ReferencedComponentEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ReferencedComponentEnumType_literals_[v])
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ReferencedComponentEnumType& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ReferencedComponentEnumType& ReferencedComponentEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ReferencedComponentEnumType_literals_[v]);

      return *this;
    }


    // RetrievalMethodEnumType
    //

    RetrievalMethodEnumType::
    RetrievalMethodEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_RetrievalMethodEnumType_literals_[v])
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const RetrievalMethodEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    RetrievalMethodEnumType& RetrievalMethodEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_RetrievalMethodEnumType_literals_[v]);

      return *this;
    }


    // MeasurementDirectiveEnumType
    //

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MeasurementDirectiveEnumType_literals_[v])
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const MeasurementDirectiveEnumType& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MeasurementDirectiveEnumType& MeasurementDirectiveEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MeasurementDirectiveEnumType_literals_[v]);

      return *this;
    }


    // MeasurementDirectiveType
    //

    const MeasurementDirectiveType::MeasurementDirectiveEnum_optional& MeasurementDirectiveType::
    MeasurementDirectiveEnum () const
    {
      return this->MeasurementDirectiveEnum_;
    }

    MeasurementDirectiveType::MeasurementDirectiveEnum_optional& MeasurementDirectiveType::
    MeasurementDirectiveEnum ()
    {
      return this->MeasurementDirectiveEnum_;
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (const MeasurementDirectiveEnum_type& x)
    {
      this->MeasurementDirectiveEnum_.set (x);
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (const MeasurementDirectiveEnum_optional& x)
    {
      this->MeasurementDirectiveEnum_ = x;
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (::std::unique_ptr< MeasurementDirectiveEnum_type > x)
    {
      this->MeasurementDirectiveEnum_.set (std::move (x));
    }

    const MeasurementDirectiveType::OtherMeasurementDirective_optional& MeasurementDirectiveType::
    OtherMeasurementDirective () const
    {
      return this->OtherMeasurementDirective_;
    }

    MeasurementDirectiveType::OtherMeasurementDirective_optional& MeasurementDirectiveType::
    OtherMeasurementDirective ()
    {
      return this->OtherMeasurementDirective_;
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (const OtherMeasurementDirective_type& x)
    {
      this->OtherMeasurementDirective_.set (x);
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (const OtherMeasurementDirective_optional& x)
    {
      this->OtherMeasurementDirective_ = x;
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (::std::unique_ptr< OtherMeasurementDirective_type > x)
    {
      this->OtherMeasurementDirective_.set (std::move (x));
    }


    // DistanceBetweenAnalysisModeEnumType
    //

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DistanceBetweenAnalysisModeEnumType_literals_[v])
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const DistanceBetweenAnalysisModeEnumType& v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DistanceBetweenAnalysisModeEnumType& DistanceBetweenAnalysisModeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DistanceBetweenAnalysisModeEnumType_literals_[v]);

      return *this;
    }


    // AngleBetweenAnalysisModeEnumType
    //

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AngleBetweenAnalysisModeEnumType_literals_[v])
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const AngleBetweenAnalysisModeEnumType& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AngleBetweenAnalysisModeEnumType& AngleBetweenAnalysisModeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AngleBetweenAnalysisModeEnumType_literals_[v]);

      return *this;
    }


    // BaseFeatureType
    //

    const BaseFeatureType::ReferencedComponent_type& BaseFeatureType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    BaseFeatureType::ReferencedComponent_type& BaseFeatureType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void BaseFeatureType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void BaseFeatureType::
    ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (std::move (x));
    }

    const BaseFeatureType::FeatureId_type& BaseFeatureType::
    FeatureId () const
    {
      return this->FeatureId_.get ();
    }

    BaseFeatureType::FeatureId_type& BaseFeatureType::
    FeatureId ()
    {
      return this->FeatureId_.get ();
    }

    void BaseFeatureType::
    FeatureId (const FeatureId_type& x)
    {
      this->FeatureId_.set (x);
    }

    void BaseFeatureType::
    FeatureId (::std::unique_ptr< FeatureId_type > x)
    {
      this->FeatureId_.set (std::move (x));
    }


    // SequencedBaseFeatureType
    //

    const SequencedBaseFeatureType::SequenceNumber_type& SequencedBaseFeatureType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    SequencedBaseFeatureType::SequenceNumber_type& SequencedBaseFeatureType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void SequencedBaseFeatureType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void SequencedBaseFeatureType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // DirectionalOffsetType
    //

    const DirectionalOffsetType::Offset_type& DirectionalOffsetType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    DirectionalOffsetType::Offset_type& DirectionalOffsetType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void DirectionalOffsetType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void DirectionalOffsetType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }

    const DirectionalOffsetType::NominalDirection_optional& DirectionalOffsetType::
    NominalDirection () const
    {
      return this->NominalDirection_;
    }

    DirectionalOffsetType::NominalDirection_optional& DirectionalOffsetType::
    NominalDirection ()
    {
      return this->NominalDirection_;
    }

    void DirectionalOffsetType::
    NominalDirection (const NominalDirection_type& x)
    {
      this->NominalDirection_.set (x);
    }

    void DirectionalOffsetType::
    NominalDirection (const NominalDirection_optional& x)
    {
      this->NominalDirection_ = x;
    }

    void DirectionalOffsetType::
    NominalDirection (::std::unique_ptr< NominalDirection_type > x)
    {
      this->NominalDirection_.set (std::move (x));
    }

    const DirectionalOffsetType::FeatureDirection_optional& DirectionalOffsetType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    DirectionalOffsetType::FeatureDirection_optional& DirectionalOffsetType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void DirectionalOffsetType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void DirectionalOffsetType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void DirectionalOffsetType::
    FeatureDirection (::std::unique_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (std::move (x));
    }


    // AlignmentFeatureType
    //

    const AlignmentFeatureType::DatumDefinitionId_optional& AlignmentFeatureType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_;
    }

    AlignmentFeatureType::DatumDefinitionId_optional& AlignmentFeatureType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_;
    }

    void AlignmentFeatureType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void AlignmentFeatureType::
    DatumDefinitionId (const DatumDefinitionId_optional& x)
    {
      this->DatumDefinitionId_ = x;
    }

    void AlignmentFeatureType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }

    const AlignmentFeatureType::BaseFeature_optional& AlignmentFeatureType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    AlignmentFeatureType::BaseFeature_optional& AlignmentFeatureType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void AlignmentFeatureType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void AlignmentFeatureType::
    BaseFeature (const BaseFeature_optional& x)
    {
      this->BaseFeature_ = x;
    }

    void AlignmentFeatureType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // AlignmentOperationBaseType
    //

    const AlignmentOperationBaseType::SequenceNumber_type& AlignmentOperationBaseType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    AlignmentOperationBaseType::SequenceNumber_type& AlignmentOperationBaseType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void AlignmentOperationBaseType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void AlignmentOperationBaseType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }

    const AlignmentOperationBaseType::Attributes_optional& AlignmentOperationBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AlignmentOperationBaseType::Attributes_optional& AlignmentOperationBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AlignmentOperationBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AlignmentOperationBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AlignmentOperationBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // PrimaryAlignmentOperationType
    //

    const PrimaryAlignmentOperationType::PrimaryEntity_type& PrimaryAlignmentOperationType::
    PrimaryEntity () const
    {
      return this->PrimaryEntity_.get ();
    }

    PrimaryAlignmentOperationType::PrimaryEntity_type& PrimaryAlignmentOperationType::
    PrimaryEntity ()
    {
      return this->PrimaryEntity_.get ();
    }

    void PrimaryAlignmentOperationType::
    PrimaryEntity (const PrimaryEntity_type& x)
    {
      this->PrimaryEntity_.set (x);
    }

    void PrimaryAlignmentOperationType::
    PrimaryEntity (::std::unique_ptr< PrimaryEntity_type > x)
    {
      this->PrimaryEntity_.set (std::move (x));
    }

    const PrimaryAlignmentOperationType::PrimaryAxis_type& PrimaryAlignmentOperationType::
    PrimaryAxis () const
    {
      return this->PrimaryAxis_.get ();
    }

    PrimaryAlignmentOperationType::PrimaryAxis_type& PrimaryAlignmentOperationType::
    PrimaryAxis ()
    {
      return this->PrimaryAxis_.get ();
    }

    void PrimaryAlignmentOperationType::
    PrimaryAxis (const PrimaryAxis_type& x)
    {
      this->PrimaryAxis_.set (x);
    }

    void PrimaryAlignmentOperationType::
    PrimaryAxis (::std::unique_ptr< PrimaryAxis_type > x)
    {
      this->PrimaryAxis_.set (std::move (x));
    }


    // SecondaryAlignmentOperationType
    //

    const SecondaryAlignmentOperationType::SecondaryEntity_type& SecondaryAlignmentOperationType::
    SecondaryEntity () const
    {
      return this->SecondaryEntity_.get ();
    }

    SecondaryAlignmentOperationType::SecondaryEntity_type& SecondaryAlignmentOperationType::
    SecondaryEntity ()
    {
      return this->SecondaryEntity_.get ();
    }

    void SecondaryAlignmentOperationType::
    SecondaryEntity (const SecondaryEntity_type& x)
    {
      this->SecondaryEntity_.set (x);
    }

    void SecondaryAlignmentOperationType::
    SecondaryEntity (::std::unique_ptr< SecondaryEntity_type > x)
    {
      this->SecondaryEntity_.set (std::move (x));
    }

    const SecondaryAlignmentOperationType::SecondaryAxis_type& SecondaryAlignmentOperationType::
    SecondaryAxis () const
    {
      return this->SecondaryAxis_.get ();
    }

    SecondaryAlignmentOperationType::SecondaryAxis_type& SecondaryAlignmentOperationType::
    SecondaryAxis ()
    {
      return this->SecondaryAxis_.get ();
    }

    void SecondaryAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_type& x)
    {
      this->SecondaryAxis_.set (x);
    }

    void SecondaryAlignmentOperationType::
    SecondaryAxis (::std::unique_ptr< SecondaryAxis_type > x)
    {
      this->SecondaryAxis_.set (std::move (x));
    }

    const SecondaryAlignmentOperationType::RotationAxis_optional& SecondaryAlignmentOperationType::
    RotationAxis () const
    {
      return this->RotationAxis_;
    }

    SecondaryAlignmentOperationType::RotationAxis_optional& SecondaryAlignmentOperationType::
    RotationAxis ()
    {
      return this->RotationAxis_;
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (const RotationAxis_type& x)
    {
      this->RotationAxis_.set (x);
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (const RotationAxis_optional& x)
    {
      this->RotationAxis_ = x;
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (::std::unique_ptr< RotationAxis_type > x)
    {
      this->RotationAxis_.set (std::move (x));
    }


    // MeasurementOriginOffsetType
    //

    const MeasurementOriginOffsetType::OriginEntity_type& MeasurementOriginOffsetType::
    OriginEntity () const
    {
      return this->OriginEntity_.get ();
    }

    MeasurementOriginOffsetType::OriginEntity_type& MeasurementOriginOffsetType::
    OriginEntity ()
    {
      return this->OriginEntity_.get ();
    }

    void MeasurementOriginOffsetType::
    OriginEntity (const OriginEntity_type& x)
    {
      this->OriginEntity_.set (x);
    }

    void MeasurementOriginOffsetType::
    OriginEntity (::std::unique_ptr< OriginEntity_type > x)
    {
      this->OriginEntity_.set (std::move (x));
    }

    const MeasurementOriginOffsetType::OriginDirection_type& MeasurementOriginOffsetType::
    OriginDirection () const
    {
      return this->OriginDirection_.get ();
    }

    MeasurementOriginOffsetType::OriginDirection_type& MeasurementOriginOffsetType::
    OriginDirection ()
    {
      return this->OriginDirection_.get ();
    }

    void MeasurementOriginOffsetType::
    OriginDirection (const OriginDirection_type& x)
    {
      this->OriginDirection_.set (x);
    }

    void MeasurementOriginOffsetType::
    OriginDirection (::std::unique_ptr< OriginDirection_type > x)
    {
      this->OriginDirection_.set (std::move (x));
    }


    // MeasurementOffsetAlignmentOperationType
    //

    const MeasurementOffsetAlignmentOperationType::Origin_sequence& MeasurementOffsetAlignmentOperationType::
    Origin () const
    {
      return this->Origin_;
    }

    MeasurementOffsetAlignmentOperationType::Origin_sequence& MeasurementOffsetAlignmentOperationType::
    Origin ()
    {
      return this->Origin_;
    }

    void MeasurementOffsetAlignmentOperationType::
    Origin (const Origin_sequence& s)
    {
      this->Origin_ = s;
    }

    const MeasurementOffsetAlignmentOperationType::n_type& MeasurementOffsetAlignmentOperationType::
    n () const
    {
      return this->n_.get ();
    }

    MeasurementOffsetAlignmentOperationType::n_type& MeasurementOffsetAlignmentOperationType::
    n ()
    {
      return this->n_.get ();
    }

    void MeasurementOffsetAlignmentOperationType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MeasurementOffsetAlignmentOperationType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // NominalOffsetAlignmentOperationType
    //

    const NominalOffsetAlignmentOperationType::Offset_type& NominalOffsetAlignmentOperationType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    NominalOffsetAlignmentOperationType::Offset_type& NominalOffsetAlignmentOperationType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void NominalOffsetAlignmentOperationType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void NominalOffsetAlignmentOperationType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }


    // NominalRotationAlignmentOperationType
    //

    const NominalRotationAlignmentOperationType::RotationAxis_type& NominalRotationAlignmentOperationType::
    RotationAxis () const
    {
      return this->RotationAxis_.get ();
    }

    NominalRotationAlignmentOperationType::RotationAxis_type& NominalRotationAlignmentOperationType::
    RotationAxis ()
    {
      return this->RotationAxis_.get ();
    }

    void NominalRotationAlignmentOperationType::
    RotationAxis (const RotationAxis_type& x)
    {
      this->RotationAxis_.set (x);
    }

    void NominalRotationAlignmentOperationType::
    RotationAxis (::std::unique_ptr< RotationAxis_type > x)
    {
      this->RotationAxis_.set (std::move (x));
    }

    const NominalRotationAlignmentOperationType::Angle_type& NominalRotationAlignmentOperationType::
    Angle () const
    {
      return this->Angle_.get ();
    }

    NominalRotationAlignmentOperationType::Angle_type& NominalRotationAlignmentOperationType::
    Angle ()
    {
      return this->Angle_.get ();
    }

    void NominalRotationAlignmentOperationType::
    Angle (const Angle_type& x)
    {
      this->Angle_.set (x);
    }

    void NominalRotationAlignmentOperationType::
    Angle (::std::unique_ptr< Angle_type > x)
    {
      this->Angle_.set (std::move (x));
    }


    // DatumPrecedenceAlignmentOperationType
    //

    const DatumPrecedenceAlignmentOperationType::DatumReferenceFrameId_type& DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId () const
    {
      return this->DatumReferenceFrameId_.get ();
    }

    DatumPrecedenceAlignmentOperationType::DatumReferenceFrameId_type& DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId ()
    {
      return this->DatumReferenceFrameId_.get ();
    }

    void DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId (const DatumReferenceFrameId_type& x)
    {
      this->DatumReferenceFrameId_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > x)
    {
      this->DatumReferenceFrameId_.set (std::move (x));
    }

    const DatumPrecedenceAlignmentOperationType::PrimaryAxis_type& DatumPrecedenceAlignmentOperationType::
    PrimaryAxis () const
    {
      return this->PrimaryAxis_.get ();
    }

    DatumPrecedenceAlignmentOperationType::PrimaryAxis_type& DatumPrecedenceAlignmentOperationType::
    PrimaryAxis ()
    {
      return this->PrimaryAxis_.get ();
    }

    void DatumPrecedenceAlignmentOperationType::
    PrimaryAxis (const PrimaryAxis_type& x)
    {
      this->PrimaryAxis_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    PrimaryAxis (::std::unique_ptr< PrimaryAxis_type > x)
    {
      this->PrimaryAxis_.set (std::move (x));
    }

    const DatumPrecedenceAlignmentOperationType::SecondaryAxis_optional& DatumPrecedenceAlignmentOperationType::
    SecondaryAxis () const
    {
      return this->SecondaryAxis_;
    }

    DatumPrecedenceAlignmentOperationType::SecondaryAxis_optional& DatumPrecedenceAlignmentOperationType::
    SecondaryAxis ()
    {
      return this->SecondaryAxis_;
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_type& x)
    {
      this->SecondaryAxis_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_optional& x)
    {
      this->SecondaryAxis_ = x;
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (::std::unique_ptr< SecondaryAxis_type > x)
    {
      this->SecondaryAxis_.set (std::move (x));
    }


    // BestFitAlignmentOperationType
    //

    const BestFitAlignmentOperationType::DegreesOfFreedom_type& BestFitAlignmentOperationType::
    DegreesOfFreedom () const
    {
      return this->DegreesOfFreedom_.get ();
    }

    BestFitAlignmentOperationType::DegreesOfFreedom_type& BestFitAlignmentOperationType::
    DegreesOfFreedom ()
    {
      return this->DegreesOfFreedom_.get ();
    }

    void BestFitAlignmentOperationType::
    DegreesOfFreedom (const DegreesOfFreedom_type& x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    void BestFitAlignmentOperationType::
    DegreesOfFreedom (::std::unique_ptr< DegreesOfFreedom_type > x)
    {
      this->DegreesOfFreedom_.set (std::move (x));
    }

    const BestFitAlignmentOperationType::BaseFeature_sequence& BestFitAlignmentOperationType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    BestFitAlignmentOperationType::BaseFeature_sequence& BestFitAlignmentOperationType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void BestFitAlignmentOperationType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const BestFitAlignmentOperationType::n_type& BestFitAlignmentOperationType::
    n () const
    {
      return this->n_.get ();
    }

    BestFitAlignmentOperationType::n_type& BestFitAlignmentOperationType::
    n ()
    {
      return this->n_.get ();
    }

    void BestFitAlignmentOperationType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void BestFitAlignmentOperationType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MachineCoordinateSystemOperationType
    //


    // AlignmentOperationsType
    //

    const AlignmentOperationsType::AlignmentOperation_sequence& AlignmentOperationsType::
    AlignmentOperation () const
    {
      return this->AlignmentOperation_;
    }

    AlignmentOperationsType::AlignmentOperation_sequence& AlignmentOperationsType::
    AlignmentOperation ()
    {
      return this->AlignmentOperation_;
    }

    void AlignmentOperationsType::
    AlignmentOperation (const AlignmentOperation_sequence& s)
    {
      this->AlignmentOperation_ = s;
    }

    const AlignmentOperationsType::BaseCoordinateSystemId_optional& AlignmentOperationsType::
    BaseCoordinateSystemId () const
    {
      return this->BaseCoordinateSystemId_;
    }

    AlignmentOperationsType::BaseCoordinateSystemId_optional& AlignmentOperationsType::
    BaseCoordinateSystemId ()
    {
      return this->BaseCoordinateSystemId_;
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (const BaseCoordinateSystemId_type& x)
    {
      this->BaseCoordinateSystemId_.set (x);
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (const BaseCoordinateSystemId_optional& x)
    {
      this->BaseCoordinateSystemId_ = x;
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (::std::unique_ptr< BaseCoordinateSystemId_type > x)
    {
      this->BaseCoordinateSystemId_.set (std::move (x));
    }

    const AlignmentOperationsType::n_type& AlignmentOperationsType::
    n () const
    {
      return this->n_.get ();
    }

    AlignmentOperationsType::n_type& AlignmentOperationsType::
    n ()
    {
      return this->n_.get ();
    }

    void AlignmentOperationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AlignmentOperationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MachineCoordinateSystemType
    //

    const MachineCoordinateSystemType::CoordinateSystemId_type& MachineCoordinateSystemType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    MachineCoordinateSystemType::CoordinateSystemId_type& MachineCoordinateSystemType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void MachineCoordinateSystemType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void MachineCoordinateSystemType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }

    const MachineCoordinateSystemType::MeasurementDeviceId_optional& MachineCoordinateSystemType::
    MeasurementDeviceId () const
    {
      return this->MeasurementDeviceId_;
    }

    MachineCoordinateSystemType::MeasurementDeviceId_optional& MachineCoordinateSystemType::
    MeasurementDeviceId ()
    {
      return this->MeasurementDeviceId_;
    }

    void MachineCoordinateSystemType::
    MeasurementDeviceId (const MeasurementDeviceId_type& x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    void MachineCoordinateSystemType::
    MeasurementDeviceId (const MeasurementDeviceId_optional& x)
    {
      this->MeasurementDeviceId_ = x;
    }

    void MachineCoordinateSystemType::
    MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > x)
    {
      this->MeasurementDeviceId_.set (std::move (x));
    }


    // CoordinateSystemListType
    //

    const CoordinateSystemListType::CoordinateSystem_sequence& CoordinateSystemListType::
    CoordinateSystem () const
    {
      return this->CoordinateSystem_;
    }

    CoordinateSystemListType::CoordinateSystem_sequence& CoordinateSystemListType::
    CoordinateSystem ()
    {
      return this->CoordinateSystem_;
    }

    void CoordinateSystemListType::
    CoordinateSystem (const CoordinateSystem_sequence& s)
    {
      this->CoordinateSystem_ = s;
    }

    const CoordinateSystemListType::n_type& CoordinateSystemListType::
    n () const
    {
      return this->n_.get ();
    }

    CoordinateSystemListType::n_type& CoordinateSystemListType::
    n ()
    {
      return this->n_.get ();
    }

    void CoordinateSystemListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CoordinateSystemListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CoordinateSystemsType
    //

    const CoordinateSystemsType::CoordinateSystemDefinitions_type& CoordinateSystemsType::
    CoordinateSystemDefinitions () const
    {
      return this->CoordinateSystemDefinitions_.get ();
    }

    CoordinateSystemsType::CoordinateSystemDefinitions_type& CoordinateSystemsType::
    CoordinateSystemDefinitions ()
    {
      return this->CoordinateSystemDefinitions_.get ();
    }

    void CoordinateSystemsType::
    CoordinateSystemDefinitions (const CoordinateSystemDefinitions_type& x)
    {
      this->CoordinateSystemDefinitions_.set (x);
    }

    void CoordinateSystemsType::
    CoordinateSystemDefinitions (::std::unique_ptr< CoordinateSystemDefinitions_type > x)
    {
      this->CoordinateSystemDefinitions_.set (std::move (x));
    }

    const CoordinateSystemsType::CommonCoordinateSystemId_optional& CoordinateSystemsType::
    CommonCoordinateSystemId () const
    {
      return this->CommonCoordinateSystemId_;
    }

    CoordinateSystemsType::CommonCoordinateSystemId_optional& CoordinateSystemsType::
    CommonCoordinateSystemId ()
    {
      return this->CommonCoordinateSystemId_;
    }

    void CoordinateSystemsType::
    CommonCoordinateSystemId (const CommonCoordinateSystemId_type& x)
    {
      this->CommonCoordinateSystemId_.set (x);
    }

    void CoordinateSystemsType::
    CommonCoordinateSystemId (const CommonCoordinateSystemId_optional& x)
    {
      this->CommonCoordinateSystemId_ = x;
    }

    void CoordinateSystemsType::
    CommonCoordinateSystemId (::std::unique_ptr< CommonCoordinateSystemId_type > x)
    {
      this->CommonCoordinateSystemId_.set (std::move (x));
    }

    const CoordinateSystemsType::MachineCoordinateSystem_sequence& CoordinateSystemsType::
    MachineCoordinateSystem () const
    {
      return this->MachineCoordinateSystem_;
    }

    CoordinateSystemsType::MachineCoordinateSystem_sequence& CoordinateSystemsType::
    MachineCoordinateSystem ()
    {
      return this->MachineCoordinateSystem_;
    }

    void CoordinateSystemsType::
    MachineCoordinateSystem (const MachineCoordinateSystem_sequence& s)
    {
      this->MachineCoordinateSystem_ = s;
    }


    // CoordinateSystemType
    //

    const CoordinateSystemType::Attributes_optional& CoordinateSystemType::
    Attributes () const
    {
      return this->Attributes_;
    }

    CoordinateSystemType::Attributes_optional& CoordinateSystemType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void CoordinateSystemType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void CoordinateSystemType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void CoordinateSystemType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const CoordinateSystemType::Name_optional& CoordinateSystemType::
    Name () const
    {
      return this->Name_;
    }

    CoordinateSystemType::Name_optional& CoordinateSystemType::
    Name ()
    {
      return this->Name_;
    }

    void CoordinateSystemType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void CoordinateSystemType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void CoordinateSystemType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const CoordinateSystemType::NominalTransform_optional& CoordinateSystemType::
    NominalTransform () const
    {
      return this->NominalTransform_;
    }

    CoordinateSystemType::NominalTransform_optional& CoordinateSystemType::
    NominalTransform ()
    {
      return this->NominalTransform_;
    }

    void CoordinateSystemType::
    NominalTransform (const NominalTransform_type& x)
    {
      this->NominalTransform_.set (x);
    }

    void CoordinateSystemType::
    NominalTransform (const NominalTransform_optional& x)
    {
      this->NominalTransform_ = x;
    }

    void CoordinateSystemType::
    NominalTransform (::std::unique_ptr< NominalTransform_type > x)
    {
      this->NominalTransform_.set (std::move (x));
    }

    const CoordinateSystemType::InternalCADCoordinateSystemId_optional& CoordinateSystemType::
    InternalCADCoordinateSystemId () const
    {
      return this->InternalCADCoordinateSystemId_;
    }

    CoordinateSystemType::InternalCADCoordinateSystemId_optional& CoordinateSystemType::
    InternalCADCoordinateSystemId ()
    {
      return this->InternalCADCoordinateSystemId_;
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_type& x)
    {
      this->InternalCADCoordinateSystemId_.set (x);
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_optional& x)
    {
      this->InternalCADCoordinateSystemId_ = x;
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (::std::unique_ptr< InternalCADCoordinateSystemId_type > x)
    {
      this->InternalCADCoordinateSystemId_.set (std::move (x));
    }

    const CoordinateSystemType::ExternalCADCoordinateSystemId_optional& CoordinateSystemType::
    ExternalCADCoordinateSystemId () const
    {
      return this->ExternalCADCoordinateSystemId_;
    }

    CoordinateSystemType::ExternalCADCoordinateSystemId_optional& CoordinateSystemType::
    ExternalCADCoordinateSystemId ()
    {
      return this->ExternalCADCoordinateSystemId_;
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_type& x)
    {
      this->ExternalCADCoordinateSystemId_.set (x);
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_optional& x)
    {
      this->ExternalCADCoordinateSystemId_ = x;
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (::std::unique_ptr< ExternalCADCoordinateSystemId_type > x)
    {
      this->ExternalCADCoordinateSystemId_.set (std::move (x));
    }

    const CoordinateSystemType::AlignmentOperations_optional& CoordinateSystemType::
    AlignmentOperations () const
    {
      return this->AlignmentOperations_;
    }

    CoordinateSystemType::AlignmentOperations_optional& CoordinateSystemType::
    AlignmentOperations ()
    {
      return this->AlignmentOperations_;
    }

    void CoordinateSystemType::
    AlignmentOperations (const AlignmentOperations_type& x)
    {
      this->AlignmentOperations_.set (x);
    }

    void CoordinateSystemType::
    AlignmentOperations (const AlignmentOperations_optional& x)
    {
      this->AlignmentOperations_ = x;
    }

    void CoordinateSystemType::
    AlignmentOperations (::std::unique_ptr< AlignmentOperations_type > x)
    {
      this->AlignmentOperations_.set (std::move (x));
    }

    const CoordinateSystemType::SequenceNumber_optional& CoordinateSystemType::
    SequenceNumber () const
    {
      return this->SequenceNumber_;
    }

    CoordinateSystemType::SequenceNumber_optional& CoordinateSystemType::
    SequenceNumber ()
    {
      return this->SequenceNumber_;
    }

    void CoordinateSystemType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void CoordinateSystemType::
    SequenceNumber (const SequenceNumber_optional& x)
    {
      this->SequenceNumber_ = x;
    }

    void CoordinateSystemType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }

    const CoordinateSystemType::id_type& CoordinateSystemType::
    id () const
    {
      return this->id_.get ();
    }

    CoordinateSystemType::id_type& CoordinateSystemType::
    id ()
    {
      return this->id_.get ();
    }

    void CoordinateSystemType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void CoordinateSystemType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CoordinateSystemActualTransformAssociationType
    //

    const CoordinateSystemActualTransformAssociationType::ActualTransformId_type& CoordinateSystemActualTransformAssociationType::
    ActualTransformId () const
    {
      return this->ActualTransformId_.get ();
    }

    CoordinateSystemActualTransformAssociationType::ActualTransformId_type& CoordinateSystemActualTransformAssociationType::
    ActualTransformId ()
    {
      return this->ActualTransformId_.get ();
    }

    void CoordinateSystemActualTransformAssociationType::
    ActualTransformId (const ActualTransformId_type& x)
    {
      this->ActualTransformId_.set (x);
    }

    void CoordinateSystemActualTransformAssociationType::
    ActualTransformId (::std::unique_ptr< ActualTransformId_type > x)
    {
      this->ActualTransformId_.set (std::move (x));
    }

    const CoordinateSystemActualTransformAssociationType::CoordinateSystemId_type& CoordinateSystemActualTransformAssociationType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    CoordinateSystemActualTransformAssociationType::CoordinateSystemId_type& CoordinateSystemActualTransformAssociationType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void CoordinateSystemActualTransformAssociationType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void CoordinateSystemActualTransformAssociationType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }


    // CoordinateSystemActualTransformAssociationsType
    //

    const CoordinateSystemActualTransformAssociationsType::CoordinateSystemActualTransformAssociation_sequence& CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociation () const
    {
      return this->CoordinateSystemActualTransformAssociation_;
    }

    CoordinateSystemActualTransformAssociationsType::CoordinateSystemActualTransformAssociation_sequence& CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociation ()
    {
      return this->CoordinateSystemActualTransformAssociation_;
    }

    void CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociation (const CoordinateSystemActualTransformAssociation_sequence& s)
    {
      this->CoordinateSystemActualTransformAssociation_ = s;
    }

    const CoordinateSystemActualTransformAssociationsType::n_type& CoordinateSystemActualTransformAssociationsType::
    n () const
    {
      return this->n_.get ();
    }

    CoordinateSystemActualTransformAssociationsType::n_type& CoordinateSystemActualTransformAssociationsType::
    n ()
    {
      return this->n_.get ();
    }

    void CoordinateSystemActualTransformAssociationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CoordinateSystemActualTransformAssociationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ThreadSpecificationDetailedBaseType
    //

    const ThreadSpecificationDetailedBaseType::Diameter_type& ThreadSpecificationDetailedBaseType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ThreadSpecificationDetailedBaseType::Diameter_type& ThreadSpecificationDetailedBaseType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::ThreadSeries_type& ThreadSpecificationDetailedBaseType::
    ThreadSeries () const
    {
      return this->ThreadSeries_.get ();
    }

    ThreadSpecificationDetailedBaseType::ThreadSeries_type& ThreadSpecificationDetailedBaseType::
    ThreadSeries ()
    {
      return this->ThreadSeries_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadSeries (const ThreadSeries_type& x)
    {
      this->ThreadSeries_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadSeries (::std::unique_ptr< ThreadSeries_type > x)
    {
      this->ThreadSeries_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::ThreadToleranceClass_type& ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass () const
    {
      return this->ThreadToleranceClass_.get ();
    }

    ThreadSpecificationDetailedBaseType::ThreadToleranceClass_type& ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass ()
    {
      return this->ThreadToleranceClass_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass (const ThreadToleranceClass_type& x)
    {
      this->ThreadToleranceClass_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass (::std::unique_ptr< ThreadToleranceClass_type > x)
    {
      this->ThreadToleranceClass_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::CrestDiameterToleranceClass_optional& ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass () const
    {
      return this->CrestDiameterToleranceClass_;
    }

    ThreadSpecificationDetailedBaseType::CrestDiameterToleranceClass_optional& ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass ()
    {
      return this->CrestDiameterToleranceClass_;
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (const CrestDiameterToleranceClass_type& x)
    {
      this->CrestDiameterToleranceClass_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (const CrestDiameterToleranceClass_optional& x)
    {
      this->CrestDiameterToleranceClass_ = x;
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (::std::unique_ptr< CrestDiameterToleranceClass_type > x)
    {
      this->CrestDiameterToleranceClass_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::LeftHanded_optional& ThreadSpecificationDetailedBaseType::
    LeftHanded () const
    {
      return this->LeftHanded_;
    }

    ThreadSpecificationDetailedBaseType::LeftHanded_optional& ThreadSpecificationDetailedBaseType::
    LeftHanded ()
    {
      return this->LeftHanded_;
    }

    void ThreadSpecificationDetailedBaseType::
    LeftHanded (const LeftHanded_type& x)
    {
      this->LeftHanded_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    LeftHanded (const LeftHanded_optional& x)
    {
      this->LeftHanded_ = x;
    }

    const ThreadSpecificationDetailedBaseType::ModifiedThread_optional& ThreadSpecificationDetailedBaseType::
    ModifiedThread () const
    {
      return this->ModifiedThread_;
    }

    ThreadSpecificationDetailedBaseType::ModifiedThread_optional& ThreadSpecificationDetailedBaseType::
    ModifiedThread ()
    {
      return this->ModifiedThread_;
    }

    void ThreadSpecificationDetailedBaseType::
    ModifiedThread (const ModifiedThread_type& x)
    {
      this->ModifiedThread_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ModifiedThread (const ModifiedThread_optional& x)
    {
      this->ModifiedThread_ = x;
    }

    const ThreadSpecificationDetailedBaseType::ThreadLengthEngagement_optional& ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement () const
    {
      return this->ThreadLengthEngagement_;
    }

    ThreadSpecificationDetailedBaseType::ThreadLengthEngagement_optional& ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement ()
    {
      return this->ThreadLengthEngagement_;
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (const ThreadLengthEngagement_type& x)
    {
      this->ThreadLengthEngagement_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (const ThreadLengthEngagement_optional& x)
    {
      this->ThreadLengthEngagement_ = x;
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (::std::unique_ptr< ThreadLengthEngagement_type > x)
    {
      this->ThreadLengthEngagement_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::Attributes_optional& ThreadSpecificationDetailedBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ThreadSpecificationDetailedBaseType::Attributes_optional& ThreadSpecificationDetailedBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ThreadSpecificationDetailedBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ThreadSpecificationDetailedBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const ThreadSpecificationDetailedBaseType::id_type& ThreadSpecificationDetailedBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ThreadSpecificationDetailedBaseType::id_type& ThreadSpecificationDetailedBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // SingleLeadThreadSpecificationType
    //

    const SingleLeadThreadSpecificationType::ThreadDensity_type& SingleLeadThreadSpecificationType::
    ThreadDensity () const
    {
      return this->ThreadDensity_.get ();
    }

    SingleLeadThreadSpecificationType::ThreadDensity_type& SingleLeadThreadSpecificationType::
    ThreadDensity ()
    {
      return this->ThreadDensity_.get ();
    }

    void SingleLeadThreadSpecificationType::
    ThreadDensity (const ThreadDensity_type& x)
    {
      this->ThreadDensity_.set (x);
    }

    void SingleLeadThreadSpecificationType::
    ThreadDensity (::std::unique_ptr< ThreadDensity_type > x)
    {
      this->ThreadDensity_.set (std::move (x));
    }


    // MultiLeadThreadSpecificationType
    //

    const MultiLeadThreadSpecificationType::ThreadPitch_type& MultiLeadThreadSpecificationType::
    ThreadPitch () const
    {
      return this->ThreadPitch_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadPitch_type& MultiLeadThreadSpecificationType::
    ThreadPitch ()
    {
      return this->ThreadPitch_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadPitch (const ThreadPitch_type& x)
    {
      this->ThreadPitch_.set (x);
    }

    void MultiLeadThreadSpecificationType::
    ThreadPitch (::std::unique_ptr< ThreadPitch_type > x)
    {
      this->ThreadPitch_.set (std::move (x));
    }

    const MultiLeadThreadSpecificationType::ThreadLeadDistance_type& MultiLeadThreadSpecificationType::
    ThreadLeadDistance () const
    {
      return this->ThreadLeadDistance_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadLeadDistance_type& MultiLeadThreadSpecificationType::
    ThreadLeadDistance ()
    {
      return this->ThreadLeadDistance_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadDistance (const ThreadLeadDistance_type& x)
    {
      this->ThreadLeadDistance_.set (x);
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadDistance (::std::unique_ptr< ThreadLeadDistance_type > x)
    {
      this->ThreadLeadDistance_.set (std::move (x));
    }

    const MultiLeadThreadSpecificationType::ThreadLeadStarts_type& MultiLeadThreadSpecificationType::
    ThreadLeadStarts () const
    {
      return this->ThreadLeadStarts_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadLeadStarts_type& MultiLeadThreadSpecificationType::
    ThreadLeadStarts ()
    {
      return this->ThreadLeadStarts_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadStarts (const ThreadLeadStarts_type& x)
    {
      this->ThreadLeadStarts_.set (x);
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadStarts (::std::unique_ptr< ThreadLeadStarts_type > x)
    {
      this->ThreadLeadStarts_.set (std::move (x));
    }


    // ThreadSpecificationType
    //

    const ThreadSpecificationType::SingleLeadSpecification_optional& ThreadSpecificationType::
    SingleLeadSpecification () const
    {
      return this->SingleLeadSpecification_;
    }

    ThreadSpecificationType::SingleLeadSpecification_optional& ThreadSpecificationType::
    SingleLeadSpecification ()
    {
      return this->SingleLeadSpecification_;
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (const SingleLeadSpecification_type& x)
    {
      this->SingleLeadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (const SingleLeadSpecification_optional& x)
    {
      this->SingleLeadSpecification_ = x;
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (::std::unique_ptr< SingleLeadSpecification_type > x)
    {
      this->SingleLeadSpecification_.set (std::move (x));
    }

    const ThreadSpecificationType::MultiLeadSpecification_optional& ThreadSpecificationType::
    MultiLeadSpecification () const
    {
      return this->MultiLeadSpecification_;
    }

    ThreadSpecificationType::MultiLeadSpecification_optional& ThreadSpecificationType::
    MultiLeadSpecification ()
    {
      return this->MultiLeadSpecification_;
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (const MultiLeadSpecification_type& x)
    {
      this->MultiLeadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (const MultiLeadSpecification_optional& x)
    {
      this->MultiLeadSpecification_ = x;
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (::std::unique_ptr< MultiLeadSpecification_type > x)
    {
      this->MultiLeadSpecification_.set (std::move (x));
    }

    const ThreadSpecificationType::TextThreadSpecification_optional& ThreadSpecificationType::
    TextThreadSpecification () const
    {
      return this->TextThreadSpecification_;
    }

    ThreadSpecificationType::TextThreadSpecification_optional& ThreadSpecificationType::
    TextThreadSpecification ()
    {
      return this->TextThreadSpecification_;
    }

    void ThreadSpecificationType::
    TextThreadSpecification (const TextThreadSpecification_type& x)
    {
      this->TextThreadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    TextThreadSpecification (const TextThreadSpecification_optional& x)
    {
      this->TextThreadSpecification_ = x;
    }

    void ThreadSpecificationType::
    TextThreadSpecification (::std::unique_ptr< TextThreadSpecification_type > x)
    {
      this->TextThreadSpecification_.set (std::move (x));
    }


    // TextThreadSpecificationType
    //

    const TextThreadSpecificationType::TextSpecification_type& TextThreadSpecificationType::
    TextSpecification () const
    {
      return this->TextSpecification_.get ();
    }

    TextThreadSpecificationType::TextSpecification_type& TextThreadSpecificationType::
    TextSpecification ()
    {
      return this->TextSpecification_.get ();
    }

    void TextThreadSpecificationType::
    TextSpecification (const TextSpecification_type& x)
    {
      this->TextSpecification_.set (x);
    }

    void TextThreadSpecificationType::
    TextSpecification (::std::unique_ptr< TextSpecification_type > x)
    {
      this->TextSpecification_.set (std::move (x));
    }

    const TextThreadSpecificationType::id_type& TextThreadSpecificationType::
    id () const
    {
      return this->id_.get ();
    }

    TextThreadSpecificationType::id_type& TextThreadSpecificationType::
    id ()
    {
      return this->id_.get ();
    }

    void TextThreadSpecificationType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void TextThreadSpecificationType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ThreadSpecificationsType
    //

    const ThreadSpecificationsType::ThreadSpecification_sequence& ThreadSpecificationsType::
    ThreadSpecification () const
    {
      return this->ThreadSpecification_;
    }

    ThreadSpecificationsType::ThreadSpecification_sequence& ThreadSpecificationsType::
    ThreadSpecification ()
    {
      return this->ThreadSpecification_;
    }

    void ThreadSpecificationsType::
    ThreadSpecification (const ThreadSpecification_sequence& s)
    {
      this->ThreadSpecification_ = s;
    }

    const ThreadSpecificationsType::n_type& ThreadSpecificationsType::
    n () const
    {
      return this->n_.get ();
    }

    ThreadSpecificationsType::n_type& ThreadSpecificationsType::
    n ()
    {
      return this->n_.get ();
    }

    void ThreadSpecificationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ThreadSpecificationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ToleranceZonePerUnitAreaType
    //

    const ToleranceZonePerUnitAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (std::move (x));
    }

    const ToleranceZonePerUnitAreaType::RectangularUnitArea_optional& ToleranceZonePerUnitAreaType::
    RectangularUnitArea () const
    {
      return this->RectangularUnitArea_;
    }

    ToleranceZonePerUnitAreaType::RectangularUnitArea_optional& ToleranceZonePerUnitAreaType::
    RectangularUnitArea ()
    {
      return this->RectangularUnitArea_;
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (const RectangularUnitArea_type& x)
    {
      this->RectangularUnitArea_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (const RectangularUnitArea_optional& x)
    {
      this->RectangularUnitArea_ = x;
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (::std::unique_ptr< RectangularUnitArea_type > x)
    {
      this->RectangularUnitArea_.set (std::move (x));
    }

    const ToleranceZonePerUnitAreaType::CircularUnitArea_optional& ToleranceZonePerUnitAreaType::
    CircularUnitArea () const
    {
      return this->CircularUnitArea_;
    }

    ToleranceZonePerUnitAreaType::CircularUnitArea_optional& ToleranceZonePerUnitAreaType::
    CircularUnitArea ()
    {
      return this->CircularUnitArea_;
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (const CircularUnitArea_type& x)
    {
      this->CircularUnitArea_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (const CircularUnitArea_optional& x)
    {
      this->CircularUnitArea_ = x;
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (::std::unique_ptr< CircularUnitArea_type > x)
    {
      this->CircularUnitArea_.set (std::move (x));
    }


    // ToleranceZonePerUnitLengthType
    //

    const ToleranceZonePerUnitLengthType::ToleranceValuePerUnit_type& ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitLengthType::ToleranceValuePerUnit_type& ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (std::move (x));
    }

    const ToleranceZonePerUnitLengthType::UnitLength_type& ToleranceZonePerUnitLengthType::
    UnitLength () const
    {
      return this->UnitLength_.get ();
    }

    ToleranceZonePerUnitLengthType::UnitLength_type& ToleranceZonePerUnitLengthType::
    UnitLength ()
    {
      return this->UnitLength_.get ();
    }

    void ToleranceZonePerUnitLengthType::
    UnitLength (const UnitLength_type& x)
    {
      this->UnitLength_.set (x);
    }

    void ToleranceZonePerUnitLengthType::
    UnitLength (::std::unique_ptr< UnitLength_type > x)
    {
      this->UnitLength_.set (std::move (x));
    }


    // ToleranceZonePerUnitAngleType
    //

    const ToleranceZonePerUnitAngleType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitAngleType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (std::move (x));
    }

    const ToleranceZonePerUnitAngleType::UnitAngle_type& ToleranceZonePerUnitAngleType::
    UnitAngle () const
    {
      return this->UnitAngle_.get ();
    }

    ToleranceZonePerUnitAngleType::UnitAngle_type& ToleranceZonePerUnitAngleType::
    UnitAngle ()
    {
      return this->UnitAngle_.get ();
    }

    void ToleranceZonePerUnitAngleType::
    UnitAngle (const UnitAngle_type& x)
    {
      this->UnitAngle_.set (x);
    }

    void ToleranceZonePerUnitAngleType::
    UnitAngle (::std::unique_ptr< UnitAngle_type > x)
    {
      this->UnitAngle_.set (std::move (x));
    }


    // ToleranceZonePerUnitPolarAreaType
    //

    const ToleranceZonePerUnitPolarAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (std::move (x));
    }

    const ToleranceZonePerUnitPolarAreaType::UnitAngle_type& ToleranceZonePerUnitPolarAreaType::
    UnitAngle () const
    {
      return this->UnitAngle_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::UnitAngle_type& ToleranceZonePerUnitPolarAreaType::
    UnitAngle ()
    {
      return this->UnitAngle_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitAngle (const UnitAngle_type& x)
    {
      this->UnitAngle_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitAngle (::std::unique_ptr< UnitAngle_type > x)
    {
      this->UnitAngle_.set (std::move (x));
    }

    const ToleranceZonePerUnitPolarAreaType::UnitLength_type& ToleranceZonePerUnitPolarAreaType::
    UnitLength () const
    {
      return this->UnitLength_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::UnitLength_type& ToleranceZonePerUnitPolarAreaType::
    UnitLength ()
    {
      return this->UnitLength_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitLength (const UnitLength_type& x)
    {
      this->UnitLength_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitLength (::std::unique_ptr< UnitLength_type > x)
    {
      this->UnitLength_.set (std::move (x));
    }


    // DatumReferenceFramesType
    //

    const DatumReferenceFramesType::DatumReferenceFrame_sequence& DatumReferenceFramesType::
    DatumReferenceFrame () const
    {
      return this->DatumReferenceFrame_;
    }

    DatumReferenceFramesType::DatumReferenceFrame_sequence& DatumReferenceFramesType::
    DatumReferenceFrame ()
    {
      return this->DatumReferenceFrame_;
    }

    void DatumReferenceFramesType::
    DatumReferenceFrame (const DatumReferenceFrame_sequence& s)
    {
      this->DatumReferenceFrame_ = s;
    }

    const DatumReferenceFramesType::n_type& DatumReferenceFramesType::
    n () const
    {
      return this->n_.get ();
    }

    DatumReferenceFramesType::n_type& DatumReferenceFramesType::
    n ()
    {
      return this->n_.get ();
    }

    void DatumReferenceFramesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DatumReferenceFramesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // EventBaseType
    //

    const EventBaseType::Description_type& EventBaseType::
    Description () const
    {
      return this->Description_.get ();
    }

    EventBaseType::Description_type& EventBaseType::
    Description ()
    {
      return this->Description_.get ();
    }

    void EventBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void EventBaseType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const EventBaseType::id_type& EventBaseType::
    id () const
    {
      return this->id_.get ();
    }

    EventBaseType::id_type& EventBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void EventBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void EventBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // NotableEventType
    //

    const NotableEventType::Active_type& NotableEventType::
    Active () const
    {
      return this->Active_.get ();
    }

    NotableEventType::Active_type& NotableEventType::
    Active ()
    {
      return this->Active_.get ();
    }

    void NotableEventType::
    Active (const Active_type& x)
    {
      this->Active_.set (x);
    }


    // NotableEventsType
    //

    const NotableEventsType::NotableEvent_sequence& NotableEventsType::
    NotableEvent () const
    {
      return this->NotableEvent_;
    }

    NotableEventsType::NotableEvent_sequence& NotableEventsType::
    NotableEvent ()
    {
      return this->NotableEvent_;
    }

    void NotableEventsType::
    NotableEvent (const NotableEvent_sequence& s)
    {
      this->NotableEvent_ = s;
    }

    const NotableEventsType::n_type& NotableEventsType::
    n () const
    {
      return this->n_.get ();
    }

    NotableEventsType::n_type& NotableEventsType::
    n ()
    {
      return this->n_.get ();
    }

    void NotableEventsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NotableEventsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // NotedEventType
    //

    const NotedEventType::SequenceNumber_type& NotedEventType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    NotedEventType::SequenceNumber_type& NotedEventType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void NotedEventType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void NotedEventType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }

    const NotedEventType::TimeOccurred_optional& NotedEventType::
    TimeOccurred () const
    {
      return this->TimeOccurred_;
    }

    NotedEventType::TimeOccurred_optional& NotedEventType::
    TimeOccurred ()
    {
      return this->TimeOccurred_;
    }

    void NotedEventType::
    TimeOccurred (const TimeOccurred_type& x)
    {
      this->TimeOccurred_.set (x);
    }

    void NotedEventType::
    TimeOccurred (const TimeOccurred_optional& x)
    {
      this->TimeOccurred_ = x;
    }

    void NotedEventType::
    TimeOccurred (::std::unique_ptr< TimeOccurred_type > x)
    {
      this->TimeOccurred_.set (std::move (x));
    }

    const NotedEventType::NotableEventId_optional& NotedEventType::
    NotableEventId () const
    {
      return this->NotableEventId_;
    }

    NotedEventType::NotableEventId_optional& NotedEventType::
    NotableEventId ()
    {
      return this->NotableEventId_;
    }

    void NotedEventType::
    NotableEventId (const NotableEventId_type& x)
    {
      this->NotableEventId_.set (x);
    }

    void NotedEventType::
    NotableEventId (const NotableEventId_optional& x)
    {
      this->NotableEventId_ = x;
    }

    void NotedEventType::
    NotableEventId (::std::unique_ptr< NotableEventId_type > x)
    {
      this->NotableEventId_.set (std::move (x));
    }


    // NotedEventsType
    //

    const NotedEventsType::NotedEvent_sequence& NotedEventsType::
    NotedEvent () const
    {
      return this->NotedEvent_;
    }

    NotedEventsType::NotedEvent_sequence& NotedEventsType::
    NotedEvent ()
    {
      return this->NotedEvent_;
    }

    void NotedEventsType::
    NotedEvent (const NotedEvent_sequence& s)
    {
      this->NotedEvent_ = s;
    }

    const NotedEventsType::n_type& NotedEventsType::
    n () const
    {
      return this->n_.get ();
    }

    NotedEventsType::n_type& NotedEventsType::
    n ()
    {
      return this->n_.get ();
    }

    void NotedEventsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NotedEventsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // InspectionStatusEnumType
    //

    InspectionStatusEnumType::
    InspectionStatusEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_InspectionStatusEnumType_literals_[v])
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const InspectionStatusEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    InspectionStatusEnumType& InspectionStatusEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_InspectionStatusEnumType_literals_[v]);

      return *this;
    }


    // InspectionStatusType
    //

    const InspectionStatusType::InspectionStatusEnum_optional& InspectionStatusType::
    InspectionStatusEnum () const
    {
      return this->InspectionStatusEnum_;
    }

    InspectionStatusType::InspectionStatusEnum_optional& InspectionStatusType::
    InspectionStatusEnum ()
    {
      return this->InspectionStatusEnum_;
    }

    void InspectionStatusType::
    InspectionStatusEnum (const InspectionStatusEnum_type& x)
    {
      this->InspectionStatusEnum_.set (x);
    }

    void InspectionStatusType::
    InspectionStatusEnum (const InspectionStatusEnum_optional& x)
    {
      this->InspectionStatusEnum_ = x;
    }

    void InspectionStatusType::
    InspectionStatusEnum (::std::unique_ptr< InspectionStatusEnum_type > x)
    {
      this->InspectionStatusEnum_.set (std::move (x));
    }

    const InspectionStatusType::OtherInspectionStatus_optional& InspectionStatusType::
    OtherInspectionStatus () const
    {
      return this->OtherInspectionStatus_;
    }

    InspectionStatusType::OtherInspectionStatus_optional& InspectionStatusType::
    OtherInspectionStatus ()
    {
      return this->OtherInspectionStatus_;
    }

    void InspectionStatusType::
    OtherInspectionStatus (const OtherInspectionStatus_type& x)
    {
      this->OtherInspectionStatus_.set (x);
    }

    void InspectionStatusType::
    OtherInspectionStatus (const OtherInspectionStatus_optional& x)
    {
      this->OtherInspectionStatus_ = x;
    }

    void InspectionStatusType::
    OtherInspectionStatus (::std::unique_ptr< OtherInspectionStatus_type > x)
    {
      this->OtherInspectionStatus_.set (std::move (x));
    }


    // EntityExternalType
    //

    const EntityExternalType::EntityId_type& EntityExternalType::
    EntityId () const
    {
      return this->EntityId_.get ();
    }

    EntityExternalType::EntityId_type& EntityExternalType::
    EntityId ()
    {
      return this->EntityId_.get ();
    }

    void EntityExternalType::
    EntityId (const EntityId_type& x)
    {
      this->EntityId_.set (x);
    }

    void EntityExternalType::
    EntityId (::std::unique_ptr< EntityId_type > x)
    {
      this->EntityId_.set (std::move (x));
    }

    const EntityExternalType::Name_optional& EntityExternalType::
    Name () const
    {
      return this->Name_;
    }

    EntityExternalType::Name_optional& EntityExternalType::
    Name ()
    {
      return this->Name_;
    }

    void EntityExternalType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void EntityExternalType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void EntityExternalType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const EntityExternalType::Description_optional& EntityExternalType::
    Description () const
    {
      return this->Description_;
    }

    EntityExternalType::Description_optional& EntityExternalType::
    Description ()
    {
      return this->Description_;
    }

    void EntityExternalType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void EntityExternalType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void EntityExternalType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const EntityExternalType::id_type& EntityExternalType::
    id () const
    {
      return this->id_.get ();
    }

    EntityExternalType::id_type& EntityExternalType::
    id ()
    {
      return this->id_.get ();
    }

    void EntityExternalType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void EntityExternalType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // EntitiesExternalType
    //

    const EntitiesExternalType::Entity_sequence& EntitiesExternalType::
    Entity () const
    {
      return this->Entity_;
    }

    EntitiesExternalType::Entity_sequence& EntitiesExternalType::
    Entity ()
    {
      return this->Entity_;
    }

    void EntitiesExternalType::
    Entity (const Entity_sequence& s)
    {
      this->Entity_ = s;
    }

    const EntitiesExternalType::n_type& EntitiesExternalType::
    n () const
    {
      return this->n_.get ();
    }

    EntitiesExternalType::n_type& EntitiesExternalType::
    n ()
    {
      return this->n_.get ();
    }

    void EntitiesExternalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void EntitiesExternalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ZoneDataType
    //

    const ZoneDataType::FeatureItemId_type& ZoneDataType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    ZoneDataType::FeatureItemId_type& ZoneDataType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void ZoneDataType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void ZoneDataType::
    FeatureItemId (::std::unique_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (std::move (x));
    }

    const ZoneDataType::Bonus_type& ZoneDataType::
    Bonus () const
    {
      return this->Bonus_.get ();
    }

    ZoneDataType::Bonus_type& ZoneDataType::
    Bonus ()
    {
      return this->Bonus_.get ();
    }

    void ZoneDataType::
    Bonus (const Bonus_type& x)
    {
      this->Bonus_.set (x);
    }

    void ZoneDataType::
    Bonus (::std::unique_ptr< Bonus_type > x)
    {
      this->Bonus_.set (std::move (x));
    }

    const ZoneDataType::ReferenceLength_type& ZoneDataType::
    ReferenceLength () const
    {
      return this->ReferenceLength_.get ();
    }

    ZoneDataType::ReferenceLength_type& ZoneDataType::
    ReferenceLength ()
    {
      return this->ReferenceLength_.get ();
    }

    void ZoneDataType::
    ReferenceLength (const ReferenceLength_type& x)
    {
      this->ReferenceLength_.set (x);
    }

    void ZoneDataType::
    ReferenceLength (::std::unique_ptr< ReferenceLength_type > x)
    {
      this->ReferenceLength_.set (std::move (x));
    }


    // ZoneDataSetType
    //

    const ZoneDataSetType::ZoneData_sequence& ZoneDataSetType::
    ZoneData () const
    {
      return this->ZoneData_;
    }

    ZoneDataSetType::ZoneData_sequence& ZoneDataSetType::
    ZoneData ()
    {
      return this->ZoneData_;
    }

    void ZoneDataSetType::
    ZoneData (const ZoneData_sequence& s)
    {
      this->ZoneData_ = s;
    }

    const ZoneDataSetType::n_type& ZoneDataSetType::
    n () const
    {
      return this->n_.get ();
    }

    ZoneDataSetType::n_type& ZoneDataSetType::
    n ()
    {
      return this->n_.get ();
    }

    void ZoneDataSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ZoneDataSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LinearToleranceType
    //

    const LinearToleranceType::MaxValue_optional& LinearToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    LinearToleranceType::MaxValue_optional& LinearToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void LinearToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void LinearToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void LinearToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const LinearToleranceType::MaxDualValue_optional& LinearToleranceType::
    MaxDualValue () const
    {
      return this->MaxDualValue_;
    }

    LinearToleranceType::MaxDualValue_optional& LinearToleranceType::
    MaxDualValue ()
    {
      return this->MaxDualValue_;
    }

    void LinearToleranceType::
    MaxDualValue (const MaxDualValue_type& x)
    {
      this->MaxDualValue_.set (x);
    }

    void LinearToleranceType::
    MaxDualValue (const MaxDualValue_optional& x)
    {
      this->MaxDualValue_ = x;
    }

    void LinearToleranceType::
    MaxDualValue (::std::unique_ptr< MaxDualValue_type > x)
    {
      this->MaxDualValue_.set (std::move (x));
    }

    const LinearToleranceType::MinValue_optional& LinearToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    LinearToleranceType::MinValue_optional& LinearToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void LinearToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void LinearToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void LinearToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const LinearToleranceType::MinDualValue_optional& LinearToleranceType::
    MinDualValue () const
    {
      return this->MinDualValue_;
    }

    LinearToleranceType::MinDualValue_optional& LinearToleranceType::
    MinDualValue ()
    {
      return this->MinDualValue_;
    }

    void LinearToleranceType::
    MinDualValue (const MinDualValue_type& x)
    {
      this->MinDualValue_.set (x);
    }

    void LinearToleranceType::
    MinDualValue (const MinDualValue_optional& x)
    {
      this->MinDualValue_ = x;
    }

    void LinearToleranceType::
    MinDualValue (::std::unique_ptr< MinDualValue_type > x)
    {
      this->MinDualValue_.set (std::move (x));
    }

    const LinearToleranceType::DefinitionId_optional& LinearToleranceType::
    DefinitionId () const
    {
      return this->DefinitionId_;
    }

    LinearToleranceType::DefinitionId_optional& LinearToleranceType::
    DefinitionId ()
    {
      return this->DefinitionId_;
    }

    void LinearToleranceType::
    DefinitionId (const DefinitionId_type& x)
    {
      this->DefinitionId_.set (x);
    }

    void LinearToleranceType::
    DefinitionId (const DefinitionId_optional& x)
    {
      this->DefinitionId_ = x;
    }

    void LinearToleranceType::
    DefinitionId (::std::unique_ptr< DefinitionId_type > x)
    {
      this->DefinitionId_.set (std::move (x));
    }

    const LinearToleranceType::DefinedAsLimit_type& LinearToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    LinearToleranceType::DefinedAsLimit_type& LinearToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void LinearToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const LinearToleranceType::Attributes_optional& LinearToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    LinearToleranceType::Attributes_optional& LinearToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void LinearToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void LinearToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void LinearToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // LinearToleranceDefinitionType
    //

    const LinearToleranceDefinitionType::Attributes_optional& LinearToleranceDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    LinearToleranceDefinitionType::Attributes_optional& LinearToleranceDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void LinearToleranceDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void LinearToleranceDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void LinearToleranceDefinitionType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const LinearToleranceDefinitionType::MaxValue_optional& LinearToleranceDefinitionType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    LinearToleranceDefinitionType::MaxValue_optional& LinearToleranceDefinitionType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void LinearToleranceDefinitionType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void LinearToleranceDefinitionType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void LinearToleranceDefinitionType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const LinearToleranceDefinitionType::MinValue_optional& LinearToleranceDefinitionType::
    MinValue () const
    {
      return this->MinValue_;
    }

    LinearToleranceDefinitionType::MinValue_optional& LinearToleranceDefinitionType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void LinearToleranceDefinitionType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void LinearToleranceDefinitionType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void LinearToleranceDefinitionType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const LinearToleranceDefinitionType::id_type& LinearToleranceDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    LinearToleranceDefinitionType::id_type& LinearToleranceDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void LinearToleranceDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void LinearToleranceDefinitionType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // AngularToleranceType
    //

    const AngularToleranceType::MaxValue_optional& AngularToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AngularToleranceType::MaxValue_optional& AngularToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AngularToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AngularToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AngularToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const AngularToleranceType::MinValue_optional& AngularToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AngularToleranceType::MinValue_optional& AngularToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AngularToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AngularToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AngularToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const AngularToleranceType::DefinitionId_optional& AngularToleranceType::
    DefinitionId () const
    {
      return this->DefinitionId_;
    }

    AngularToleranceType::DefinitionId_optional& AngularToleranceType::
    DefinitionId ()
    {
      return this->DefinitionId_;
    }

    void AngularToleranceType::
    DefinitionId (const DefinitionId_type& x)
    {
      this->DefinitionId_.set (x);
    }

    void AngularToleranceType::
    DefinitionId (const DefinitionId_optional& x)
    {
      this->DefinitionId_ = x;
    }

    void AngularToleranceType::
    DefinitionId (::std::unique_ptr< DefinitionId_type > x)
    {
      this->DefinitionId_.set (std::move (x));
    }

    const AngularToleranceType::DefinedAsLimit_type& AngularToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    AngularToleranceType::DefinedAsLimit_type& AngularToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void AngularToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const AngularToleranceType::Attributes_optional& AngularToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AngularToleranceType::Attributes_optional& AngularToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AngularToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AngularToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AngularToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // AngularToleranceDefinitionType
    //

    const AngularToleranceDefinitionType::Attributes_optional& AngularToleranceDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AngularToleranceDefinitionType::Attributes_optional& AngularToleranceDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AngularToleranceDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AngularToleranceDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AngularToleranceDefinitionType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const AngularToleranceDefinitionType::MaxValue_optional& AngularToleranceDefinitionType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AngularToleranceDefinitionType::MaxValue_optional& AngularToleranceDefinitionType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AngularToleranceDefinitionType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AngularToleranceDefinitionType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AngularToleranceDefinitionType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const AngularToleranceDefinitionType::MinValue_optional& AngularToleranceDefinitionType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AngularToleranceDefinitionType::MinValue_optional& AngularToleranceDefinitionType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AngularToleranceDefinitionType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AngularToleranceDefinitionType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AngularToleranceDefinitionType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const AngularToleranceDefinitionType::id_type& AngularToleranceDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    AngularToleranceDefinitionType::id_type& AngularToleranceDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void AngularToleranceDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AngularToleranceDefinitionType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // TemperatureToleranceType
    //

    const TemperatureToleranceType::MaxValue_optional& TemperatureToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    TemperatureToleranceType::MaxValue_optional& TemperatureToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void TemperatureToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void TemperatureToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void TemperatureToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const TemperatureToleranceType::MinValue_optional& TemperatureToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    TemperatureToleranceType::MinValue_optional& TemperatureToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void TemperatureToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void TemperatureToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void TemperatureToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const TemperatureToleranceType::DefinedAsLimit_type& TemperatureToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    TemperatureToleranceType::DefinedAsLimit_type& TemperatureToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void TemperatureToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const TemperatureToleranceType::Attributes_optional& TemperatureToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TemperatureToleranceType::Attributes_optional& TemperatureToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TemperatureToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TemperatureToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TemperatureToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // AreaToleranceType
    //

    const AreaToleranceType::MaxValue_optional& AreaToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AreaToleranceType::MaxValue_optional& AreaToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AreaToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AreaToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AreaToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const AreaToleranceType::MinValue_optional& AreaToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AreaToleranceType::MinValue_optional& AreaToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AreaToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AreaToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AreaToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const AreaToleranceType::DefinedAsLimit_type& AreaToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    AreaToleranceType::DefinedAsLimit_type& AreaToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void AreaToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const AreaToleranceType::Attributes_optional& AreaToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AreaToleranceType::Attributes_optional& AreaToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AreaToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AreaToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AreaToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // ForceToleranceType
    //

    const ForceToleranceType::MaxValue_optional& ForceToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    ForceToleranceType::MaxValue_optional& ForceToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void ForceToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void ForceToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void ForceToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const ForceToleranceType::MinValue_optional& ForceToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    ForceToleranceType::MinValue_optional& ForceToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void ForceToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void ForceToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void ForceToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const ForceToleranceType::DefinedAsLimit_type& ForceToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    ForceToleranceType::DefinedAsLimit_type& ForceToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void ForceToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const ForceToleranceType::Attributes_optional& ForceToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ForceToleranceType::Attributes_optional& ForceToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ForceToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ForceToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ForceToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // MassToleranceType
    //

    const MassToleranceType::MaxValue_optional& MassToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    MassToleranceType::MaxValue_optional& MassToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void MassToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void MassToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void MassToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const MassToleranceType::MinValue_optional& MassToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    MassToleranceType::MinValue_optional& MassToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void MassToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void MassToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void MassToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const MassToleranceType::DefinedAsLimit_type& MassToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    MassToleranceType::DefinedAsLimit_type& MassToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void MassToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const MassToleranceType::Attributes_optional& MassToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    MassToleranceType::Attributes_optional& MassToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void MassToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void MassToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void MassToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // PressureToleranceType
    //

    const PressureToleranceType::MaxValue_optional& PressureToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    PressureToleranceType::MaxValue_optional& PressureToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void PressureToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void PressureToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void PressureToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const PressureToleranceType::MinValue_optional& PressureToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    PressureToleranceType::MinValue_optional& PressureToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void PressureToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void PressureToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void PressureToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const PressureToleranceType::DefinedAsLimit_type& PressureToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    PressureToleranceType::DefinedAsLimit_type& PressureToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void PressureToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const PressureToleranceType::Attributes_optional& PressureToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    PressureToleranceType::Attributes_optional& PressureToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void PressureToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void PressureToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void PressureToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // SpeedToleranceType
    //

    const SpeedToleranceType::MaxValue_optional& SpeedToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    SpeedToleranceType::MaxValue_optional& SpeedToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void SpeedToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void SpeedToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void SpeedToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const SpeedToleranceType::MinValue_optional& SpeedToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    SpeedToleranceType::MinValue_optional& SpeedToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void SpeedToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void SpeedToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void SpeedToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const SpeedToleranceType::DefinedAsLimit_type& SpeedToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    SpeedToleranceType::DefinedAsLimit_type& SpeedToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void SpeedToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const SpeedToleranceType::Attributes_optional& SpeedToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    SpeedToleranceType::Attributes_optional& SpeedToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void SpeedToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void SpeedToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void SpeedToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // TimeToleranceType
    //

    const TimeToleranceType::MaxValue_optional& TimeToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    TimeToleranceType::MaxValue_optional& TimeToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void TimeToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void TimeToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void TimeToleranceType::
    MaxValue (::std::unique_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (std::move (x));
    }

    const TimeToleranceType::MinValue_optional& TimeToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    TimeToleranceType::MinValue_optional& TimeToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void TimeToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void TimeToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void TimeToleranceType::
    MinValue (::std::unique_ptr< MinValue_type > x)
    {
      this->MinValue_.set (std::move (x));
    }

    const TimeToleranceType::DefinedAsLimit_type& TimeToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    TimeToleranceType::DefinedAsLimit_type& TimeToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void TimeToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }

    const TimeToleranceType::Attributes_optional& TimeToleranceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TimeToleranceType::Attributes_optional& TimeToleranceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TimeToleranceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TimeToleranceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TimeToleranceType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // DimensionModifierEnumType
    //

    DimensionModifierEnumType::
    DimensionModifierEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DimensionModifierEnumType_literals_[v])
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const DimensionModifierEnumType& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DimensionModifierEnumType& DimensionModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DimensionModifierEnumType_literals_[v]);

      return *this;
    }


    // DimensionDeterminationEnumType
    //

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DimensionDeterminationEnumType_literals_[v])
    {
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const DimensionDeterminationEnumType& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DimensionDeterminationEnumType& DimensionDeterminationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DimensionDeterminationEnumType_literals_[v]);

      return *this;
    }


    // SignificantDimensionEnumType
    //

    SignificantDimensionEnumType::
    SignificantDimensionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SignificantDimensionEnumType_literals_[v])
    {
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const SignificantDimensionEnumType& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SignificantDimensionEnumType& SignificantDimensionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SignificantDimensionEnumType_literals_[v]);

      return *this;
    }


    // DimensionModifiersType
    //

    const DimensionModifiersType::DeterminationModifier_optional& DimensionModifiersType::
    DeterminationModifier () const
    {
      return this->DeterminationModifier_;
    }

    DimensionModifiersType::DeterminationModifier_optional& DimensionModifiersType::
    DeterminationModifier ()
    {
      return this->DeterminationModifier_;
    }

    void DimensionModifiersType::
    DeterminationModifier (const DeterminationModifier_type& x)
    {
      this->DeterminationModifier_.set (x);
    }

    void DimensionModifiersType::
    DeterminationModifier (const DeterminationModifier_optional& x)
    {
      this->DeterminationModifier_ = x;
    }

    void DimensionModifiersType::
    DeterminationModifier (::std::unique_ptr< DeterminationModifier_type > x)
    {
      this->DeterminationModifier_.set (std::move (x));
    }

    const DimensionModifiersType::SignificanceModifier_optional& DimensionModifiersType::
    SignificanceModifier () const
    {
      return this->SignificanceModifier_;
    }

    DimensionModifiersType::SignificanceModifier_optional& DimensionModifiersType::
    SignificanceModifier ()
    {
      return this->SignificanceModifier_;
    }

    void DimensionModifiersType::
    SignificanceModifier (const SignificanceModifier_type& x)
    {
      this->SignificanceModifier_.set (x);
    }

    void DimensionModifiersType::
    SignificanceModifier (const SignificanceModifier_optional& x)
    {
      this->SignificanceModifier_ = x;
    }

    void DimensionModifiersType::
    SignificanceModifier (::std::unique_ptr< SignificanceModifier_type > x)
    {
      this->SignificanceModifier_.set (std::move (x));
    }

    const DimensionModifiersType::SectionModifier_optional& DimensionModifiersType::
    SectionModifier () const
    {
      return this->SectionModifier_;
    }

    DimensionModifiersType::SectionModifier_optional& DimensionModifiersType::
    SectionModifier ()
    {
      return this->SectionModifier_;
    }

    void DimensionModifiersType::
    SectionModifier (const SectionModifier_type& x)
    {
      this->SectionModifier_.set (x);
    }

    void DimensionModifiersType::
    SectionModifier (const SectionModifier_optional& x)
    {
      this->SectionModifier_ = x;
    }

    void DimensionModifiersType::
    SectionModifier (::std::unique_ptr< SectionModifier_type > x)
    {
      this->SectionModifier_.set (std::move (x));
    }


    // NonToleranceEnumType
    //

    NonToleranceEnumType::
    NonToleranceEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_NonToleranceEnumType_literals_[v])
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const NonToleranceEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    NonToleranceEnumType& NonToleranceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_NonToleranceEnumType_literals_[v]);

      return *this;
    }


    // LimitsAndFitsZoneVarianceType
    //

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType ()
    : ::xml_schema::nmtoken ()
    {
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (value v)
    : ::xml_schema::nmtoken (_xsd_LimitsAndFitsZoneVarianceType_literals_[v])
    {
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const LimitsAndFitsZoneVarianceType& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    LimitsAndFitsZoneVarianceType& LimitsAndFitsZoneVarianceType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_LimitsAndFitsZoneVarianceType_literals_[v]);

      return *this;
    }


    // LimitsAndFitsSpecificationType
    //

    const LimitsAndFitsSpecificationType::FormVariance_type& LimitsAndFitsSpecificationType::
    FormVariance () const
    {
      return this->FormVariance_.get ();
    }

    LimitsAndFitsSpecificationType::FormVariance_type& LimitsAndFitsSpecificationType::
    FormVariance ()
    {
      return this->FormVariance_.get ();
    }

    void LimitsAndFitsSpecificationType::
    FormVariance (const FormVariance_type& x)
    {
      this->FormVariance_.set (x);
    }

    void LimitsAndFitsSpecificationType::
    FormVariance (::std::unique_ptr< FormVariance_type > x)
    {
      this->FormVariance_.set (std::move (x));
    }

    const LimitsAndFitsSpecificationType::Grade_type& LimitsAndFitsSpecificationType::
    Grade () const
    {
      return this->Grade_.get ();
    }

    LimitsAndFitsSpecificationType::Grade_type& LimitsAndFitsSpecificationType::
    Grade ()
    {
      return this->Grade_.get ();
    }

    void LimitsAndFitsSpecificationType::
    Grade (const Grade_type& x)
    {
      this->Grade_.set (x);
    }

    void LimitsAndFitsSpecificationType::
    Grade (::std::unique_ptr< Grade_type > x)
    {
      this->Grade_.set (std::move (x));
    }

    const LimitsAndFitsSpecificationType::zoneVariance_type& LimitsAndFitsSpecificationType::
    zoneVariance () const
    {
      return this->zoneVariance_.get ();
    }

    LimitsAndFitsSpecificationType::zoneVariance_type& LimitsAndFitsSpecificationType::
    zoneVariance ()
    {
      return this->zoneVariance_.get ();
    }

    void LimitsAndFitsSpecificationType::
    zoneVariance (const zoneVariance_type& x)
    {
      this->zoneVariance_.set (x);
    }

    void LimitsAndFitsSpecificationType::
    zoneVariance (::std::unique_ptr< zoneVariance_type > x)
    {
      this->zoneVariance_.set (std::move (x));
    }


    // CommonFileSpecEnumType
    //

    CommonFileSpecEnumType::
    CommonFileSpecEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CommonFileSpecEnumType_literals_[v])
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const CommonFileSpecEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CommonFileSpecEnumType& CommonFileSpecEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CommonFileSpecEnumType_literals_[v]);

      return *this;
    }


    // FileSpecType
    //

    const FileSpecType::CommonFileSpecEnum_optional& FileSpecType::
    CommonFileSpecEnum () const
    {
      return this->CommonFileSpecEnum_;
    }

    FileSpecType::CommonFileSpecEnum_optional& FileSpecType::
    CommonFileSpecEnum ()
    {
      return this->CommonFileSpecEnum_;
    }

    void FileSpecType::
    CommonFileSpecEnum (const CommonFileSpecEnum_type& x)
    {
      this->CommonFileSpecEnum_.set (x);
    }

    void FileSpecType::
    CommonFileSpecEnum (const CommonFileSpecEnum_optional& x)
    {
      this->CommonFileSpecEnum_ = x;
    }

    void FileSpecType::
    CommonFileSpecEnum (::std::unique_ptr< CommonFileSpecEnum_type > x)
    {
      this->CommonFileSpecEnum_.set (std::move (x));
    }

    const FileSpecType::OtherFileSpec_optional& FileSpecType::
    OtherFileSpec () const
    {
      return this->OtherFileSpec_;
    }

    FileSpecType::OtherFileSpec_optional& FileSpecType::
    OtherFileSpec ()
    {
      return this->OtherFileSpec_;
    }

    void FileSpecType::
    OtherFileSpec (const OtherFileSpec_type& x)
    {
      this->OtherFileSpec_.set (x);
    }

    void FileSpecType::
    OtherFileSpec (const OtherFileSpec_optional& x)
    {
      this->OtherFileSpec_ = x;
    }

    void FileSpecType::
    OtherFileSpec (::std::unique_ptr< OtherFileSpec_type > x)
    {
      this->OtherFileSpec_.set (std::move (x));
    }


    // ExternalFileReferenceType
    //

    const ExternalFileReferenceType::URI_type& ExternalFileReferenceType::
    URI () const
    {
      return this->URI_.get ();
    }

    ExternalFileReferenceType::URI_type& ExternalFileReferenceType::
    URI ()
    {
      return this->URI_.get ();
    }

    void ExternalFileReferenceType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void ExternalFileReferenceType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }

    const ExternalFileReferenceType::FileSpec_type& ExternalFileReferenceType::
    FileSpec () const
    {
      return this->FileSpec_.get ();
    }

    ExternalFileReferenceType::FileSpec_type& ExternalFileReferenceType::
    FileSpec ()
    {
      return this->FileSpec_.get ();
    }

    void ExternalFileReferenceType::
    FileSpec (const FileSpec_type& x)
    {
      this->FileSpec_.set (x);
    }

    void ExternalFileReferenceType::
    FileSpec (::std::unique_ptr< FileSpec_type > x)
    {
      this->FileSpec_.set (std::move (x));
    }

    const ExternalFileReferenceType::Description_type& ExternalFileReferenceType::
    Description () const
    {
      return this->Description_.get ();
    }

    ExternalFileReferenceType::Description_type& ExternalFileReferenceType::
    Description ()
    {
      return this->Description_.get ();
    }

    void ExternalFileReferenceType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void ExternalFileReferenceType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // ExternalFileReferencesType
    //

    const ExternalFileReferencesType::ExternalFileReference_sequence& ExternalFileReferencesType::
    ExternalFileReference () const
    {
      return this->ExternalFileReference_;
    }

    ExternalFileReferencesType::ExternalFileReference_sequence& ExternalFileReferencesType::
    ExternalFileReference ()
    {
      return this->ExternalFileReference_;
    }

    void ExternalFileReferencesType::
    ExternalFileReference (const ExternalFileReference_sequence& s)
    {
      this->ExternalFileReference_ = s;
    }

    const ExternalFileReferencesType::n_type& ExternalFileReferencesType::
    n () const
    {
      return this->n_.get ();
    }

    ExternalFileReferencesType::n_type& ExternalFileReferencesType::
    n ()
    {
      return this->n_.get ();
    }

    void ExternalFileReferencesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExternalFileReferencesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DatumTargetDefinitionsType
    //

    const DatumTargetDefinitionsType::DatumTarget_sequence& DatumTargetDefinitionsType::
    DatumTarget () const
    {
      return this->DatumTarget_;
    }

    DatumTargetDefinitionsType::DatumTarget_sequence& DatumTargetDefinitionsType::
    DatumTarget ()
    {
      return this->DatumTarget_;
    }

    void DatumTargetDefinitionsType::
    DatumTarget (const DatumTarget_sequence& s)
    {
      this->DatumTarget_ = s;
    }

    const DatumTargetDefinitionsType::n_type& DatumTargetDefinitionsType::
    n () const
    {
      return this->n_.get ();
    }

    DatumTargetDefinitionsType::n_type& DatumTargetDefinitionsType::
    n ()
    {
      return this->n_.get ();
    }

    void DatumTargetDefinitionsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DatumTargetDefinitionsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DatumDefinitionType
    //

    const DatumDefinitionType::Attributes_optional& DatumDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumDefinitionType::Attributes_optional& DatumDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumDefinitionType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const DatumDefinitionType::DatumLabel_type& DatumDefinitionType::
    DatumLabel () const
    {
      return this->DatumLabel_.get ();
    }

    DatumDefinitionType::DatumLabel_type& DatumDefinitionType::
    DatumLabel ()
    {
      return this->DatumLabel_.get ();
    }

    void DatumDefinitionType::
    DatumLabel (const DatumLabel_type& x)
    {
      this->DatumLabel_.set (x);
    }

    void DatumDefinitionType::
    DatumLabel (::std::unique_ptr< DatumLabel_type > x)
    {
      this->DatumLabel_.set (std::move (x));
    }

    const DatumDefinitionType::DatumTargetIds_optional& DatumDefinitionType::
    DatumTargetIds () const
    {
      return this->DatumTargetIds_;
    }

    DatumDefinitionType::DatumTargetIds_optional& DatumDefinitionType::
    DatumTargetIds ()
    {
      return this->DatumTargetIds_;
    }

    void DatumDefinitionType::
    DatumTargetIds (const DatumTargetIds_type& x)
    {
      this->DatumTargetIds_.set (x);
    }

    void DatumDefinitionType::
    DatumTargetIds (const DatumTargetIds_optional& x)
    {
      this->DatumTargetIds_ = x;
    }

    void DatumDefinitionType::
    DatumTargetIds (::std::unique_ptr< DatumTargetIds_type > x)
    {
      this->DatumTargetIds_.set (std::move (x));
    }

    const DatumDefinitionType::FeatureNominalIds_optional& DatumDefinitionType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_;
    }

    DatumDefinitionType::FeatureNominalIds_optional& DatumDefinitionType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_;
    }

    void DatumDefinitionType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void DatumDefinitionType::
    FeatureNominalIds (const FeatureNominalIds_optional& x)
    {
      this->FeatureNominalIds_ = x;
    }

    void DatumDefinitionType::
    FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (std::move (x));
    }

    const DatumDefinitionType::id_type& DatumDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    DatumDefinitionType::id_type& DatumDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumDefinitionType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // DatumDefinitionsType
    //

    const DatumDefinitionsType::DatumDefinition_sequence& DatumDefinitionsType::
    DatumDefinition () const
    {
      return this->DatumDefinition_;
    }

    DatumDefinitionsType::DatumDefinition_sequence& DatumDefinitionsType::
    DatumDefinition ()
    {
      return this->DatumDefinition_;
    }

    void DatumDefinitionsType::
    DatumDefinition (const DatumDefinition_sequence& s)
    {
      this->DatumDefinition_ = s;
    }

    const DatumDefinitionsType::n_type& DatumDefinitionsType::
    n () const
    {
      return this->n_.get ();
    }

    DatumDefinitionsType::n_type& DatumDefinitionsType::
    n ()
    {
      return this->n_.get ();
    }

    void DatumDefinitionsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DatumDefinitionsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DatumTargetType
    //

    const DatumTargetType::Attributes_optional& DatumTargetType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumTargetType::Attributes_optional& DatumTargetType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumTargetType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumTargetType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumTargetType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const DatumTargetType::DatumTargetLabel_type& DatumTargetType::
    DatumTargetLabel () const
    {
      return this->DatumTargetLabel_.get ();
    }

    DatumTargetType::DatumTargetLabel_type& DatumTargetType::
    DatumTargetLabel ()
    {
      return this->DatumTargetLabel_.get ();
    }

    void DatumTargetType::
    DatumTargetLabel (const DatumTargetLabel_type& x)
    {
      this->DatumTargetLabel_.set (x);
    }

    void DatumTargetType::
    DatumTargetLabel (::std::unique_ptr< DatumTargetLabel_type > x)
    {
      this->DatumTargetLabel_.set (std::move (x));
    }

    const DatumTargetType::FeatureNominalId_optional& DatumTargetType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_;
    }

    DatumTargetType::FeatureNominalId_optional& DatumTargetType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_;
    }

    void DatumTargetType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void DatumTargetType::
    FeatureNominalId (const FeatureNominalId_optional& x)
    {
      this->FeatureNominalId_ = x;
    }

    void DatumTargetType::
    FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (std::move (x));
    }

    const DatumTargetType::TargetZoneId_optional& DatumTargetType::
    TargetZoneId () const
    {
      return this->TargetZoneId_;
    }

    DatumTargetType::TargetZoneId_optional& DatumTargetType::
    TargetZoneId ()
    {
      return this->TargetZoneId_;
    }

    void DatumTargetType::
    TargetZoneId (const TargetZoneId_type& x)
    {
      this->TargetZoneId_.set (x);
    }

    void DatumTargetType::
    TargetZoneId (const TargetZoneId_optional& x)
    {
      this->TargetZoneId_ = x;
    }

    void DatumTargetType::
    TargetZoneId (::std::unique_ptr< TargetZoneId_type > x)
    {
      this->TargetZoneId_.set (std::move (x));
    }

    const DatumTargetType::MovableDatumTarget_optional& DatumTargetType::
    MovableDatumTarget () const
    {
      return this->MovableDatumTarget_;
    }

    DatumTargetType::MovableDatumTarget_optional& DatumTargetType::
    MovableDatumTarget ()
    {
      return this->MovableDatumTarget_;
    }

    void DatumTargetType::
    MovableDatumTarget (const MovableDatumTarget_type& x)
    {
      this->MovableDatumTarget_.set (x);
    }

    void DatumTargetType::
    MovableDatumTarget (const MovableDatumTarget_optional& x)
    {
      this->MovableDatumTarget_ = x;
    }

    void DatumTargetType::
    MovableDatumTarget (::std::unique_ptr< MovableDatumTarget_type > x)
    {
      this->MovableDatumTarget_.set (std::move (x));
    }

    const DatumTargetType::id_type& DatumTargetType::
    id () const
    {
      return this->id_.get ();
    }

    DatumTargetType::id_type& DatumTargetType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumTargetType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumTargetType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // EmployeeType
    //

    const EmployeeType::Name_type& EmployeeType::
    Name () const
    {
      return this->Name_.get ();
    }

    EmployeeType::Name_type& EmployeeType::
    Name ()
    {
      return this->Name_.get ();
    }

    void EmployeeType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void EmployeeType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const EmployeeType::EmployeeId_optional& EmployeeType::
    EmployeeId () const
    {
      return this->EmployeeId_;
    }

    EmployeeType::EmployeeId_optional& EmployeeType::
    EmployeeId ()
    {
      return this->EmployeeId_;
    }

    void EmployeeType::
    EmployeeId (const EmployeeId_type& x)
    {
      this->EmployeeId_.set (x);
    }

    void EmployeeType::
    EmployeeId (const EmployeeId_optional& x)
    {
      this->EmployeeId_ = x;
    }

    void EmployeeType::
    EmployeeId (::std::unique_ptr< EmployeeId_type > x)
    {
      this->EmployeeId_.set (std::move (x));
    }

    const EmployeeType::Shift_optional& EmployeeType::
    Shift () const
    {
      return this->Shift_;
    }

    EmployeeType::Shift_optional& EmployeeType::
    Shift ()
    {
      return this->Shift_;
    }

    void EmployeeType::
    Shift (const Shift_type& x)
    {
      this->Shift_.set (x);
    }

    void EmployeeType::
    Shift (const Shift_optional& x)
    {
      this->Shift_ = x;
    }

    void EmployeeType::
    Shift (::std::unique_ptr< Shift_type > x)
    {
      this->Shift_.set (std::move (x));
    }


    // FileType
    //

    const FileType::Name_type& FileType::
    Name () const
    {
      return this->Name_.get ();
    }

    FileType::Name_type& FileType::
    Name ()
    {
      return this->Name_.get ();
    }

    void FileType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FileType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const FileType::Version_optional& FileType::
    Version () const
    {
      return this->Version_;
    }

    FileType::Version_optional& FileType::
    Version ()
    {
      return this->Version_;
    }

    void FileType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void FileType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void FileType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const FileType::Format_optional& FileType::
    Format () const
    {
      return this->Format_;
    }

    FileType::Format_optional& FileType::
    Format ()
    {
      return this->Format_;
    }

    void FileType::
    Format (const Format_type& x)
    {
      this->Format_.set (x);
    }

    void FileType::
    Format (const Format_optional& x)
    {
      this->Format_ = x;
    }

    void FileType::
    Format (::std::unique_ptr< Format_type > x)
    {
      this->Format_.set (std::move (x));
    }


    // SoftwareType
    //

    const SoftwareType::Attributes_optional& SoftwareType::
    Attributes () const
    {
      return this->Attributes_;
    }

    SoftwareType::Attributes_optional& SoftwareType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void SoftwareType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void SoftwareType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void SoftwareType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const SoftwareType::VendorName_type& SoftwareType::
    VendorName () const
    {
      return this->VendorName_.get ();
    }

    SoftwareType::VendorName_type& SoftwareType::
    VendorName ()
    {
      return this->VendorName_.get ();
    }

    void SoftwareType::
    VendorName (const VendorName_type& x)
    {
      this->VendorName_.set (x);
    }

    void SoftwareType::
    VendorName (::std::unique_ptr< VendorName_type > x)
    {
      this->VendorName_.set (std::move (x));
    }

    const SoftwareType::ApplicationName_type& SoftwareType::
    ApplicationName () const
    {
      return this->ApplicationName_.get ();
    }

    SoftwareType::ApplicationName_type& SoftwareType::
    ApplicationName ()
    {
      return this->ApplicationName_.get ();
    }

    void SoftwareType::
    ApplicationName (const ApplicationName_type& x)
    {
      this->ApplicationName_.set (x);
    }

    void SoftwareType::
    ApplicationName (::std::unique_ptr< ApplicationName_type > x)
    {
      this->ApplicationName_.set (std::move (x));
    }

    const SoftwareType::Version_optional& SoftwareType::
    Version () const
    {
      return this->Version_;
    }

    SoftwareType::Version_optional& SoftwareType::
    Version ()
    {
      return this->Version_;
    }

    void SoftwareType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void SoftwareType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void SoftwareType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const SoftwareType::Description_optional& SoftwareType::
    Description () const
    {
      return this->Description_;
    }

    SoftwareType::Description_optional& SoftwareType::
    Description ()
    {
      return this->Description_;
    }

    void SoftwareType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void SoftwareType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void SoftwareType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const SoftwareType::URI_optional& SoftwareType::
    URI () const
    {
      return this->URI_;
    }

    SoftwareType::URI_optional& SoftwareType::
    URI ()
    {
      return this->URI_;
    }

    void SoftwareType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void SoftwareType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void SoftwareType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }

    const SoftwareType::ReferencedStandardIds_optional& SoftwareType::
    ReferencedStandardIds () const
    {
      return this->ReferencedStandardIds_;
    }

    SoftwareType::ReferencedStandardIds_optional& SoftwareType::
    ReferencedStandardIds ()
    {
      return this->ReferencedStandardIds_;
    }

    void SoftwareType::
    ReferencedStandardIds (const ReferencedStandardIds_type& x)
    {
      this->ReferencedStandardIds_.set (x);
    }

    void SoftwareType::
    ReferencedStandardIds (const ReferencedStandardIds_optional& x)
    {
      this->ReferencedStandardIds_ = x;
    }

    void SoftwareType::
    ReferencedStandardIds (::std::unique_ptr< ReferencedStandardIds_type > x)
    {
      this->ReferencedStandardIds_.set (std::move (x));
    }

    const SoftwareType::id_type& SoftwareType::
    id () const
    {
      return this->id_.get ();
    }

    SoftwareType::id_type& SoftwareType::
    id ()
    {
      return this->id_.get ();
    }

    void SoftwareType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SoftwareType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // StandardsOrganizationEnumType
    //

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_StandardsOrganizationEnumType_literals_[v])
    {
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const StandardsOrganizationEnumType& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    StandardsOrganizationEnumType& StandardsOrganizationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_StandardsOrganizationEnumType_literals_[v]);

      return *this;
    }


    // StandardsOrganizationType
    //

    const StandardsOrganizationType::StandardsOrganizationEnum_optional& StandardsOrganizationType::
    StandardsOrganizationEnum () const
    {
      return this->StandardsOrganizationEnum_;
    }

    StandardsOrganizationType::StandardsOrganizationEnum_optional& StandardsOrganizationType::
    StandardsOrganizationEnum ()
    {
      return this->StandardsOrganizationEnum_;
    }

    void StandardsOrganizationType::
    StandardsOrganizationEnum (const StandardsOrganizationEnum_type& x)
    {
      this->StandardsOrganizationEnum_.set (x);
    }

    void StandardsOrganizationType::
    StandardsOrganizationEnum (const StandardsOrganizationEnum_optional& x)
    {
      this->StandardsOrganizationEnum_ = x;
    }

    void StandardsOrganizationType::
    StandardsOrganizationEnum (::std::unique_ptr< StandardsOrganizationEnum_type > x)
    {
      this->StandardsOrganizationEnum_.set (std::move (x));
    }

    const StandardsOrganizationType::OtherStandardsOrganization_optional& StandardsOrganizationType::
    OtherStandardsOrganization () const
    {
      return this->OtherStandardsOrganization_;
    }

    StandardsOrganizationType::OtherStandardsOrganization_optional& StandardsOrganizationType::
    OtherStandardsOrganization ()
    {
      return this->OtherStandardsOrganization_;
    }

    void StandardsOrganizationType::
    OtherStandardsOrganization (const OtherStandardsOrganization_type& x)
    {
      this->OtherStandardsOrganization_.set (x);
    }

    void StandardsOrganizationType::
    OtherStandardsOrganization (const OtherStandardsOrganization_optional& x)
    {
      this->OtherStandardsOrganization_ = x;
    }

    void StandardsOrganizationType::
    OtherStandardsOrganization (::std::unique_ptr< OtherStandardsOrganization_type > x)
    {
      this->OtherStandardsOrganization_.set (std::move (x));
    }


    // StandardType
    //

    const StandardType::Attributes_optional& StandardType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StandardType::Attributes_optional& StandardType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StandardType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StandardType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StandardType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StandardType::Organization_type& StandardType::
    Organization () const
    {
      return this->Organization_.get ();
    }

    StandardType::Organization_type& StandardType::
    Organization ()
    {
      return this->Organization_.get ();
    }

    void StandardType::
    Organization (const Organization_type& x)
    {
      this->Organization_.set (x);
    }

    void StandardType::
    Organization (::std::unique_ptr< Organization_type > x)
    {
      this->Organization_.set (std::move (x));
    }

    const StandardType::Designator_type& StandardType::
    Designator () const
    {
      return this->Designator_.get ();
    }

    StandardType::Designator_type& StandardType::
    Designator ()
    {
      return this->Designator_.get ();
    }

    void StandardType::
    Designator (const Designator_type& x)
    {
      this->Designator_.set (x);
    }

    void StandardType::
    Designator (::std::unique_ptr< Designator_type > x)
    {
      this->Designator_.set (std::move (x));
    }

    const StandardType::Year_optional& StandardType::
    Year () const
    {
      return this->Year_;
    }

    StandardType::Year_optional& StandardType::
    Year ()
    {
      return this->Year_;
    }

    void StandardType::
    Year (const Year_type& x)
    {
      this->Year_.set (x);
    }

    void StandardType::
    Year (const Year_optional& x)
    {
      this->Year_ = x;
    }

    void StandardType::
    Year (::std::unique_ptr< Year_type > x)
    {
      this->Year_.set (std::move (x));
    }

    const StandardType::Title_optional& StandardType::
    Title () const
    {
      return this->Title_;
    }

    StandardType::Title_optional& StandardType::
    Title ()
    {
      return this->Title_;
    }

    void StandardType::
    Title (const Title_type& x)
    {
      this->Title_.set (x);
    }

    void StandardType::
    Title (const Title_optional& x)
    {
      this->Title_ = x;
    }

    void StandardType::
    Title (::std::unique_ptr< Title_type > x)
    {
      this->Title_.set (std::move (x));
    }

    const StandardType::Description_optional& StandardType::
    Description () const
    {
      return this->Description_;
    }

    StandardType::Description_optional& StandardType::
    Description ()
    {
      return this->Description_;
    }

    void StandardType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void StandardType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void StandardType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const StandardType::URI_optional& StandardType::
    URI () const
    {
      return this->URI_;
    }

    StandardType::URI_optional& StandardType::
    URI ()
    {
      return this->URI_;
    }

    void StandardType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void StandardType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void StandardType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }

    const StandardType::ISBN_optional& StandardType::
    ISBN () const
    {
      return this->ISBN_;
    }

    StandardType::ISBN_optional& StandardType::
    ISBN ()
    {
      return this->ISBN_;
    }

    void StandardType::
    ISBN (const ISBN_type& x)
    {
      this->ISBN_.set (x);
    }

    void StandardType::
    ISBN (const ISBN_optional& x)
    {
      this->ISBN_ = x;
    }

    void StandardType::
    ISBN (::std::unique_ptr< ISBN_type > x)
    {
      this->ISBN_.set (std::move (x));
    }

    const StandardType::ReferencedStandardIds_optional& StandardType::
    ReferencedStandardIds () const
    {
      return this->ReferencedStandardIds_;
    }

    StandardType::ReferencedStandardIds_optional& StandardType::
    ReferencedStandardIds ()
    {
      return this->ReferencedStandardIds_;
    }

    void StandardType::
    ReferencedStandardIds (const ReferencedStandardIds_type& x)
    {
      this->ReferencedStandardIds_.set (x);
    }

    void StandardType::
    ReferencedStandardIds (const ReferencedStandardIds_optional& x)
    {
      this->ReferencedStandardIds_ = x;
    }

    void StandardType::
    ReferencedStandardIds (::std::unique_ptr< ReferencedStandardIds_type > x)
    {
      this->ReferencedStandardIds_.set (std::move (x));
    }

    const StandardType::id_type& StandardType::
    id () const
    {
      return this->id_.get ();
    }

    StandardType::id_type& StandardType::
    id ()
    {
      return this->id_.get ();
    }

    void StandardType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void StandardType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // StandardsType
    //

    const StandardsType::Standard_sequence& StandardsType::
    Standard () const
    {
      return this->Standard_;
    }

    StandardsType::Standard_sequence& StandardsType::
    Standard ()
    {
      return this->Standard_;
    }

    void StandardsType::
    Standard (const Standard_sequence& s)
    {
      this->Standard_ = s;
    }

    const StandardsType::n_type& StandardsType::
    n () const
    {
      return this->n_.get ();
    }

    StandardsType::n_type& StandardsType::
    n ()
    {
      return this->n_.get ();
    }

    void StandardsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void StandardsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SoftwaresType
    //

    const SoftwaresType::Software_sequence& SoftwaresType::
    Software () const
    {
      return this->Software_;
    }

    SoftwaresType::Software_sequence& SoftwaresType::
    Software ()
    {
      return this->Software_;
    }

    void SoftwaresType::
    Software (const Software_sequence& s)
    {
      this->Software_ = s;
    }

    const SoftwaresType::n_type& SoftwaresType::
    n () const
    {
      return this->n_.get ();
    }

    SoftwaresType::n_type& SoftwaresType::
    n ()
    {
      return this->n_.get ();
    }

    void SoftwaresType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SoftwaresType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AlgorithmType
    //

    const AlgorithmType::Attributes_optional& AlgorithmType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AlgorithmType::Attributes_optional& AlgorithmType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AlgorithmType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AlgorithmType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AlgorithmType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const AlgorithmType::SoftwareId_optional& AlgorithmType::
    SoftwareId () const
    {
      return this->SoftwareId_;
    }

    AlgorithmType::SoftwareId_optional& AlgorithmType::
    SoftwareId ()
    {
      return this->SoftwareId_;
    }

    void AlgorithmType::
    SoftwareId (const SoftwareId_type& x)
    {
      this->SoftwareId_.set (x);
    }

    void AlgorithmType::
    SoftwareId (const SoftwareId_optional& x)
    {
      this->SoftwareId_ = x;
    }

    void AlgorithmType::
    SoftwareId (::std::unique_ptr< SoftwareId_type > x)
    {
      this->SoftwareId_.set (std::move (x));
    }

    const AlgorithmType::Parameters_optional& AlgorithmType::
    Parameters () const
    {
      return this->Parameters_;
    }

    AlgorithmType::Parameters_optional& AlgorithmType::
    Parameters ()
    {
      return this->Parameters_;
    }

    void AlgorithmType::
    Parameters (const Parameters_type& x)
    {
      this->Parameters_.set (x);
    }

    void AlgorithmType::
    Parameters (const Parameters_optional& x)
    {
      this->Parameters_ = x;
    }

    void AlgorithmType::
    Parameters (::std::unique_ptr< Parameters_type > x)
    {
      this->Parameters_.set (std::move (x));
    }

    const AlgorithmType::StandardId_optional& AlgorithmType::
    StandardId () const
    {
      return this->StandardId_;
    }

    AlgorithmType::StandardId_optional& AlgorithmType::
    StandardId ()
    {
      return this->StandardId_;
    }

    void AlgorithmType::
    StandardId (const StandardId_type& x)
    {
      this->StandardId_.set (x);
    }

    void AlgorithmType::
    StandardId (const StandardId_optional& x)
    {
      this->StandardId_ = x;
    }

    void AlgorithmType::
    StandardId (::std::unique_ptr< StandardId_type > x)
    {
      this->StandardId_.set (std::move (x));
    }

    const AlgorithmType::Section_optional& AlgorithmType::
    Section () const
    {
      return this->Section_;
    }

    AlgorithmType::Section_optional& AlgorithmType::
    Section ()
    {
      return this->Section_;
    }

    void AlgorithmType::
    Section (const Section_type& x)
    {
      this->Section_.set (x);
    }

    void AlgorithmType::
    Section (const Section_optional& x)
    {
      this->Section_ = x;
    }

    void AlgorithmType::
    Section (::std::unique_ptr< Section_type > x)
    {
      this->Section_.set (std::move (x));
    }

    const AlgorithmType::Name_type& AlgorithmType::
    Name () const
    {
      return this->Name_.get ();
    }

    AlgorithmType::Name_type& AlgorithmType::
    Name ()
    {
      return this->Name_.get ();
    }

    void AlgorithmType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void AlgorithmType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const AlgorithmType::Description_optional& AlgorithmType::
    Description () const
    {
      return this->Description_;
    }

    AlgorithmType::Description_optional& AlgorithmType::
    Description ()
    {
      return this->Description_;
    }

    void AlgorithmType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void AlgorithmType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void AlgorithmType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const AlgorithmType::id_type& AlgorithmType::
    id () const
    {
      return this->id_.get ();
    }

    AlgorithmType::id_type& AlgorithmType::
    id ()
    {
      return this->id_.get ();
    }

    void AlgorithmType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AlgorithmType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // AlgorithmsType
    //

    const AlgorithmsType::Algorithm_sequence& AlgorithmsType::
    Algorithm () const
    {
      return this->Algorithm_;
    }

    AlgorithmsType::Algorithm_sequence& AlgorithmsType::
    Algorithm ()
    {
      return this->Algorithm_;
    }

    void AlgorithmsType::
    Algorithm (const Algorithm_sequence& s)
    {
      this->Algorithm_ = s;
    }

    const AlgorithmsType::n_type& AlgorithmsType::
    n () const
    {
      return this->n_.get ();
    }

    AlgorithmsType::n_type& AlgorithmsType::
    n ()
    {
      return this->n_.get ();
    }

    void AlgorithmsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AlgorithmsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OrganizationType
    //

    const OrganizationType::Name_type& OrganizationType::
    Name () const
    {
      return this->Name_.get ();
    }

    OrganizationType::Name_type& OrganizationType::
    Name ()
    {
      return this->Name_.get ();
    }

    void OrganizationType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void OrganizationType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const OrganizationType::Address_optional& OrganizationType::
    Address () const
    {
      return this->Address_;
    }

    OrganizationType::Address_optional& OrganizationType::
    Address ()
    {
      return this->Address_;
    }

    void OrganizationType::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void OrganizationType::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void OrganizationType::
    Address (::std::unique_ptr< Address_type > x)
    {
      this->Address_.set (std::move (x));
    }

    const OrganizationType::Attributes_optional& OrganizationType::
    Attributes () const
    {
      return this->Attributes_;
    }

    OrganizationType::Attributes_optional& OrganizationType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void OrganizationType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void OrganizationType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void OrganizationType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // PhysicalAddressType
    //

    const PhysicalAddressType::Description_optional& PhysicalAddressType::
    Description () const
    {
      return this->Description_;
    }

    PhysicalAddressType::Description_optional& PhysicalAddressType::
    Description ()
    {
      return this->Description_;
    }

    void PhysicalAddressType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PhysicalAddressType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PhysicalAddressType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const PhysicalAddressType::InternalLocation_optional& PhysicalAddressType::
    InternalLocation () const
    {
      return this->InternalLocation_;
    }

    PhysicalAddressType::InternalLocation_optional& PhysicalAddressType::
    InternalLocation ()
    {
      return this->InternalLocation_;
    }

    void PhysicalAddressType::
    InternalLocation (const InternalLocation_type& x)
    {
      this->InternalLocation_.set (x);
    }

    void PhysicalAddressType::
    InternalLocation (const InternalLocation_optional& x)
    {
      this->InternalLocation_ = x;
    }

    void PhysicalAddressType::
    InternalLocation (::std::unique_ptr< InternalLocation_type > x)
    {
      this->InternalLocation_.set (std::move (x));
    }

    const PhysicalAddressType::StreetNumber_optional& PhysicalAddressType::
    StreetNumber () const
    {
      return this->StreetNumber_;
    }

    PhysicalAddressType::StreetNumber_optional& PhysicalAddressType::
    StreetNumber ()
    {
      return this->StreetNumber_;
    }

    void PhysicalAddressType::
    StreetNumber (const StreetNumber_type& x)
    {
      this->StreetNumber_.set (x);
    }

    void PhysicalAddressType::
    StreetNumber (const StreetNumber_optional& x)
    {
      this->StreetNumber_ = x;
    }

    void PhysicalAddressType::
    StreetNumber (::std::unique_ptr< StreetNumber_type > x)
    {
      this->StreetNumber_.set (std::move (x));
    }

    const PhysicalAddressType::Street_optional& PhysicalAddressType::
    Street () const
    {
      return this->Street_;
    }

    PhysicalAddressType::Street_optional& PhysicalAddressType::
    Street ()
    {
      return this->Street_;
    }

    void PhysicalAddressType::
    Street (const Street_type& x)
    {
      this->Street_.set (x);
    }

    void PhysicalAddressType::
    Street (const Street_optional& x)
    {
      this->Street_ = x;
    }

    void PhysicalAddressType::
    Street (::std::unique_ptr< Street_type > x)
    {
      this->Street_.set (std::move (x));
    }

    const PhysicalAddressType::PostalBox_optional& PhysicalAddressType::
    PostalBox () const
    {
      return this->PostalBox_;
    }

    PhysicalAddressType::PostalBox_optional& PhysicalAddressType::
    PostalBox ()
    {
      return this->PostalBox_;
    }

    void PhysicalAddressType::
    PostalBox (const PostalBox_type& x)
    {
      this->PostalBox_.set (x);
    }

    void PhysicalAddressType::
    PostalBox (const PostalBox_optional& x)
    {
      this->PostalBox_ = x;
    }

    void PhysicalAddressType::
    PostalBox (::std::unique_ptr< PostalBox_type > x)
    {
      this->PostalBox_.set (std::move (x));
    }

    const PhysicalAddressType::Town_optional& PhysicalAddressType::
    Town () const
    {
      return this->Town_;
    }

    PhysicalAddressType::Town_optional& PhysicalAddressType::
    Town ()
    {
      return this->Town_;
    }

    void PhysicalAddressType::
    Town (const Town_type& x)
    {
      this->Town_.set (x);
    }

    void PhysicalAddressType::
    Town (const Town_optional& x)
    {
      this->Town_ = x;
    }

    void PhysicalAddressType::
    Town (::std::unique_ptr< Town_type > x)
    {
      this->Town_.set (std::move (x));
    }

    const PhysicalAddressType::Region_optional& PhysicalAddressType::
    Region () const
    {
      return this->Region_;
    }

    PhysicalAddressType::Region_optional& PhysicalAddressType::
    Region ()
    {
      return this->Region_;
    }

    void PhysicalAddressType::
    Region (const Region_type& x)
    {
      this->Region_.set (x);
    }

    void PhysicalAddressType::
    Region (const Region_optional& x)
    {
      this->Region_ = x;
    }

    void PhysicalAddressType::
    Region (::std::unique_ptr< Region_type > x)
    {
      this->Region_.set (std::move (x));
    }

    const PhysicalAddressType::PostalCode_optional& PhysicalAddressType::
    PostalCode () const
    {
      return this->PostalCode_;
    }

    PhysicalAddressType::PostalCode_optional& PhysicalAddressType::
    PostalCode ()
    {
      return this->PostalCode_;
    }

    void PhysicalAddressType::
    PostalCode (const PostalCode_type& x)
    {
      this->PostalCode_.set (x);
    }

    void PhysicalAddressType::
    PostalCode (const PostalCode_optional& x)
    {
      this->PostalCode_ = x;
    }

    void PhysicalAddressType::
    PostalCode (::std::unique_ptr< PostalCode_type > x)
    {
      this->PostalCode_.set (std::move (x));
    }

    const PhysicalAddressType::Country_optional& PhysicalAddressType::
    Country () const
    {
      return this->Country_;
    }

    PhysicalAddressType::Country_optional& PhysicalAddressType::
    Country ()
    {
      return this->Country_;
    }

    void PhysicalAddressType::
    Country (const Country_type& x)
    {
      this->Country_.set (x);
    }

    void PhysicalAddressType::
    Country (const Country_optional& x)
    {
      this->Country_ = x;
    }

    void PhysicalAddressType::
    Country (::std::unique_ptr< Country_type > x)
    {
      this->Country_.set (std::move (x));
    }

    const PhysicalAddressType::FacsimileNumber_optional& PhysicalAddressType::
    FacsimileNumber () const
    {
      return this->FacsimileNumber_;
    }

    PhysicalAddressType::FacsimileNumber_optional& PhysicalAddressType::
    FacsimileNumber ()
    {
      return this->FacsimileNumber_;
    }

    void PhysicalAddressType::
    FacsimileNumber (const FacsimileNumber_type& x)
    {
      this->FacsimileNumber_.set (x);
    }

    void PhysicalAddressType::
    FacsimileNumber (const FacsimileNumber_optional& x)
    {
      this->FacsimileNumber_ = x;
    }

    void PhysicalAddressType::
    FacsimileNumber (::std::unique_ptr< FacsimileNumber_type > x)
    {
      this->FacsimileNumber_.set (std::move (x));
    }

    const PhysicalAddressType::TelephoneNumber_optional& PhysicalAddressType::
    TelephoneNumber () const
    {
      return this->TelephoneNumber_;
    }

    PhysicalAddressType::TelephoneNumber_optional& PhysicalAddressType::
    TelephoneNumber ()
    {
      return this->TelephoneNumber_;
    }

    void PhysicalAddressType::
    TelephoneNumber (const TelephoneNumber_type& x)
    {
      this->TelephoneNumber_.set (x);
    }

    void PhysicalAddressType::
    TelephoneNumber (const TelephoneNumber_optional& x)
    {
      this->TelephoneNumber_ = x;
    }

    void PhysicalAddressType::
    TelephoneNumber (::std::unique_ptr< TelephoneNumber_type > x)
    {
      this->TelephoneNumber_.set (std::move (x));
    }

    const PhysicalAddressType::ElectronicMailAddress_optional& PhysicalAddressType::
    ElectronicMailAddress () const
    {
      return this->ElectronicMailAddress_;
    }

    PhysicalAddressType::ElectronicMailAddress_optional& PhysicalAddressType::
    ElectronicMailAddress ()
    {
      return this->ElectronicMailAddress_;
    }

    void PhysicalAddressType::
    ElectronicMailAddress (const ElectronicMailAddress_type& x)
    {
      this->ElectronicMailAddress_.set (x);
    }

    void PhysicalAddressType::
    ElectronicMailAddress (const ElectronicMailAddress_optional& x)
    {
      this->ElectronicMailAddress_ = x;
    }

    void PhysicalAddressType::
    ElectronicMailAddress (::std::unique_ptr< ElectronicMailAddress_type > x)
    {
      this->ElectronicMailAddress_.set (std::move (x));
    }

    const PhysicalAddressType::TelexNumber_optional& PhysicalAddressType::
    TelexNumber () const
    {
      return this->TelexNumber_;
    }

    PhysicalAddressType::TelexNumber_optional& PhysicalAddressType::
    TelexNumber ()
    {
      return this->TelexNumber_;
    }

    void PhysicalAddressType::
    TelexNumber (const TelexNumber_type& x)
    {
      this->TelexNumber_.set (x);
    }

    void PhysicalAddressType::
    TelexNumber (const TelexNumber_optional& x)
    {
      this->TelexNumber_ = x;
    }

    void PhysicalAddressType::
    TelexNumber (::std::unique_ptr< TelexNumber_type > x)
    {
      this->TelexNumber_.set (std::move (x));
    }


    // AddressDescriptionEnumType
    //

    AddressDescriptionEnumType::
    AddressDescriptionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AddressDescriptionEnumType_literals_[v])
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const AddressDescriptionEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AddressDescriptionEnumType& AddressDescriptionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AddressDescriptionEnumType_literals_[v]);

      return *this;
    }


    // AddressDescriptionType
    //

    const AddressDescriptionType::AddressDescriptionEnum_optional& AddressDescriptionType::
    AddressDescriptionEnum () const
    {
      return this->AddressDescriptionEnum_;
    }

    AddressDescriptionType::AddressDescriptionEnum_optional& AddressDescriptionType::
    AddressDescriptionEnum ()
    {
      return this->AddressDescriptionEnum_;
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (const AddressDescriptionEnum_type& x)
    {
      this->AddressDescriptionEnum_.set (x);
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (const AddressDescriptionEnum_optional& x)
    {
      this->AddressDescriptionEnum_ = x;
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (::std::unique_ptr< AddressDescriptionEnum_type > x)
    {
      this->AddressDescriptionEnum_.set (std::move (x));
    }

    const AddressDescriptionType::OtherAddressDescription_optional& AddressDescriptionType::
    OtherAddressDescription () const
    {
      return this->OtherAddressDescription_;
    }

    AddressDescriptionType::OtherAddressDescription_optional& AddressDescriptionType::
    OtherAddressDescription ()
    {
      return this->OtherAddressDescription_;
    }

    void AddressDescriptionType::
    OtherAddressDescription (const OtherAddressDescription_type& x)
    {
      this->OtherAddressDescription_.set (x);
    }

    void AddressDescriptionType::
    OtherAddressDescription (const OtherAddressDescription_optional& x)
    {
      this->OtherAddressDescription_ = x;
    }

    void AddressDescriptionType::
    OtherAddressDescription (::std::unique_ptr< OtherAddressDescription_type > x)
    {
      this->OtherAddressDescription_.set (std::move (x));
    }


    // LocationType
    //

    const LocationType::LocationDescription_type& LocationType::
    LocationDescription () const
    {
      return this->LocationDescription_.get ();
    }

    LocationType::LocationDescription_type& LocationType::
    LocationDescription ()
    {
      return this->LocationDescription_.get ();
    }

    void LocationType::
    LocationDescription (const LocationDescription_type& x)
    {
      this->LocationDescription_.set (x);
    }

    void LocationType::
    LocationDescription (::std::unique_ptr< LocationDescription_type > x)
    {
      this->LocationDescription_.set (std::move (x));
    }

    const LocationType::Address_optional& LocationType::
    Address () const
    {
      return this->Address_;
    }

    LocationType::Address_optional& LocationType::
    Address ()
    {
      return this->Address_;
    }

    void LocationType::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void LocationType::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void LocationType::
    Address (::std::unique_ptr< Address_type > x)
    {
      this->Address_.set (std::move (x));
    }

    const LocationType::id_type& LocationType::
    id () const
    {
      return this->id_.get ();
    }

    LocationType::id_type& LocationType::
    id ()
    {
      return this->id_.get ();
    }

    void LocationType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void LocationType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CustomerOrganizationType
    //

    const CustomerOrganizationType::CustomerNumber_type& CustomerOrganizationType::
    CustomerNumber () const
    {
      return this->CustomerNumber_.get ();
    }

    CustomerOrganizationType::CustomerNumber_type& CustomerOrganizationType::
    CustomerNumber ()
    {
      return this->CustomerNumber_.get ();
    }

    void CustomerOrganizationType::
    CustomerNumber (const CustomerNumber_type& x)
    {
      this->CustomerNumber_.set (x);
    }

    void CustomerOrganizationType::
    CustomerNumber (::std::unique_ptr< CustomerNumber_type > x)
    {
      this->CustomerNumber_.set (std::move (x));
    }


    // VersionHistoryType
    //

    const VersionHistoryType::EarlierVersion_sequence& VersionHistoryType::
    EarlierVersion () const
    {
      return this->EarlierVersion_;
    }

    VersionHistoryType::EarlierVersion_sequence& VersionHistoryType::
    EarlierVersion ()
    {
      return this->EarlierVersion_;
    }

    void VersionHistoryType::
    EarlierVersion (const EarlierVersion_sequence& s)
    {
      this->EarlierVersion_ = s;
    }

    const VersionHistoryType::n_type& VersionHistoryType::
    n () const
    {
      return this->n_.get ();
    }

    VersionHistoryType::n_type& VersionHistoryType::
    n ()
    {
      return this->n_.get ();
    }

    void VersionHistoryType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void VersionHistoryType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // VersionBaseType
    //

    const VersionBaseType::TimeCreated_optional& VersionBaseType::
    TimeCreated () const
    {
      return this->TimeCreated_;
    }

    VersionBaseType::TimeCreated_optional& VersionBaseType::
    TimeCreated ()
    {
      return this->TimeCreated_;
    }

    void VersionBaseType::
    TimeCreated (const TimeCreated_type& x)
    {
      this->TimeCreated_.set (x);
    }

    void VersionBaseType::
    TimeCreated (const TimeCreated_optional& x)
    {
      this->TimeCreated_ = x;
    }

    void VersionBaseType::
    TimeCreated (::std::unique_ptr< TimeCreated_type > x)
    {
      this->TimeCreated_.set (std::move (x));
    }

    const VersionBaseType::SignOffs_optional& VersionBaseType::
    SignOffs () const
    {
      return this->SignOffs_;
    }

    VersionBaseType::SignOffs_optional& VersionBaseType::
    SignOffs ()
    {
      return this->SignOffs_;
    }

    void VersionBaseType::
    SignOffs (const SignOffs_type& x)
    {
      this->SignOffs_.set (x);
    }

    void VersionBaseType::
    SignOffs (const SignOffs_optional& x)
    {
      this->SignOffs_ = x;
    }

    void VersionBaseType::
    SignOffs (::std::unique_ptr< SignOffs_type > x)
    {
      this->SignOffs_.set (std::move (x));
    }


    // VersionType
    //

    const VersionType::ThisInstanceQPId_optional& VersionType::
    ThisInstanceQPId () const
    {
      return this->ThisInstanceQPId_;
    }

    VersionType::ThisInstanceQPId_optional& VersionType::
    ThisInstanceQPId ()
    {
      return this->ThisInstanceQPId_;
    }

    void VersionType::
    ThisInstanceQPId (const ThisInstanceQPId_type& x)
    {
      this->ThisInstanceQPId_.set (x);
    }

    void VersionType::
    ThisInstanceQPId (const ThisInstanceQPId_optional& x)
    {
      this->ThisInstanceQPId_ = x;
    }

    void VersionType::
    ThisInstanceQPId (::std::unique_ptr< ThisInstanceQPId_type > x)
    {
      this->ThisInstanceQPId_.set (std::move (x));
    }


    // VersionReferenceType
    //

    const VersionReferenceType::QPIdReference_optional& VersionReferenceType::
    QPIdReference () const
    {
      return this->QPIdReference_;
    }

    VersionReferenceType::QPIdReference_optional& VersionReferenceType::
    QPIdReference ()
    {
      return this->QPIdReference_;
    }

    void VersionReferenceType::
    QPIdReference (const QPIdReference_type& x)
    {
      this->QPIdReference_.set (x);
    }

    void VersionReferenceType::
    QPIdReference (const QPIdReference_optional& x)
    {
      this->QPIdReference_ = x;
    }

    void VersionReferenceType::
    QPIdReference (::std::unique_ptr< QPIdReference_type > x)
    {
      this->QPIdReference_.set (std::move (x));
    }


    // SignOffsType
    //

    const SignOffsType::Employee_sequence& SignOffsType::
    Employee () const
    {
      return this->Employee_;
    }

    SignOffsType::Employee_sequence& SignOffsType::
    Employee ()
    {
      return this->Employee_;
    }

    void SignOffsType::
    Employee (const Employee_sequence& s)
    {
      this->Employee_ = s;
    }

    const SignOffsType::n_type& SignOffsType::
    n () const
    {
      return this->n_.get ();
    }

    SignOffsType::n_type& SignOffsType::
    n ()
    {
      return this->n_.get ();
    }

    void SignOffsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SignOffsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MaterialClassEnumType
    //

    MaterialClassEnumType::
    MaterialClassEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    MaterialClassEnumType::
    MaterialClassEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MaterialClassEnumType_literals_[v])
    {
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const MaterialClassEnumType& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MaterialClassEnumType& MaterialClassEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MaterialClassEnumType_literals_[v]);

      return *this;
    }


    // MaterialType
    //

    const MaterialType::Attributes_optional& MaterialType::
    Attributes () const
    {
      return this->Attributes_;
    }

    MaterialType::Attributes_optional& MaterialType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void MaterialType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void MaterialType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void MaterialType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const MaterialType::MaterialClassEnum_optional& MaterialType::
    MaterialClassEnum () const
    {
      return this->MaterialClassEnum_;
    }

    MaterialType::MaterialClassEnum_optional& MaterialType::
    MaterialClassEnum ()
    {
      return this->MaterialClassEnum_;
    }

    void MaterialType::
    MaterialClassEnum (const MaterialClassEnum_type& x)
    {
      this->MaterialClassEnum_.set (x);
    }

    void MaterialType::
    MaterialClassEnum (const MaterialClassEnum_optional& x)
    {
      this->MaterialClassEnum_ = x;
    }

    void MaterialType::
    MaterialClassEnum (::std::unique_ptr< MaterialClassEnum_type > x)
    {
      this->MaterialClassEnum_.set (std::move (x));
    }

    const MaterialType::OtherMaterialClass_optional& MaterialType::
    OtherMaterialClass () const
    {
      return this->OtherMaterialClass_;
    }

    MaterialType::OtherMaterialClass_optional& MaterialType::
    OtherMaterialClass ()
    {
      return this->OtherMaterialClass_;
    }

    void MaterialType::
    OtherMaterialClass (const OtherMaterialClass_type& x)
    {
      this->OtherMaterialClass_.set (x);
    }

    void MaterialType::
    OtherMaterialClass (const OtherMaterialClass_optional& x)
    {
      this->OtherMaterialClass_ = x;
    }

    void MaterialType::
    OtherMaterialClass (::std::unique_ptr< OtherMaterialClass_type > x)
    {
      this->OtherMaterialClass_.set (std::move (x));
    }

    const MaterialType::Description_optional& MaterialType::
    Description () const
    {
      return this->Description_;
    }

    MaterialType::Description_optional& MaterialType::
    Description ()
    {
      return this->Description_;
    }

    void MaterialType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void MaterialType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void MaterialType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const MaterialType::MassDensity_optional& MaterialType::
    MassDensity () const
    {
      return this->MassDensity_;
    }

    MaterialType::MassDensity_optional& MaterialType::
    MassDensity ()
    {
      return this->MassDensity_;
    }

    void MaterialType::
    MassDensity (const MassDensity_type& x)
    {
      this->MassDensity_.set (x);
    }

    void MaterialType::
    MassDensity (const MassDensity_optional& x)
    {
      this->MassDensity_ = x;
    }

    const MaterialType::PoissonsRatio_optional& MaterialType::
    PoissonsRatio () const
    {
      return this->PoissonsRatio_;
    }

    MaterialType::PoissonsRatio_optional& MaterialType::
    PoissonsRatio ()
    {
      return this->PoissonsRatio_;
    }

    void MaterialType::
    PoissonsRatio (const PoissonsRatio_type& x)
    {
      this->PoissonsRatio_.set (x);
    }

    void MaterialType::
    PoissonsRatio (const PoissonsRatio_optional& x)
    {
      this->PoissonsRatio_ = x;
    }

    const MaterialType::YoungsModulus_optional& MaterialType::
    YoungsModulus () const
    {
      return this->YoungsModulus_;
    }

    MaterialType::YoungsModulus_optional& MaterialType::
    YoungsModulus ()
    {
      return this->YoungsModulus_;
    }

    void MaterialType::
    YoungsModulus (const YoungsModulus_type& x)
    {
      this->YoungsModulus_.set (x);
    }

    void MaterialType::
    YoungsModulus (const YoungsModulus_optional& x)
    {
      this->YoungsModulus_ = x;
    }

    const MaterialType::UltimateTensileStress_optional& MaterialType::
    UltimateTensileStress () const
    {
      return this->UltimateTensileStress_;
    }

    MaterialType::UltimateTensileStress_optional& MaterialType::
    UltimateTensileStress ()
    {
      return this->UltimateTensileStress_;
    }

    void MaterialType::
    UltimateTensileStress (const UltimateTensileStress_type& x)
    {
      this->UltimateTensileStress_.set (x);
    }

    void MaterialType::
    UltimateTensileStress (const UltimateTensileStress_optional& x)
    {
      this->UltimateTensileStress_ = x;
    }

    const MaterialType::CompressiveYieldStress_optional& MaterialType::
    CompressiveYieldStress () const
    {
      return this->CompressiveYieldStress_;
    }

    MaterialType::CompressiveYieldStress_optional& MaterialType::
    CompressiveYieldStress ()
    {
      return this->CompressiveYieldStress_;
    }

    void MaterialType::
    CompressiveYieldStress (const CompressiveYieldStress_type& x)
    {
      this->CompressiveYieldStress_.set (x);
    }

    void MaterialType::
    CompressiveYieldStress (const CompressiveYieldStress_optional& x)
    {
      this->CompressiveYieldStress_ = x;
    }

    const MaterialType::TensileYieldStress_optional& MaterialType::
    TensileYieldStress () const
    {
      return this->TensileYieldStress_;
    }

    MaterialType::TensileYieldStress_optional& MaterialType::
    TensileYieldStress ()
    {
      return this->TensileYieldStress_;
    }

    void MaterialType::
    TensileYieldStress (const TensileYieldStress_type& x)
    {
      this->TensileYieldStress_.set (x);
    }

    void MaterialType::
    TensileYieldStress (const TensileYieldStress_optional& x)
    {
      this->TensileYieldStress_ = x;
    }

    const MaterialType::ThermalExpansion_optional& MaterialType::
    ThermalExpansion () const
    {
      return this->ThermalExpansion_;
    }

    MaterialType::ThermalExpansion_optional& MaterialType::
    ThermalExpansion ()
    {
      return this->ThermalExpansion_;
    }

    void MaterialType::
    ThermalExpansion (const ThermalExpansion_type& x)
    {
      this->ThermalExpansion_.set (x);
    }

    void MaterialType::
    ThermalExpansion (const ThermalExpansion_optional& x)
    {
      this->ThermalExpansion_ = x;
    }

    const MaterialType::SpecificHeatCapacity_optional& MaterialType::
    SpecificHeatCapacity () const
    {
      return this->SpecificHeatCapacity_;
    }

    MaterialType::SpecificHeatCapacity_optional& MaterialType::
    SpecificHeatCapacity ()
    {
      return this->SpecificHeatCapacity_;
    }

    void MaterialType::
    SpecificHeatCapacity (const SpecificHeatCapacity_type& x)
    {
      this->SpecificHeatCapacity_.set (x);
    }

    void MaterialType::
    SpecificHeatCapacity (const SpecificHeatCapacity_optional& x)
    {
      this->SpecificHeatCapacity_ = x;
    }

    const MaterialType::ThermalConductivity_optional& MaterialType::
    ThermalConductivity () const
    {
      return this->ThermalConductivity_;
    }

    MaterialType::ThermalConductivity_optional& MaterialType::
    ThermalConductivity ()
    {
      return this->ThermalConductivity_;
    }

    void MaterialType::
    ThermalConductivity (const ThermalConductivity_type& x)
    {
      this->ThermalConductivity_.set (x);
    }

    void MaterialType::
    ThermalConductivity (const ThermalConductivity_optional& x)
    {
      this->ThermalConductivity_ = x;
    }

    const MaterialType::Index_type& MaterialType::
    Index () const
    {
      return this->Index_.get ();
    }

    MaterialType::Index_type& MaterialType::
    Index ()
    {
      return this->Index_.get ();
    }

    void MaterialType::
    Index (const Index_type& x)
    {
      this->Index_.set (x);
    }

    void MaterialType::
    Index (::std::unique_ptr< Index_type > x)
    {
      this->Index_.set (std::move (x));
    }

    const MaterialType::MaterialName_type& MaterialType::
    MaterialName () const
    {
      return this->MaterialName_.get ();
    }

    MaterialType::MaterialName_type& MaterialType::
    MaterialName ()
    {
      return this->MaterialName_.get ();
    }

    void MaterialType::
    MaterialName (const MaterialName_type& x)
    {
      this->MaterialName_.set (x);
    }

    void MaterialType::
    MaterialName (::std::unique_ptr< MaterialName_type > x)
    {
      this->MaterialName_.set (std::move (x));
    }


    // MaterialsType
    //

    const MaterialsType::Material_sequence& MaterialsType::
    Material () const
    {
      return this->Material_;
    }

    MaterialsType::Material_sequence& MaterialsType::
    Material ()
    {
      return this->Material_;
    }

    void MaterialsType::
    Material (const Material_sequence& s)
    {
      this->Material_ = s;
    }

    const MaterialsType::n_type& MaterialsType::
    n () const
    {
      return this->n_.get ();
    }

    MaterialsType::n_type& MaterialsType::
    n ()
    {
      return this->n_.get ();
    }

    void MaterialsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MaterialsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // VirtualMeasurementType
    //

    const VirtualMeasurementType::id_type& VirtualMeasurementType::
    id () const
    {
      return this->id_.get ();
    }

    VirtualMeasurementType::id_type& VirtualMeasurementType::
    id ()
    {
      return this->id_.get ();
    }

    void VirtualMeasurementType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void VirtualMeasurementType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // PointSetReferenceBaseType
    //


    // PointSetReferenceWholeType
    //


    // PointSetReferenceRangeType
    //

    const PointSetReferenceRangeType::range_type& PointSetReferenceRangeType::
    range () const
    {
      return this->range_.get ();
    }

    PointSetReferenceRangeType::range_type& PointSetReferenceRangeType::
    range ()
    {
      return this->range_.get ();
    }

    void PointSetReferenceRangeType::
    range (const range_type& x)
    {
      this->range_.set (x);
    }

    void PointSetReferenceRangeType::
    range (::std::unique_ptr< range_type > x)
    {
      this->range_.set (std::move (x));
    }


    // PointSetReferenceSingleType
    //

    const PointSetReferenceSingleType::index_type& PointSetReferenceSingleType::
    index () const
    {
      return this->index_.get ();
    }

    PointSetReferenceSingleType::index_type& PointSetReferenceSingleType::
    index ()
    {
      return this->index_.get ();
    }

    void PointSetReferenceSingleType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    void PointSetReferenceSingleType::
    index (::std::unique_ptr< index_type > x)
    {
      this->index_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // SequencedDatumType
    //

    SequencedDatumType::
    SequencedDatumType ()
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      CompoundDatum_ (this),
      SequenceNumber_ (this)
    {
    }

    SequencedDatumType::
    SequencedDatumType (const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      CompoundDatum_ (this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedDatumType::
    SequencedDatumType (const SequencedDatumType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimpleDatum_ (x.SimpleDatum_, f, this),
      CompoundDatum_ (x.CompoundDatum_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    SequencedDatumType::
    SequencedDatumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimpleDatum_ (this),
      CompoundDatum_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SequencedDatumType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SimpleDatum
        //
        if (n.name () == L"SimpleDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimpleDatum_type > r (
            SimpleDatum_traits::create (i, f, this));

          if (!this->SimpleDatum_)
          {
            this->SimpleDatum_.set (::std::move (r));
            continue;
          }
        }

        // CompoundDatum
        //
        if (n.name () == L"CompoundDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CompoundDatum_type > r (
            CompoundDatum_traits::create (i, f, this));

          if (!this->CompoundDatum_)
          {
            this->CompoundDatum_.set (::std::move (r));
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SequencedDatumType* SequencedDatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SequencedDatumType (*this, f, c);
    }

    SequencedDatumType& SequencedDatumType::
    operator= (const SequencedDatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimpleDatum_ = x.SimpleDatum_;
        this->CompoundDatum_ = x.CompoundDatum_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    SequencedDatumType::
    ~SequencedDatumType ()
    {
    }

    // CompoundDatumType
    //

    CompoundDatumType::
    CompoundDatumType ()
    : ::xml_schema::type (),
      Datum_ (this),
      ReducedDatum_ (this),
      n_ (this)
    {
    }

    CompoundDatumType::
    CompoundDatumType (const n_type& n)
    : ::xml_schema::type (),
      Datum_ (this),
      ReducedDatum_ (this),
      n_ (n, this)
    {
    }

    CompoundDatumType::
    CompoundDatumType (const CompoundDatumType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Datum_ (x.Datum_, f, this),
      ReducedDatum_ (x.ReducedDatum_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CompoundDatumType::
    CompoundDatumType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Datum_ (this),
      ReducedDatum_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CompoundDatumType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Datum
        //
        if (n.name () == L"Datum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Datum_type > r (
            Datum_traits::create (i, f, this));

          this->Datum_.push_back (::std::move (r));
          continue;
        }

        // ReducedDatum
        //
        if (n.name () == L"ReducedDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReducedDatum_type > r (
            ReducedDatum_traits::create (i, f, this));

          if (!this->ReducedDatum_)
          {
            this->ReducedDatum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CompoundDatumType* CompoundDatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundDatumType (*this, f, c);
    }

    CompoundDatumType& CompoundDatumType::
    operator= (const CompoundDatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Datum_ = x.Datum_;
        this->ReducedDatum_ = x.ReducedDatum_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CompoundDatumType::
    ~CompoundDatumType ()
    {
    }

    // DatumWithPrecedenceType
    //

    DatumWithPrecedenceType::
    DatumWithPrecedenceType ()
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      MeasuredDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const Precedence_type& Precedence)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      MeasuredDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (Precedence, this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (::std::unique_ptr< Precedence_type > Precedence)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      MeasuredDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (std::move (Precedence), this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const DatumWithPrecedenceType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimpleDatum_ (x.SimpleDatum_, f, this),
      NominalDatumFeature_ (x.NominalDatumFeature_, f, this),
      MeasuredDatumFeature_ (x.MeasuredDatumFeature_, f, this),
      CompoundDatum_ (x.CompoundDatum_, f, this),
      Precedence_ (x.Precedence_, f, this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      MeasuredDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumWithPrecedenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SimpleDatum
        //
        if (n.name () == L"SimpleDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimpleDatum_type > r (
            SimpleDatum_traits::create (i, f, this));

          if (!this->SimpleDatum_)
          {
            this->SimpleDatum_.set (::std::move (r));
            continue;
          }
        }

        // NominalDatumFeature
        //
        if (n.name () == L"NominalDatumFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalDatumFeature_type > r (
            NominalDatumFeature_traits::create (i, f, this));

          if (!this->NominalDatumFeature_)
          {
            this->NominalDatumFeature_.set (::std::move (r));
            continue;
          }
        }

        // MeasuredDatumFeature
        //
        if (n.name () == L"MeasuredDatumFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredDatumFeature_type > r (
            MeasuredDatumFeature_traits::create (i, f, this));

          if (!this->MeasuredDatumFeature_)
          {
            this->MeasuredDatumFeature_.set (::std::move (r));
            continue;
          }
        }

        // CompoundDatum
        //
        if (n.name () == L"CompoundDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CompoundDatum_type > r (
            CompoundDatum_traits::create (i, f, this));

          if (!this->CompoundDatum_)
          {
            this->CompoundDatum_.set (::std::move (r));
            continue;
          }
        }

        // Precedence
        //
        if (n.name () == L"Precedence" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Precedence_type > r (
            Precedence_traits::create (i, f, this));

          if (!Precedence_.present ())
          {
            this->Precedence_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Precedence_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Precedence",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DatumWithPrecedenceType* DatumWithPrecedenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumWithPrecedenceType (*this, f, c);
    }

    DatumWithPrecedenceType& DatumWithPrecedenceType::
    operator= (const DatumWithPrecedenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimpleDatum_ = x.SimpleDatum_;
        this->NominalDatumFeature_ = x.NominalDatumFeature_;
        this->MeasuredDatumFeature_ = x.MeasuredDatumFeature_;
        this->CompoundDatum_ = x.CompoundDatum_;
        this->Precedence_ = x.Precedence_;
      }

      return *this;
    }

    DatumWithPrecedenceType::
    ~DatumWithPrecedenceType ()
    {
    }

    // DatumType
    //

    DatumType::
    DatumType ()
    : ::xml_schema::type (),
      DatumDefinitionId_ (this),
      MaterialModifier_ (this),
      SizeCharacteristicDefinitionId_ (this),
      ReferencedComponent_ (this),
      SubstituteFeatureAlgorithm_ (this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this),
      Attributes_ (this)
    {
    }

    DatumType::
    DatumType (const DatumDefinitionId_type& DatumDefinitionId,
               const MaterialModifier_type& MaterialModifier,
               const ReferencedComponent_type& ReferencedComponent)
    : ::xml_schema::type (),
      DatumDefinitionId_ (DatumDefinitionId, this),
      MaterialModifier_ (MaterialModifier, this),
      SizeCharacteristicDefinitionId_ (this),
      ReferencedComponent_ (ReferencedComponent, this),
      SubstituteFeatureAlgorithm_ (this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this),
      Attributes_ (this)
    {
    }

    DatumType::
    DatumType (::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId,
               const MaterialModifier_type& MaterialModifier,
               const ReferencedComponent_type& ReferencedComponent)
    : ::xml_schema::type (),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this),
      MaterialModifier_ (MaterialModifier, this),
      SizeCharacteristicDefinitionId_ (this),
      ReferencedComponent_ (ReferencedComponent, this),
      SubstituteFeatureAlgorithm_ (this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this),
      Attributes_ (this)
    {
    }

    DatumType::
    DatumType (const DatumType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      MaterialModifier_ (x.MaterialModifier_, f, this),
      SizeCharacteristicDefinitionId_ (x.SizeCharacteristicDefinitionId_, f, this),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this),
      DatumFeatureSimulatorModifier_ (x.DatumFeatureSimulatorModifier_, f, this),
      DatumTranslation_ (x.DatumTranslation_, f, this),
      DegreesOfFreedom_ (x.DegreesOfFreedom_, f, this),
      ProjectedDatum_ (x.ProjectedDatum_, f, this),
      DiameterModifier_ (x.DiameterModifier_, f, this),
      SectionModifier_ (x.SectionModifier_, f, this),
      ContactingFeature_ (x.ContactingFeature_, f, this),
      DistanceVariable_ (x.DistanceVariable_, f, this),
      DatumFixed_ (x.DatumFixed_, f, this),
      ReducedDatum_ (x.ReducedDatum_, f, this),
      ConstrainOrientation_ (x.ConstrainOrientation_, f, this),
      ConstrainSubsequent_ (x.ConstrainSubsequent_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    DatumType::
    DatumType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      MaterialModifier_ (this),
      SizeCharacteristicDefinitionId_ (this),
      ReferencedComponent_ (this),
      SubstituteFeatureAlgorithm_ (this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // MaterialModifier
        //
        if (n.name () == L"MaterialModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaterialModifier_type > r (
            MaterialModifier_traits::create (i, f, this));

          if (!MaterialModifier_.present ())
          {
            this->MaterialModifier_.set (::std::move (r));
            continue;
          }
        }

        // SizeCharacteristicDefinitionId
        //
        if (n.name () == L"SizeCharacteristicDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SizeCharacteristicDefinitionId_type > r (
            SizeCharacteristicDefinitionId_traits::create (i, f, this));

          if (!this->SizeCharacteristicDefinitionId_)
          {
            this->SizeCharacteristicDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // ReferencedComponent
        //
        if (n.name () == L"ReferencedComponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == L"SubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        // DatumFeatureSimulatorModifier
        //
        if (n.name () == L"DatumFeatureSimulatorModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumFeatureSimulatorModifier_type > r (
            DatumFeatureSimulatorModifier_traits::create (i, f, this));

          if (!this->DatumFeatureSimulatorModifier_)
          {
            this->DatumFeatureSimulatorModifier_.set (::std::move (r));
            continue;
          }
        }

        // DatumTranslation
        //
        if (n.name () == L"DatumTranslation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTranslation_type > r (
            DatumTranslation_traits::create (i, f, this));

          if (!this->DatumTranslation_)
          {
            this->DatumTranslation_.set (::std::move (r));
            continue;
          }
        }

        // DegreesOfFreedom
        //
        if (n.name () == L"DegreesOfFreedom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DegreesOfFreedom_type > r (
            DegreesOfFreedom_traits::create (i, f, this));

          if (!this->DegreesOfFreedom_)
          {
            this->DegreesOfFreedom_.set (::std::move (r));
            continue;
          }
        }

        // ProjectedDatum
        //
        if (n.name () == L"ProjectedDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectedDatum_type > r (
            ProjectedDatum_traits::create (i, f, this));

          if (!this->ProjectedDatum_)
          {
            this->ProjectedDatum_.set (::std::move (r));
            continue;
          }
        }

        // DiameterModifier
        //
        if (n.name () == L"DiameterModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterModifier_type > r (
            DiameterModifier_traits::create (i, f, this));

          if (!this->DiameterModifier_)
          {
            this->DiameterModifier_.set (::std::move (r));
            continue;
          }
        }

        // SectionModifier
        //
        if (n.name () == L"SectionModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionModifier_type > r (
            SectionModifier_traits::create (i, f, this));

          if (!this->SectionModifier_)
          {
            this->SectionModifier_.set (::std::move (r));
            continue;
          }
        }

        // ContactingFeature
        //
        if (n.name () == L"ContactingFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ContactingFeature_)
          {
            this->ContactingFeature_.set (ContactingFeature_traits::create (i, f, this));
            continue;
          }
        }

        // DistanceVariable
        //
        if (n.name () == L"DistanceVariable" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DistanceVariable_)
          {
            this->DistanceVariable_.set (DistanceVariable_traits::create (i, f, this));
            continue;
          }
        }

        // DatumFixed
        //
        if (n.name () == L"DatumFixed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DatumFixed_)
          {
            this->DatumFixed_.set (DatumFixed_traits::create (i, f, this));
            continue;
          }
        }

        // ReducedDatum
        //
        if (n.name () == L"ReducedDatum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReducedDatum_type > r (
            ReducedDatum_traits::create (i, f, this));

          if (!this->ReducedDatum_)
          {
            this->ReducedDatum_.set (::std::move (r));
            continue;
          }
        }

        // ConstrainOrientation
        //
        if (n.name () == L"ConstrainOrientation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ConstrainOrientation_)
          {
            this->ConstrainOrientation_.set (ConstrainOrientation_traits::create (i, f, this));
            continue;
          }
        }

        // ConstrainSubsequent
        //
        if (n.name () == L"ConstrainSubsequent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ConstrainSubsequent_)
          {
            this->ConstrainSubsequent_.set (ConstrainSubsequent_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaterialModifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaterialModifier",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferencedComponent",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DatumType* DatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumType (*this, f, c);
    }

    DatumType& DatumType::
    operator= (const DatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->MaterialModifier_ = x.MaterialModifier_;
        this->SizeCharacteristicDefinitionId_ = x.SizeCharacteristicDefinitionId_;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
        this->DatumFeatureSimulatorModifier_ = x.DatumFeatureSimulatorModifier_;
        this->DatumTranslation_ = x.DatumTranslation_;
        this->DegreesOfFreedom_ = x.DegreesOfFreedom_;
        this->ProjectedDatum_ = x.ProjectedDatum_;
        this->DiameterModifier_ = x.DiameterModifier_;
        this->SectionModifier_ = x.SectionModifier_;
        this->ContactingFeature_ = x.ContactingFeature_;
        this->DistanceVariable_ = x.DistanceVariable_;
        this->DatumFixed_ = x.DatumFixed_;
        this->ReducedDatum_ = x.ReducedDatum_;
        this->ConstrainOrientation_ = x.ConstrainOrientation_;
        this->ConstrainSubsequent_ = x.ConstrainSubsequent_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    DatumType::
    ~DatumType ()
    {
    }

    // DatumTranslationType
    //

    DatumTranslationType::
    DatumTranslationType ()
    : ::xml_schema::type (),
      DatumTranslationAllowed_ (this)
    {
    }

    DatumTranslationType::
    DatumTranslationType (const DatumTranslationAllowed_type& DatumTranslationAllowed)
    : ::xml_schema::type (),
      DatumTranslationAllowed_ (DatumTranslationAllowed, this)
    {
    }

    DatumTranslationType::
    DatumTranslationType (const DatumTranslationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTranslationAllowed_ (x.DatumTranslationAllowed_, f, this)
    {
    }

    DatumTranslationType::
    DatumTranslationType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTranslationAllowed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumTranslationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumTranslationAllowed
        //
        if (n.name () == L"DatumTranslationAllowed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DatumTranslationAllowed_.present ())
          {
            this->DatumTranslationAllowed_.set (DatumTranslationAllowed_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DatumTranslationAllowed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumTranslationAllowed",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DatumTranslationType* DatumTranslationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTranslationType (*this, f, c);
    }

    DatumTranslationType& DatumTranslationType::
    operator= (const DatumTranslationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTranslationAllowed_ = x.DatumTranslationAllowed_;
      }

      return *this;
    }

    DatumTranslationType::
    ~DatumTranslationType ()
    {
    }

    // DatumFeatureBaseType
    //

    DatumFeatureBaseType::
    DatumFeatureBaseType ()
    : ::xml_schema::type (),
      FeatureNominalId_ (this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (const FeatureNominalId_type& FeatureNominalId)
    : ::xml_schema::type (),
      FeatureNominalId_ (FeatureNominalId, this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (::std::unique_ptr< FeatureNominalId_type > FeatureNominalId)
    : ::xml_schema::type (),
      FeatureNominalId_ (std::move (FeatureNominalId), this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (const DatumFeatureBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureNominalId_ (x.FeatureNominalId_, f, this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumFeatureBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureNominalId
        //
        if (n.name () == L"FeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!FeatureNominalId_.present ())
          {
            this->FeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureNominalId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureNominalId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DatumFeatureBaseType& DatumFeatureBaseType::
    operator= (const DatumFeatureBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureNominalId_ = x.FeatureNominalId_;
      }

      return *this;
    }

    DatumFeatureBaseType::
    ~DatumFeatureBaseType ()
    {
    }

    // MeasuredDatumFeatureType
    //

    MeasuredDatumFeatureType::
    MeasuredDatumFeatureType ()
    : ::xsd::qif30::DatumFeatureBaseType (),
      MaterialModifier_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    MeasuredDatumFeatureType::
    MeasuredDatumFeatureType (const FeatureNominalId_type& FeatureNominalId,
                              const MaterialModifier_type& MaterialModifier)
    : ::xsd::qif30::DatumFeatureBaseType (FeatureNominalId),
      MaterialModifier_ (MaterialModifier, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    MeasuredDatumFeatureType::
    MeasuredDatumFeatureType (::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                              const MaterialModifier_type& MaterialModifier)
    : ::xsd::qif30::DatumFeatureBaseType (std::move (FeatureNominalId)),
      MaterialModifier_ (MaterialModifier, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    MeasuredDatumFeatureType::
    MeasuredDatumFeatureType (const MeasuredDatumFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::DatumFeatureBaseType (x, f, c),
      MaterialModifier_ (x.MaterialModifier_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    MeasuredDatumFeatureType::
    MeasuredDatumFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::DatumFeatureBaseType (e, f | ::xml_schema::flags::base, c),
      MaterialModifier_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredDatumFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DatumFeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaterialModifier
        //
        if (n.name () == L"MaterialModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaterialModifier_type > r (
            MaterialModifier_traits::create (i, f, this));

          if (!MaterialModifier_.present ())
          {
            this->MaterialModifier_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == L"SubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MaterialModifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaterialModifier",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredDatumFeatureType* MeasuredDatumFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredDatumFeatureType (*this, f, c);
    }

    MeasuredDatumFeatureType& MeasuredDatumFeatureType::
    operator= (const MeasuredDatumFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DatumFeatureBaseType& > (*this) = x;
        this->MaterialModifier_ = x.MaterialModifier_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    MeasuredDatumFeatureType::
    ~MeasuredDatumFeatureType ()
    {
    }

    // NominalDatumFeatureType
    //

    NominalDatumFeatureType::
    NominalDatumFeatureType ()
    : ::xsd::qif30::DatumFeatureBaseType ()
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (const FeatureNominalId_type& FeatureNominalId)
    : ::xsd::qif30::DatumFeatureBaseType (FeatureNominalId)
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (::std::unique_ptr< FeatureNominalId_type > FeatureNominalId)
    : ::xsd::qif30::DatumFeatureBaseType (std::move (FeatureNominalId))
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (const NominalDatumFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::DatumFeatureBaseType (x, f, c)
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::DatumFeatureBaseType (e, f, c)
    {
    }

    NominalDatumFeatureType* NominalDatumFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalDatumFeatureType (*this, f, c);
    }

    NominalDatumFeatureType::
    ~NominalDatumFeatureType ()
    {
    }

    // DatumFeatureSimulatorModifierType
    //

    const DatumFeatureSimulatorModifierType::BasicSize_type DatumFeatureSimulatorModifierType::BasicSize_default_value_ (
      L"BASIC");

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType ()
    : ::xml_schema::type (),
      LinearSize_ (this),
      DiametricalSize_ (this),
      BasicSize_ (this)
    {
    }

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType (const DatumFeatureSimulatorModifierType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearSize_ (x.LinearSize_, f, this),
      DiametricalSize_ (x.DiametricalSize_, f, this),
      BasicSize_ (x.BasicSize_, f, this)
    {
    }

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearSize_ (this),
      DiametricalSize_ (this),
      BasicSize_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumFeatureSimulatorModifierType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearSize
        //
        if (n.name () == L"LinearSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearSize_type > r (
            LinearSize_traits::create (i, f, this));

          if (!this->LinearSize_)
          {
            this->LinearSize_.set (::std::move (r));
            continue;
          }
        }

        // DiametricalSize
        //
        if (n.name () == L"DiametricalSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiametricalSize_type > r (
            DiametricalSize_traits::create (i, f, this));

          if (!this->DiametricalSize_)
          {
            this->DiametricalSize_.set (::std::move (r));
            continue;
          }
        }

        // BasicSize
        //
        if (n.name () == L"BasicSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasicSize_type > r (
            BasicSize_traits::create (i, f, this));

          if (!this->BasicSize_)
          {
            this->BasicSize_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DatumFeatureSimulatorModifierType* DatumFeatureSimulatorModifierType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumFeatureSimulatorModifierType (*this, f, c);
    }

    DatumFeatureSimulatorModifierType& DatumFeatureSimulatorModifierType::
    operator= (const DatumFeatureSimulatorModifierType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearSize_ = x.LinearSize_;
        this->DiametricalSize_ = x.DiametricalSize_;
        this->BasicSize_ = x.BasicSize_;
      }

      return *this;
    }

    DatumFeatureSimulatorModifierType::
    ~DatumFeatureSimulatorModifierType ()
    {
    }

    // DatumsType
    //

    DatumsType::
    DatumsType ()
    : ::xml_schema::type (),
      Datum_ (this),
      n_ (this)
    {
    }

    DatumsType::
    DatumsType (const n_type& n)
    : ::xml_schema::type (),
      Datum_ (this),
      n_ (n, this)
    {
    }

    DatumsType::
    DatumsType (const DatumsType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Datum_ (x.Datum_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DatumsType::
    DatumsType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Datum_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Datum
        //
        if (n.name () == L"Datum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Datum_type > r (
            Datum_traits::create (i, f, this));

          this->Datum_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DatumsType* DatumsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumsType (*this, f, c);
    }

    DatumsType& DatumsType::
    operator= (const DatumsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Datum_ = x.Datum_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DatumsType::
    ~DatumsType ()
    {
    }

    // DatumReferenceFrameType
    //

    DatumReferenceFrameType::
    DatumReferenceFrameType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Datums_ (this),
      Name_ (this),
      Description_ (this),
      CoordinateSystemId_ (this),
      id_ (this)
    {
    }

    DatumReferenceFrameType::
    DatumReferenceFrameType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Datums_ (this),
      Name_ (this),
      Description_ (this),
      CoordinateSystemId_ (this),
      id_ (id, this)
    {
    }

    DatumReferenceFrameType::
    DatumReferenceFrameType (const DatumReferenceFrameType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Datums_ (x.Datums_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumReferenceFrameType::
    DatumReferenceFrameType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Datums_ (this),
      Name_ (this),
      Description_ (this),
      CoordinateSystemId_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumReferenceFrameType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Datums
        //
        if (n.name () == L"Datums" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Datums_type > r (
            Datums_traits::create (i, f, this));

          if (!this->Datums_)
          {
            this->Datums_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DatumReferenceFrameType* DatumReferenceFrameType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumReferenceFrameType (*this, f, c);
    }

    DatumReferenceFrameType& DatumReferenceFrameType::
    operator= (const DatumReferenceFrameType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Datums_ = x.Datums_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumReferenceFrameType::
    ~DatumReferenceFrameType ()
    {
    }

    // DegreeOfFreedomEnumType
    //

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType* DegreeOfFreedomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DegreeOfFreedomEnumType (*this, f, c);
    }

    DegreeOfFreedomEnumType::value DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DegreeOfFreedomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DegreeOfFreedomEnumType_indexes_,
                        _xsd_DegreeOfFreedomEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_DegreeOfFreedomEnumType_indexes_ + 6 || _xsd_DegreeOfFreedomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_literals_[6] =
    {
      L"U",
      L"V",
      L"W",
      L"X",
      L"Y",
      L"Z"
    };

    const DegreeOfFreedomEnumType::value DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_indexes_[6] =
    {
      ::xsd::qif30::DegreeOfFreedomEnumType::U,
      ::xsd::qif30::DegreeOfFreedomEnumType::V,
      ::xsd::qif30::DegreeOfFreedomEnumType::W,
      ::xsd::qif30::DegreeOfFreedomEnumType::X,
      ::xsd::qif30::DegreeOfFreedomEnumType::Y,
      ::xsd::qif30::DegreeOfFreedomEnumType::Z
    };

    // ISODegreeOfFreedomEnumType
    //

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType* ISODegreeOfFreedomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ISODegreeOfFreedomEnumType (*this, f, c);
    }

    ISODegreeOfFreedomEnumType::value ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ISODegreeOfFreedomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ISODegreeOfFreedomEnumType_indexes_,
                        _xsd_ISODegreeOfFreedomEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_ISODegreeOfFreedomEnumType_indexes_ + 6 || _xsd_ISODegreeOfFreedomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_literals_[6] =
    {
      L"Rx",
      L"Ry",
      L"Rz",
      L"Tx",
      L"Ty",
      L"Tz"
    };

    const ISODegreeOfFreedomEnumType::value ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_indexes_[6] =
    {
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Rx,
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Ry,
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Rz,
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Tx,
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Ty,
      ::xsd::qif30::ISODegreeOfFreedomEnumType::Tz
    };

    // IntersectionPlaneEnumType
    //

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType* IntersectionPlaneEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IntersectionPlaneEnumType (*this, f, c);
    }

    IntersectionPlaneEnumType::value IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_IntersectionPlaneEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_IntersectionPlaneEnumType_indexes_,
                        _xsd_IntersectionPlaneEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_IntersectionPlaneEnumType_indexes_ + 3 || _xsd_IntersectionPlaneEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_literals_[3] =
    {
      L"PARALLEL",
      L"PERPENDICULAR",
      L"INCLUDING"
    };

    const IntersectionPlaneEnumType::value IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_indexes_[3] =
    {
      ::xsd::qif30::IntersectionPlaneEnumType::INCLUDING,
      ::xsd::qif30::IntersectionPlaneEnumType::PARALLEL,
      ::xsd::qif30::IntersectionPlaneEnumType::PERPENDICULAR
    };

    // IntersectionPlaneType
    //

    IntersectionPlaneType::
    IntersectionPlaneType ()
    : ::xml_schema::type (),
      IntersectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneEnum_type& IntersectionPlaneEnum,
                           const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      IntersectionPlaneEnum_ (IntersectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneEnum_type& IntersectionPlaneEnum,
                           ::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      IntersectionPlaneEnum_ (IntersectionPlaneEnum, this),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IntersectionPlaneEnum_ (x.IntersectionPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IntersectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntersectionPlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionPlaneEnum
        //
        if (n.name () == L"IntersectionPlaneEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionPlaneEnum_type > r (
            IntersectionPlaneEnum_traits::create (i, f, this));

          if (!IntersectionPlaneEnum_.present ())
          {
            this->IntersectionPlaneEnum_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionPlaneEnum",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    IntersectionPlaneType* IntersectionPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IntersectionPlaneType (*this, f, c);
    }

    IntersectionPlaneType& IntersectionPlaneType::
    operator= (const IntersectionPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IntersectionPlaneEnum_ = x.IntersectionPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    IntersectionPlaneType::
    ~IntersectionPlaneType ()
    {
    }

    // ModifyingPlaneEnumType
    //

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType* ModifyingPlaneEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ModifyingPlaneEnumType (*this, f, c);
    }

    ModifyingPlaneEnumType::value ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ModifyingPlaneEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ModifyingPlaneEnumType_indexes_,
                        _xsd_ModifyingPlaneEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ModifyingPlaneEnumType_indexes_ + 3 || _xsd_ModifyingPlaneEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_literals_[3] =
    {
      L"PARALLEL",
      L"PERPENDICULAR",
      L"INCLINED"
    };

    const ModifyingPlaneEnumType::value ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_indexes_[3] =
    {
      ::xsd::qif30::ModifyingPlaneEnumType::INCLINED,
      ::xsd::qif30::ModifyingPlaneEnumType::PARALLEL,
      ::xsd::qif30::ModifyingPlaneEnumType::PERPENDICULAR
    };

    // DirectionFeatureType
    //

    DirectionFeatureType::
    DirectionFeatureType ()
    : ::xml_schema::type (),
      DirectionFeatureEnum_ (this),
      DatumDefinitionId_ (this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureEnum_type& DirectionFeatureEnum,
                          const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      DirectionFeatureEnum_ (DirectionFeatureEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureEnum_type& DirectionFeatureEnum,
                          ::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      DirectionFeatureEnum_ (DirectionFeatureEnum, this),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirectionFeatureEnum_ (x.DirectionFeatureEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirectionFeatureEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DirectionFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DirectionFeatureEnum
        //
        if (n.name () == L"DirectionFeatureEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirectionFeatureEnum_type > r (
            DirectionFeatureEnum_traits::create (i, f, this));

          if (!DirectionFeatureEnum_.present ())
          {
            this->DirectionFeatureEnum_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DirectionFeatureEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirectionFeatureEnum",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DirectionFeatureType* DirectionFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DirectionFeatureType (*this, f, c);
    }

    DirectionFeatureType& DirectionFeatureType::
    operator= (const DirectionFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DirectionFeatureEnum_ = x.DirectionFeatureEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    DirectionFeatureType::
    ~DirectionFeatureType ()
    {
    }

    // CollectionPlaneType
    //

    CollectionPlaneType::
    CollectionPlaneType ()
    : ::xml_schema::type (),
      CollectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneEnum_type& CollectionPlaneEnum,
                         const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      CollectionPlaneEnum_ (CollectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneEnum_type& CollectionPlaneEnum,
                         ::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      CollectionPlaneEnum_ (CollectionPlaneEnum, this),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CollectionPlaneEnum_ (x.CollectionPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CollectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CollectionPlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CollectionPlaneEnum
        //
        if (n.name () == L"CollectionPlaneEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CollectionPlaneEnum_type > r (
            CollectionPlaneEnum_traits::create (i, f, this));

          if (!CollectionPlaneEnum_.present ())
          {
            this->CollectionPlaneEnum_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CollectionPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CollectionPlaneEnum",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CollectionPlaneType* CollectionPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CollectionPlaneType (*this, f, c);
    }

    CollectionPlaneType& CollectionPlaneType::
    operator= (const CollectionPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CollectionPlaneEnum_ = x.CollectionPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    CollectionPlaneType::
    ~CollectionPlaneType ()
    {
    }

    // OrientationPlaneType
    //

    OrientationPlaneType::
    OrientationPlaneType ()
    : ::xml_schema::type (),
      OrientationPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneEnum_type& OrientationPlaneEnum,
                          const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      OrientationPlaneEnum_ (OrientationPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneEnum_type& OrientationPlaneEnum,
                          ::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      OrientationPlaneEnum_ (OrientationPlaneEnum, this),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      OrientationPlaneEnum_ (x.OrientationPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      OrientationPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrientationPlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // OrientationPlaneEnum
        //
        if (n.name () == L"OrientationPlaneEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OrientationPlaneEnum_type > r (
            OrientationPlaneEnum_traits::create (i, f, this));

          if (!OrientationPlaneEnum_.present ())
          {
            this->OrientationPlaneEnum_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!OrientationPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OrientationPlaneEnum",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OrientationPlaneType* OrientationPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrientationPlaneType (*this, f, c);
    }

    OrientationPlaneType& OrientationPlaneType::
    operator= (const OrientationPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->OrientationPlaneEnum_ = x.OrientationPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    OrientationPlaneType::
    ~OrientationPlaneType ()
    {
    }

    // ReducedDatumEnumType
    //

    ReducedDatumEnumType::
    ReducedDatumEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType* ReducedDatumEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReducedDatumEnumType (*this, f, c);
    }

    ReducedDatumEnumType::value ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ReducedDatumEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ReducedDatumEnumType_indexes_,
                        _xsd_ReducedDatumEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ReducedDatumEnumType_indexes_ + 3 || _xsd_ReducedDatumEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_literals_[3] =
    {
      L"PT",
      L"SL",
      L"PL"
    };

    const ReducedDatumEnumType::value ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_indexes_[3] =
    {
      ::xsd::qif30::ReducedDatumEnumType::PL,
      ::xsd::qif30::ReducedDatumEnumType::PT,
      ::xsd::qif30::ReducedDatumEnumType::SL
    };

    // DegreesOfFreedomType
    //

    DegreesOfFreedomType::
    DegreesOfFreedomType ()
    : ::xml_schema::type (),
      DegreeOfFreedom_ (this),
      ISODegreeOfFreedom_ (this),
      n_ (this)
    {
    }

    DegreesOfFreedomType::
    DegreesOfFreedomType (const n_type& n)
    : ::xml_schema::type (),
      DegreeOfFreedom_ (this),
      ISODegreeOfFreedom_ (this),
      n_ (n, this)
    {
    }

    DegreesOfFreedomType::
    DegreesOfFreedomType (const DegreesOfFreedomType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DegreeOfFreedom_ (x.DegreeOfFreedom_, f, this),
      ISODegreeOfFreedom_ (x.ISODegreeOfFreedom_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DegreesOfFreedomType::
    DegreesOfFreedomType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DegreeOfFreedom_ (this),
      ISODegreeOfFreedom_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DegreesOfFreedomType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DegreeOfFreedom
        //
        if (n.name () == L"DegreeOfFreedom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DegreeOfFreedom_type > r (
            DegreeOfFreedom_traits::create (i, f, this));

          this->DegreeOfFreedom_.push_back (::std::move (r));
          continue;
        }

        // ISODegreeOfFreedom
        //
        if (n.name () == L"ISODegreeOfFreedom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ISODegreeOfFreedom_type > r (
            ISODegreeOfFreedom_traits::create (i, f, this));

          this->ISODegreeOfFreedom_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DegreesOfFreedomType* DegreesOfFreedomType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DegreesOfFreedomType (*this, f, c);
    }

    DegreesOfFreedomType& DegreesOfFreedomType::
    operator= (const DegreesOfFreedomType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DegreeOfFreedom_ = x.DegreeOfFreedom_;
        this->ISODegreeOfFreedom_ = x.ISODegreeOfFreedom_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DegreesOfFreedomType::
    ~DegreesOfFreedomType ()
    {
    }

    // DiameterModifierEnumType
    //

    DiameterModifierEnumType::
    DiameterModifierEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType* DiameterModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DiameterModifierEnumType (*this, f, c);
    }

    DiameterModifierEnumType::value DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DiameterModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DiameterModifierEnumType_indexes_,
                        _xsd_DiameterModifierEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DiameterModifierEnumType_indexes_ + 3 || _xsd_DiameterModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_literals_[3] =
    {
      L"PD",
      L"MD",
      L"LD"
    };

    const DiameterModifierEnumType::value DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_indexes_[3] =
    {
      ::xsd::qif30::DiameterModifierEnumType::LD,
      ::xsd::qif30::DiameterModifierEnumType::MD,
      ::xsd::qif30::DiameterModifierEnumType::PD
    };

    // SectionModifierEnumType
    //

    SectionModifierEnumType::
    SectionModifierEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType* SectionModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionModifierEnumType (*this, f, c);
    }

    SectionModifierEnumType::value SectionModifierEnumType::
    _xsd_SectionModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SectionModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SectionModifierEnumType_indexes_,
                        _xsd_SectionModifierEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_SectionModifierEnumType_indexes_ + 3 || _xsd_SectionModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SectionModifierEnumType::
    _xsd_SectionModifierEnumType_literals_[3] =
    {
      L"ACS",
      L"ALS",
      L"SCS"
    };

    const SectionModifierEnumType::value SectionModifierEnumType::
    _xsd_SectionModifierEnumType_indexes_[3] =
    {
      ::xsd::qif30::SectionModifierEnumType::ACS,
      ::xsd::qif30::SectionModifierEnumType::ALS,
      ::xsd::qif30::SectionModifierEnumType::SCS
    };

    // PointWithNormalBaseType
    //

    PointWithNormalBaseType::
    PointWithNormalBaseType ()
    : ::xml_schema::type (),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (const Point_type& Point,
                             const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (::std::unique_ptr< Point_type > Point,
                             const id_type& id)
    : ::xml_schema::type (),
      Point_ (std::move (Point), this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (const PointWithNormalBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointWithNormalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    PointWithNormalBaseType& PointWithNormalBaseType::
    operator= (const PointWithNormalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PointWithNormalBaseType::
    ~PointWithNormalBaseType ()
    {
    }

    // MeasuredPointWithNormalBaseType
    //

    MeasuredPointWithNormalBaseType::
    MeasuredPointWithNormalBaseType ()
    : ::xml_schema::type (),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
    }

    MeasuredPointWithNormalBaseType::
    MeasuredPointWithNormalBaseType (const Point_type& Point,
                                     const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    MeasuredPointWithNormalBaseType::
    MeasuredPointWithNormalBaseType (::std::unique_ptr< Point_type > Point,
                                     const id_type& id)
    : ::xml_schema::type (),
      Point_ (std::move (Point), this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    MeasuredPointWithNormalBaseType::
    MeasuredPointWithNormalBaseType (const MeasuredPointWithNormalBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasuredPointWithNormalBaseType::
    MeasuredPointWithNormalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredPointWithNormalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    MeasuredPointWithNormalBaseType& MeasuredPointWithNormalBaseType::
    operator= (const MeasuredPointWithNormalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasuredPointWithNormalBaseType::
    ~MeasuredPointWithNormalBaseType ()
    {
    }

    // MeasurePointNominalType
    //

    MeasurePointNominalType::
    MeasurePointNominalType ()
    : ::xsd::qif30::PointWithNormalBaseType (),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      TipId_ (this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (const Point_type& Point,
                             const id_type& id)
    : ::xsd::qif30::PointWithNormalBaseType (Point,
                                             id),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      TipId_ (this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (::std::unique_ptr< Point_type > Point,
                             const id_type& id)
    : ::xsd::qif30::PointWithNormalBaseType (std::move (Point),
                                             id),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      TipId_ (this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (const MeasurePointNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::PointWithNormalBaseType (x, f, c),
      MeasurementDeviceId_ (x.MeasurementDeviceId_, f, this),
      SensorId_ (x.SensorId_, f, this),
      TipId_ (x.TipId_, f, this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::PointWithNormalBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      TipId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurePointNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointWithNormalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceId
        //
        if (n.name () == L"MeasurementDeviceId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceId_type > r (
            MeasurementDeviceId_traits::create (i, f, this));

          if (!this->MeasurementDeviceId_)
          {
            this->MeasurementDeviceId_.set (::std::move (r));
            continue;
          }
        }

        // SensorId
        //
        if (n.name () == L"SensorId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SensorId_type > r (
            SensorId_traits::create (i, f, this));

          if (!this->SensorId_)
          {
            this->SensorId_.set (::std::move (r));
            continue;
          }
        }

        // TipId
        //
        if (n.name () == L"TipId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipId_type > r (
            TipId_traits::create (i, f, this));

          if (!this->TipId_)
          {
            this->TipId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasurePointNominalType* MeasurePointNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurePointNominalType (*this, f, c);
    }

    MeasurePointNominalType& MeasurePointNominalType::
    operator= (const MeasurePointNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointWithNormalBaseType& > (*this) = x;
        this->MeasurementDeviceId_ = x.MeasurementDeviceId_;
        this->SensorId_ = x.SensorId_;
        this->TipId_ = x.TipId_;
      }

      return *this;
    }

    MeasurePointNominalType::
    ~MeasurePointNominalType ()
    {
    }

    // MovableDatumTargetDirectionType
    //

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType ()
    : ::xml_schema::type (),
      DatumTargetTranslationDirection_ (this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const DatumTargetTranslationDirection_type& DatumTargetTranslationDirection)
    : ::xml_schema::type (),
      DatumTargetTranslationDirection_ (DatumTargetTranslationDirection, this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (::std::unique_ptr< DatumTargetTranslationDirection_type > DatumTargetTranslationDirection)
    : ::xml_schema::type (),
      DatumTargetTranslationDirection_ (std::move (DatumTargetTranslationDirection), this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const MovableDatumTargetDirectionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTargetTranslationDirection_ (x.DatumTargetTranslationDirection_, f, this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTargetTranslationDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MovableDatumTargetDirectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumTargetTranslationDirection
        //
        if (n.name () == L"DatumTargetTranslationDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTargetTranslationDirection_type > r (
            DatumTargetTranslationDirection_traits::create (i, f, this));

          if (!DatumTargetTranslationDirection_.present ())
          {
            this->DatumTargetTranslationDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumTargetTranslationDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumTargetTranslationDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MovableDatumTargetDirectionType* MovableDatumTargetDirectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MovableDatumTargetDirectionType (*this, f, c);
    }

    MovableDatumTargetDirectionType& MovableDatumTargetDirectionType::
    operator= (const MovableDatumTargetDirectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTargetTranslationDirection_ = x.DatumTargetTranslationDirection_;
      }

      return *this;
    }

    MovableDatumTargetDirectionType::
    ~MovableDatumTargetDirectionType ()
    {
    }

    // DefiningPointNominalType
    //

    DefiningPointNominalType::
    DefiningPointNominalType ()
    : ::xsd::qif30::PointWithNormalBaseType (),
      SequenceNumber_ (this)
    {
    }

    DefiningPointNominalType::
    DefiningPointNominalType (const Point_type& Point,
                              const id_type& id,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::PointWithNormalBaseType (Point,
                                             id),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    DefiningPointNominalType::
    DefiningPointNominalType (::std::unique_ptr< Point_type > Point,
                              const id_type& id,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::PointWithNormalBaseType (std::move (Point),
                                             id),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    DefiningPointNominalType::
    DefiningPointNominalType (const DefiningPointNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::PointWithNormalBaseType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    DefiningPointNominalType::
    DefiningPointNominalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::PointWithNormalBaseType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DefiningPointNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointWithNormalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DefiningPointNominalType* DefiningPointNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefiningPointNominalType (*this, f, c);
    }

    DefiningPointNominalType& DefiningPointNominalType::
    operator= (const DefiningPointNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointWithNormalBaseType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    DefiningPointNominalType::
    ~DefiningPointNominalType ()
    {
    }

    // DefiningPointMeasurementType
    //

    DefiningPointMeasurementType::
    DefiningPointMeasurementType ()
    : ::xsd::qif30::MeasuredPointWithNormalBaseType (),
      SequenceNumber_ (this)
    {
    }

    DefiningPointMeasurementType::
    DefiningPointMeasurementType (const Point_type& Point,
                                  const id_type& id,
                                  const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::MeasuredPointWithNormalBaseType (Point,
                                                     id),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    DefiningPointMeasurementType::
    DefiningPointMeasurementType (::std::unique_ptr< Point_type > Point,
                                  const id_type& id,
                                  const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::MeasuredPointWithNormalBaseType (std::move (Point),
                                                     id),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    DefiningPointMeasurementType::
    DefiningPointMeasurementType (const DefiningPointMeasurementType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredPointWithNormalBaseType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    DefiningPointMeasurementType::
    DefiningPointMeasurementType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredPointWithNormalBaseType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DefiningPointMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredPointWithNormalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DefiningPointMeasurementType* DefiningPointMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefiningPointMeasurementType (*this, f, c);
    }

    DefiningPointMeasurementType& DefiningPointMeasurementType::
    operator= (const DefiningPointMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredPointWithNormalBaseType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    DefiningPointMeasurementType::
    ~DefiningPointMeasurementType ()
    {
    }

    // TransformListType
    //

    TransformListType::
    TransformListType ()
    : ::xml_schema::type (),
      Transform_ (this),
      n_ (this)
    {
    }

    TransformListType::
    TransformListType (const n_type& n)
    : ::xml_schema::type (),
      Transform_ (this),
      n_ (n, this)
    {
    }

    TransformListType::
    TransformListType (const TransformListType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transform_ (x.Transform_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TransformListType::
    TransformListType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transform_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TransformListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          this->Transform_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TransformListType* TransformListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformListType (*this, f, c);
    }

    TransformListType& TransformListType::
    operator= (const TransformListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transform_ = x.Transform_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TransformListType::
    ~TransformListType ()
    {
    }

    // TransformInstanceType
    //

    TransformInstanceType::
    TransformInstanceType ()
    : ::xsd::qif30::TransformMatrixType (),
      Attributes_ (this),
      Name_ (this),
      id_ (this)
    {
    }

    TransformInstanceType::
    TransformInstanceType (const id_type& id)
    : ::xsd::qif30::TransformMatrixType (),
      Attributes_ (this),
      Name_ (this),
      id_ (id, this)
    {
    }

    TransformInstanceType::
    TransformInstanceType (const TransformInstanceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::TransformMatrixType (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      id_ (x.id_, f, this)
    {
    }

    TransformInstanceType::
    TransformInstanceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::TransformMatrixType (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Name_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TransformInstanceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TransformMatrixType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    TransformInstanceType* TransformInstanceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformInstanceType (*this, f, c);
    }

    TransformInstanceType& TransformInstanceType::
    operator= (const TransformInstanceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TransformMatrixType& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Name_ = x.Name_;
        this->id_ = x.id_;
      }

      return *this;
    }

    TransformInstanceType::
    ~TransformInstanceType ()
    {
    }

    // LinearCoordinateDirectionEnumType
    //

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType* LinearCoordinateDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearCoordinateDirectionEnumType (*this, f, c);
    }

    LinearCoordinateDirectionEnumType::value LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LinearCoordinateDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LinearCoordinateDirectionEnumType_indexes_,
                        _xsd_LinearCoordinateDirectionEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_LinearCoordinateDirectionEnumType_indexes_ + 4 || _xsd_LinearCoordinateDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_literals_[4] =
    {
      L"XAXIS",
      L"YAXIS",
      L"ZAXIS",
      L"RADIAL"
    };

    const LinearCoordinateDirectionEnumType::value LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_indexes_[4] =
    {
      ::xsd::qif30::LinearCoordinateDirectionEnumType::RADIAL,
      ::xsd::qif30::LinearCoordinateDirectionEnumType::XAXIS,
      ::xsd::qif30::LinearCoordinateDirectionEnumType::YAXIS,
      ::xsd::qif30::LinearCoordinateDirectionEnumType::ZAXIS
    };

    // AngularCoordinateDirectionEnumType
    //

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType* AngularCoordinateDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularCoordinateDirectionEnumType (*this, f, c);
    }

    AngularCoordinateDirectionEnumType::value AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AngularCoordinateDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AngularCoordinateDirectionEnumType_indexes_,
                        _xsd_AngularCoordinateDirectionEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_AngularCoordinateDirectionEnumType_indexes_ + 3 || _xsd_AngularCoordinateDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_literals_[3] =
    {
      L"ANGULAR",
      L"AZIMUTH",
      L"POLAR"
    };

    const AngularCoordinateDirectionEnumType::value AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_indexes_[3] =
    {
      ::xsd::qif30::AngularCoordinateDirectionEnumType::ANGULAR,
      ::xsd::qif30::AngularCoordinateDirectionEnumType::AZIMUTH,
      ::xsd::qif30::AngularCoordinateDirectionEnumType::POLAR
    };

    // SubstituteFeatureAlgorithmEnumType
    //

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SubstituteFeatureAlgorithmEnumType_convert ();
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SubstituteFeatureAlgorithmEnumType_convert ();
    }

    SubstituteFeatureAlgorithmEnumType::
    SubstituteFeatureAlgorithmEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SubstituteFeatureAlgorithmEnumType_convert ();
    }

    SubstituteFeatureAlgorithmEnumType* SubstituteFeatureAlgorithmEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubstituteFeatureAlgorithmEnumType (*this, f, c);
    }

    SubstituteFeatureAlgorithmEnumType::value SubstituteFeatureAlgorithmEnumType::
    _xsd_SubstituteFeatureAlgorithmEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SubstituteFeatureAlgorithmEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SubstituteFeatureAlgorithmEnumType_indexes_,
                        _xsd_SubstituteFeatureAlgorithmEnumType_indexes_ + 14,
                        *this,
                        c));

      if (i == _xsd_SubstituteFeatureAlgorithmEnumType_indexes_ + 14 || _xsd_SubstituteFeatureAlgorithmEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SubstituteFeatureAlgorithmEnumType::
    _xsd_SubstituteFeatureAlgorithmEnumType_literals_[14] =
    {
      L"BEZIER",
      L"BSPLINE",
      L"DEFAULT",
      L"LEASTSQUARES",
      L"MAXINSCRIBED",
      L"MAXINNERLOCALSIZE",
      L"MAXOUTERLOCALSIZE",
      L"MINCIRCUMSCRIBED",
      L"MININNERLOCALSIZE",
      L"MINOUTERLOCALSIZE",
      L"MINMAX",
      L"NURBS",
      L"ONESIDED",
      L"UNDEFINED"
    };

    const SubstituteFeatureAlgorithmEnumType::value SubstituteFeatureAlgorithmEnumType::
    _xsd_SubstituteFeatureAlgorithmEnumType_indexes_[14] =
    {
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::BEZIER,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::BSPLINE,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::DEFAULT,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::LEASTSQUARES,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MAXINNERLOCALSIZE,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MAXINSCRIBED,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MAXOUTERLOCALSIZE,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MINCIRCUMSCRIBED,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MININNERLOCALSIZE,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MINMAX,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::MINOUTERLOCALSIZE,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::NURBS,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::ONESIDED,
      ::xsd::qif30::SubstituteFeatureAlgorithmEnumType::UNDEFINED
    };

    // SubstituteFeatureAlgorithmType
    //

    SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      SubstituteFeatureAlgorithmEnum_ (this),
      SubstituteFeatureAlgorithmId_ (this),
      OtherSubstituteFeatureAlgorithm_ (this)
    {
    }

    SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmType (const SubstituteFeatureAlgorithmType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      SubstituteFeatureAlgorithmEnum_ (x.SubstituteFeatureAlgorithmEnum_, f, this),
      SubstituteFeatureAlgorithmId_ (x.SubstituteFeatureAlgorithmId_, f, this),
      OtherSubstituteFeatureAlgorithm_ (x.OtherSubstituteFeatureAlgorithm_, f, this)
    {
    }

    SubstituteFeatureAlgorithmType::
    SubstituteFeatureAlgorithmType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      SubstituteFeatureAlgorithmEnum_ (this),
      SubstituteFeatureAlgorithmId_ (this),
      OtherSubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SubstituteFeatureAlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithmEnum
        //
        if (n.name () == L"SubstituteFeatureAlgorithmEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithmEnum_type > r (
            SubstituteFeatureAlgorithmEnum_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithmEnum_)
          {
            this->SubstituteFeatureAlgorithmEnum_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithmId
        //
        if (n.name () == L"SubstituteFeatureAlgorithmId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithmId_type > r (
            SubstituteFeatureAlgorithmId_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithmId_)
          {
            this->SubstituteFeatureAlgorithmId_.set (::std::move (r));
            continue;
          }
        }

        // OtherSubstituteFeatureAlgorithm
        //
        if (n.name () == L"OtherSubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherSubstituteFeatureAlgorithm_type > r (
            OtherSubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->OtherSubstituteFeatureAlgorithm_)
          {
            this->OtherSubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SubstituteFeatureAlgorithmType* SubstituteFeatureAlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubstituteFeatureAlgorithmType (*this, f, c);
    }

    SubstituteFeatureAlgorithmType& SubstituteFeatureAlgorithmType::
    operator= (const SubstituteFeatureAlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->SubstituteFeatureAlgorithmEnum_ = x.SubstituteFeatureAlgorithmEnum_;
        this->SubstituteFeatureAlgorithmId_ = x.SubstituteFeatureAlgorithmId_;
        this->OtherSubstituteFeatureAlgorithm_ = x.OtherSubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    SubstituteFeatureAlgorithmType::
    ~SubstituteFeatureAlgorithmType ()
    {
    }

    // MaterialModifierEnumType
    //

    MaterialModifierEnumType::
    MaterialModifierEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType* MaterialModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaterialModifierEnumType (*this, f, c);
    }

    MaterialModifierEnumType::value MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_MaterialModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MaterialModifierEnumType_indexes_,
                        _xsd_MaterialModifierEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_MaterialModifierEnumType_indexes_ + 6 || _xsd_MaterialModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_literals_[6] =
    {
      L"REGARDLESS",
      L"LEAST",
      L"MAXIMUM",
      L"LEAST_RPR",
      L"MAXIMUM_RPR",
      L"NONE"
    };

    const MaterialModifierEnumType::value MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_indexes_[6] =
    {
      ::xsd::qif30::MaterialModifierEnumType::LEAST,
      ::xsd::qif30::MaterialModifierEnumType::LEAST_RPR,
      ::xsd::qif30::MaterialModifierEnumType::MAXIMUM,
      ::xsd::qif30::MaterialModifierEnumType::MAXIMUM_RPR,
      ::xsd::qif30::MaterialModifierEnumType::NONE,
      ::xsd::qif30::MaterialModifierEnumType::REGARDLESS
    };

    // PrecedenceEnumType
    //

    PrecedenceEnumType::
    PrecedenceEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType* PrecedenceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecedenceEnumType (*this, f, c);
    }

    PrecedenceEnumType::value PrecedenceEnumType::
    _xsd_PrecedenceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PrecedenceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PrecedenceEnumType_indexes_,
                        _xsd_PrecedenceEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_PrecedenceEnumType_indexes_ + 6 || _xsd_PrecedenceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const PrecedenceEnumType::
    _xsd_PrecedenceEnumType_literals_[6] =
    {
      L"PRIMARY",
      L"SECONDARY",
      L"TERTIARY",
      L"QUATERNARY",
      L"QUINARY",
      L"SENARY"
    };

    const PrecedenceEnumType::value PrecedenceEnumType::
    _xsd_PrecedenceEnumType_indexes_[6] =
    {
      ::xsd::qif30::PrecedenceEnumType::PRIMARY,
      ::xsd::qif30::PrecedenceEnumType::QUATERNARY,
      ::xsd::qif30::PrecedenceEnumType::QUINARY,
      ::xsd::qif30::PrecedenceEnumType::SECONDARY,
      ::xsd::qif30::PrecedenceEnumType::SENARY,
      ::xsd::qif30::PrecedenceEnumType::TERTIARY
    };

    // PrecedenceType
    //

    PrecedenceType::
    PrecedenceType ()
    : ::xml_schema::type (),
      PrecedenceEnum_ (this),
      OtherPrecedence_ (this)
    {
    }

    PrecedenceType::
    PrecedenceType (const PrecedenceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrecedenceEnum_ (x.PrecedenceEnum_, f, this),
      OtherPrecedence_ (x.OtherPrecedence_, f, this)
    {
    }

    PrecedenceType::
    PrecedenceType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrecedenceEnum_ (this),
      OtherPrecedence_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrecedenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PrecedenceEnum
        //
        if (n.name () == L"PrecedenceEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrecedenceEnum_type > r (
            PrecedenceEnum_traits::create (i, f, this));

          if (!this->PrecedenceEnum_)
          {
            this->PrecedenceEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherPrecedence
        //
        if (n.name () == L"OtherPrecedence" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherPrecedence_type > r (
            OtherPrecedence_traits::create (i, f, this));

          if (!this->OtherPrecedence_)
          {
            this->OtherPrecedence_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PrecedenceType* PrecedenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecedenceType (*this, f, c);
    }

    PrecedenceType& PrecedenceType::
    operator= (const PrecedenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrecedenceEnum_ = x.PrecedenceEnum_;
        this->OtherPrecedence_ = x.OtherPrecedence_;
      }

      return *this;
    }

    PrecedenceType::
    ~PrecedenceType ()
    {
    }

    // ReferencedComponentEnumType
    //

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType* ReferencedComponentEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferencedComponentEnumType (*this, f, c);
    }

    ReferencedComponentEnumType::value ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ReferencedComponentEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ReferencedComponentEnumType_indexes_,
                        _xsd_ReferencedComponentEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ReferencedComponentEnumType_indexes_ + 2 || _xsd_ReferencedComponentEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_literals_[2] =
    {
      L"NOMINAL",
      L"ACTUAL"
    };

    const ReferencedComponentEnumType::value ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_indexes_[2] =
    {
      ::xsd::qif30::ReferencedComponentEnumType::ACTUAL,
      ::xsd::qif30::ReferencedComponentEnumType::NOMINAL
    };

    // RetrievalMethodEnumType
    //

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType* RetrievalMethodEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RetrievalMethodEnumType (*this, f, c);
    }

    RetrievalMethodEnumType::value RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_RetrievalMethodEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_RetrievalMethodEnumType_indexes_,
                        _xsd_RetrievalMethodEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_RetrievalMethodEnumType_indexes_ + 6 || _xsd_RetrievalMethodEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_literals_[6] =
    {
      L"AVERAGE",
      L"MAXEXTREME",
      L"MINEXTREME",
      L"CLOSEST1D",
      L"CLOSEST2D",
      L"CLOSEST3D"
    };

    const RetrievalMethodEnumType::value RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_indexes_[6] =
    {
      ::xsd::qif30::RetrievalMethodEnumType::AVERAGE,
      ::xsd::qif30::RetrievalMethodEnumType::CLOSEST1D,
      ::xsd::qif30::RetrievalMethodEnumType::CLOSEST2D,
      ::xsd::qif30::RetrievalMethodEnumType::CLOSEST3D,
      ::xsd::qif30::RetrievalMethodEnumType::MAXEXTREME,
      ::xsd::qif30::RetrievalMethodEnumType::MINEXTREME
    };

    // MeasurementDirectiveEnumType
    //

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType* MeasurementDirectiveEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDirectiveEnumType (*this, f, c);
    }

    MeasurementDirectiveEnumType::value MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_MeasurementDirectiveEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MeasurementDirectiveEnumType_indexes_,
                        _xsd_MeasurementDirectiveEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_MeasurementDirectiveEnumType_indexes_ + 4 || _xsd_MeasurementDirectiveEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_literals_[4] =
    {
      L"MINIMUM",
      L"MAXIMUM",
      L"AVERAGE",
      L"UNDEFINED"
    };

    const MeasurementDirectiveEnumType::value MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_indexes_[4] =
    {
      ::xsd::qif30::MeasurementDirectiveEnumType::AVERAGE,
      ::xsd::qif30::MeasurementDirectiveEnumType::MAXIMUM,
      ::xsd::qif30::MeasurementDirectiveEnumType::MINIMUM,
      ::xsd::qif30::MeasurementDirectiveEnumType::UNDEFINED
    };

    // MeasurementDirectiveType
    //

    MeasurementDirectiveType::
    MeasurementDirectiveType ()
    : ::xml_schema::type (),
      MeasurementDirectiveEnum_ (this),
      OtherMeasurementDirective_ (this)
    {
    }

    MeasurementDirectiveType::
    MeasurementDirectiveType (const MeasurementDirectiveType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementDirectiveEnum_ (x.MeasurementDirectiveEnum_, f, this),
      OtherMeasurementDirective_ (x.OtherMeasurementDirective_, f, this)
    {
    }

    MeasurementDirectiveType::
    MeasurementDirectiveType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementDirectiveEnum_ (this),
      OtherMeasurementDirective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementDirectiveType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDirectiveEnum
        //
        if (n.name () == L"MeasurementDirectiveEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDirectiveEnum_type > r (
            MeasurementDirectiveEnum_traits::create (i, f, this));

          if (!this->MeasurementDirectiveEnum_)
          {
            this->MeasurementDirectiveEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherMeasurementDirective
        //
        if (n.name () == L"OtherMeasurementDirective" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherMeasurementDirective_type > r (
            OtherMeasurementDirective_traits::create (i, f, this));

          if (!this->OtherMeasurementDirective_)
          {
            this->OtherMeasurementDirective_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasurementDirectiveType* MeasurementDirectiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDirectiveType (*this, f, c);
    }

    MeasurementDirectiveType& MeasurementDirectiveType::
    operator= (const MeasurementDirectiveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurementDirectiveEnum_ = x.MeasurementDirectiveEnum_;
        this->OtherMeasurementDirective_ = x.OtherMeasurementDirective_;
      }

      return *this;
    }

    MeasurementDirectiveType::
    ~MeasurementDirectiveType ()
    {
    }

    // DistanceBetweenAnalysisModeEnumType
    //

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const xercesc::DOMAttr& a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::std::wstring& s,
                                         const xercesc::DOMElement* e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType* DistanceBetweenAnalysisModeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistanceBetweenAnalysisModeEnumType (*this, f, c);
    }

    DistanceBetweenAnalysisModeEnumType::value DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DistanceBetweenAnalysisModeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DistanceBetweenAnalysisModeEnumType_indexes_,
                        _xsd_DistanceBetweenAnalysisModeEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DistanceBetweenAnalysisModeEnumType_indexes_ + 3 || _xsd_DistanceBetweenAnalysisModeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_literals_[3] =
    {
      L"ONEDIMENSIONAL",
      L"TWODIMENSIONAL",
      L"THREEDIMENSIONAL"
    };

    const DistanceBetweenAnalysisModeEnumType::value DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_indexes_[3] =
    {
      ::xsd::qif30::DistanceBetweenAnalysisModeEnumType::ONEDIMENSIONAL,
      ::xsd::qif30::DistanceBetweenAnalysisModeEnumType::THREEDIMENSIONAL,
      ::xsd::qif30::DistanceBetweenAnalysisModeEnumType::TWODIMENSIONAL
    };

    // AngleBetweenAnalysisModeEnumType
    //

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::std::wstring& s,
                                      const xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType* AngleBetweenAnalysisModeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleBetweenAnalysisModeEnumType (*this, f, c);
    }

    AngleBetweenAnalysisModeEnumType::value AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AngleBetweenAnalysisModeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AngleBetweenAnalysisModeEnumType_indexes_,
                        _xsd_AngleBetweenAnalysisModeEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_AngleBetweenAnalysisModeEnumType_indexes_ + 2 || _xsd_AngleBetweenAnalysisModeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_literals_[2] =
    {
      L"TWODIMENSIONAL",
      L"THREEDIMENSIONAL"
    };

    const AngleBetweenAnalysisModeEnumType::value AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_indexes_[2] =
    {
      ::xsd::qif30::AngleBetweenAnalysisModeEnumType::THREEDIMENSIONAL,
      ::xsd::qif30::AngleBetweenAnalysisModeEnumType::TWODIMENSIONAL
    };

    // BaseFeatureType
    //

    BaseFeatureType::
    BaseFeatureType ()
    : ::xml_schema::type (),
      ReferencedComponent_ (this),
      FeatureId_ (this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                     const FeatureId_type& FeatureId)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      FeatureId_ (FeatureId, this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                     ::std::unique_ptr< FeatureId_type > FeatureId)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      FeatureId_ (std::move (FeatureId), this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const BaseFeatureType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      FeatureId_ (x.FeatureId_, f, this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ReferencedComponent_ (this),
      FeatureId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BaseFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ReferencedComponent
        //
        if (n.name () == L"ReferencedComponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (::std::move (r));
            continue;
          }
        }

        // FeatureId
        //
        if (n.name () == L"FeatureId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureId_type > r (
            FeatureId_traits::create (i, f, this));

          if (!FeatureId_.present ())
          {
            this->FeatureId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferencedComponent",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!FeatureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    BaseFeatureType* BaseFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeatureType (*this, f, c);
    }

    BaseFeatureType& BaseFeatureType::
    operator= (const BaseFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->FeatureId_ = x.FeatureId_;
      }

      return *this;
    }

    BaseFeatureType::
    ~BaseFeatureType ()
    {
    }

    // SequencedBaseFeatureType
    //

    SequencedBaseFeatureType::
    SequencedBaseFeatureType ()
    : ::xsd::qif30::BaseFeatureType (),
      SequenceNumber_ (this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                              const FeatureId_type& FeatureId,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::BaseFeatureType (ReferencedComponent,
                                     FeatureId),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                              ::std::unique_ptr< FeatureId_type > FeatureId,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::BaseFeatureType (ReferencedComponent,
                                     std::move (FeatureId)),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const SequencedBaseFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::BaseFeatureType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::BaseFeatureType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SequencedBaseFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::BaseFeatureType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SequencedBaseFeatureType* SequencedBaseFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SequencedBaseFeatureType (*this, f, c);
    }

    SequencedBaseFeatureType& SequencedBaseFeatureType::
    operator= (const SequencedBaseFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BaseFeatureType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    SequencedBaseFeatureType::
    ~SequencedBaseFeatureType ()
    {
    }

    // DirectionalOffsetType
    //

    DirectionalOffsetType::
    DirectionalOffsetType ()
    : ::xml_schema::type (),
      Offset_ (this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (const Offset_type& Offset)
    : ::xml_schema::type (),
      Offset_ (Offset, this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (::std::unique_ptr< Offset_type > Offset)
    : ::xml_schema::type (),
      Offset_ (std::move (Offset), this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (const DirectionalOffsetType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Offset_ (x.Offset_, f, this),
      NominalDirection_ (x.NominalDirection_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Offset_ (this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DirectionalOffsetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        // NominalDirection
        //
        if (n.name () == L"NominalDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalDirection_type > r (
            NominalDirection_traits::create (i, f, this));

          if (!this->NominalDirection_)
          {
            this->NominalDirection_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == L"FeatureDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Offset",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DirectionalOffsetType* DirectionalOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DirectionalOffsetType (*this, f, c);
    }

    DirectionalOffsetType& DirectionalOffsetType::
    operator= (const DirectionalOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Offset_ = x.Offset_;
        this->NominalDirection_ = x.NominalDirection_;
        this->FeatureDirection_ = x.FeatureDirection_;
      }

      return *this;
    }

    DirectionalOffsetType::
    ~DirectionalOffsetType ()
    {
    }

    // AlignmentFeatureType
    //

    AlignmentFeatureType::
    AlignmentFeatureType ()
    : ::xml_schema::type (),
      DatumDefinitionId_ (this),
      BaseFeature_ (this)
    {
    }

    AlignmentFeatureType::
    AlignmentFeatureType (const AlignmentFeatureType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    AlignmentFeatureType::
    AlignmentFeatureType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AlignmentFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!this->DatumDefinitionId_)
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!this->BaseFeature_)
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AlignmentFeatureType* AlignmentFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentFeatureType (*this, f, c);
    }

    AlignmentFeatureType& AlignmentFeatureType::
    operator= (const AlignmentFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    AlignmentFeatureType::
    ~AlignmentFeatureType ()
    {
    }

    // AlignmentOperationBaseType
    //

    AlignmentOperationBaseType::
    AlignmentOperationBaseType ()
    : ::xml_schema::type (),
      SequenceNumber_ (this),
      Attributes_ (this)
    {
    }

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this),
      Attributes_ (this)
    {
    }

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const AlignmentOperationBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AlignmentOperationBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AlignmentOperationBaseType& AlignmentOperationBaseType::
    operator= (const AlignmentOperationBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    AlignmentOperationBaseType::
    ~AlignmentOperationBaseType ()
    {
    }

    // PrimaryAlignmentOperationType
    //

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      PrimaryEntity_ (this),
      PrimaryAxis_ (this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   const PrimaryEntity_type& PrimaryEntity,
                                   const PrimaryAxis_type& PrimaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      PrimaryEntity_ (PrimaryEntity, this),
      PrimaryAxis_ (PrimaryAxis, this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   ::std::unique_ptr< PrimaryEntity_type > PrimaryEntity,
                                   ::std::unique_ptr< PrimaryAxis_type > PrimaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      PrimaryEntity_ (std::move (PrimaryEntity), this),
      PrimaryAxis_ (std::move (PrimaryAxis), this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const PrimaryAlignmentOperationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      PrimaryEntity_ (x.PrimaryEntity_, f, this),
      PrimaryAxis_ (x.PrimaryAxis_, f, this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      PrimaryEntity_ (this),
      PrimaryAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrimaryAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PrimaryEntity
        //
        if (n.name () == L"PrimaryEntity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryEntity_type > r (
            PrimaryEntity_traits::create (i, f, this));

          if (!PrimaryEntity_.present ())
          {
            this->PrimaryEntity_.set (::std::move (r));
            continue;
          }
        }

        // PrimaryAxis
        //
        if (n.name () == L"PrimaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryAxis_type > r (
            PrimaryAxis_traits::create (i, f, this));

          if (!PrimaryAxis_.present ())
          {
            this->PrimaryAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PrimaryEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PrimaryEntity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PrimaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PrimaryAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PrimaryAlignmentOperationType* PrimaryAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrimaryAlignmentOperationType (*this, f, c);
    }

    PrimaryAlignmentOperationType& PrimaryAlignmentOperationType::
    operator= (const PrimaryAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->PrimaryEntity_ = x.PrimaryEntity_;
        this->PrimaryAxis_ = x.PrimaryAxis_;
      }

      return *this;
    }

    PrimaryAlignmentOperationType::
    ~PrimaryAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignmentOperationType_type_factory_init (
      L"PrimaryAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // SecondaryAlignmentOperationType
    //

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      SecondaryEntity_ (this),
      SecondaryAxis_ (this),
      RotationAxis_ (this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                     const SecondaryEntity_type& SecondaryEntity,
                                     const SecondaryAxis_type& SecondaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      SecondaryEntity_ (SecondaryEntity, this),
      SecondaryAxis_ (SecondaryAxis, this),
      RotationAxis_ (this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                     ::std::unique_ptr< SecondaryEntity_type > SecondaryEntity,
                                     ::std::unique_ptr< SecondaryAxis_type > SecondaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      SecondaryEntity_ (std::move (SecondaryEntity), this),
      SecondaryAxis_ (std::move (SecondaryAxis), this),
      RotationAxis_ (this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SecondaryAlignmentOperationType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      SecondaryEntity_ (x.SecondaryEntity_, f, this),
      SecondaryAxis_ (x.SecondaryAxis_, f, this),
      RotationAxis_ (x.RotationAxis_, f, this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      SecondaryEntity_ (this),
      SecondaryAxis_ (this),
      RotationAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecondaryAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SecondaryEntity
        //
        if (n.name () == L"SecondaryEntity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondaryEntity_type > r (
            SecondaryEntity_traits::create (i, f, this));

          if (!SecondaryEntity_.present ())
          {
            this->SecondaryEntity_.set (::std::move (r));
            continue;
          }
        }

        // SecondaryAxis
        //
        if (n.name () == L"SecondaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondaryAxis_type > r (
            SecondaryAxis_traits::create (i, f, this));

          if (!SecondaryAxis_.present ())
          {
            this->SecondaryAxis_.set (::std::move (r));
            continue;
          }
        }

        // RotationAxis
        //
        if (n.name () == L"RotationAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RotationAxis_type > r (
            RotationAxis_traits::create (i, f, this));

          if (!this->RotationAxis_)
          {
            this->RotationAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SecondaryEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondaryEntity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SecondaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondaryAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SecondaryAlignmentOperationType* SecondaryAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecondaryAlignmentOperationType (*this, f, c);
    }

    SecondaryAlignmentOperationType& SecondaryAlignmentOperationType::
    operator= (const SecondaryAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->SecondaryEntity_ = x.SecondaryEntity_;
        this->SecondaryAxis_ = x.SecondaryAxis_;
        this->RotationAxis_ = x.RotationAxis_;
      }

      return *this;
    }

    SecondaryAlignmentOperationType::
    ~SecondaryAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignmentOperationType_type_factory_init (
      L"SecondaryAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasurementOriginOffsetType
    //

    MeasurementOriginOffsetType::
    MeasurementOriginOffsetType ()
    : ::xml_schema::type (),
      OriginEntity_ (this),
      OriginDirection_ (this)
    {
    }

    MeasurementOriginOffsetType::
    MeasurementOriginOffsetType (const OriginEntity_type& OriginEntity,
                                 const OriginDirection_type& OriginDirection)
    : ::xml_schema::type (),
      OriginEntity_ (OriginEntity, this),
      OriginDirection_ (OriginDirection, this)
    {
    }

    MeasurementOriginOffsetType::
    MeasurementOriginOffsetType (::std::unique_ptr< OriginEntity_type > OriginEntity,
                                 ::std::unique_ptr< OriginDirection_type > OriginDirection)
    : ::xml_schema::type (),
      OriginEntity_ (std::move (OriginEntity), this),
      OriginDirection_ (std::move (OriginDirection), this)
    {
    }

    MeasurementOriginOffsetType::
    MeasurementOriginOffsetType (const MeasurementOriginOffsetType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      OriginEntity_ (x.OriginEntity_, f, this),
      OriginDirection_ (x.OriginDirection_, f, this)
    {
    }

    MeasurementOriginOffsetType::
    MeasurementOriginOffsetType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      OriginEntity_ (this),
      OriginDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementOriginOffsetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // OriginEntity
        //
        if (n.name () == L"OriginEntity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OriginEntity_type > r (
            OriginEntity_traits::create (i, f, this));

          if (!OriginEntity_.present ())
          {
            this->OriginEntity_.set (::std::move (r));
            continue;
          }
        }

        // OriginDirection
        //
        if (n.name () == L"OriginDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OriginDirection_type > r (
            OriginDirection_traits::create (i, f, this));

          if (!OriginDirection_.present ())
          {
            this->OriginDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!OriginEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OriginEntity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!OriginDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OriginDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasurementOriginOffsetType* MeasurementOriginOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementOriginOffsetType (*this, f, c);
    }

    MeasurementOriginOffsetType& MeasurementOriginOffsetType::
    operator= (const MeasurementOriginOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->OriginEntity_ = x.OriginEntity_;
        this->OriginDirection_ = x.OriginDirection_;
      }

      return *this;
    }

    MeasurementOriginOffsetType::
    ~MeasurementOriginOffsetType ()
    {
    }

    // MeasurementOffsetAlignmentOperationType
    //

    MeasurementOffsetAlignmentOperationType::
    MeasurementOffsetAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      Origin_ (this),
      n_ (this)
    {
    }

    MeasurementOffsetAlignmentOperationType::
    MeasurementOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                             const n_type& n)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      Origin_ (this),
      n_ (n, this)
    {
    }

    MeasurementOffsetAlignmentOperationType::
    MeasurementOffsetAlignmentOperationType (const MeasurementOffsetAlignmentOperationType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      Origin_ (x.Origin_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MeasurementOffsetAlignmentOperationType::
    MeasurementOffsetAlignmentOperationType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      Origin_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementOffsetAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          this->Origin_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MeasurementOffsetAlignmentOperationType* MeasurementOffsetAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementOffsetAlignmentOperationType (*this, f, c);
    }

    MeasurementOffsetAlignmentOperationType& MeasurementOffsetAlignmentOperationType::
    operator= (const MeasurementOffsetAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->Origin_ = x.Origin_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MeasurementOffsetAlignmentOperationType::
    ~MeasurementOffsetAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasurementOffsetAlignmentOperationType >
    _xsd_MeasurementOffsetAlignmentOperationType_type_factory_init (
      L"MeasurementOffsetAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // NominalOffsetAlignmentOperationType
    //

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      Offset_ (this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                         const Offset_type& Offset)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      Offset_ (Offset, this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                         ::std::unique_ptr< Offset_type > Offset)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      Offset_ (std::move (Offset), this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const NominalOffsetAlignmentOperationType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      Offset_ (x.Offset_, f, this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NominalOffsetAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Offset",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NominalOffsetAlignmentOperationType* NominalOffsetAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalOffsetAlignmentOperationType (*this, f, c);
    }

    NominalOffsetAlignmentOperationType& NominalOffsetAlignmentOperationType::
    operator= (const NominalOffsetAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    NominalOffsetAlignmentOperationType::
    ~NominalOffsetAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NominalOffsetAlignmentOperationType >
    _xsd_NominalOffsetAlignmentOperationType_type_factory_init (
      L"NominalOffsetAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // NominalRotationAlignmentOperationType
    //

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      RotationAxis_ (this),
      Angle_ (this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           const RotationAxis_type& RotationAxis,
                                           const Angle_type& Angle)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      RotationAxis_ (RotationAxis, this),
      Angle_ (Angle, this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           ::std::unique_ptr< RotationAxis_type > RotationAxis,
                                           ::std::unique_ptr< Angle_type > Angle)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      RotationAxis_ (std::move (RotationAxis), this),
      Angle_ (std::move (Angle), this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const NominalRotationAlignmentOperationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      RotationAxis_ (x.RotationAxis_, f, this),
      Angle_ (x.Angle_, f, this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      RotationAxis_ (this),
      Angle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NominalRotationAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RotationAxis
        //
        if (n.name () == L"RotationAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RotationAxis_type > r (
            RotationAxis_traits::create (i, f, this));

          if (!RotationAxis_.present ())
          {
            this->RotationAxis_.set (::std::move (r));
            continue;
          }
        }

        // Angle
        //
        if (n.name () == L"Angle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Angle_type > r (
            Angle_traits::create (i, f, this));

          if (!Angle_.present ())
          {
            this->Angle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RotationAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RotationAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Angle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Angle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NominalRotationAlignmentOperationType* NominalRotationAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalRotationAlignmentOperationType (*this, f, c);
    }

    NominalRotationAlignmentOperationType& NominalRotationAlignmentOperationType::
    operator= (const NominalRotationAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->RotationAxis_ = x.RotationAxis_;
        this->Angle_ = x.Angle_;
      }

      return *this;
    }

    NominalRotationAlignmentOperationType::
    ~NominalRotationAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NominalRotationAlignmentOperationType >
    _xsd_NominalRotationAlignmentOperationType_type_factory_init (
      L"NominalRotationAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // DatumPrecedenceAlignmentOperationType
    //

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      DatumReferenceFrameId_ (this),
      PrimaryAxis_ (this),
      SecondaryAxis_ (this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           const DatumReferenceFrameId_type& DatumReferenceFrameId,
                                           const PrimaryAxis_type& PrimaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this),
      PrimaryAxis_ (PrimaryAxis, this),
      SecondaryAxis_ (this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           ::std::unique_ptr< DatumReferenceFrameId_type > DatumReferenceFrameId,
                                           ::std::unique_ptr< PrimaryAxis_type > PrimaryAxis)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      DatumReferenceFrameId_ (std::move (DatumReferenceFrameId), this),
      PrimaryAxis_ (std::move (PrimaryAxis), this),
      SecondaryAxis_ (this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const DatumPrecedenceAlignmentOperationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      DatumReferenceFrameId_ (x.DatumReferenceFrameId_, f, this),
      PrimaryAxis_ (x.PrimaryAxis_, f, this),
      SecondaryAxis_ (x.SecondaryAxis_, f, this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      DatumReferenceFrameId_ (this),
      PrimaryAxis_ (this),
      SecondaryAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumPrecedenceAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumReferenceFrameId
        //
        if (n.name () == L"DatumReferenceFrameId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumReferenceFrameId_type > r (
            DatumReferenceFrameId_traits::create (i, f, this));

          if (!DatumReferenceFrameId_.present ())
          {
            this->DatumReferenceFrameId_.set (::std::move (r));
            continue;
          }
        }

        // PrimaryAxis
        //
        if (n.name () == L"PrimaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryAxis_type > r (
            PrimaryAxis_traits::create (i, f, this));

          if (!PrimaryAxis_.present ())
          {
            this->PrimaryAxis_.set (::std::move (r));
            continue;
          }
        }

        // SecondaryAxis
        //
        if (n.name () == L"SecondaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondaryAxis_type > r (
            SecondaryAxis_traits::create (i, f, this));

          if (!this->SecondaryAxis_)
          {
            this->SecondaryAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumReferenceFrameId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumReferenceFrameId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PrimaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PrimaryAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DatumPrecedenceAlignmentOperationType* DatumPrecedenceAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumPrecedenceAlignmentOperationType (*this, f, c);
    }

    DatumPrecedenceAlignmentOperationType& DatumPrecedenceAlignmentOperationType::
    operator= (const DatumPrecedenceAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->DatumReferenceFrameId_ = x.DatumReferenceFrameId_;
        this->PrimaryAxis_ = x.PrimaryAxis_;
        this->SecondaryAxis_ = x.SecondaryAxis_;
      }

      return *this;
    }

    DatumPrecedenceAlignmentOperationType::
    ~DatumPrecedenceAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedenceAlignmentOperationType_type_factory_init (
      L"DatumPrecedenceAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // BestFitAlignmentOperationType
    //

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType (),
      DegreesOfFreedom_ (this),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   const DegreesOfFreedom_type& DegreesOfFreedom,
                                   const n_type& n)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      DegreesOfFreedom_ (DegreesOfFreedom, this),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   ::std::unique_ptr< DegreesOfFreedom_type > DegreesOfFreedom,
                                   const n_type& n)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber),
      DegreesOfFreedom_ (std::move (DegreesOfFreedom), this),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const BestFitAlignmentOperationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c),
      DegreesOfFreedom_ (x.DegreesOfFreedom_, f, this),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      DegreesOfFreedom_ (this),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BestFitAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DegreesOfFreedom
        //
        if (n.name () == L"DegreesOfFreedom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DegreesOfFreedom_type > r (
            DegreesOfFreedom_traits::create (i, f, this));

          if (!DegreesOfFreedom_.present ())
          {
            this->DegreesOfFreedom_.set (::std::move (r));
            continue;
          }
        }

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!DegreesOfFreedom_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DegreesOfFreedom",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    BestFitAlignmentOperationType* BestFitAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BestFitAlignmentOperationType (*this, f, c);
    }

    BestFitAlignmentOperationType& BestFitAlignmentOperationType::
    operator= (const BestFitAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AlignmentOperationBaseType& > (*this) = x;
        this->DegreesOfFreedom_ = x.DegreesOfFreedom_;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    BestFitAlignmentOperationType::
    ~BestFitAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BestFitAlignmentOperationType >
    _xsd_BestFitAlignmentOperationType_type_factory_init (
      L"BestFitAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");

    // MachineCoordinateSystemOperationType
    //

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType ()
    : ::xsd::qif30::AlignmentOperationBaseType ()
    {
    }

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::AlignmentOperationBaseType (SequenceNumber)
    {
    }

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const MachineCoordinateSystemOperationType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (x, f, c)
    {
    }

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::AlignmentOperationBaseType (e, f, c)
    {
    }

    MachineCoordinateSystemOperationType* MachineCoordinateSystemOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MachineCoordinateSystemOperationType (*this, f, c);
    }

    MachineCoordinateSystemOperationType::
    ~MachineCoordinateSystemOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MachineCoordinateSystemOperationType >
    _xsd_MachineCoordinateSystemOperationType_type_factory_init (
      L"MachineCoordinateSystemOperationType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PrimaryAlignment_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"PrimaryAlignment",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PrimaryAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SecondaryAlignment_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"SecondaryAlignment",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SecondaryAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MeasurementOffset_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasurementOffset",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MeasurementOffsetAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NominalOffset_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"NominalOffset",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::NominalOffsetAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NominalRotation_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"NominalRotation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::NominalRotationAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DatumPrecedence_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"DatumPrecedence",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DatumPrecedenceAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_BestFit_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"BestFit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::BestFitAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Machine_element_factory_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"Machine",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MachineCoordinateSystemOperationType >);


    // AlignmentOperationsType
    //

    AlignmentOperationsType::
    AlignmentOperationsType ()
    : ::xml_schema::type (),
      AlignmentOperation_ (this),
      BaseCoordinateSystemId_ (this),
      n_ (this)
    {
    }

    AlignmentOperationsType::
    AlignmentOperationsType (const n_type& n)
    : ::xml_schema::type (),
      AlignmentOperation_ (this),
      BaseCoordinateSystemId_ (this),
      n_ (n, this)
    {
    }

    AlignmentOperationsType::
    AlignmentOperationsType (const AlignmentOperationsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AlignmentOperation_ (x.AlignmentOperation_, f, this),
      BaseCoordinateSystemId_ (x.BaseCoordinateSystemId_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AlignmentOperationsType::
    AlignmentOperationsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AlignmentOperation_ (this),
      BaseCoordinateSystemId_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AlignmentOperationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AlignmentOperation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"AlignmentOperation",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< AlignmentOperation_type > r (
              dynamic_cast< AlignmentOperation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AlignmentOperation_.push_back (::std::move (r));
            continue;
          }
        }

        // BaseCoordinateSystemId
        //
        if (n.name () == L"BaseCoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCoordinateSystemId_type > r (
            BaseCoordinateSystemId_traits::create (i, f, this));

          if (!this->BaseCoordinateSystemId_)
          {
            this->BaseCoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AlignmentOperationsType* AlignmentOperationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentOperationsType (*this, f, c);
    }

    AlignmentOperationsType& AlignmentOperationsType::
    operator= (const AlignmentOperationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AlignmentOperation_ = x.AlignmentOperation_;
        this->BaseCoordinateSystemId_ = x.BaseCoordinateSystemId_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AlignmentOperationsType::
    ~AlignmentOperationsType ()
    {
    }

    // MachineCoordinateSystemType
    //

    MachineCoordinateSystemType::
    MachineCoordinateSystemType ()
    : ::xml_schema::type (),
      CoordinateSystemId_ (this),
      MeasurementDeviceId_ (this)
    {
    }

    MachineCoordinateSystemType::
    MachineCoordinateSystemType (const CoordinateSystemId_type& CoordinateSystemId)
    : ::xml_schema::type (),
      CoordinateSystemId_ (CoordinateSystemId, this),
      MeasurementDeviceId_ (this)
    {
    }

    MachineCoordinateSystemType::
    MachineCoordinateSystemType (::std::unique_ptr< CoordinateSystemId_type > CoordinateSystemId)
    : ::xml_schema::type (),
      CoordinateSystemId_ (std::move (CoordinateSystemId), this),
      MeasurementDeviceId_ (this)
    {
    }

    MachineCoordinateSystemType::
    MachineCoordinateSystemType (const MachineCoordinateSystemType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      MeasurementDeviceId_ (x.MeasurementDeviceId_, f, this)
    {
    }

    MachineCoordinateSystemType::
    MachineCoordinateSystemType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateSystemId_ (this),
      MeasurementDeviceId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MachineCoordinateSystemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementDeviceId
        //
        if (n.name () == L"MeasurementDeviceId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceId_type > r (
            MeasurementDeviceId_traits::create (i, f, this));

          if (!this->MeasurementDeviceId_)
          {
            this->MeasurementDeviceId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoordinateSystemId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MachineCoordinateSystemType* MachineCoordinateSystemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MachineCoordinateSystemType (*this, f, c);
    }

    MachineCoordinateSystemType& MachineCoordinateSystemType::
    operator= (const MachineCoordinateSystemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->MeasurementDeviceId_ = x.MeasurementDeviceId_;
      }

      return *this;
    }

    MachineCoordinateSystemType::
    ~MachineCoordinateSystemType ()
    {
    }

    // CoordinateSystemListType
    //

    CoordinateSystemListType::
    CoordinateSystemListType ()
    : ::xml_schema::type (),
      CoordinateSystem_ (this),
      n_ (this)
    {
    }

    CoordinateSystemListType::
    CoordinateSystemListType (const n_type& n)
    : ::xml_schema::type (),
      CoordinateSystem_ (this),
      n_ (n, this)
    {
    }

    CoordinateSystemListType::
    CoordinateSystemListType (const CoordinateSystemListType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateSystem_ (x.CoordinateSystem_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CoordinateSystemListType::
    CoordinateSystemListType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateSystem_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateSystemListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoordinateSystem
        //
        if (n.name () == L"CoordinateSystem" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystem_type > r (
            CoordinateSystem_traits::create (i, f, this));

          this->CoordinateSystem_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CoordinateSystemListType* CoordinateSystemListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemListType (*this, f, c);
    }

    CoordinateSystemListType& CoordinateSystemListType::
    operator= (const CoordinateSystemListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateSystem_ = x.CoordinateSystem_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CoordinateSystemListType::
    ~CoordinateSystemListType ()
    {
    }

    // CoordinateSystemsType
    //

    CoordinateSystemsType::
    CoordinateSystemsType ()
    : ::xml_schema::type (),
      CoordinateSystemDefinitions_ (this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystem_ (this)
    {
    }

    CoordinateSystemsType::
    CoordinateSystemsType (const CoordinateSystemDefinitions_type& CoordinateSystemDefinitions)
    : ::xml_schema::type (),
      CoordinateSystemDefinitions_ (CoordinateSystemDefinitions, this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystem_ (this)
    {
    }

    CoordinateSystemsType::
    CoordinateSystemsType (::std::unique_ptr< CoordinateSystemDefinitions_type > CoordinateSystemDefinitions)
    : ::xml_schema::type (),
      CoordinateSystemDefinitions_ (std::move (CoordinateSystemDefinitions), this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystem_ (this)
    {
    }

    CoordinateSystemsType::
    CoordinateSystemsType (const CoordinateSystemsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateSystemDefinitions_ (x.CoordinateSystemDefinitions_, f, this),
      CommonCoordinateSystemId_ (x.CommonCoordinateSystemId_, f, this),
      MachineCoordinateSystem_ (x.MachineCoordinateSystem_, f, this)
    {
    }

    CoordinateSystemsType::
    CoordinateSystemsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateSystemDefinitions_ (this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystem_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoordinateSystemDefinitions
        //
        if (n.name () == L"CoordinateSystemDefinitions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemDefinitions_type > r (
            CoordinateSystemDefinitions_traits::create (i, f, this));

          if (!CoordinateSystemDefinitions_.present ())
          {
            this->CoordinateSystemDefinitions_.set (::std::move (r));
            continue;
          }
        }

        // CommonCoordinateSystemId
        //
        if (n.name () == L"CommonCoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CommonCoordinateSystemId_type > r (
            CommonCoordinateSystemId_traits::create (i, f, this));

          if (!this->CommonCoordinateSystemId_)
          {
            this->CommonCoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // MachineCoordinateSystem
        //
        if (n.name () == L"MachineCoordinateSystem" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MachineCoordinateSystem_type > r (
            MachineCoordinateSystem_traits::create (i, f, this));

          this->MachineCoordinateSystem_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!CoordinateSystemDefinitions_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoordinateSystemDefinitions",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CoordinateSystemsType* CoordinateSystemsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemsType (*this, f, c);
    }

    CoordinateSystemsType& CoordinateSystemsType::
    operator= (const CoordinateSystemsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateSystemDefinitions_ = x.CoordinateSystemDefinitions_;
        this->CommonCoordinateSystemId_ = x.CommonCoordinateSystemId_;
        this->MachineCoordinateSystem_ = x.MachineCoordinateSystem_;
      }

      return *this;
    }

    CoordinateSystemsType::
    ~CoordinateSystemsType ()
    {
    }

    // CoordinateSystemType
    //

    CoordinateSystemType::
    CoordinateSystemType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Name_ (this),
      NominalTransform_ (this),
      InternalCADCoordinateSystemId_ (this),
      ExternalCADCoordinateSystemId_ (this),
      AlignmentOperations_ (this),
      SequenceNumber_ (this),
      id_ (this)
    {
    }

    CoordinateSystemType::
    CoordinateSystemType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Name_ (this),
      NominalTransform_ (this),
      InternalCADCoordinateSystemId_ (this),
      ExternalCADCoordinateSystemId_ (this),
      AlignmentOperations_ (this),
      SequenceNumber_ (this),
      id_ (id, this)
    {
    }

    CoordinateSystemType::
    CoordinateSystemType (const CoordinateSystemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      NominalTransform_ (x.NominalTransform_, f, this),
      InternalCADCoordinateSystemId_ (x.InternalCADCoordinateSystemId_, f, this),
      ExternalCADCoordinateSystemId_ (x.ExternalCADCoordinateSystemId_, f, this),
      AlignmentOperations_ (x.AlignmentOperations_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      id_ (x.id_, f, this)
    {
    }

    CoordinateSystemType::
    CoordinateSystemType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Name_ (this),
      NominalTransform_ (this),
      InternalCADCoordinateSystemId_ (this),
      ExternalCADCoordinateSystemId_ (this),
      AlignmentOperations_ (this),
      SequenceNumber_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateSystemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // NominalTransform
        //
        if (n.name () == L"NominalTransform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalTransform_type > r (
            NominalTransform_traits::create (i, f, this));

          if (!this->NominalTransform_)
          {
            this->NominalTransform_.set (::std::move (r));
            continue;
          }
        }

        // InternalCADCoordinateSystemId
        //
        if (n.name () == L"InternalCADCoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalCADCoordinateSystemId_type > r (
            InternalCADCoordinateSystemId_traits::create (i, f, this));

          if (!this->InternalCADCoordinateSystemId_)
          {
            this->InternalCADCoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // ExternalCADCoordinateSystemId
        //
        if (n.name () == L"ExternalCADCoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalCADCoordinateSystemId_type > r (
            ExternalCADCoordinateSystemId_traits::create (i, f, this));

          if (!this->ExternalCADCoordinateSystemId_)
          {
            this->ExternalCADCoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // AlignmentOperations
        //
        if (n.name () == L"AlignmentOperations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AlignmentOperations_type > r (
            AlignmentOperations_traits::create (i, f, this));

          if (!this->AlignmentOperations_)
          {
            this->AlignmentOperations_.set (::std::move (r));
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!this->SequenceNumber_)
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    CoordinateSystemType* CoordinateSystemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemType (*this, f, c);
    }

    CoordinateSystemType& CoordinateSystemType::
    operator= (const CoordinateSystemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Name_ = x.Name_;
        this->NominalTransform_ = x.NominalTransform_;
        this->InternalCADCoordinateSystemId_ = x.InternalCADCoordinateSystemId_;
        this->ExternalCADCoordinateSystemId_ = x.ExternalCADCoordinateSystemId_;
        this->AlignmentOperations_ = x.AlignmentOperations_;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->id_ = x.id_;
      }

      return *this;
    }

    CoordinateSystemType::
    ~CoordinateSystemType ()
    {
    }

    // CoordinateSystemActualTransformAssociationType
    //

    CoordinateSystemActualTransformAssociationType::
    CoordinateSystemActualTransformAssociationType ()
    : ::xml_schema::type (),
      ActualTransformId_ (this),
      CoordinateSystemId_ (this)
    {
    }

    CoordinateSystemActualTransformAssociationType::
    CoordinateSystemActualTransformAssociationType (const ActualTransformId_type& ActualTransformId,
                                                    const CoordinateSystemId_type& CoordinateSystemId)
    : ::xml_schema::type (),
      ActualTransformId_ (ActualTransformId, this),
      CoordinateSystemId_ (CoordinateSystemId, this)
    {
    }

    CoordinateSystemActualTransformAssociationType::
    CoordinateSystemActualTransformAssociationType (::std::unique_ptr< ActualTransformId_type > ActualTransformId,
                                                    ::std::unique_ptr< CoordinateSystemId_type > CoordinateSystemId)
    : ::xml_schema::type (),
      ActualTransformId_ (std::move (ActualTransformId), this),
      CoordinateSystemId_ (std::move (CoordinateSystemId), this)
    {
    }

    CoordinateSystemActualTransformAssociationType::
    CoordinateSystemActualTransformAssociationType (const CoordinateSystemActualTransformAssociationType& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ActualTransformId_ (x.ActualTransformId_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this)
    {
    }

    CoordinateSystemActualTransformAssociationType::
    CoordinateSystemActualTransformAssociationType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ActualTransformId_ (this),
      CoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemActualTransformAssociationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ActualTransformId
        //
        if (n.name () == L"ActualTransformId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActualTransformId_type > r (
            ActualTransformId_traits::create (i, f, this));

          if (!ActualTransformId_.present ())
          {
            this->ActualTransformId_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ActualTransformId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ActualTransformId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoordinateSystemId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CoordinateSystemActualTransformAssociationType* CoordinateSystemActualTransformAssociationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemActualTransformAssociationType (*this, f, c);
    }

    CoordinateSystemActualTransformAssociationType& CoordinateSystemActualTransformAssociationType::
    operator= (const CoordinateSystemActualTransformAssociationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ActualTransformId_ = x.ActualTransformId_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
      }

      return *this;
    }

    CoordinateSystemActualTransformAssociationType::
    ~CoordinateSystemActualTransformAssociationType ()
    {
    }

    // CoordinateSystemActualTransformAssociationsType
    //

    CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociationsType ()
    : ::xml_schema::type (),
      CoordinateSystemActualTransformAssociation_ (this),
      n_ (this)
    {
    }

    CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociationsType (const n_type& n)
    : ::xml_schema::type (),
      CoordinateSystemActualTransformAssociation_ (this),
      n_ (n, this)
    {
    }

    CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociationsType (const CoordinateSystemActualTransformAssociationsType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateSystemActualTransformAssociation_ (x.CoordinateSystemActualTransformAssociation_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CoordinateSystemActualTransformAssociationsType::
    CoordinateSystemActualTransformAssociationsType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateSystemActualTransformAssociation_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateSystemActualTransformAssociationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoordinateSystemActualTransformAssociation
        //
        if (n.name () == L"CoordinateSystemActualTransformAssociation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemActualTransformAssociation_type > r (
            CoordinateSystemActualTransformAssociation_traits::create (i, f, this));

          this->CoordinateSystemActualTransformAssociation_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CoordinateSystemActualTransformAssociationsType* CoordinateSystemActualTransformAssociationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemActualTransformAssociationsType (*this, f, c);
    }

    CoordinateSystemActualTransformAssociationsType& CoordinateSystemActualTransformAssociationsType::
    operator= (const CoordinateSystemActualTransformAssociationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateSystemActualTransformAssociation_ = x.CoordinateSystemActualTransformAssociation_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CoordinateSystemActualTransformAssociationsType::
    ~CoordinateSystemActualTransformAssociationsType ()
    {
    }

    // ThreadSpecificationDetailedBaseType
    //

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType ()
    : ::xml_schema::type (),
      Diameter_ (this),
      ThreadSeries_ (this),
      ThreadToleranceClass_ (this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      Attributes_ (this),
      id_ (this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const Diameter_type& Diameter,
                                         const ThreadSeries_type& ThreadSeries,
                                         const ThreadToleranceClass_type& ThreadToleranceClass,
                                         const id_type& id)
    : ::xml_schema::type (),
      Diameter_ (Diameter, this),
      ThreadSeries_ (ThreadSeries, this),
      ThreadToleranceClass_ (ThreadToleranceClass, this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (::std::unique_ptr< Diameter_type > Diameter,
                                         ::std::unique_ptr< ThreadSeries_type > ThreadSeries,
                                         ::std::unique_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                         const id_type& id)
    : ::xml_schema::type (),
      Diameter_ (std::move (Diameter), this),
      ThreadSeries_ (std::move (ThreadSeries), this),
      ThreadToleranceClass_ (std::move (ThreadToleranceClass), this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const ThreadSpecificationDetailedBaseType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      ThreadSeries_ (x.ThreadSeries_, f, this),
      ThreadToleranceClass_ (x.ThreadToleranceClass_, f, this),
      CrestDiameterToleranceClass_ (x.CrestDiameterToleranceClass_, f, this),
      LeftHanded_ (x.LeftHanded_, f, this),
      ModifiedThread_ (x.ModifiedThread_, f, this),
      ThreadLengthEngagement_ (x.ThreadLengthEngagement_, f, this),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      ThreadSeries_ (this),
      ThreadToleranceClass_ (this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationDetailedBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // ThreadSeries
        //
        if (n.name () == L"ThreadSeries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadSeries_type > r (
            ThreadSeries_traits::create (i, f, this));

          if (!ThreadSeries_.present ())
          {
            this->ThreadSeries_.set (::std::move (r));
            continue;
          }
        }

        // ThreadToleranceClass
        //
        if (n.name () == L"ThreadToleranceClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadToleranceClass_type > r (
            ThreadToleranceClass_traits::create (i, f, this));

          if (!ThreadToleranceClass_.present ())
          {
            this->ThreadToleranceClass_.set (::std::move (r));
            continue;
          }
        }

        // CrestDiameterToleranceClass
        //
        if (n.name () == L"CrestDiameterToleranceClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CrestDiameterToleranceClass_type > r (
            CrestDiameterToleranceClass_traits::create (i, f, this));

          if (!this->CrestDiameterToleranceClass_)
          {
            this->CrestDiameterToleranceClass_.set (::std::move (r));
            continue;
          }
        }

        // LeftHanded
        //
        if (n.name () == L"LeftHanded" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->LeftHanded_)
          {
            this->LeftHanded_.set (LeftHanded_traits::create (i, f, this));
            continue;
          }
        }

        // ModifiedThread
        //
        if (n.name () == L"ModifiedThread" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ModifiedThread_)
          {
            this->ModifiedThread_.set (ModifiedThread_traits::create (i, f, this));
            continue;
          }
        }

        // ThreadLengthEngagement
        //
        if (n.name () == L"ThreadLengthEngagement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadLengthEngagement_type > r (
            ThreadLengthEngagement_traits::create (i, f, this));

          if (!this->ThreadLengthEngagement_)
          {
            this->ThreadLengthEngagement_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThreadSeries_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadSeries",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThreadToleranceClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadToleranceClass",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    ThreadSpecificationDetailedBaseType& ThreadSpecificationDetailedBaseType::
    operator= (const ThreadSpecificationDetailedBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->ThreadSeries_ = x.ThreadSeries_;
        this->ThreadToleranceClass_ = x.ThreadToleranceClass_;
        this->CrestDiameterToleranceClass_ = x.CrestDiameterToleranceClass_;
        this->LeftHanded_ = x.LeftHanded_;
        this->ModifiedThread_ = x.ModifiedThread_;
        this->ThreadLengthEngagement_ = x.ThreadLengthEngagement_;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ThreadSpecificationDetailedBaseType::
    ~ThreadSpecificationDetailedBaseType ()
    {
    }

    // SingleLeadThreadSpecificationType
    //

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType ()
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (),
      ThreadDensity_ (this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const Diameter_type& Diameter,
                                       const ThreadSeries_type& ThreadSeries,
                                       const ThreadToleranceClass_type& ThreadToleranceClass,
                                       const id_type& id,
                                       const ThreadDensity_type& ThreadDensity)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (Diameter,
                                                         ThreadSeries,
                                                         ThreadToleranceClass,
                                                         id),
      ThreadDensity_ (ThreadDensity, this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (::std::unique_ptr< Diameter_type > Diameter,
                                       ::std::unique_ptr< ThreadSeries_type > ThreadSeries,
                                       ::std::unique_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                       const id_type& id,
                                       ::std::unique_ptr< ThreadDensity_type > ThreadDensity)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (std::move (Diameter),
                                                         std::move (ThreadSeries),
                                                         std::move (ThreadToleranceClass),
                                                         id),
      ThreadDensity_ (std::move (ThreadDensity), this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const SingleLeadThreadSpecificationType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (x, f, c),
      ThreadDensity_ (x.ThreadDensity_, f, this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (e, f | ::xml_schema::flags::base, c),
      ThreadDensity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SingleLeadThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ThreadSpecificationDetailedBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadDensity
        //
        if (n.name () == L"ThreadDensity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadDensity_type > r (
            ThreadDensity_traits::create (i, f, this));

          if (!ThreadDensity_.present ())
          {
            this->ThreadDensity_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ThreadDensity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadDensity",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SingleLeadThreadSpecificationType* SingleLeadThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SingleLeadThreadSpecificationType (*this, f, c);
    }

    SingleLeadThreadSpecificationType& SingleLeadThreadSpecificationType::
    operator= (const SingleLeadThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ThreadSpecificationDetailedBaseType& > (*this) = x;
        this->ThreadDensity_ = x.ThreadDensity_;
      }

      return *this;
    }

    SingleLeadThreadSpecificationType::
    ~SingleLeadThreadSpecificationType ()
    {
    }

    // MultiLeadThreadSpecificationType
    //

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType ()
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (),
      ThreadPitch_ (this),
      ThreadLeadDistance_ (this),
      ThreadLeadStarts_ (this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const Diameter_type& Diameter,
                                      const ThreadSeries_type& ThreadSeries,
                                      const ThreadToleranceClass_type& ThreadToleranceClass,
                                      const id_type& id,
                                      const ThreadPitch_type& ThreadPitch,
                                      const ThreadLeadDistance_type& ThreadLeadDistance,
                                      const ThreadLeadStarts_type& ThreadLeadStarts)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (Diameter,
                                                         ThreadSeries,
                                                         ThreadToleranceClass,
                                                         id),
      ThreadPitch_ (ThreadPitch, this),
      ThreadLeadDistance_ (ThreadLeadDistance, this),
      ThreadLeadStarts_ (ThreadLeadStarts, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (::std::unique_ptr< Diameter_type > Diameter,
                                      ::std::unique_ptr< ThreadSeries_type > ThreadSeries,
                                      ::std::unique_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                      const id_type& id,
                                      ::std::unique_ptr< ThreadPitch_type > ThreadPitch,
                                      ::std::unique_ptr< ThreadLeadDistance_type > ThreadLeadDistance,
                                      const ThreadLeadStarts_type& ThreadLeadStarts)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (std::move (Diameter),
                                                         std::move (ThreadSeries),
                                                         std::move (ThreadToleranceClass),
                                                         id),
      ThreadPitch_ (std::move (ThreadPitch), this),
      ThreadLeadDistance_ (std::move (ThreadLeadDistance), this),
      ThreadLeadStarts_ (ThreadLeadStarts, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const MultiLeadThreadSpecificationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (x, f, c),
      ThreadPitch_ (x.ThreadPitch_, f, this),
      ThreadLeadDistance_ (x.ThreadLeadDistance_, f, this),
      ThreadLeadStarts_ (x.ThreadLeadStarts_, f, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ThreadSpecificationDetailedBaseType (e, f | ::xml_schema::flags::base, c),
      ThreadPitch_ (this),
      ThreadLeadDistance_ (this),
      ThreadLeadStarts_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MultiLeadThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ThreadSpecificationDetailedBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadPitch
        //
        if (n.name () == L"ThreadPitch" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadPitch_type > r (
            ThreadPitch_traits::create (i, f, this));

          if (!ThreadPitch_.present ())
          {
            this->ThreadPitch_.set (::std::move (r));
            continue;
          }
        }

        // ThreadLeadDistance
        //
        if (n.name () == L"ThreadLeadDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadLeadDistance_type > r (
            ThreadLeadDistance_traits::create (i, f, this));

          if (!ThreadLeadDistance_.present ())
          {
            this->ThreadLeadDistance_.set (::std::move (r));
            continue;
          }
        }

        // ThreadLeadStarts
        //
        if (n.name () == L"ThreadLeadStarts" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadLeadStarts_type > r (
            ThreadLeadStarts_traits::create (i, f, this));

          if (!ThreadLeadStarts_.present ())
          {
            this->ThreadLeadStarts_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ThreadPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadPitch",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThreadLeadDistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadLeadDistance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThreadLeadStarts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadLeadStarts",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MultiLeadThreadSpecificationType* MultiLeadThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MultiLeadThreadSpecificationType (*this, f, c);
    }

    MultiLeadThreadSpecificationType& MultiLeadThreadSpecificationType::
    operator= (const MultiLeadThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ThreadSpecificationDetailedBaseType& > (*this) = x;
        this->ThreadPitch_ = x.ThreadPitch_;
        this->ThreadLeadDistance_ = x.ThreadLeadDistance_;
        this->ThreadLeadStarts_ = x.ThreadLeadStarts_;
      }

      return *this;
    }

    MultiLeadThreadSpecificationType::
    ~MultiLeadThreadSpecificationType ()
    {
    }

    // ThreadSpecificationType
    //

    ThreadSpecificationType::
    ThreadSpecificationType ()
    : ::xml_schema::type (),
      SingleLeadSpecification_ (this),
      MultiLeadSpecification_ (this),
      TextThreadSpecification_ (this)
    {
    }

    ThreadSpecificationType::
    ThreadSpecificationType (const ThreadSpecificationType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SingleLeadSpecification_ (x.SingleLeadSpecification_, f, this),
      MultiLeadSpecification_ (x.MultiLeadSpecification_, f, this),
      TextThreadSpecification_ (x.TextThreadSpecification_, f, this)
    {
    }

    ThreadSpecificationType::
    ThreadSpecificationType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SingleLeadSpecification_ (this),
      MultiLeadSpecification_ (this),
      TextThreadSpecification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SingleLeadSpecification
        //
        if (n.name () == L"SingleLeadSpecification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SingleLeadSpecification_type > r (
            SingleLeadSpecification_traits::create (i, f, this));

          if (!this->SingleLeadSpecification_)
          {
            this->SingleLeadSpecification_.set (::std::move (r));
            continue;
          }
        }

        // MultiLeadSpecification
        //
        if (n.name () == L"MultiLeadSpecification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MultiLeadSpecification_type > r (
            MultiLeadSpecification_traits::create (i, f, this));

          if (!this->MultiLeadSpecification_)
          {
            this->MultiLeadSpecification_.set (::std::move (r));
            continue;
          }
        }

        // TextThreadSpecification
        //
        if (n.name () == L"TextThreadSpecification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TextThreadSpecification_type > r (
            TextThreadSpecification_traits::create (i, f, this));

          if (!this->TextThreadSpecification_)
          {
            this->TextThreadSpecification_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadSpecificationType* ThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSpecificationType (*this, f, c);
    }

    ThreadSpecificationType& ThreadSpecificationType::
    operator= (const ThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SingleLeadSpecification_ = x.SingleLeadSpecification_;
        this->MultiLeadSpecification_ = x.MultiLeadSpecification_;
        this->TextThreadSpecification_ = x.TextThreadSpecification_;
      }

      return *this;
    }

    ThreadSpecificationType::
    ~ThreadSpecificationType ()
    {
    }

    // TextThreadSpecificationType
    //

    TextThreadSpecificationType::
    TextThreadSpecificationType ()
    : ::xml_schema::type (),
      TextSpecification_ (this),
      id_ (this)
    {
    }

    TextThreadSpecificationType::
    TextThreadSpecificationType (const TextSpecification_type& TextSpecification,
                                 const id_type& id)
    : ::xml_schema::type (),
      TextSpecification_ (TextSpecification, this),
      id_ (id, this)
    {
    }

    TextThreadSpecificationType::
    TextThreadSpecificationType (const TextThreadSpecificationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TextSpecification_ (x.TextSpecification_, f, this),
      id_ (x.id_, f, this)
    {
    }

    TextThreadSpecificationType::
    TextThreadSpecificationType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TextSpecification_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TextSpecification
        //
        if (n.name () == L"TextSpecification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TextSpecification_type > r (
            TextSpecification_traits::create (i, f, this));

          if (!TextSpecification_.present ())
          {
            this->TextSpecification_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TextSpecification_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TextSpecification",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    TextThreadSpecificationType* TextThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextThreadSpecificationType (*this, f, c);
    }

    TextThreadSpecificationType& TextThreadSpecificationType::
    operator= (const TextThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TextSpecification_ = x.TextSpecification_;
        this->id_ = x.id_;
      }

      return *this;
    }

    TextThreadSpecificationType::
    ~TextThreadSpecificationType ()
    {
    }

    // ThreadSpecificationsType
    //

    ThreadSpecificationsType::
    ThreadSpecificationsType ()
    : ::xml_schema::type (),
      ThreadSpecification_ (this),
      n_ (this)
    {
    }

    ThreadSpecificationsType::
    ThreadSpecificationsType (const n_type& n)
    : ::xml_schema::type (),
      ThreadSpecification_ (this),
      n_ (n, this)
    {
    }

    ThreadSpecificationsType::
    ThreadSpecificationsType (const ThreadSpecificationsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadSpecification_ (x.ThreadSpecification_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ThreadSpecificationsType::
    ThreadSpecificationsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadSpecification_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadSpecification
        //
        if (n.name () == L"ThreadSpecification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadSpecification_type > r (
            ThreadSpecification_traits::create (i, f, this));

          this->ThreadSpecification_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ThreadSpecificationsType* ThreadSpecificationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSpecificationsType (*this, f, c);
    }

    ThreadSpecificationsType& ThreadSpecificationsType::
    operator= (const ThreadSpecificationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadSpecification_ = x.ThreadSpecification_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ThreadSpecificationsType::
    ~ThreadSpecificationsType ()
    {
    }

    // ToleranceZonePerUnitAreaType
    //

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType ()
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (::std::unique_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (std::move (ToleranceValuePerUnit), this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const ToleranceZonePerUnitAreaType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      RectangularUnitArea_ (x.RectangularUnitArea_, f, this),
      CircularUnitArea_ (x.CircularUnitArea_, f, this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == L"ToleranceValuePerUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (::std::move (r));
            continue;
          }
        }

        // RectangularUnitArea
        //
        if (n.name () == L"RectangularUnitArea" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RectangularUnitArea_type > r (
            RectangularUnitArea_traits::create (i, f, this));

          if (!this->RectangularUnitArea_)
          {
            this->RectangularUnitArea_.set (::std::move (r));
            continue;
          }
        }

        // CircularUnitArea
        //
        if (n.name () == L"CircularUnitArea" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CircularUnitArea_type > r (
            CircularUnitArea_traits::create (i, f, this));

          if (!this->CircularUnitArea_)
          {
            this->CircularUnitArea_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ToleranceValuePerUnit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToleranceZonePerUnitAreaType* ToleranceZonePerUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitAreaType (*this, f, c);
    }

    ToleranceZonePerUnitAreaType& ToleranceZonePerUnitAreaType::
    operator= (const ToleranceZonePerUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->RectangularUnitArea_ = x.RectangularUnitArea_;
        this->CircularUnitArea_ = x.CircularUnitArea_;
      }

      return *this;
    }

    ToleranceZonePerUnitAreaType::
    ~ToleranceZonePerUnitAreaType ()
    {
    }

    // ToleranceZonePerUnitLengthType
    //

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType ()
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (this),
      UnitLength_ (this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                    const UnitLength_type& UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (::std::unique_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                    ::std::unique_ptr< UnitLength_type > UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (std::move (ToleranceValuePerUnit), this),
      UnitLength_ (std::move (UnitLength), this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const ToleranceZonePerUnitLengthType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitLength_ (x.UnitLength_, f, this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitLengthType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == L"ToleranceValuePerUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (::std::move (r));
            continue;
          }
        }

        // UnitLength
        //
        if (n.name () == L"UnitLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitLength_type > r (
            UnitLength_traits::create (i, f, this));

          if (!UnitLength_.present ())
          {
            this->UnitLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ToleranceValuePerUnit",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!UnitLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitLength",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToleranceZonePerUnitLengthType* ToleranceZonePerUnitLengthType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitLengthType (*this, f, c);
    }

    ToleranceZonePerUnitLengthType& ToleranceZonePerUnitLengthType::
    operator= (const ToleranceZonePerUnitLengthType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitLength_ = x.UnitLength_;
      }

      return *this;
    }

    ToleranceZonePerUnitLengthType::
    ~ToleranceZonePerUnitLengthType ()
    {
    }

    // ToleranceZonePerUnitAngleType
    //

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType ()
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                   const UnitAngle_type& UnitAngle)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (::std::unique_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                   ::std::unique_ptr< UnitAngle_type > UnitAngle)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (std::move (ToleranceValuePerUnit), this),
      UnitAngle_ (std::move (UnitAngle), this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const ToleranceZonePerUnitAngleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitAngle_ (x.UnitAngle_, f, this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitAngleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == L"ToleranceValuePerUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (::std::move (r));
            continue;
          }
        }

        // UnitAngle
        //
        if (n.name () == L"UnitAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitAngle_type > r (
            UnitAngle_traits::create (i, f, this));

          if (!UnitAngle_.present ())
          {
            this->UnitAngle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ToleranceValuePerUnit",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!UnitAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitAngle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToleranceZonePerUnitAngleType* ToleranceZonePerUnitAngleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitAngleType (*this, f, c);
    }

    ToleranceZonePerUnitAngleType& ToleranceZonePerUnitAngleType::
    operator= (const ToleranceZonePerUnitAngleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitAngle_ = x.UnitAngle_;
      }

      return *this;
    }

    ToleranceZonePerUnitAngleType::
    ~ToleranceZonePerUnitAngleType ()
    {
    }

    // ToleranceZonePerUnitPolarAreaType
    //

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType ()
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this),
      UnitLength_ (this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                       const UnitAngle_type& UnitAngle,
                                       const UnitLength_type& UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (::std::unique_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                       ::std::unique_ptr< UnitAngle_type > UnitAngle,
                                       ::std::unique_ptr< UnitLength_type > UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (std::move (ToleranceValuePerUnit), this),
      UnitAngle_ (std::move (UnitAngle), this),
      UnitLength_ (std::move (UnitLength), this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const ToleranceZonePerUnitPolarAreaType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitAngle_ (x.UnitAngle_, f, this),
      UnitLength_ (x.UnitLength_, f, this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this),
      UnitLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitPolarAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == L"ToleranceValuePerUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (::std::move (r));
            continue;
          }
        }

        // UnitAngle
        //
        if (n.name () == L"UnitAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitAngle_type > r (
            UnitAngle_traits::create (i, f, this));

          if (!UnitAngle_.present ())
          {
            this->UnitAngle_.set (::std::move (r));
            continue;
          }
        }

        // UnitLength
        //
        if (n.name () == L"UnitLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitLength_type > r (
            UnitLength_traits::create (i, f, this));

          if (!UnitLength_.present ())
          {
            this->UnitLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ToleranceValuePerUnit",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!UnitAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!UnitLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitLength",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToleranceZonePerUnitPolarAreaType* ToleranceZonePerUnitPolarAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitPolarAreaType (*this, f, c);
    }

    ToleranceZonePerUnitPolarAreaType& ToleranceZonePerUnitPolarAreaType::
    operator= (const ToleranceZonePerUnitPolarAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitAngle_ = x.UnitAngle_;
        this->UnitLength_ = x.UnitLength_;
      }

      return *this;
    }

    ToleranceZonePerUnitPolarAreaType::
    ~ToleranceZonePerUnitPolarAreaType ()
    {
    }

    // DatumReferenceFramesType
    //

    DatumReferenceFramesType::
    DatumReferenceFramesType ()
    : ::xml_schema::type (),
      DatumReferenceFrame_ (this),
      n_ (this)
    {
    }

    DatumReferenceFramesType::
    DatumReferenceFramesType (const n_type& n)
    : ::xml_schema::type (),
      DatumReferenceFrame_ (this),
      n_ (n, this)
    {
    }

    DatumReferenceFramesType::
    DatumReferenceFramesType (const DatumReferenceFramesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumReferenceFrame_ (x.DatumReferenceFrame_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DatumReferenceFramesType::
    DatumReferenceFramesType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumReferenceFrame_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumReferenceFramesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumReferenceFrame
        //
        if (n.name () == L"DatumReferenceFrame" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumReferenceFrame_type > r (
            DatumReferenceFrame_traits::create (i, f, this));

          this->DatumReferenceFrame_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DatumReferenceFramesType* DatumReferenceFramesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumReferenceFramesType (*this, f, c);
    }

    DatumReferenceFramesType& DatumReferenceFramesType::
    operator= (const DatumReferenceFramesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumReferenceFrame_ = x.DatumReferenceFrame_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DatumReferenceFramesType::
    ~DatumReferenceFramesType ()
    {
    }

    // EventBaseType
    //

    EventBaseType::
    EventBaseType ()
    : ::xml_schema::type (),
      Description_ (this),
      id_ (this)
    {
    }

    EventBaseType::
    EventBaseType (const Description_type& Description,
                   const id_type& id)
    : ::xml_schema::type (),
      Description_ (Description, this),
      id_ (id, this)
    {
    }

    EventBaseType::
    EventBaseType (const EventBaseType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Description_ (x.Description_, f, this),
      id_ (x.id_, f, this)
    {
    }

    EventBaseType::
    EventBaseType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Description_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EventBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Description",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    EventBaseType& EventBaseType::
    operator= (const EventBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Description_ = x.Description_;
        this->id_ = x.id_;
      }

      return *this;
    }

    EventBaseType::
    ~EventBaseType ()
    {
    }

    // NotableEventType
    //

    NotableEventType::
    NotableEventType ()
    : ::xsd::qif30::EventBaseType (),
      Active_ (this)
    {
    }

    NotableEventType::
    NotableEventType (const Description_type& Description,
                      const id_type& id,
                      const Active_type& Active)
    : ::xsd::qif30::EventBaseType (Description,
                                   id),
      Active_ (Active, this)
    {
    }

    NotableEventType::
    NotableEventType (const NotableEventType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::EventBaseType (x, f, c),
      Active_ (x.Active_, f, this)
    {
    }

    NotableEventType::
    NotableEventType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::EventBaseType (e, f | ::xml_schema::flags::base, c),
      Active_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotableEventType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::EventBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Active
        //
        if (n.name () == L"Active" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Active_.present ())
          {
            this->Active_.set (Active_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Active_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Active",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NotableEventType* NotableEventType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotableEventType (*this, f, c);
    }

    NotableEventType& NotableEventType::
    operator= (const NotableEventType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EventBaseType& > (*this) = x;
        this->Active_ = x.Active_;
      }

      return *this;
    }

    NotableEventType::
    ~NotableEventType ()
    {
    }

    // NotableEventsType
    //

    NotableEventsType::
    NotableEventsType ()
    : ::xml_schema::type (),
      NotableEvent_ (this),
      n_ (this)
    {
    }

    NotableEventsType::
    NotableEventsType (const n_type& n)
    : ::xml_schema::type (),
      NotableEvent_ (this),
      n_ (n, this)
    {
    }

    NotableEventsType::
    NotableEventsType (const NotableEventsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NotableEvent_ (x.NotableEvent_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NotableEventsType::
    NotableEventsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NotableEvent_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotableEventsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NotableEvent
        //
        if (n.name () == L"NotableEvent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NotableEvent_type > r (
            NotableEvent_traits::create (i, f, this));

          this->NotableEvent_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NotableEventsType* NotableEventsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotableEventsType (*this, f, c);
    }

    NotableEventsType& NotableEventsType::
    operator= (const NotableEventsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NotableEvent_ = x.NotableEvent_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NotableEventsType::
    ~NotableEventsType ()
    {
    }

    // NotedEventType
    //

    NotedEventType::
    NotedEventType ()
    : ::xsd::qif30::EventBaseType (),
      SequenceNumber_ (this),
      TimeOccurred_ (this),
      NotableEventId_ (this)
    {
    }

    NotedEventType::
    NotedEventType (const Description_type& Description,
                    const id_type& id,
                    const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif30::EventBaseType (Description,
                                   id),
      SequenceNumber_ (SequenceNumber, this),
      TimeOccurred_ (this),
      NotableEventId_ (this)
    {
    }

    NotedEventType::
    NotedEventType (const NotedEventType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::EventBaseType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      TimeOccurred_ (x.TimeOccurred_, f, this),
      NotableEventId_ (x.NotableEventId_, f, this)
    {
    }

    NotedEventType::
    NotedEventType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::EventBaseType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this),
      TimeOccurred_ (this),
      NotableEventId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotedEventType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::EventBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        // TimeOccurred
        //
        if (n.name () == L"TimeOccurred" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeOccurred_type > r (
            TimeOccurred_traits::create (i, f, this));

          if (!this->TimeOccurred_)
          {
            this->TimeOccurred_.set (::std::move (r));
            continue;
          }
        }

        // NotableEventId
        //
        if (n.name () == L"NotableEventId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NotableEventId_type > r (
            NotableEventId_traits::create (i, f, this));

          if (!this->NotableEventId_)
          {
            this->NotableEventId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NotedEventType* NotedEventType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotedEventType (*this, f, c);
    }

    NotedEventType& NotedEventType::
    operator= (const NotedEventType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EventBaseType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->TimeOccurred_ = x.TimeOccurred_;
        this->NotableEventId_ = x.NotableEventId_;
      }

      return *this;
    }

    NotedEventType::
    ~NotedEventType ()
    {
    }

    // NotedEventsType
    //

    NotedEventsType::
    NotedEventsType ()
    : ::xml_schema::type (),
      NotedEvent_ (this),
      n_ (this)
    {
    }

    NotedEventsType::
    NotedEventsType (const n_type& n)
    : ::xml_schema::type (),
      NotedEvent_ (this),
      n_ (n, this)
    {
    }

    NotedEventsType::
    NotedEventsType (const NotedEventsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NotedEvent_ (x.NotedEvent_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NotedEventsType::
    NotedEventsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NotedEvent_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotedEventsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NotedEvent
        //
        if (n.name () == L"NotedEvent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NotedEvent_type > r (
            NotedEvent_traits::create (i, f, this));

          this->NotedEvent_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NotedEventsType* NotedEventsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotedEventsType (*this, f, c);
    }

    NotedEventsType& NotedEventsType::
    operator= (const NotedEventsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NotedEvent_ = x.NotedEvent_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NotedEventsType::
    ~NotedEventsType ()
    {
    }

    // InspectionStatusEnumType
    //

    InspectionStatusEnumType::
    InspectionStatusEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType* InspectionStatusEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InspectionStatusEnumType (*this, f, c);
    }

    InspectionStatusEnumType::value InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_InspectionStatusEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_InspectionStatusEnumType_indexes_,
                        _xsd_InspectionStatusEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_InspectionStatusEnumType_indexes_ + 8 || _xsd_InspectionStatusEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_literals_[8] =
    {
      L"PASS",
      L"FAIL",
      L"REWORK",
      L"SYSERROR",
      L"UNKNOWN",
      L"NOT_CALCULATED",
      L"NOT_MEASURED",
      L"UNDEFINED"
    };

    const InspectionStatusEnumType::value InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_indexes_[8] =
    {
      ::xsd::qif30::InspectionStatusEnumType::FAIL,
      ::xsd::qif30::InspectionStatusEnumType::NOT_CALCULATED,
      ::xsd::qif30::InspectionStatusEnumType::NOT_MEASURED,
      ::xsd::qif30::InspectionStatusEnumType::PASS,
      ::xsd::qif30::InspectionStatusEnumType::REWORK,
      ::xsd::qif30::InspectionStatusEnumType::SYSERROR,
      ::xsd::qif30::InspectionStatusEnumType::UNDEFINED,
      ::xsd::qif30::InspectionStatusEnumType::UNKNOWN
    };

    // InspectionStatusType
    //

    InspectionStatusType::
    InspectionStatusType ()
    : ::xml_schema::type (),
      InspectionStatusEnum_ (this),
      OtherInspectionStatus_ (this)
    {
    }

    InspectionStatusType::
    InspectionStatusType (const InspectionStatusType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      InspectionStatusEnum_ (x.InspectionStatusEnum_, f, this),
      OtherInspectionStatus_ (x.OtherInspectionStatus_, f, this)
    {
    }

    InspectionStatusType::
    InspectionStatusType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      InspectionStatusEnum_ (this),
      OtherInspectionStatus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void InspectionStatusType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InspectionStatusEnum
        //
        if (n.name () == L"InspectionStatusEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InspectionStatusEnum_type > r (
            InspectionStatusEnum_traits::create (i, f, this));

          if (!this->InspectionStatusEnum_)
          {
            this->InspectionStatusEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherInspectionStatus
        //
        if (n.name () == L"OtherInspectionStatus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherInspectionStatus_type > r (
            OtherInspectionStatus_traits::create (i, f, this));

          if (!this->OtherInspectionStatus_)
          {
            this->OtherInspectionStatus_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    InspectionStatusType* InspectionStatusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InspectionStatusType (*this, f, c);
    }

    InspectionStatusType& InspectionStatusType::
    operator= (const InspectionStatusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->InspectionStatusEnum_ = x.InspectionStatusEnum_;
        this->OtherInspectionStatus_ = x.OtherInspectionStatus_;
      }

      return *this;
    }

    InspectionStatusType::
    ~InspectionStatusType ()
    {
    }

    // EntityExternalType
    //

    EntityExternalType::
    EntityExternalType ()
    : ::xml_schema::type (),
      EntityId_ (this),
      Name_ (this),
      Description_ (this),
      id_ (this)
    {
    }

    EntityExternalType::
    EntityExternalType (const EntityId_type& EntityId,
                        const id_type& id)
    : ::xml_schema::type (),
      EntityId_ (EntityId, this),
      Name_ (this),
      Description_ (this),
      id_ (id, this)
    {
    }

    EntityExternalType::
    EntityExternalType (const EntityExternalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EntityId_ (x.EntityId_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      id_ (x.id_, f, this)
    {
    }

    EntityExternalType::
    EntityExternalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EntityId_ (this),
      Name_ (this),
      Description_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EntityExternalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EntityId
        //
        if (n.name () == L"EntityId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EntityId_type > r (
            EntityId_traits::create (i, f, this));

          if (!EntityId_.present ())
          {
            this->EntityId_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!EntityId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EntityId",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    EntityExternalType* EntityExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EntityExternalType (*this, f, c);
    }

    EntityExternalType& EntityExternalType::
    operator= (const EntityExternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EntityId_ = x.EntityId_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->id_ = x.id_;
      }

      return *this;
    }

    EntityExternalType::
    ~EntityExternalType ()
    {
    }

    // EntitiesExternalType
    //

    EntitiesExternalType::
    EntitiesExternalType ()
    : ::xml_schema::type (),
      Entity_ (this),
      n_ (this)
    {
    }

    EntitiesExternalType::
    EntitiesExternalType (const n_type& n)
    : ::xml_schema::type (),
      Entity_ (this),
      n_ (n, this)
    {
    }

    EntitiesExternalType::
    EntitiesExternalType (const EntitiesExternalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Entity_ (x.Entity_, f, this),
      n_ (x.n_, f, this)
    {
    }

    EntitiesExternalType::
    EntitiesExternalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Entity_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EntitiesExternalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Entity
        //
        if (n.name () == L"Entity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Entity_type > r (
            Entity_traits::create (i, f, this));

          this->Entity_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    EntitiesExternalType* EntitiesExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EntitiesExternalType (*this, f, c);
    }

    EntitiesExternalType& EntitiesExternalType::
    operator= (const EntitiesExternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Entity_ = x.Entity_;
        this->n_ = x.n_;
      }

      return *this;
    }

    EntitiesExternalType::
    ~EntitiesExternalType ()
    {
    }

    // ZoneDataType
    //

    ZoneDataType::
    ZoneDataType ()
    : ::xml_schema::type (),
      FeatureItemId_ (this),
      Bonus_ (this),
      ReferenceLength_ (this)
    {
    }

    ZoneDataType::
    ZoneDataType (const FeatureItemId_type& FeatureItemId,
                  const Bonus_type& Bonus,
                  const ReferenceLength_type& ReferenceLength)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this),
      Bonus_ (Bonus, this),
      ReferenceLength_ (ReferenceLength, this)
    {
    }

    ZoneDataType::
    ZoneDataType (::std::unique_ptr< FeatureItemId_type > FeatureItemId,
                  ::std::unique_ptr< Bonus_type > Bonus,
                  ::std::unique_ptr< ReferenceLength_type > ReferenceLength)
    : ::xml_schema::type (),
      FeatureItemId_ (std::move (FeatureItemId), this),
      Bonus_ (std::move (Bonus), this),
      ReferenceLength_ (std::move (ReferenceLength), this)
    {
    }

    ZoneDataType::
    ZoneDataType (const ZoneDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      Bonus_ (x.Bonus_, f, this),
      ReferenceLength_ (x.ReferenceLength_, f, this)
    {
    }

    ZoneDataType::
    ZoneDataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (this),
      Bonus_ (this),
      ReferenceLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ZoneDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureItemId
        //
        if (n.name () == L"FeatureItemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (::std::move (r));
            continue;
          }
        }

        // Bonus
        //
        if (n.name () == L"Bonus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bonus_type > r (
            Bonus_traits::create (i, f, this));

          if (!Bonus_.present ())
          {
            this->Bonus_.set (::std::move (r));
            continue;
          }
        }

        // ReferenceLength
        //
        if (n.name () == L"ReferenceLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceLength_type > r (
            ReferenceLength_traits::create (i, f, this));

          if (!ReferenceLength_.present ())
          {
            this->ReferenceLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureItemId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Bonus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Bonus",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ReferenceLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferenceLength",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ZoneDataType* ZoneDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneDataType (*this, f, c);
    }

    ZoneDataType& ZoneDataType::
    operator= (const ZoneDataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItemId_ = x.FeatureItemId_;
        this->Bonus_ = x.Bonus_;
        this->ReferenceLength_ = x.ReferenceLength_;
      }

      return *this;
    }

    ZoneDataType::
    ~ZoneDataType ()
    {
    }

    // ZoneDataSetType
    //

    ZoneDataSetType::
    ZoneDataSetType ()
    : ::xml_schema::type (),
      ZoneData_ (this),
      n_ (this)
    {
    }

    ZoneDataSetType::
    ZoneDataSetType (const n_type& n)
    : ::xml_schema::type (),
      ZoneData_ (this),
      n_ (n, this)
    {
    }

    ZoneDataSetType::
    ZoneDataSetType (const ZoneDataSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ZoneData_ (x.ZoneData_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ZoneDataSetType::
    ZoneDataSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ZoneData_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ZoneDataSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ZoneData
        //
        if (n.name () == L"ZoneData" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZoneData_type > r (
            ZoneData_traits::create (i, f, this));

          this->ZoneData_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ZoneDataSetType* ZoneDataSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneDataSetType (*this, f, c);
    }

    ZoneDataSetType& ZoneDataSetType::
    operator= (const ZoneDataSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ZoneData_ = x.ZoneData_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ZoneDataSetType::
    ~ZoneDataSetType ()
    {
    }

    // LinearToleranceType
    //

    LinearToleranceType::
    LinearToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MaxDualValue_ (this),
      MinValue_ (this),
      MinDualValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    LinearToleranceType::
    LinearToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MaxDualValue_ (this),
      MinValue_ (this),
      MinDualValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    LinearToleranceType::
    LinearToleranceType (const LinearToleranceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MaxDualValue_ (x.MaxDualValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      MinDualValue_ (x.MinDualValue_, f, this),
      DefinitionId_ (x.DefinitionId_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    LinearToleranceType::
    LinearToleranceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MaxDualValue_ (this),
      MinValue_ (this),
      MinDualValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MaxDualValue
        //
        if (n.name () == L"MaxDualValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDualValue_type > r (
            MaxDualValue_traits::create (i, f, this));

          if (!this->MaxDualValue_)
          {
            this->MaxDualValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // MinDualValue
        //
        if (n.name () == L"MinDualValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDualValue_type > r (
            MinDualValue_traits::create (i, f, this));

          if (!this->MinDualValue_)
          {
            this->MinDualValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinitionId
        //
        if (n.name () == L"DefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefinitionId_type > r (
            DefinitionId_traits::create (i, f, this));

          if (!this->DefinitionId_)
          {
            this->DefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearToleranceType* LinearToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearToleranceType (*this, f, c);
    }

    LinearToleranceType& LinearToleranceType::
    operator= (const LinearToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MaxDualValue_ = x.MaxDualValue_;
        this->MinValue_ = x.MinValue_;
        this->MinDualValue_ = x.MinDualValue_;
        this->DefinitionId_ = x.DefinitionId_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    LinearToleranceType::
    ~LinearToleranceType ()
    {
    }

    // LinearToleranceDefinitionType
    //

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
    }

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (id, this)
    {
    }

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const LinearToleranceDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      id_ (x.id_, f, this)
    {
    }

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LinearToleranceDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    LinearToleranceDefinitionType* LinearToleranceDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearToleranceDefinitionType (*this, f, c);
    }

    LinearToleranceDefinitionType& LinearToleranceDefinitionType::
    operator= (const LinearToleranceDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->id_ = x.id_;
      }

      return *this;
    }

    LinearToleranceDefinitionType::
    ~LinearToleranceDefinitionType ()
    {
    }

    // AngularToleranceType
    //

    AngularToleranceType::
    AngularToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    AngularToleranceType::
    AngularToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    AngularToleranceType::
    AngularToleranceType (const AngularToleranceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinitionId_ (x.DefinitionId_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    AngularToleranceType::
    AngularToleranceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinitionId
        //
        if (n.name () == L"DefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefinitionId_type > r (
            DefinitionId_traits::create (i, f, this));

          if (!this->DefinitionId_)
          {
            this->DefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AngularToleranceType* AngularToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularToleranceType (*this, f, c);
    }

    AngularToleranceType& AngularToleranceType::
    operator= (const AngularToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinitionId_ = x.DefinitionId_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    AngularToleranceType::
    ~AngularToleranceType ()
    {
    }

    // AngularToleranceDefinitionType
    //

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
    }

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (id, this)
    {
    }

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const AngularToleranceDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AngularToleranceDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    AngularToleranceDefinitionType* AngularToleranceDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularToleranceDefinitionType (*this, f, c);
    }

    AngularToleranceDefinitionType& AngularToleranceDefinitionType::
    operator= (const AngularToleranceDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AngularToleranceDefinitionType::
    ~AngularToleranceDefinitionType ()
    {
    }

    // TemperatureToleranceType
    //

    TemperatureToleranceType::
    TemperatureToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    TemperatureToleranceType::
    TemperatureToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    TemperatureToleranceType::
    TemperatureToleranceType (const TemperatureToleranceType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    TemperatureToleranceType::
    TemperatureToleranceType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TemperatureToleranceType* TemperatureToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureToleranceType (*this, f, c);
    }

    TemperatureToleranceType& TemperatureToleranceType::
    operator= (const TemperatureToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    TemperatureToleranceType::
    ~TemperatureToleranceType ()
    {
    }

    // AreaToleranceType
    //

    AreaToleranceType::
    AreaToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    AreaToleranceType::
    AreaToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    AreaToleranceType::
    AreaToleranceType (const AreaToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    AreaToleranceType::
    AreaToleranceType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AreaToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AreaToleranceType* AreaToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaToleranceType (*this, f, c);
    }

    AreaToleranceType& AreaToleranceType::
    operator= (const AreaToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    AreaToleranceType::
    ~AreaToleranceType ()
    {
    }

    // ForceToleranceType
    //

    ForceToleranceType::
    ForceToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    ForceToleranceType::
    ForceToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    ForceToleranceType::
    ForceToleranceType (const ForceToleranceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    ForceToleranceType::
    ForceToleranceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ForceToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ForceToleranceType* ForceToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceToleranceType (*this, f, c);
    }

    ForceToleranceType& ForceToleranceType::
    operator= (const ForceToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    ForceToleranceType::
    ~ForceToleranceType ()
    {
    }

    // MassToleranceType
    //

    MassToleranceType::
    MassToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    MassToleranceType::
    MassToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    MassToleranceType::
    MassToleranceType (const MassToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    MassToleranceType::
    MassToleranceType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MassToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MassToleranceType* MassToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassToleranceType (*this, f, c);
    }

    MassToleranceType& MassToleranceType::
    operator= (const MassToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    MassToleranceType::
    ~MassToleranceType ()
    {
    }

    // PressureToleranceType
    //

    PressureToleranceType::
    PressureToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    PressureToleranceType::
    PressureToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    PressureToleranceType::
    PressureToleranceType (const PressureToleranceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    PressureToleranceType::
    PressureToleranceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PressureToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PressureToleranceType* PressureToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureToleranceType (*this, f, c);
    }

    PressureToleranceType& PressureToleranceType::
    operator= (const PressureToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    PressureToleranceType::
    ~PressureToleranceType ()
    {
    }

    // SpeedToleranceType
    //

    SpeedToleranceType::
    SpeedToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    SpeedToleranceType::
    SpeedToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    SpeedToleranceType::
    SpeedToleranceType (const SpeedToleranceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    SpeedToleranceType::
    SpeedToleranceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpeedToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SpeedToleranceType* SpeedToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedToleranceType (*this, f, c);
    }

    SpeedToleranceType& SpeedToleranceType::
    operator= (const SpeedToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    SpeedToleranceType::
    ~SpeedToleranceType ()
    {
    }

    // TimeToleranceType
    //

    TimeToleranceType::
    TimeToleranceType ()
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
    }

    TimeToleranceType::
    TimeToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this),
      Attributes_ (this)
    {
    }

    TimeToleranceType::
    TimeToleranceType (const TimeToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    TimeToleranceType::
    TimeToleranceType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TimeToleranceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxValue
        //
        if (n.name () == L"MaxValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (::std::move (r));
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == L"MinValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (::std::move (r));
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == L"DefinedAsLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefinedAsLimit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TimeToleranceType* TimeToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeToleranceType (*this, f, c);
    }

    TimeToleranceType& TimeToleranceType::
    operator= (const TimeToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    TimeToleranceType::
    ~TimeToleranceType ()
    {
    }

    // DimensionModifierEnumType
    //

    DimensionModifierEnumType::
    DimensionModifierEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType* DimensionModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionModifierEnumType (*this, f, c);
    }

    DimensionModifierEnumType::value DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DimensionModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DimensionModifierEnumType_indexes_,
                        _xsd_DimensionModifierEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DimensionModifierEnumType_indexes_ + 3 || _xsd_DimensionModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_literals_[3] =
    {
      L"BASIC_OR_TED",
      L"SET",
      L"REFERENCE_OR_AUXILIARY"
    };

    const DimensionModifierEnumType::value DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_indexes_[3] =
    {
      ::xsd::qif30::DimensionModifierEnumType::BASIC_OR_TED,
      ::xsd::qif30::DimensionModifierEnumType::REFERENCE_OR_AUXILIARY,
      ::xsd::qif30::DimensionModifierEnumType::SET
    };

    // DimensionDeterminationEnumType
    //

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DimensionDeterminationEnumType_convert ();
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DimensionDeterminationEnumType_convert ();
    }

    DimensionDeterminationEnumType::
    DimensionDeterminationEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DimensionDeterminationEnumType_convert ();
    }

    DimensionDeterminationEnumType* DimensionDeterminationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionDeterminationEnumType (*this, f, c);
    }

    DimensionDeterminationEnumType::value DimensionDeterminationEnumType::
    _xsd_DimensionDeterminationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DimensionDeterminationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DimensionDeterminationEnumType_indexes_,
                        _xsd_DimensionDeterminationEnumType_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_DimensionDeterminationEnumType_indexes_ + 9 || _xsd_DimensionDeterminationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DimensionDeterminationEnumType::
    _xsd_DimensionDeterminationEnumType_literals_[9] =
    {
      L"LP",
      L"LS",
      L"GG",
      L"GX",
      L"GN",
      L"GC",
      L"CC",
      L"CA",
      L"CV"
    };

    const DimensionDeterminationEnumType::value DimensionDeterminationEnumType::
    _xsd_DimensionDeterminationEnumType_indexes_[9] =
    {
      ::xsd::qif30::DimensionDeterminationEnumType::CA,
      ::xsd::qif30::DimensionDeterminationEnumType::CC,
      ::xsd::qif30::DimensionDeterminationEnumType::CV,
      ::xsd::qif30::DimensionDeterminationEnumType::GC,
      ::xsd::qif30::DimensionDeterminationEnumType::GG,
      ::xsd::qif30::DimensionDeterminationEnumType::GN,
      ::xsd::qif30::DimensionDeterminationEnumType::GX,
      ::xsd::qif30::DimensionDeterminationEnumType::LP,
      ::xsd::qif30::DimensionDeterminationEnumType::LS
    };

    // SignificantDimensionEnumType
    //

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SignificantDimensionEnumType_convert ();
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SignificantDimensionEnumType_convert ();
    }

    SignificantDimensionEnumType::
    SignificantDimensionEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SignificantDimensionEnumType_convert ();
    }

    SignificantDimensionEnumType* SignificantDimensionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignificantDimensionEnumType (*this, f, c);
    }

    SignificantDimensionEnumType::value SignificantDimensionEnumType::
    _xsd_SignificantDimensionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SignificantDimensionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SignificantDimensionEnumType_indexes_,
                        _xsd_SignificantDimensionEnumType_indexes_ + 7,
                        *this,
                        c));

      if (i == _xsd_SignificantDimensionEnumType_indexes_ + 7 || _xsd_SignificantDimensionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SignificantDimensionEnumType::
    _xsd_SignificantDimensionEnumType_literals_[7] =
    {
      L"SX",
      L"SN",
      L"SA",
      L"SM",
      L"SD",
      L"SR",
      L"SQ"
    };

    const SignificantDimensionEnumType::value SignificantDimensionEnumType::
    _xsd_SignificantDimensionEnumType_indexes_[7] =
    {
      ::xsd::qif30::SignificantDimensionEnumType::SA,
      ::xsd::qif30::SignificantDimensionEnumType::SD,
      ::xsd::qif30::SignificantDimensionEnumType::SM,
      ::xsd::qif30::SignificantDimensionEnumType::SN,
      ::xsd::qif30::SignificantDimensionEnumType::SQ,
      ::xsd::qif30::SignificantDimensionEnumType::SR,
      ::xsd::qif30::SignificantDimensionEnumType::SX
    };

    // DimensionModifiersType
    //

    DimensionModifiersType::
    DimensionModifiersType ()
    : ::xml_schema::type (),
      DeterminationModifier_ (this),
      SignificanceModifier_ (this),
      SectionModifier_ (this)
    {
    }

    DimensionModifiersType::
    DimensionModifiersType (const DimensionModifiersType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DeterminationModifier_ (x.DeterminationModifier_, f, this),
      SignificanceModifier_ (x.SignificanceModifier_, f, this),
      SectionModifier_ (x.SectionModifier_, f, this)
    {
    }

    DimensionModifiersType::
    DimensionModifiersType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DeterminationModifier_ (this),
      SignificanceModifier_ (this),
      SectionModifier_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DimensionModifiersType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationModifier
        //
        if (n.name () == L"DeterminationModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationModifier_type > r (
            DeterminationModifier_traits::create (i, f, this));

          if (!this->DeterminationModifier_)
          {
            this->DeterminationModifier_.set (::std::move (r));
            continue;
          }
        }

        // SignificanceModifier
        //
        if (n.name () == L"SignificanceModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignificanceModifier_type > r (
            SignificanceModifier_traits::create (i, f, this));

          if (!this->SignificanceModifier_)
          {
            this->SignificanceModifier_.set (::std::move (r));
            continue;
          }
        }

        // SectionModifier
        //
        if (n.name () == L"SectionModifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionModifier_type > r (
            SectionModifier_traits::create (i, f, this));

          if (!this->SectionModifier_)
          {
            this->SectionModifier_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DimensionModifiersType* DimensionModifiersType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionModifiersType (*this, f, c);
    }

    DimensionModifiersType& DimensionModifiersType::
    operator= (const DimensionModifiersType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DeterminationModifier_ = x.DeterminationModifier_;
        this->SignificanceModifier_ = x.SignificanceModifier_;
        this->SectionModifier_ = x.SectionModifier_;
      }

      return *this;
    }

    DimensionModifiersType::
    ~DimensionModifiersType ()
    {
    }

    // NonToleranceEnumType
    //

    NonToleranceEnumType::
    NonToleranceEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType* NonToleranceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonToleranceEnumType (*this, f, c);
    }

    NonToleranceEnumType::value NonToleranceEnumType::
    _xsd_NonToleranceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_NonToleranceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_NonToleranceEnumType_indexes_,
                        _xsd_NonToleranceEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_NonToleranceEnumType_indexes_ + 2 || _xsd_NonToleranceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const NonToleranceEnumType::
    _xsd_NonToleranceEnumType_literals_[2] =
    {
      L"MEASURED",
      L"SET"
    };

    const NonToleranceEnumType::value NonToleranceEnumType::
    _xsd_NonToleranceEnumType_indexes_[2] =
    {
      ::xsd::qif30::NonToleranceEnumType::MEASURED,
      ::xsd::qif30::NonToleranceEnumType::SET
    };

    // LimitsAndFitsZoneVarianceType
    //

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_LimitsAndFitsZoneVarianceType_convert ();
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_LimitsAndFitsZoneVarianceType_convert ();
    }

    LimitsAndFitsZoneVarianceType::
    LimitsAndFitsZoneVarianceType (const ::std::wstring& s,
                                   const xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_LimitsAndFitsZoneVarianceType_convert ();
    }

    LimitsAndFitsZoneVarianceType* LimitsAndFitsZoneVarianceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LimitsAndFitsZoneVarianceType (*this, f, c);
    }

    LimitsAndFitsZoneVarianceType::value LimitsAndFitsZoneVarianceType::
    _xsd_LimitsAndFitsZoneVarianceType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LimitsAndFitsZoneVarianceType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LimitsAndFitsZoneVarianceType_indexes_,
                        _xsd_LimitsAndFitsZoneVarianceType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_LimitsAndFitsZoneVarianceType_indexes_ + 2 || _xsd_LimitsAndFitsZoneVarianceType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LimitsAndFitsZoneVarianceType::
    _xsd_LimitsAndFitsZoneVarianceType_literals_[2] =
    {
      L"HOLE",
      L"SHAFT"
    };

    const LimitsAndFitsZoneVarianceType::value LimitsAndFitsZoneVarianceType::
    _xsd_LimitsAndFitsZoneVarianceType_indexes_[2] =
    {
      ::xsd::qif30::LimitsAndFitsZoneVarianceType::HOLE,
      ::xsd::qif30::LimitsAndFitsZoneVarianceType::SHAFT
    };

    // LimitsAndFitsSpecificationType
    //

    LimitsAndFitsSpecificationType::
    LimitsAndFitsSpecificationType ()
    : ::xml_schema::type (),
      FormVariance_ (this),
      Grade_ (this),
      zoneVariance_ (this)
    {
    }

    LimitsAndFitsSpecificationType::
    LimitsAndFitsSpecificationType (const FormVariance_type& FormVariance,
                                    const Grade_type& Grade,
                                    const zoneVariance_type& zoneVariance)
    : ::xml_schema::type (),
      FormVariance_ (FormVariance, this),
      Grade_ (Grade, this),
      zoneVariance_ (zoneVariance, this)
    {
    }

    LimitsAndFitsSpecificationType::
    LimitsAndFitsSpecificationType (const LimitsAndFitsSpecificationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FormVariance_ (x.FormVariance_, f, this),
      Grade_ (x.Grade_, f, this),
      zoneVariance_ (x.zoneVariance_, f, this)
    {
    }

    LimitsAndFitsSpecificationType::
    LimitsAndFitsSpecificationType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FormVariance_ (this),
      Grade_ (this),
      zoneVariance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LimitsAndFitsSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FormVariance
        //
        if (n.name () == L"FormVariance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FormVariance_type > r (
            FormVariance_traits::create (i, f, this));

          if (!FormVariance_.present ())
          {
            this->FormVariance_.set (::std::move (r));
            continue;
          }
        }

        // Grade
        //
        if (n.name () == L"Grade" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Grade_type > r (
            Grade_traits::create (i, f, this));

          if (!Grade_.present ())
          {
            this->Grade_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FormVariance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FormVariance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Grade_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Grade",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"zoneVariance" && n.namespace_ ().empty ())
        {
          this->zoneVariance_.set (zoneVariance_traits::create (i, f, this));
          continue;
        }
      }

      if (!zoneVariance_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"zoneVariance",
          L"");
      }
    }

    LimitsAndFitsSpecificationType* LimitsAndFitsSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LimitsAndFitsSpecificationType (*this, f, c);
    }

    LimitsAndFitsSpecificationType& LimitsAndFitsSpecificationType::
    operator= (const LimitsAndFitsSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FormVariance_ = x.FormVariance_;
        this->Grade_ = x.Grade_;
        this->zoneVariance_ = x.zoneVariance_;
      }

      return *this;
    }

    LimitsAndFitsSpecificationType::
    ~LimitsAndFitsSpecificationType ()
    {
    }

    // CommonFileSpecEnumType
    //

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType* CommonFileSpecEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CommonFileSpecEnumType (*this, f, c);
    }

    CommonFileSpecEnumType::value CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CommonFileSpecEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CommonFileSpecEnumType_indexes_,
                        _xsd_CommonFileSpecEnumType_indexes_ + 36,
                        *this,
                        c));

      if (i == _xsd_CommonFileSpecEnumType_indexes_ + 36 || _xsd_CommonFileSpecEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_literals_[36] =
    {
      L"AVI",
      L"BMP",
      L"DOC",
      L"DOCX",
      L"DXF",
      L"DTD",
      L"GIF",
      L"GZIP",
      L"HTML",
      L"IGES",
      L"JPEG",
      L"JPG",
      L"MOV",
      L"MPEG",
      L"MPG",
      L"PDF",
      L"PNG",
      L"PPM",
      L"PPT",
      L"PRT",
      L"RAR",
      L"RTF",
      L"STL",
      L"STEP",
      L"STP",
      L"TAR",
      L"TIF",
      L"TIFF",
      L"TXT",
      L"WMV",
      L"XLS",
      L"XLSX",
      L"XML",
      L"XSD",
      L"X_T",
      L"ZIP"
    };

    const CommonFileSpecEnumType::value CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_indexes_[36] =
    {
      ::xsd::qif30::CommonFileSpecEnumType::AVI,
      ::xsd::qif30::CommonFileSpecEnumType::BMP,
      ::xsd::qif30::CommonFileSpecEnumType::DOC,
      ::xsd::qif30::CommonFileSpecEnumType::DOCX,
      ::xsd::qif30::CommonFileSpecEnumType::DTD,
      ::xsd::qif30::CommonFileSpecEnumType::DXF,
      ::xsd::qif30::CommonFileSpecEnumType::GIF,
      ::xsd::qif30::CommonFileSpecEnumType::GZIP,
      ::xsd::qif30::CommonFileSpecEnumType::HTML,
      ::xsd::qif30::CommonFileSpecEnumType::IGES,
      ::xsd::qif30::CommonFileSpecEnumType::JPEG,
      ::xsd::qif30::CommonFileSpecEnumType::JPG,
      ::xsd::qif30::CommonFileSpecEnumType::MOV,
      ::xsd::qif30::CommonFileSpecEnumType::MPEG,
      ::xsd::qif30::CommonFileSpecEnumType::MPG,
      ::xsd::qif30::CommonFileSpecEnumType::PDF,
      ::xsd::qif30::CommonFileSpecEnumType::PNG,
      ::xsd::qif30::CommonFileSpecEnumType::PPM,
      ::xsd::qif30::CommonFileSpecEnumType::PPT,
      ::xsd::qif30::CommonFileSpecEnumType::PRT,
      ::xsd::qif30::CommonFileSpecEnumType::RAR,
      ::xsd::qif30::CommonFileSpecEnumType::RTF,
      ::xsd::qif30::CommonFileSpecEnumType::STEP,
      ::xsd::qif30::CommonFileSpecEnumType::STL,
      ::xsd::qif30::CommonFileSpecEnumType::STP,
      ::xsd::qif30::CommonFileSpecEnumType::TAR,
      ::xsd::qif30::CommonFileSpecEnumType::TIF,
      ::xsd::qif30::CommonFileSpecEnumType::TIFF,
      ::xsd::qif30::CommonFileSpecEnumType::TXT,
      ::xsd::qif30::CommonFileSpecEnumType::WMV,
      ::xsd::qif30::CommonFileSpecEnumType::XLS,
      ::xsd::qif30::CommonFileSpecEnumType::XLSX,
      ::xsd::qif30::CommonFileSpecEnumType::XML,
      ::xsd::qif30::CommonFileSpecEnumType::XSD,
      ::xsd::qif30::CommonFileSpecEnumType::X_T,
      ::xsd::qif30::CommonFileSpecEnumType::ZIP
    };

    // FileSpecType
    //

    FileSpecType::
    FileSpecType ()
    : ::xml_schema::type (),
      CommonFileSpecEnum_ (this),
      OtherFileSpec_ (this)
    {
    }

    FileSpecType::
    FileSpecType (const FileSpecType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CommonFileSpecEnum_ (x.CommonFileSpecEnum_, f, this),
      OtherFileSpec_ (x.OtherFileSpec_, f, this)
    {
    }

    FileSpecType::
    FileSpecType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CommonFileSpecEnum_ (this),
      OtherFileSpec_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileSpecType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CommonFileSpecEnum
        //
        if (n.name () == L"CommonFileSpecEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CommonFileSpecEnum_type > r (
            CommonFileSpecEnum_traits::create (i, f, this));

          if (!this->CommonFileSpecEnum_)
          {
            this->CommonFileSpecEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherFileSpec
        //
        if (n.name () == L"OtherFileSpec" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherFileSpec_type > r (
            OtherFileSpec_traits::create (i, f, this));

          if (!this->OtherFileSpec_)
          {
            this->OtherFileSpec_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FileSpecType* FileSpecType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileSpecType (*this, f, c);
    }

    FileSpecType& FileSpecType::
    operator= (const FileSpecType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CommonFileSpecEnum_ = x.CommonFileSpecEnum_;
        this->OtherFileSpec_ = x.OtherFileSpec_;
      }

      return *this;
    }

    FileSpecType::
    ~FileSpecType ()
    {
    }

    // ExternalFileReferenceType
    //

    ExternalFileReferenceType::
    ExternalFileReferenceType ()
    : ::xml_schema::type (),
      URI_ (this),
      FileSpec_ (this),
      Description_ (this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const URI_type& URI,
                               const FileSpec_type& FileSpec,
                               const Description_type& Description)
    : ::xml_schema::type (),
      URI_ (URI, this),
      FileSpec_ (FileSpec, this),
      Description_ (Description, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const URI_type& URI,
                               ::std::unique_ptr< FileSpec_type > FileSpec,
                               const Description_type& Description)
    : ::xml_schema::type (),
      URI_ (URI, this),
      FileSpec_ (std::move (FileSpec), this),
      Description_ (Description, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const ExternalFileReferenceType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      URI_ (x.URI_, f, this),
      FileSpec_ (x.FileSpec_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      URI_ (this),
      FileSpec_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExternalFileReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // URI
        //
        if (n.name () == L"URI" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!URI_.present ())
          {
            this->URI_.set (::std::move (r));
            continue;
          }
        }

        // FileSpec
        //
        if (n.name () == L"FileSpec" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FileSpec_type > r (
            FileSpec_traits::create (i, f, this));

          if (!FileSpec_.present ())
          {
            this->FileSpec_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"URI",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!FileSpec_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FileSpec",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Description",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExternalFileReferenceType* ExternalFileReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExternalFileReferenceType (*this, f, c);
    }

    ExternalFileReferenceType& ExternalFileReferenceType::
    operator= (const ExternalFileReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->URI_ = x.URI_;
        this->FileSpec_ = x.FileSpec_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    ExternalFileReferenceType::
    ~ExternalFileReferenceType ()
    {
    }

    // ExternalFileReferencesType
    //

    ExternalFileReferencesType::
    ExternalFileReferencesType ()
    : ::xml_schema::type (),
      ExternalFileReference_ (this),
      n_ (this)
    {
    }

    ExternalFileReferencesType::
    ExternalFileReferencesType (const n_type& n)
    : ::xml_schema::type (),
      ExternalFileReference_ (this),
      n_ (n, this)
    {
    }

    ExternalFileReferencesType::
    ExternalFileReferencesType (const ExternalFileReferencesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ExternalFileReference_ (x.ExternalFileReference_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExternalFileReferencesType::
    ExternalFileReferencesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ExternalFileReference_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExternalFileReferencesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExternalFileReference
        //
        if (n.name () == L"ExternalFileReference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalFileReference_type > r (
            ExternalFileReference_traits::create (i, f, this));

          this->ExternalFileReference_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExternalFileReferencesType* ExternalFileReferencesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExternalFileReferencesType (*this, f, c);
    }

    ExternalFileReferencesType& ExternalFileReferencesType::
    operator= (const ExternalFileReferencesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ExternalFileReference_ = x.ExternalFileReference_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExternalFileReferencesType::
    ~ExternalFileReferencesType ()
    {
    }

    // DatumTargetDefinitionsType
    //

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType ()
    : ::xml_schema::type (),
      DatumTarget_ (this),
      n_ (this)
    {
    }

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const n_type& n)
    : ::xml_schema::type (),
      DatumTarget_ (this),
      n_ (n, this)
    {
    }

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const DatumTargetDefinitionsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTarget_ (x.DatumTarget_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTarget_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumTarget
        //
        if (n.name () == L"DatumTarget" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTarget_type > r (
            DatumTarget_traits::create (i, f, this));

          this->DatumTarget_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DatumTargetDefinitionsType* DatumTargetDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetDefinitionsType (*this, f, c);
    }

    DatumTargetDefinitionsType& DatumTargetDefinitionsType::
    operator= (const DatumTargetDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTarget_ = x.DatumTarget_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DatumTargetDefinitionsType::
    ~DatumTargetDefinitionsType ()
    {
    }

    // DatumDefinitionType
    //

    DatumDefinitionType::
    DatumDefinitionType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumLabel_ (this),
      DatumTargetIds_ (this),
      FeatureNominalIds_ (this),
      id_ (this)
    {
    }

    DatumDefinitionType::
    DatumDefinitionType (const DatumLabel_type& DatumLabel,
                         const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumLabel_ (DatumLabel, this),
      DatumTargetIds_ (this),
      FeatureNominalIds_ (this),
      id_ (id, this)
    {
    }

    DatumDefinitionType::
    DatumDefinitionType (const DatumDefinitionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      DatumLabel_ (x.DatumLabel_, f, this),
      DatumTargetIds_ (x.DatumTargetIds_, f, this),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumDefinitionType::
    DatumDefinitionType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      DatumLabel_ (this),
      DatumTargetIds_ (this),
      FeatureNominalIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // DatumLabel
        //
        if (n.name () == L"DatumLabel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumLabel_type > r (
            DatumLabel_traits::create (i, f, this));

          if (!DatumLabel_.present ())
          {
            this->DatumLabel_.set (::std::move (r));
            continue;
          }
        }

        // DatumTargetIds
        //
        if (n.name () == L"DatumTargetIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTargetIds_type > r (
            DatumTargetIds_traits::create (i, f, this));

          if (!this->DatumTargetIds_)
          {
            this->DatumTargetIds_.set (::std::move (r));
            continue;
          }
        }

        // FeatureNominalIds
        //
        if (n.name () == L"FeatureNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!this->FeatureNominalIds_)
          {
            this->FeatureNominalIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumLabel",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DatumDefinitionType* DatumDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumDefinitionType (*this, f, c);
    }

    DatumDefinitionType& DatumDefinitionType::
    operator= (const DatumDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->DatumLabel_ = x.DatumLabel_;
        this->DatumTargetIds_ = x.DatumTargetIds_;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumDefinitionType::
    ~DatumDefinitionType ()
    {
    }

    // DatumDefinitionsType
    //

    DatumDefinitionsType::
    DatumDefinitionsType ()
    : ::xml_schema::type (),
      DatumDefinition_ (this),
      n_ (this)
    {
    }

    DatumDefinitionsType::
    DatumDefinitionsType (const n_type& n)
    : ::xml_schema::type (),
      DatumDefinition_ (this),
      n_ (n, this)
    {
    }

    DatumDefinitionsType::
    DatumDefinitionsType (const DatumDefinitionsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinition_ (x.DatumDefinition_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DatumDefinitionsType::
    DatumDefinitionsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinition_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumDefinition
        //
        if (n.name () == L"DatumDefinition" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinition_type > r (
            DatumDefinition_traits::create (i, f, this));

          this->DatumDefinition_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DatumDefinitionsType* DatumDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumDefinitionsType (*this, f, c);
    }

    DatumDefinitionsType& DatumDefinitionsType::
    operator= (const DatumDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinition_ = x.DatumDefinition_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DatumDefinitionsType::
    ~DatumDefinitionsType ()
    {
    }

    // DatumTargetType
    //

    DatumTargetType::
    DatumTargetType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumTargetLabel_ (this),
      FeatureNominalId_ (this),
      TargetZoneId_ (this),
      MovableDatumTarget_ (this),
      id_ (this)
    {
    }

    DatumTargetType::
    DatumTargetType (const DatumTargetLabel_type& DatumTargetLabel,
                     const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumTargetLabel_ (DatumTargetLabel, this),
      FeatureNominalId_ (this),
      TargetZoneId_ (this),
      MovableDatumTarget_ (this),
      id_ (id, this)
    {
    }

    DatumTargetType::
    DatumTargetType (const DatumTargetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      DatumTargetLabel_ (x.DatumTargetLabel_, f, this),
      FeatureNominalId_ (x.FeatureNominalId_, f, this),
      TargetZoneId_ (x.TargetZoneId_, f, this),
      MovableDatumTarget_ (x.MovableDatumTarget_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumTargetType::
    DatumTargetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      DatumTargetLabel_ (this),
      FeatureNominalId_ (this),
      TargetZoneId_ (this),
      MovableDatumTarget_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // DatumTargetLabel
        //
        if (n.name () == L"DatumTargetLabel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTargetLabel_type > r (
            DatumTargetLabel_traits::create (i, f, this));

          if (!DatumTargetLabel_.present ())
          {
            this->DatumTargetLabel_.set (::std::move (r));
            continue;
          }
        }

        // FeatureNominalId
        //
        if (n.name () == L"FeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!this->FeatureNominalId_)
          {
            this->FeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        // TargetZoneId
        //
        if (n.name () == L"TargetZoneId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TargetZoneId_type > r (
            TargetZoneId_traits::create (i, f, this));

          if (!this->TargetZoneId_)
          {
            this->TargetZoneId_.set (::std::move (r));
            continue;
          }
        }

        // MovableDatumTarget
        //
        if (n.name () == L"MovableDatumTarget" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MovableDatumTarget_type > r (
            MovableDatumTarget_traits::create (i, f, this));

          if (!this->MovableDatumTarget_)
          {
            this->MovableDatumTarget_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumTargetLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumTargetLabel",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DatumTargetType* DatumTargetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetType (*this, f, c);
    }

    DatumTargetType& DatumTargetType::
    operator= (const DatumTargetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->DatumTargetLabel_ = x.DatumTargetLabel_;
        this->FeatureNominalId_ = x.FeatureNominalId_;
        this->TargetZoneId_ = x.TargetZoneId_;
        this->MovableDatumTarget_ = x.MovableDatumTarget_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumTargetType::
    ~DatumTargetType ()
    {
    }

    // EmployeeType
    //

    EmployeeType::
    EmployeeType ()
    : ::xml_schema::type (),
      Name_ (this),
      EmployeeId_ (this),
      Shift_ (this)
    {
    }

    EmployeeType::
    EmployeeType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      EmployeeId_ (this),
      Shift_ (this)
    {
    }

    EmployeeType::
    EmployeeType (const EmployeeType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      EmployeeId_ (x.EmployeeId_, f, this),
      Shift_ (x.Shift_, f, this)
    {
    }

    EmployeeType::
    EmployeeType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      EmployeeId_ (this),
      Shift_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EmployeeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // EmployeeId
        //
        if (n.name () == L"EmployeeId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EmployeeId_type > r (
            EmployeeId_traits::create (i, f, this));

          if (!this->EmployeeId_)
          {
            this->EmployeeId_.set (::std::move (r));
            continue;
          }
        }

        // Shift
        //
        if (n.name () == L"Shift" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Shift_type > r (
            Shift_traits::create (i, f, this));

          if (!this->Shift_)
          {
            this->Shift_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EmployeeType* EmployeeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EmployeeType (*this, f, c);
    }

    EmployeeType& EmployeeType::
    operator= (const EmployeeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->EmployeeId_ = x.EmployeeId_;
        this->Shift_ = x.Shift_;
      }

      return *this;
    }

    EmployeeType::
    ~EmployeeType ()
    {
    }

    // FileType
    //

    FileType::
    FileType ()
    : ::xml_schema::type (),
      Name_ (this),
      Version_ (this),
      Format_ (this)
    {
    }

    FileType::
    FileType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Version_ (this),
      Format_ (this)
    {
    }

    FileType::
    FileType (const FileType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Format_ (x.Format_, f, this)
    {
    }

    FileType::
    FileType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Version_ (this),
      Format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Format
        //
        if (n.name () == L"Format" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Format_type > r (
            Format_traits::create (i, f, this));

          if (!this->Format_)
          {
            this->Format_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FileType* FileType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileType (*this, f, c);
    }

    FileType& FileType::
    operator= (const FileType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Version_ = x.Version_;
        this->Format_ = x.Format_;
      }

      return *this;
    }

    FileType::
    ~FileType ()
    {
    }

    // SoftwareType
    //

    SoftwareType::
    SoftwareType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      VendorName_ (this),
      ApplicationName_ (this),
      Version_ (this),
      Description_ (this),
      URI_ (this),
      ReferencedStandardIds_ (this),
      id_ (this)
    {
    }

    SoftwareType::
    SoftwareType (const VendorName_type& VendorName,
                  const ApplicationName_type& ApplicationName,
                  const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      VendorName_ (VendorName, this),
      ApplicationName_ (ApplicationName, this),
      Version_ (this),
      Description_ (this),
      URI_ (this),
      ReferencedStandardIds_ (this),
      id_ (id, this)
    {
    }

    SoftwareType::
    SoftwareType (const SoftwareType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      VendorName_ (x.VendorName_, f, this),
      ApplicationName_ (x.ApplicationName_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this),
      URI_ (x.URI_, f, this),
      ReferencedStandardIds_ (x.ReferencedStandardIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    SoftwareType::
    SoftwareType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      VendorName_ (this),
      ApplicationName_ (this),
      Version_ (this),
      Description_ (this),
      URI_ (this),
      ReferencedStandardIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SoftwareType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // VendorName
        //
        if (n.name () == L"VendorName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VendorName_type > r (
            VendorName_traits::create (i, f, this));

          if (!VendorName_.present ())
          {
            this->VendorName_.set (::std::move (r));
            continue;
          }
        }

        // ApplicationName
        //
        if (n.name () == L"ApplicationName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApplicationName_type > r (
            ApplicationName_traits::create (i, f, this));

          if (!ApplicationName_.present ())
          {
            this->ApplicationName_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // URI
        //
        if (n.name () == L"URI" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!this->URI_)
          {
            this->URI_.set (::std::move (r));
            continue;
          }
        }

        // ReferencedStandardIds
        //
        if (n.name () == L"ReferencedStandardIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedStandardIds_type > r (
            ReferencedStandardIds_traits::create (i, f, this));

          if (!this->ReferencedStandardIds_)
          {
            this->ReferencedStandardIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!VendorName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VendorName",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ApplicationName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ApplicationName",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    SoftwareType* SoftwareType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwareType (*this, f, c);
    }

    SoftwareType& SoftwareType::
    operator= (const SoftwareType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->VendorName_ = x.VendorName_;
        this->ApplicationName_ = x.ApplicationName_;
        this->Version_ = x.Version_;
        this->Description_ = x.Description_;
        this->URI_ = x.URI_;
        this->ReferencedStandardIds_ = x.ReferencedStandardIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    SoftwareType::
    ~SoftwareType ()
    {
    }

    // StandardsOrganizationEnumType
    //

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_StandardsOrganizationEnumType_convert ();
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_StandardsOrganizationEnumType_convert ();
    }

    StandardsOrganizationEnumType::
    StandardsOrganizationEnumType (const ::std::wstring& s,
                                   const xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_StandardsOrganizationEnumType_convert ();
    }

    StandardsOrganizationEnumType* StandardsOrganizationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StandardsOrganizationEnumType (*this, f, c);
    }

    StandardsOrganizationEnumType::value StandardsOrganizationEnumType::
    _xsd_StandardsOrganizationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_StandardsOrganizationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_StandardsOrganizationEnumType_indexes_,
                        _xsd_StandardsOrganizationEnumType_indexes_ + 19,
                        *this,
                        c));

      if (i == _xsd_StandardsOrganizationEnumType_indexes_ + 19 || _xsd_StandardsOrganizationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const StandardsOrganizationEnumType::
    _xsd_StandardsOrganizationEnumType_literals_[19] =
    {
      L"AIAG",
      L"ANSI",
      L"ASAM",
      L"ASME",
      L"AWS",
      L"BSI",
      L"DIN",
      L"DOD",
      L"EASC",
      L"GOST",
      L"GOST_R",
      L"IEC",
      L"IEEE",
      L"ISO",
      L"JEITA",
      L"JIS",
      L"UL",
      L"VDA",
      L"W3C"
    };

    const StandardsOrganizationEnumType::value StandardsOrganizationEnumType::
    _xsd_StandardsOrganizationEnumType_indexes_[19] =
    {
      ::xsd::qif30::StandardsOrganizationEnumType::AIAG,
      ::xsd::qif30::StandardsOrganizationEnumType::ANSI,
      ::xsd::qif30::StandardsOrganizationEnumType::ASAM,
      ::xsd::qif30::StandardsOrganizationEnumType::ASME,
      ::xsd::qif30::StandardsOrganizationEnumType::AWS,
      ::xsd::qif30::StandardsOrganizationEnumType::BSI,
      ::xsd::qif30::StandardsOrganizationEnumType::DIN,
      ::xsd::qif30::StandardsOrganizationEnumType::DOD,
      ::xsd::qif30::StandardsOrganizationEnumType::EASC,
      ::xsd::qif30::StandardsOrganizationEnumType::GOST,
      ::xsd::qif30::StandardsOrganizationEnumType::GOST_R,
      ::xsd::qif30::StandardsOrganizationEnumType::IEC,
      ::xsd::qif30::StandardsOrganizationEnumType::IEEE,
      ::xsd::qif30::StandardsOrganizationEnumType::ISO,
      ::xsd::qif30::StandardsOrganizationEnumType::JEITA,
      ::xsd::qif30::StandardsOrganizationEnumType::JIS,
      ::xsd::qif30::StandardsOrganizationEnumType::UL,
      ::xsd::qif30::StandardsOrganizationEnumType::VDA,
      ::xsd::qif30::StandardsOrganizationEnumType::W3C
    };

    // StandardsOrganizationType
    //

    StandardsOrganizationType::
    StandardsOrganizationType ()
    : ::xml_schema::type (),
      StandardsOrganizationEnum_ (this),
      OtherStandardsOrganization_ (this)
    {
    }

    StandardsOrganizationType::
    StandardsOrganizationType (const StandardsOrganizationType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StandardsOrganizationEnum_ (x.StandardsOrganizationEnum_, f, this),
      OtherStandardsOrganization_ (x.OtherStandardsOrganization_, f, this)
    {
    }

    StandardsOrganizationType::
    StandardsOrganizationType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StandardsOrganizationEnum_ (this),
      OtherStandardsOrganization_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StandardsOrganizationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StandardsOrganizationEnum
        //
        if (n.name () == L"StandardsOrganizationEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardsOrganizationEnum_type > r (
            StandardsOrganizationEnum_traits::create (i, f, this));

          if (!this->StandardsOrganizationEnum_)
          {
            this->StandardsOrganizationEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherStandardsOrganization
        //
        if (n.name () == L"OtherStandardsOrganization" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherStandardsOrganization_type > r (
            OtherStandardsOrganization_traits::create (i, f, this));

          if (!this->OtherStandardsOrganization_)
          {
            this->OtherStandardsOrganization_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StandardsOrganizationType* StandardsOrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StandardsOrganizationType (*this, f, c);
    }

    StandardsOrganizationType& StandardsOrganizationType::
    operator= (const StandardsOrganizationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StandardsOrganizationEnum_ = x.StandardsOrganizationEnum_;
        this->OtherStandardsOrganization_ = x.OtherStandardsOrganization_;
      }

      return *this;
    }

    StandardsOrganizationType::
    ~StandardsOrganizationType ()
    {
    }

    // StandardType
    //

    StandardType::
    StandardType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Organization_ (this),
      Designator_ (this),
      Year_ (this),
      Title_ (this),
      Description_ (this),
      URI_ (this),
      ISBN_ (this),
      ReferencedStandardIds_ (this),
      id_ (this)
    {
    }

    StandardType::
    StandardType (const Organization_type& Organization,
                  const Designator_type& Designator,
                  const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Organization_ (Organization, this),
      Designator_ (Designator, this),
      Year_ (this),
      Title_ (this),
      Description_ (this),
      URI_ (this),
      ISBN_ (this),
      ReferencedStandardIds_ (this),
      id_ (id, this)
    {
    }

    StandardType::
    StandardType (::std::unique_ptr< Organization_type > Organization,
                  const Designator_type& Designator,
                  const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Organization_ (std::move (Organization), this),
      Designator_ (Designator, this),
      Year_ (this),
      Title_ (this),
      Description_ (this),
      URI_ (this),
      ISBN_ (this),
      ReferencedStandardIds_ (this),
      id_ (id, this)
    {
    }

    StandardType::
    StandardType (const StandardType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Organization_ (x.Organization_, f, this),
      Designator_ (x.Designator_, f, this),
      Year_ (x.Year_, f, this),
      Title_ (x.Title_, f, this),
      Description_ (x.Description_, f, this),
      URI_ (x.URI_, f, this),
      ISBN_ (x.ISBN_, f, this),
      ReferencedStandardIds_ (x.ReferencedStandardIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    StandardType::
    StandardType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Organization_ (this),
      Designator_ (this),
      Year_ (this),
      Title_ (this),
      Description_ (this),
      URI_ (this),
      ISBN_ (this),
      ReferencedStandardIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StandardType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Organization
        //
        if (n.name () == L"Organization" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Organization_type > r (
            Organization_traits::create (i, f, this));

          if (!Organization_.present ())
          {
            this->Organization_.set (::std::move (r));
            continue;
          }
        }

        // Designator
        //
        if (n.name () == L"Designator" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Designator_type > r (
            Designator_traits::create (i, f, this));

          if (!Designator_.present ())
          {
            this->Designator_.set (::std::move (r));
            continue;
          }
        }

        // Year
        //
        if (n.name () == L"Year" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Year_type > r (
            Year_traits::create (i, f, this));

          if (!this->Year_)
          {
            this->Year_.set (::std::move (r));
            continue;
          }
        }

        // Title
        //
        if (n.name () == L"Title" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Title_type > r (
            Title_traits::create (i, f, this));

          if (!this->Title_)
          {
            this->Title_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // URI
        //
        if (n.name () == L"URI" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!this->URI_)
          {
            this->URI_.set (::std::move (r));
            continue;
          }
        }

        // ISBN
        //
        if (n.name () == L"ISBN" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ISBN_type > r (
            ISBN_traits::create (i, f, this));

          if (!this->ISBN_)
          {
            this->ISBN_.set (::std::move (r));
            continue;
          }
        }

        // ReferencedStandardIds
        //
        if (n.name () == L"ReferencedStandardIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedStandardIds_type > r (
            ReferencedStandardIds_traits::create (i, f, this));

          if (!this->ReferencedStandardIds_)
          {
            this->ReferencedStandardIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Organization_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Organization",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Designator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Designator",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    StandardType* StandardType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StandardType (*this, f, c);
    }

    StandardType& StandardType::
    operator= (const StandardType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Organization_ = x.Organization_;
        this->Designator_ = x.Designator_;
        this->Year_ = x.Year_;
        this->Title_ = x.Title_;
        this->Description_ = x.Description_;
        this->URI_ = x.URI_;
        this->ISBN_ = x.ISBN_;
        this->ReferencedStandardIds_ = x.ReferencedStandardIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    StandardType::
    ~StandardType ()
    {
    }

    // StandardsType
    //

    StandardsType::
    StandardsType ()
    : ::xml_schema::type (),
      Standard_ (this),
      n_ (this)
    {
    }

    StandardsType::
    StandardsType (const n_type& n)
    : ::xml_schema::type (),
      Standard_ (this),
      n_ (n, this)
    {
    }

    StandardsType::
    StandardsType (const StandardsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Standard_ (x.Standard_, f, this),
      n_ (x.n_, f, this)
    {
    }

    StandardsType::
    StandardsType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Standard_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StandardsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Standard
        //
        if (n.name () == L"Standard" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Standard_type > r (
            Standard_traits::create (i, f, this));

          this->Standard_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    StandardsType* StandardsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StandardsType (*this, f, c);
    }

    StandardsType& StandardsType::
    operator= (const StandardsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Standard_ = x.Standard_;
        this->n_ = x.n_;
      }

      return *this;
    }

    StandardsType::
    ~StandardsType ()
    {
    }

    // SoftwaresType
    //

    SoftwaresType::
    SoftwaresType ()
    : ::xml_schema::type (),
      Software_ (this),
      n_ (this)
    {
    }

    SoftwaresType::
    SoftwaresType (const n_type& n)
    : ::xml_schema::type (),
      Software_ (this),
      n_ (n, this)
    {
    }

    SoftwaresType::
    SoftwaresType (const SoftwaresType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Software_ (x.Software_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SoftwaresType::
    SoftwaresType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Software_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SoftwaresType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Software
        //
        if (n.name () == L"Software" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Software_type > r (
            Software_traits::create (i, f, this));

          this->Software_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SoftwaresType* SoftwaresType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwaresType (*this, f, c);
    }

    SoftwaresType& SoftwaresType::
    operator= (const SoftwaresType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Software_ = x.Software_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SoftwaresType::
    ~SoftwaresType ()
    {
    }

    // AlgorithmType
    //

    AlgorithmType::
    AlgorithmType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      SoftwareId_ (this),
      Parameters_ (this),
      StandardId_ (this),
      Section_ (this),
      Name_ (this),
      Description_ (this),
      id_ (this)
    {
    }

    AlgorithmType::
    AlgorithmType (const Name_type& Name,
                   const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      SoftwareId_ (this),
      Parameters_ (this),
      StandardId_ (this),
      Section_ (this),
      Name_ (Name, this),
      Description_ (this),
      id_ (id, this)
    {
    }

    AlgorithmType::
    AlgorithmType (const AlgorithmType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      SoftwareId_ (x.SoftwareId_, f, this),
      Parameters_ (x.Parameters_, f, this),
      StandardId_ (x.StandardId_, f, this),
      Section_ (x.Section_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AlgorithmType::
    AlgorithmType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      SoftwareId_ (this),
      Parameters_ (this),
      StandardId_ (this),
      Section_ (this),
      Name_ (this),
      Description_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // SoftwareId
        //
        if (n.name () == L"SoftwareId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SoftwareId_type > r (
            SoftwareId_traits::create (i, f, this));

          if (!this->SoftwareId_)
          {
            this->SoftwareId_.set (::std::move (r));
            continue;
          }
        }

        // Parameters
        //
        if (n.name () == L"Parameters" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parameters_type > r (
            Parameters_traits::create (i, f, this));

          if (!this->Parameters_)
          {
            this->Parameters_.set (::std::move (r));
            continue;
          }
        }

        // StandardId
        //
        if (n.name () == L"StandardId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardId_type > r (
            StandardId_traits::create (i, f, this));

          if (!this->StandardId_)
          {
            this->StandardId_.set (::std::move (r));
            continue;
          }
        }

        // Section
        //
        if (n.name () == L"Section" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Section_type > r (
            Section_traits::create (i, f, this));

          if (!this->Section_)
          {
            this->Section_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    AlgorithmType* AlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlgorithmType (*this, f, c);
    }

    AlgorithmType& AlgorithmType::
    operator= (const AlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->SoftwareId_ = x.SoftwareId_;
        this->Parameters_ = x.Parameters_;
        this->StandardId_ = x.StandardId_;
        this->Section_ = x.Section_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AlgorithmType::
    ~AlgorithmType ()
    {
    }

    // AlgorithmsType
    //

    AlgorithmsType::
    AlgorithmsType ()
    : ::xml_schema::type (),
      Algorithm_ (this),
      n_ (this)
    {
    }

    AlgorithmsType::
    AlgorithmsType (const n_type& n)
    : ::xml_schema::type (),
      Algorithm_ (this),
      n_ (n, this)
    {
    }

    AlgorithmsType::
    AlgorithmsType (const AlgorithmsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Algorithm_ (x.Algorithm_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AlgorithmsType::
    AlgorithmsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Algorithm_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AlgorithmsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Algorithm
        //
        if (n.name () == L"Algorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Algorithm_type > r (
            Algorithm_traits::create (i, f, this));

          this->Algorithm_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AlgorithmsType* AlgorithmsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlgorithmsType (*this, f, c);
    }

    AlgorithmsType& AlgorithmsType::
    operator= (const AlgorithmsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Algorithm_ = x.Algorithm_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AlgorithmsType::
    ~AlgorithmsType ()
    {
    }

    // OrganizationType
    //

    OrganizationType::
    OrganizationType ()
    : ::xml_schema::type (),
      Name_ (this),
      Address_ (this),
      Attributes_ (this)
    {
    }

    OrganizationType::
    OrganizationType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Address_ (this),
      Attributes_ (this)
    {
    }

    OrganizationType::
    OrganizationType (const OrganizationType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Address_ (x.Address_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    OrganizationType::
    OrganizationType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Address_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrganizationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Address
        //
        if (n.name () == L"Address" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OrganizationType* OrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrganizationType (*this, f, c);
    }

    OrganizationType& OrganizationType::
    operator= (const OrganizationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Address_ = x.Address_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    OrganizationType::
    ~OrganizationType ()
    {
    }

    // PhysicalAddressType
    //

    PhysicalAddressType::
    PhysicalAddressType ()
    : ::xml_schema::type (),
      Description_ (this),
      InternalLocation_ (this),
      StreetNumber_ (this),
      Street_ (this),
      PostalBox_ (this),
      Town_ (this),
      Region_ (this),
      PostalCode_ (this),
      Country_ (this),
      FacsimileNumber_ (this),
      TelephoneNumber_ (this),
      ElectronicMailAddress_ (this),
      TelexNumber_ (this)
    {
    }

    PhysicalAddressType::
    PhysicalAddressType (const PhysicalAddressType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Description_ (x.Description_, f, this),
      InternalLocation_ (x.InternalLocation_, f, this),
      StreetNumber_ (x.StreetNumber_, f, this),
      Street_ (x.Street_, f, this),
      PostalBox_ (x.PostalBox_, f, this),
      Town_ (x.Town_, f, this),
      Region_ (x.Region_, f, this),
      PostalCode_ (x.PostalCode_, f, this),
      Country_ (x.Country_, f, this),
      FacsimileNumber_ (x.FacsimileNumber_, f, this),
      TelephoneNumber_ (x.TelephoneNumber_, f, this),
      ElectronicMailAddress_ (x.ElectronicMailAddress_, f, this),
      TelexNumber_ (x.TelexNumber_, f, this)
    {
    }

    PhysicalAddressType::
    PhysicalAddressType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Description_ (this),
      InternalLocation_ (this),
      StreetNumber_ (this),
      Street_ (this),
      PostalBox_ (this),
      Town_ (this),
      Region_ (this),
      PostalCode_ (this),
      Country_ (this),
      FacsimileNumber_ (this),
      TelephoneNumber_ (this),
      ElectronicMailAddress_ (this),
      TelexNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PhysicalAddressType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // InternalLocation
        //
        if (n.name () == L"InternalLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalLocation_type > r (
            InternalLocation_traits::create (i, f, this));

          if (!this->InternalLocation_)
          {
            this->InternalLocation_.set (::std::move (r));
            continue;
          }
        }

        // StreetNumber
        //
        if (n.name () == L"StreetNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StreetNumber_type > r (
            StreetNumber_traits::create (i, f, this));

          if (!this->StreetNumber_)
          {
            this->StreetNumber_.set (::std::move (r));
            continue;
          }
        }

        // Street
        //
        if (n.name () == L"Street" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Street_type > r (
            Street_traits::create (i, f, this));

          if (!this->Street_)
          {
            this->Street_.set (::std::move (r));
            continue;
          }
        }

        // PostalBox
        //
        if (n.name () == L"PostalBox" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PostalBox_type > r (
            PostalBox_traits::create (i, f, this));

          if (!this->PostalBox_)
          {
            this->PostalBox_.set (::std::move (r));
            continue;
          }
        }

        // Town
        //
        if (n.name () == L"Town" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Town_type > r (
            Town_traits::create (i, f, this));

          if (!this->Town_)
          {
            this->Town_.set (::std::move (r));
            continue;
          }
        }

        // Region
        //
        if (n.name () == L"Region" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Region_type > r (
            Region_traits::create (i, f, this));

          if (!this->Region_)
          {
            this->Region_.set (::std::move (r));
            continue;
          }
        }

        // PostalCode
        //
        if (n.name () == L"PostalCode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PostalCode_type > r (
            PostalCode_traits::create (i, f, this));

          if (!this->PostalCode_)
          {
            this->PostalCode_.set (::std::move (r));
            continue;
          }
        }

        // Country
        //
        if (n.name () == L"Country" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Country_type > r (
            Country_traits::create (i, f, this));

          if (!this->Country_)
          {
            this->Country_.set (::std::move (r));
            continue;
          }
        }

        // FacsimileNumber
        //
        if (n.name () == L"FacsimileNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FacsimileNumber_type > r (
            FacsimileNumber_traits::create (i, f, this));

          if (!this->FacsimileNumber_)
          {
            this->FacsimileNumber_.set (::std::move (r));
            continue;
          }
        }

        // TelephoneNumber
        //
        if (n.name () == L"TelephoneNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TelephoneNumber_type > r (
            TelephoneNumber_traits::create (i, f, this));

          if (!this->TelephoneNumber_)
          {
            this->TelephoneNumber_.set (::std::move (r));
            continue;
          }
        }

        // ElectronicMailAddress
        //
        if (n.name () == L"ElectronicMailAddress" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElectronicMailAddress_type > r (
            ElectronicMailAddress_traits::create (i, f, this));

          if (!this->ElectronicMailAddress_)
          {
            this->ElectronicMailAddress_.set (::std::move (r));
            continue;
          }
        }

        // TelexNumber
        //
        if (n.name () == L"TelexNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TelexNumber_type > r (
            TelexNumber_traits::create (i, f, this));

          if (!this->TelexNumber_)
          {
            this->TelexNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PhysicalAddressType* PhysicalAddressType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PhysicalAddressType (*this, f, c);
    }

    PhysicalAddressType& PhysicalAddressType::
    operator= (const PhysicalAddressType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Description_ = x.Description_;
        this->InternalLocation_ = x.InternalLocation_;
        this->StreetNumber_ = x.StreetNumber_;
        this->Street_ = x.Street_;
        this->PostalBox_ = x.PostalBox_;
        this->Town_ = x.Town_;
        this->Region_ = x.Region_;
        this->PostalCode_ = x.PostalCode_;
        this->Country_ = x.Country_;
        this->FacsimileNumber_ = x.FacsimileNumber_;
        this->TelephoneNumber_ = x.TelephoneNumber_;
        this->ElectronicMailAddress_ = x.ElectronicMailAddress_;
        this->TelexNumber_ = x.TelexNumber_;
      }

      return *this;
    }

    PhysicalAddressType::
    ~PhysicalAddressType ()
    {
    }

    // AddressDescriptionEnumType
    //

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType* AddressDescriptionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AddressDescriptionEnumType (*this, f, c);
    }

    AddressDescriptionEnumType::value AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AddressDescriptionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AddressDescriptionEnumType_indexes_,
                        _xsd_AddressDescriptionEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_AddressDescriptionEnumType_indexes_ + 4 || _xsd_AddressDescriptionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_literals_[4] =
    {
      L"DELIVERY",
      L"POSTAL",
      L"VISITOR",
      L"NOTDEFINED"
    };

    const AddressDescriptionEnumType::value AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_indexes_[4] =
    {
      ::xsd::qif30::AddressDescriptionEnumType::DELIVERY,
      ::xsd::qif30::AddressDescriptionEnumType::NOTDEFINED,
      ::xsd::qif30::AddressDescriptionEnumType::POSTAL,
      ::xsd::qif30::AddressDescriptionEnumType::VISITOR
    };

    // AddressDescriptionType
    //

    AddressDescriptionType::
    AddressDescriptionType ()
    : ::xml_schema::type (),
      AddressDescriptionEnum_ (this),
      OtherAddressDescription_ (this)
    {
    }

    AddressDescriptionType::
    AddressDescriptionType (const AddressDescriptionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AddressDescriptionEnum_ (x.AddressDescriptionEnum_, f, this),
      OtherAddressDescription_ (x.OtherAddressDescription_, f, this)
    {
    }

    AddressDescriptionType::
    AddressDescriptionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AddressDescriptionEnum_ (this),
      OtherAddressDescription_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AddressDescriptionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AddressDescriptionEnum
        //
        if (n.name () == L"AddressDescriptionEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AddressDescriptionEnum_type > r (
            AddressDescriptionEnum_traits::create (i, f, this));

          if (!this->AddressDescriptionEnum_)
          {
            this->AddressDescriptionEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherAddressDescription
        //
        if (n.name () == L"OtherAddressDescription" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherAddressDescription_type > r (
            OtherAddressDescription_traits::create (i, f, this));

          if (!this->OtherAddressDescription_)
          {
            this->OtherAddressDescription_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AddressDescriptionType* AddressDescriptionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AddressDescriptionType (*this, f, c);
    }

    AddressDescriptionType& AddressDescriptionType::
    operator= (const AddressDescriptionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AddressDescriptionEnum_ = x.AddressDescriptionEnum_;
        this->OtherAddressDescription_ = x.OtherAddressDescription_;
      }

      return *this;
    }

    AddressDescriptionType::
    ~AddressDescriptionType ()
    {
    }

    // LocationType
    //

    LocationType::
    LocationType ()
    : ::xml_schema::type (),
      LocationDescription_ (this),
      Address_ (this),
      id_ (this)
    {
    }

    LocationType::
    LocationType (const LocationDescription_type& LocationDescription,
                  const id_type& id)
    : ::xml_schema::type (),
      LocationDescription_ (LocationDescription, this),
      Address_ (this),
      id_ (id, this)
    {
    }

    LocationType::
    LocationType (const LocationType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocationDescription_ (x.LocationDescription_, f, this),
      Address_ (x.Address_, f, this),
      id_ (x.id_, f, this)
    {
    }

    LocationType::
    LocationType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocationDescription_ (this),
      Address_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LocationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LocationDescription
        //
        if (n.name () == L"LocationDescription" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocationDescription_type > r (
            LocationDescription_traits::create (i, f, this));

          if (!LocationDescription_.present ())
          {
            this->LocationDescription_.set (::std::move (r));
            continue;
          }
        }

        // Address
        //
        if (n.name () == L"Address" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LocationDescription_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LocationDescription",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    LocationType* LocationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocationType (*this, f, c);
    }

    LocationType& LocationType::
    operator= (const LocationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LocationDescription_ = x.LocationDescription_;
        this->Address_ = x.Address_;
        this->id_ = x.id_;
      }

      return *this;
    }

    LocationType::
    ~LocationType ()
    {
    }

    // CustomerOrganizationType
    //

    CustomerOrganizationType::
    CustomerOrganizationType ()
    : ::xsd::qif30::OrganizationType (),
      CustomerNumber_ (this)
    {
    }

    CustomerOrganizationType::
    CustomerOrganizationType (const Name_type& Name,
                              const CustomerNumber_type& CustomerNumber)
    : ::xsd::qif30::OrganizationType (Name),
      CustomerNumber_ (CustomerNumber, this)
    {
    }

    CustomerOrganizationType::
    CustomerOrganizationType (const CustomerOrganizationType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::OrganizationType (x, f, c),
      CustomerNumber_ (x.CustomerNumber_, f, this)
    {
    }

    CustomerOrganizationType::
    CustomerOrganizationType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::OrganizationType (e, f | ::xml_schema::flags::base, c),
      CustomerNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CustomerOrganizationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::OrganizationType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CustomerNumber
        //
        if (n.name () == L"CustomerNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CustomerNumber_type > r (
            CustomerNumber_traits::create (i, f, this));

          if (!CustomerNumber_.present ())
          {
            this->CustomerNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CustomerNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CustomerNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CustomerOrganizationType* CustomerOrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CustomerOrganizationType (*this, f, c);
    }

    CustomerOrganizationType& CustomerOrganizationType::
    operator= (const CustomerOrganizationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::OrganizationType& > (*this) = x;
        this->CustomerNumber_ = x.CustomerNumber_;
      }

      return *this;
    }

    CustomerOrganizationType::
    ~CustomerOrganizationType ()
    {
    }

    // VersionHistoryType
    //

    VersionHistoryType::
    VersionHistoryType ()
    : ::xml_schema::type (),
      EarlierVersion_ (this),
      n_ (this)
    {
    }

    VersionHistoryType::
    VersionHistoryType (const n_type& n)
    : ::xml_schema::type (),
      EarlierVersion_ (this),
      n_ (n, this)
    {
    }

    VersionHistoryType::
    VersionHistoryType (const VersionHistoryType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EarlierVersion_ (x.EarlierVersion_, f, this),
      n_ (x.n_, f, this)
    {
    }

    VersionHistoryType::
    VersionHistoryType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EarlierVersion_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VersionHistoryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EarlierVersion
        //
        if (n.name () == L"EarlierVersion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EarlierVersion_type > r (
            EarlierVersion_traits::create (i, f, this));

          this->EarlierVersion_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    VersionHistoryType* VersionHistoryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionHistoryType (*this, f, c);
    }

    VersionHistoryType& VersionHistoryType::
    operator= (const VersionHistoryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EarlierVersion_ = x.EarlierVersion_;
        this->n_ = x.n_;
      }

      return *this;
    }

    VersionHistoryType::
    ~VersionHistoryType ()
    {
    }

    // VersionBaseType
    //

    VersionBaseType::
    VersionBaseType ()
    : ::xml_schema::type (),
      TimeCreated_ (this),
      SignOffs_ (this)
    {
    }

    VersionBaseType::
    VersionBaseType (const VersionBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TimeCreated_ (x.TimeCreated_, f, this),
      SignOffs_ (x.SignOffs_, f, this)
    {
    }

    VersionBaseType::
    VersionBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TimeCreated_ (this),
      SignOffs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TimeCreated
        //
        if (n.name () == L"TimeCreated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeCreated_type > r (
            TimeCreated_traits::create (i, f, this));

          if (!this->TimeCreated_)
          {
            this->TimeCreated_.set (::std::move (r));
            continue;
          }
        }

        // SignOffs
        //
        if (n.name () == L"SignOffs" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignOffs_type > r (
            SignOffs_traits::create (i, f, this));

          if (!this->SignOffs_)
          {
            this->SignOffs_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    VersionBaseType* VersionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionBaseType (*this, f, c);
    }

    VersionBaseType& VersionBaseType::
    operator= (const VersionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TimeCreated_ = x.TimeCreated_;
        this->SignOffs_ = x.SignOffs_;
      }

      return *this;
    }

    VersionBaseType::
    ~VersionBaseType ()
    {
    }

    // VersionType
    //

    VersionType::
    VersionType ()
    : ::xsd::qif30::VersionBaseType (),
      ThisInstanceQPId_ (this)
    {
    }

    VersionType::
    VersionType (const VersionType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::VersionBaseType (x, f, c),
      ThisInstanceQPId_ (x.ThisInstanceQPId_, f, this)
    {
    }

    VersionType::
    VersionType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::VersionBaseType (e, f | ::xml_schema::flags::base, c),
      ThisInstanceQPId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::VersionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThisInstanceQPId
        //
        if (n.name () == L"ThisInstanceQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThisInstanceQPId_type > r (
            ThisInstanceQPId_traits::create (i, f, this));

          if (!this->ThisInstanceQPId_)
          {
            this->ThisInstanceQPId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    VersionType* VersionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionType (*this, f, c);
    }

    VersionType& VersionType::
    operator= (const VersionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::VersionBaseType& > (*this) = x;
        this->ThisInstanceQPId_ = x.ThisInstanceQPId_;
      }

      return *this;
    }

    VersionType::
    ~VersionType ()
    {
    }

    // VersionReferenceType
    //

    VersionReferenceType::
    VersionReferenceType ()
    : ::xsd::qif30::VersionBaseType (),
      QPIdReference_ (this)
    {
    }

    VersionReferenceType::
    VersionReferenceType (const VersionReferenceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::VersionBaseType (x, f, c),
      QPIdReference_ (x.QPIdReference_, f, this)
    {
    }

    VersionReferenceType::
    VersionReferenceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::VersionBaseType (e, f | ::xml_schema::flags::base, c),
      QPIdReference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::VersionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // QPIdReference
        //
        if (n.name () == L"QPIdReference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< QPIdReference_type > r (
            QPIdReference_traits::create (i, f, this));

          if (!this->QPIdReference_)
          {
            this->QPIdReference_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    VersionReferenceType* VersionReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionReferenceType (*this, f, c);
    }

    VersionReferenceType& VersionReferenceType::
    operator= (const VersionReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::VersionBaseType& > (*this) = x;
        this->QPIdReference_ = x.QPIdReference_;
      }

      return *this;
    }

    VersionReferenceType::
    ~VersionReferenceType ()
    {
    }

    // SignOffsType
    //

    SignOffsType::
    SignOffsType ()
    : ::xml_schema::type (),
      Employee_ (this),
      n_ (this)
    {
    }

    SignOffsType::
    SignOffsType (const n_type& n)
    : ::xml_schema::type (),
      Employee_ (this),
      n_ (n, this)
    {
    }

    SignOffsType::
    SignOffsType (const SignOffsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Employee_ (x.Employee_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SignOffsType::
    SignOffsType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Employee_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignOffsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Employee
        //
        if (n.name () == L"Employee" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Employee_type > r (
            Employee_traits::create (i, f, this));

          this->Employee_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SignOffsType* SignOffsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignOffsType (*this, f, c);
    }

    SignOffsType& SignOffsType::
    operator= (const SignOffsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Employee_ = x.Employee_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SignOffsType::
    ~SignOffsType ()
    {
    }

    // MaterialClassEnumType
    //

    MaterialClassEnumType::
    MaterialClassEnumType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MaterialClassEnumType_convert ();
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MaterialClassEnumType_convert ();
    }

    MaterialClassEnumType::
    MaterialClassEnumType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MaterialClassEnumType_convert ();
    }

    MaterialClassEnumType* MaterialClassEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaterialClassEnumType (*this, f, c);
    }

    MaterialClassEnumType::value MaterialClassEnumType::
    _xsd_MaterialClassEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_MaterialClassEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MaterialClassEnumType_indexes_,
                        _xsd_MaterialClassEnumType_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_MaterialClassEnumType_indexes_ + 9 || _xsd_MaterialClassEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const MaterialClassEnumType::
    _xsd_MaterialClassEnumType_literals_[9] =
    {
      L"PLASTIC",
      L"METAL",
      L"WOOD",
      L"STONE",
      L"RUBBER",
      L"COMPOSITE",
      L"FOAM",
      L"CERAMIC",
      L"GLASS"
    };

    const MaterialClassEnumType::value MaterialClassEnumType::
    _xsd_MaterialClassEnumType_indexes_[9] =
    {
      ::xsd::qif30::MaterialClassEnumType::CERAMIC,
      ::xsd::qif30::MaterialClassEnumType::COMPOSITE,
      ::xsd::qif30::MaterialClassEnumType::FOAM,
      ::xsd::qif30::MaterialClassEnumType::GLASS,
      ::xsd::qif30::MaterialClassEnumType::METAL,
      ::xsd::qif30::MaterialClassEnumType::PLASTIC,
      ::xsd::qif30::MaterialClassEnumType::RUBBER,
      ::xsd::qif30::MaterialClassEnumType::STONE,
      ::xsd::qif30::MaterialClassEnumType::WOOD
    };

    // MaterialType
    //

    MaterialType::
    MaterialType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      MaterialClassEnum_ (this),
      OtherMaterialClass_ (this),
      Description_ (this),
      MassDensity_ (this),
      PoissonsRatio_ (this),
      YoungsModulus_ (this),
      UltimateTensileStress_ (this),
      CompressiveYieldStress_ (this),
      TensileYieldStress_ (this),
      ThermalExpansion_ (this),
      SpecificHeatCapacity_ (this),
      ThermalConductivity_ (this),
      Index_ (this),
      MaterialName_ (this)
    {
    }

    MaterialType::
    MaterialType (const Index_type& Index,
                  const MaterialName_type& MaterialName)
    : ::xml_schema::type (),
      Attributes_ (this),
      MaterialClassEnum_ (this),
      OtherMaterialClass_ (this),
      Description_ (this),
      MassDensity_ (this),
      PoissonsRatio_ (this),
      YoungsModulus_ (this),
      UltimateTensileStress_ (this),
      CompressiveYieldStress_ (this),
      TensileYieldStress_ (this),
      ThermalExpansion_ (this),
      SpecificHeatCapacity_ (this),
      ThermalConductivity_ (this),
      Index_ (Index, this),
      MaterialName_ (MaterialName, this)
    {
    }

    MaterialType::
    MaterialType (const MaterialType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      MaterialClassEnum_ (x.MaterialClassEnum_, f, this),
      OtherMaterialClass_ (x.OtherMaterialClass_, f, this),
      Description_ (x.Description_, f, this),
      MassDensity_ (x.MassDensity_, f, this),
      PoissonsRatio_ (x.PoissonsRatio_, f, this),
      YoungsModulus_ (x.YoungsModulus_, f, this),
      UltimateTensileStress_ (x.UltimateTensileStress_, f, this),
      CompressiveYieldStress_ (x.CompressiveYieldStress_, f, this),
      TensileYieldStress_ (x.TensileYieldStress_, f, this),
      ThermalExpansion_ (x.ThermalExpansion_, f, this),
      SpecificHeatCapacity_ (x.SpecificHeatCapacity_, f, this),
      ThermalConductivity_ (x.ThermalConductivity_, f, this),
      Index_ (x.Index_, f, this),
      MaterialName_ (x.MaterialName_, f, this)
    {
    }

    MaterialType::
    MaterialType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      MaterialClassEnum_ (this),
      OtherMaterialClass_ (this),
      Description_ (this),
      MassDensity_ (this),
      PoissonsRatio_ (this),
      YoungsModulus_ (this),
      UltimateTensileStress_ (this),
      CompressiveYieldStress_ (this),
      TensileYieldStress_ (this),
      ThermalExpansion_ (this),
      SpecificHeatCapacity_ (this),
      ThermalConductivity_ (this),
      Index_ (this),
      MaterialName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MaterialType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // MaterialClassEnum
        //
        if (n.name () == L"MaterialClassEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaterialClassEnum_type > r (
            MaterialClassEnum_traits::create (i, f, this));

          if (!this->MaterialClassEnum_)
          {
            this->MaterialClassEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherMaterialClass
        //
        if (n.name () == L"OtherMaterialClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherMaterialClass_type > r (
            OtherMaterialClass_traits::create (i, f, this));

          if (!this->OtherMaterialClass_)
          {
            this->OtherMaterialClass_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // MassDensity
        //
        if (n.name () == L"MassDensity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->MassDensity_)
          {
            this->MassDensity_.set (MassDensity_traits::create (i, f, this));
            continue;
          }
        }

        // PoissonsRatio
        //
        if (n.name () == L"PoissonsRatio" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->PoissonsRatio_)
          {
            this->PoissonsRatio_.set (PoissonsRatio_traits::create (i, f, this));
            continue;
          }
        }

        // YoungsModulus
        //
        if (n.name () == L"YoungsModulus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->YoungsModulus_)
          {
            this->YoungsModulus_.set (YoungsModulus_traits::create (i, f, this));
            continue;
          }
        }

        // UltimateTensileStress
        //
        if (n.name () == L"UltimateTensileStress" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->UltimateTensileStress_)
          {
            this->UltimateTensileStress_.set (UltimateTensileStress_traits::create (i, f, this));
            continue;
          }
        }

        // CompressiveYieldStress
        //
        if (n.name () == L"CompressiveYieldStress" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->CompressiveYieldStress_)
          {
            this->CompressiveYieldStress_.set (CompressiveYieldStress_traits::create (i, f, this));
            continue;
          }
        }

        // TensileYieldStress
        //
        if (n.name () == L"TensileYieldStress" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->TensileYieldStress_)
          {
            this->TensileYieldStress_.set (TensileYieldStress_traits::create (i, f, this));
            continue;
          }
        }

        // ThermalExpansion
        //
        if (n.name () == L"ThermalExpansion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ThermalExpansion_)
          {
            this->ThermalExpansion_.set (ThermalExpansion_traits::create (i, f, this));
            continue;
          }
        }

        // SpecificHeatCapacity
        //
        if (n.name () == L"SpecificHeatCapacity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SpecificHeatCapacity_)
          {
            this->SpecificHeatCapacity_.set (SpecificHeatCapacity_traits::create (i, f, this));
            continue;
          }
        }

        // ThermalConductivity
        //
        if (n.name () == L"ThermalConductivity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ThermalConductivity_)
          {
            this->ThermalConductivity_.set (ThermalConductivity_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Index" && n.namespace_ ().empty ())
        {
          this->Index_.set (Index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"MaterialName" && n.namespace_ ().empty ())
        {
          this->MaterialName_.set (MaterialName_traits::create (i, f, this));
          continue;
        }
      }

      if (!Index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Index",
          L"");
      }

      if (!MaterialName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"MaterialName",
          L"");
      }
    }

    MaterialType* MaterialType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaterialType (*this, f, c);
    }

    MaterialType& MaterialType::
    operator= (const MaterialType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->MaterialClassEnum_ = x.MaterialClassEnum_;
        this->OtherMaterialClass_ = x.OtherMaterialClass_;
        this->Description_ = x.Description_;
        this->MassDensity_ = x.MassDensity_;
        this->PoissonsRatio_ = x.PoissonsRatio_;
        this->YoungsModulus_ = x.YoungsModulus_;
        this->UltimateTensileStress_ = x.UltimateTensileStress_;
        this->CompressiveYieldStress_ = x.CompressiveYieldStress_;
        this->TensileYieldStress_ = x.TensileYieldStress_;
        this->ThermalExpansion_ = x.ThermalExpansion_;
        this->SpecificHeatCapacity_ = x.SpecificHeatCapacity_;
        this->ThermalConductivity_ = x.ThermalConductivity_;
        this->Index_ = x.Index_;
        this->MaterialName_ = x.MaterialName_;
      }

      return *this;
    }

    MaterialType::
    ~MaterialType ()
    {
    }

    // MaterialsType
    //

    MaterialsType::
    MaterialsType ()
    : ::xml_schema::type (),
      Material_ (this),
      n_ (this)
    {
    }

    MaterialsType::
    MaterialsType (const n_type& n)
    : ::xml_schema::type (),
      Material_ (this),
      n_ (n, this)
    {
    }

    MaterialsType::
    MaterialsType (const MaterialsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Material_ (x.Material_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MaterialsType::
    MaterialsType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Material_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MaterialsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Material
        //
        if (n.name () == L"Material" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Material_type > r (
            Material_traits::create (i, f, this));

          this->Material_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MaterialsType* MaterialsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaterialsType (*this, f, c);
    }

    MaterialsType& MaterialsType::
    operator= (const MaterialsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Material_ = x.Material_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MaterialsType::
    ~MaterialsType ()
    {
    }

    // VirtualMeasurementType
    //

    VirtualMeasurementType::
    VirtualMeasurementType ()
    : ::xml_schema::type (),
      id_ (this)
    {
    }

    VirtualMeasurementType::
    VirtualMeasurementType (const id_type& id)
    : ::xml_schema::type (),
      id_ (id, this)
    {
    }

    VirtualMeasurementType::
    VirtualMeasurementType (const VirtualMeasurementType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    VirtualMeasurementType::
    VirtualMeasurementType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void VirtualMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    VirtualMeasurementType* VirtualMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VirtualMeasurementType (*this, f, c);
    }

    VirtualMeasurementType& VirtualMeasurementType::
    operator= (const VirtualMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    VirtualMeasurementType::
    ~VirtualMeasurementType ()
    {
    }

    // PointSetReferenceBaseType
    //

    PointSetReferenceBaseType::
    PointSetReferenceBaseType ()
    : ::xsd::qif30::QIFReferenceType ()
    {
    }

    PointSetReferenceBaseType::
    PointSetReferenceBaseType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFReferenceType (_xsd_unsigned_int_base)
    {
    }

    PointSetReferenceBaseType::
    PointSetReferenceBaseType (const PointSetReferenceBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (x, f, c)
    {
    }

    PointSetReferenceBaseType::
    PointSetReferenceBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (e, f, c)
    {
    }

    PointSetReferenceBaseType::
    ~PointSetReferenceBaseType ()
    {
    }

    // PointSetReferenceWholeType
    //

    PointSetReferenceWholeType::
    PointSetReferenceWholeType ()
    : ::xsd::qif30::PointSetReferenceBaseType ()
    {
    }

    PointSetReferenceWholeType::
    PointSetReferenceWholeType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::PointSetReferenceBaseType (_xsd_unsigned_int_base)
    {
    }

    PointSetReferenceWholeType::
    PointSetReferenceWholeType (const PointSetReferenceWholeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (x, f, c)
    {
    }

    PointSetReferenceWholeType::
    PointSetReferenceWholeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (e, f, c)
    {
    }

    PointSetReferenceWholeType* PointSetReferenceWholeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSetReferenceWholeType (*this, f, c);
    }

    PointSetReferenceWholeType::
    ~PointSetReferenceWholeType ()
    {
    }

    // PointSetReferenceRangeType
    //

    PointSetReferenceRangeType::
    PointSetReferenceRangeType ()
    : ::xsd::qif30::PointSetReferenceBaseType (),
      range_ (this)
    {
    }

    PointSetReferenceRangeType::
    PointSetReferenceRangeType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base,
                                const range_type& range)
    : ::xsd::qif30::PointSetReferenceBaseType (_xsd_unsigned_int_base),
      range_ (range, this)
    {
    }

    PointSetReferenceRangeType::
    PointSetReferenceRangeType (const PointSetReferenceRangeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (x, f, c),
      range_ (x.range_, f, this)
    {
    }

    PointSetReferenceRangeType::
    PointSetReferenceRangeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      range_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PointSetReferenceRangeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointSetReferenceBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"range" && n.namespace_ ().empty ())
        {
          this->range_.set (range_traits::create (i, f, this));
          continue;
        }
      }

      if (!range_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"range",
          L"");
      }
    }

    PointSetReferenceRangeType* PointSetReferenceRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSetReferenceRangeType (*this, f, c);
    }

    PointSetReferenceRangeType& PointSetReferenceRangeType::
    operator= (const PointSetReferenceRangeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointSetReferenceBaseType& > (*this) = x;
        this->range_ = x.range_;
      }

      return *this;
    }

    PointSetReferenceRangeType::
    ~PointSetReferenceRangeType ()
    {
    }

    // PointSetReferenceSingleType
    //

    PointSetReferenceSingleType::
    PointSetReferenceSingleType ()
    : ::xsd::qif30::PointSetReferenceBaseType (),
      index_ (this)
    {
    }

    PointSetReferenceSingleType::
    PointSetReferenceSingleType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base,
                                 const index_type& index)
    : ::xsd::qif30::PointSetReferenceBaseType (_xsd_unsigned_int_base),
      index_ (index, this)
    {
    }

    PointSetReferenceSingleType::
    PointSetReferenceSingleType (const PointSetReferenceSingleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (x, f, c),
      index_ (x.index_, f, this)
    {
    }

    PointSetReferenceSingleType::
    PointSetReferenceSingleType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointSetReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      index_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PointSetReferenceSingleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointSetReferenceBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    PointSetReferenceSingleType* PointSetReferenceSingleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSetReferenceSingleType (*this, f, c);
    }

    PointSetReferenceSingleType& PointSetReferenceSingleType::
    operator= (const PointSetReferenceSingleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointSetReferenceBaseType& > (*this) = x;
        this->index_ = x.index_;
      }

      return *this;
    }

    PointSetReferenceSingleType::
    ~PointSetReferenceSingleType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const SequencedDatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimpleDatum
      //
      if (i.SimpleDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimpleDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SimpleDatum ();
      }

      // CompoundDatum
      //
      if (i.CompoundDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompoundDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CompoundDatum ();
      }

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompoundDatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Datum
      //
      for (CompoundDatumType::Datum_const_iterator
           b (i.Datum ().begin ()), n (i.Datum ().end ());
           b != n; ++b)
      {
        const CompoundDatumType::Datum_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Datum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // ReducedDatum
      //
      if (i.ReducedDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReducedDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReducedDatum ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumWithPrecedenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimpleDatum
      //
      if (i.SimpleDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimpleDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SimpleDatum ();
      }

      // NominalDatumFeature
      //
      if (i.NominalDatumFeature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalDatumFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalDatumFeature ();
      }

      // MeasuredDatumFeature
      //
      if (i.MeasuredDatumFeature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredDatumFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuredDatumFeature ();
      }

      // CompoundDatum
      //
      if (i.CompoundDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompoundDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CompoundDatum ();
      }

      // Precedence
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Precedence",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Precedence ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }

      // MaterialModifier
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaterialModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaterialModifier ();
      }

      // SizeCharacteristicDefinitionId
      //
      if (i.SizeCharacteristicDefinitionId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SizeCharacteristicDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SizeCharacteristicDefinitionId ();
      }

      // ReferencedComponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedComponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferencedComponent ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }

      // DatumFeatureSimulatorModifier
      //
      if (i.DatumFeatureSimulatorModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumFeatureSimulatorModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumFeatureSimulatorModifier ();
      }

      // DatumTranslation
      //
      if (i.DatumTranslation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTranslation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumTranslation ();
      }

      // DegreesOfFreedom
      //
      if (i.DegreesOfFreedom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DegreesOfFreedom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DegreesOfFreedom ();
      }

      // ProjectedDatum
      //
      if (i.ProjectedDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectedDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ProjectedDatum ();
      }

      // DiameterModifier
      //
      if (i.DiameterModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterModifier ();
      }

      // SectionModifier
      //
      if (i.SectionModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SectionModifier ();
      }

      // ContactingFeature
      //
      if (i.ContactingFeature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ContactingFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ContactingFeature ();
      }

      // DistanceVariable
      //
      if (i.DistanceVariable ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DistanceVariable",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DistanceVariable ();
      }

      // DatumFixed
      //
      if (i.DatumFixed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumFixed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumFixed ();
      }

      // ReducedDatum
      //
      if (i.ReducedDatum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReducedDatum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReducedDatum ();
      }

      // ConstrainOrientation
      //
      if (i.ConstrainOrientation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ConstrainOrientation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ConstrainOrientation ();
      }

      // ConstrainSubsequent
      //
      if (i.ConstrainSubsequent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ConstrainSubsequent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ConstrainSubsequent ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumTranslationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTranslationAllowed
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTranslationAllowed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumTranslationAllowed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumFeatureBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureNominalId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureNominalId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredDatumFeatureType& i)
    {
      e << static_cast< const ::xsd::qif30::DatumFeatureBaseType& > (i);

      // MaterialModifier
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaterialModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaterialModifier ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NominalDatumFeatureType& i)
    {
      e << static_cast< const ::xsd::qif30::DatumFeatureBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumFeatureSimulatorModifierType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearSize
      //
      if (i.LinearSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearSize ();
      }

      // DiametricalSize
      //
      if (i.DiametricalSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiametricalSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiametricalSize ();
      }

      // BasicSize
      //
      if (i.BasicSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasicSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BasicSize ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Datum
      //
      for (DatumsType::Datum_const_iterator
           b (i.Datum ().begin ()), n (i.Datum ().end ());
           b != n; ++b)
      {
        const DatumsType::Datum_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Datum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumReferenceFrameType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Datums
      //
      if (i.Datums ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Datums",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Datums ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // CoordinateSystemId
      //
      if (i.CoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemId ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DegreeOfFreedomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DegreeOfFreedomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DegreeOfFreedomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ISODegreeOfFreedomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ISODegreeOfFreedomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ISODegreeOfFreedomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const IntersectionPlaneEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const IntersectionPlaneEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const IntersectionPlaneEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const IntersectionPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IntersectionPlaneEnum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionPlaneEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ModifyingPlaneEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ModifyingPlaneEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ModifyingPlaneEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DirectionFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DirectionFeatureEnum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirectionFeatureEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirectionFeatureEnum ();
      }

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CollectionPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CollectionPlaneEnum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CollectionPlaneEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CollectionPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OrientationPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // OrientationPlaneEnum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OrientationPlaneEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OrientationPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ReducedDatumEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ReducedDatumEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ReducedDatumEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DegreesOfFreedomType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DegreeOfFreedom
      //
      for (DegreesOfFreedomType::DegreeOfFreedom_const_iterator
           b (i.DegreeOfFreedom ().begin ()), n (i.DegreeOfFreedom ().end ());
           b != n; ++b)
      {
        const DegreesOfFreedomType::DegreeOfFreedom_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DegreeOfFreedom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // ISODegreeOfFreedom
      //
      for (DegreesOfFreedomType::ISODegreeOfFreedom_const_iterator
           b (i.ISODegreeOfFreedom ().begin ()), n (i.ISODegreeOfFreedom ().end ());
           b != n; ++b)
      {
        const DegreesOfFreedomType::ISODegreeOfFreedom_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ISODegreeOfFreedom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DiameterModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DiameterModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DiameterModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SectionModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SectionModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointWithNormalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPointWithNormalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurePointNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PointWithNormalBaseType& > (i);

      // MeasurementDeviceId
      //
      if (i.MeasurementDeviceId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceId ();
      }

      // SensorId
      //
      if (i.SensorId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SensorId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SensorId ();
      }

      // TipId
      //
      if (i.TipId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MovableDatumTargetDirectionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTargetTranslationDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTargetTranslationDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumTargetTranslationDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DefiningPointNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PointWithNormalBaseType& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DefiningPointMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredPointWithNormalBaseType& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transform
      //
      for (TransformListType::Transform_const_iterator
           b (i.Transform ().begin ()), n (i.Transform ().end ());
           b != n; ++b)
      {
        const TransformListType::Transform_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformInstanceType& i)
    {
      e << static_cast< const ::xsd::qif30::TransformMatrixType& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearCoordinateDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LinearCoordinateDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LinearCoordinateDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const AngularCoordinateDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AngularCoordinateDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AngularCoordinateDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SubstituteFeatureAlgorithmEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SubstituteFeatureAlgorithmEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SubstituteFeatureAlgorithmEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SubstituteFeatureAlgorithmType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // SubstituteFeatureAlgorithmEnum
      //
      if (i.SubstituteFeatureAlgorithmEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithmEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithmEnum ();
      }

      // SubstituteFeatureAlgorithmId
      //
      if (i.SubstituteFeatureAlgorithmId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithmId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithmId ();
      }

      // OtherSubstituteFeatureAlgorithm
      //
      if (i.OtherSubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherSubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherSubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MaterialModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const MaterialModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MaterialModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PrecedenceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PrecedenceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PrecedenceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PrecedenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrecedenceEnum
      //
      if (i.PrecedenceEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrecedenceEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PrecedenceEnum ();
      }

      // OtherPrecedence
      //
      if (i.OtherPrecedence ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherPrecedence",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherPrecedence ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ReferencedComponentEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ReferencedComponentEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ReferencedComponentEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const RetrievalMethodEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const RetrievalMethodEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const RetrievalMethodEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementDirectiveEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const MeasurementDirectiveEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MeasurementDirectiveEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementDirectiveType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurementDirectiveEnum
      //
      if (i.MeasurementDirectiveEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDirectiveEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDirectiveEnum ();
      }

      // OtherMeasurementDirective
      //
      if (i.OtherMeasurementDirective ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherMeasurementDirective",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherMeasurementDirective ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DistanceBetweenAnalysisModeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DistanceBetweenAnalysisModeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DistanceBetweenAnalysisModeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const AngleBetweenAnalysisModeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AngleBetweenAnalysisModeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AngleBetweenAnalysisModeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const BaseFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ReferencedComponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedComponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferencedComponent ();
      }

      // FeatureId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SequencedBaseFeatureType& i)
    {
      e << static_cast< const ::xsd::qif30::BaseFeatureType& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DirectionalOffsetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Offset
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Offset ();
      }

      // NominalDirection
      //
      if (i.NominalDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalDirection ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AlignmentFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinitionId
      //
      if (i.DatumDefinitionId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumDefinitionId ();
      }

      // BaseFeature
      //
      if (i.BaseFeature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AlignmentOperationBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PrimaryAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // PrimaryEntity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryEntity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PrimaryEntity ();
      }

      // PrimaryAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PrimaryAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignmentOperationType_type_serializer_init (
      L"PrimaryAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SecondaryAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // SecondaryEntity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondaryEntity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondaryEntity ();
      }

      // SecondaryAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondaryAxis ();
      }

      // RotationAxis
      //
      if (i.RotationAxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RotationAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RotationAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignmentOperationType_type_serializer_init (
      L"SecondaryAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasurementOriginOffsetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // OriginEntity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OriginEntity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OriginEntity ();
      }

      // OriginDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OriginDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OriginDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementOffsetAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // Origin
      //
      for (MeasurementOffsetAlignmentOperationType::Origin_const_iterator
           b (i.Origin ().begin ()), n (i.Origin ().end ());
           b != n; ++b)
      {
        const MeasurementOffsetAlignmentOperationType::Origin_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasurementOffsetAlignmentOperationType >
    _xsd_MeasurementOffsetAlignmentOperationType_type_serializer_init (
      L"MeasurementOffsetAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const NominalOffsetAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // Offset
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Offset ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NominalOffsetAlignmentOperationType >
    _xsd_NominalOffsetAlignmentOperationType_type_serializer_init (
      L"NominalOffsetAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const NominalRotationAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // RotationAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RotationAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RotationAxis ();
      }

      // Angle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Angle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Angle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NominalRotationAlignmentOperationType >
    _xsd_NominalRotationAlignmentOperationType_type_serializer_init (
      L"NominalRotationAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DatumPrecedenceAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // DatumReferenceFrameId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumReferenceFrameId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumReferenceFrameId ();
      }

      // PrimaryAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PrimaryAxis ();
      }

      // SecondaryAxis
      //
      if (i.SecondaryAxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SecondaryAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedenceAlignmentOperationType_type_serializer_init (
      L"DatumPrecedenceAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BestFitAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);

      // DegreesOfFreedom
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DegreesOfFreedom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DegreesOfFreedom ();
      }

      // BaseFeature
      //
      for (BestFitAlignmentOperationType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const BestFitAlignmentOperationType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BestFitAlignmentOperationType >
    _xsd_BestFitAlignmentOperationType_type_serializer_init (
      L"BestFitAlignmentOperationType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MachineCoordinateSystemOperationType& i)
    {
      e << static_cast< const ::xsd::qif30::AlignmentOperationBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MachineCoordinateSystemOperationType >
    _xsd_MachineCoordinateSystemOperationType_type_serializer_init (
      L"MachineCoordinateSystemOperationType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignment_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"PrimaryAlignment",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PrimaryAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignment_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"SecondaryAlignment",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SecondaryAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MeasurementOffsetAlignmentOperationType >
    _xsd_MeasurementOffset_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasurementOffset",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MeasurementOffsetAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::NominalOffsetAlignmentOperationType >
    _xsd_NominalOffset_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"NominalOffset",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::NominalOffsetAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::NominalRotationAlignmentOperationType >
    _xsd_NominalRotation_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"NominalRotation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::NominalRotationAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedence_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"DatumPrecedence",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DatumPrecedenceAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::BestFitAlignmentOperationType >
    _xsd_BestFit_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"BestFit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::BestFitAlignmentOperationType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MachineCoordinateSystemOperationType >
    _xsd_Machine_element_serializer_init (
      L"AlignmentOperation",
      L"http://qifstandards.org/xsd/qif3",
      L"Machine",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MachineCoordinateSystemOperationType >);


    void
    operator<< (xercesc::DOMElement& e, const AlignmentOperationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AlignmentOperation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AlignmentOperationsType::AlignmentOperation_const_iterator
             b (i.AlignmentOperation ().begin ()), n (i.AlignmentOperation ().end ());
             b != n; ++b)
        {
          const AlignmentOperationsType::AlignmentOperation_type& x (*b);

          if (typeid (AlignmentOperationsType::AlignmentOperation_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AlignmentOperation",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"AlignmentOperation",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // BaseCoordinateSystemId
      //
      if (i.BaseCoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BaseCoordinateSystemId ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MachineCoordinateSystemType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateSystemId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoordinateSystemId ();
      }

      // MeasurementDeviceId
      //
      if (i.MeasurementDeviceId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateSystem
      //
      for (CoordinateSystemListType::CoordinateSystem_const_iterator
           b (i.CoordinateSystem ().begin ()), n (i.CoordinateSystem ().end ());
           b != n; ++b)
      {
        const CoordinateSystemListType::CoordinateSystem_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystem",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateSystemDefinitions
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemDefinitions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoordinateSystemDefinitions ();
      }

      // CommonCoordinateSystemId
      //
      if (i.CommonCoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CommonCoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CommonCoordinateSystemId ();
      }

      // MachineCoordinateSystem
      //
      for (CoordinateSystemsType::MachineCoordinateSystem_const_iterator
           b (i.MachineCoordinateSystem ().begin ()), n (i.MachineCoordinateSystem ().end ());
           b != n; ++b)
      {
        const CoordinateSystemsType::MachineCoordinateSystem_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MachineCoordinateSystem",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // NominalTransform
      //
      if (i.NominalTransform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalTransform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalTransform ();
      }

      // InternalCADCoordinateSystemId
      //
      if (i.InternalCADCoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalCADCoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.InternalCADCoordinateSystemId ();
      }

      // ExternalCADCoordinateSystemId
      //
      if (i.ExternalCADCoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalCADCoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExternalCADCoordinateSystemId ();
      }

      // AlignmentOperations
      //
      if (i.AlignmentOperations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AlignmentOperations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AlignmentOperations ();
      }

      // SequenceNumber
      //
      if (i.SequenceNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SequenceNumber ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemActualTransformAssociationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ActualTransformId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActualTransformId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ActualTransformId ();
      }

      // CoordinateSystemId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoordinateSystemId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemActualTransformAssociationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateSystemActualTransformAssociation
      //
      for (CoordinateSystemActualTransformAssociationsType::CoordinateSystemActualTransformAssociation_const_iterator
           b (i.CoordinateSystemActualTransformAssociation ().begin ()), n (i.CoordinateSystemActualTransformAssociation ().end ());
           b != n; ++b)
      {
        const CoordinateSystemActualTransformAssociationsType::CoordinateSystemActualTransformAssociation_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemActualTransformAssociation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadSpecificationDetailedBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // ThreadSeries
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadSeries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadSeries ();
      }

      // ThreadToleranceClass
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadToleranceClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadToleranceClass ();
      }

      // CrestDiameterToleranceClass
      //
      if (i.CrestDiameterToleranceClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CrestDiameterToleranceClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CrestDiameterToleranceClass ();
      }

      // LeftHanded
      //
      if (i.LeftHanded ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LeftHanded",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LeftHanded ();
      }

      // ModifiedThread
      //
      if (i.ModifiedThread ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModifiedThread",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ModifiedThread ();
      }

      // ThreadLengthEngagement
      //
      if (i.ThreadLengthEngagement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadLengthEngagement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThreadLengthEngagement ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SingleLeadThreadSpecificationType& i)
    {
      e << static_cast< const ::xsd::qif30::ThreadSpecificationDetailedBaseType& > (i);

      // ThreadDensity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadDensity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadDensity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MultiLeadThreadSpecificationType& i)
    {
      e << static_cast< const ::xsd::qif30::ThreadSpecificationDetailedBaseType& > (i);

      // ThreadPitch
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadPitch",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadPitch ();
      }

      // ThreadLeadDistance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadLeadDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadLeadDistance ();
      }

      // ThreadLeadStarts
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadLeadStarts",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadLeadStarts ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SingleLeadSpecification
      //
      if (i.SingleLeadSpecification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SingleLeadSpecification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SingleLeadSpecification ();
      }

      // MultiLeadSpecification
      //
      if (i.MultiLeadSpecification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MultiLeadSpecification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MultiLeadSpecification ();
      }

      // TextThreadSpecification
      //
      if (i.TextThreadSpecification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TextThreadSpecification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TextThreadSpecification ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TextThreadSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TextSpecification
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TextSpecification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TextSpecification ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadSpecificationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadSpecification
      //
      for (ThreadSpecificationsType::ThreadSpecification_const_iterator
           b (i.ThreadSpecification ().begin ()), n (i.ThreadSpecification ().end ());
           b != n; ++b)
      {
        const ThreadSpecificationsType::ThreadSpecification_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadSpecification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToleranceZonePerUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToleranceValuePerUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // RectangularUnitArea
      //
      if (i.RectangularUnitArea ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RectangularUnitArea",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RectangularUnitArea ();
      }

      // CircularUnitArea
      //
      if (i.CircularUnitArea ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CircularUnitArea",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CircularUnitArea ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToleranceZonePerUnitLengthType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToleranceValuePerUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitLength ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToleranceZonePerUnitAngleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToleranceValuePerUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitAngle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToleranceZonePerUnitPolarAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToleranceValuePerUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitAngle ();
      }

      // UnitLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitLength ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumReferenceFramesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumReferenceFrame
      //
      for (DatumReferenceFramesType::DatumReferenceFrame_const_iterator
           b (i.DatumReferenceFrame ().begin ()), n (i.DatumReferenceFrame ().end ());
           b != n; ++b)
      {
        const DatumReferenceFramesType::DatumReferenceFrame_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumReferenceFrame",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EventBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Description
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Description ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NotableEventType& i)
    {
      e << static_cast< const ::xsd::qif30::EventBaseType& > (i);

      // Active
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Active",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Active ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NotableEventsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NotableEvent
      //
      for (NotableEventsType::NotableEvent_const_iterator
           b (i.NotableEvent ().begin ()), n (i.NotableEvent ().end ());
           b != n; ++b)
      {
        const NotableEventsType::NotableEvent_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NotableEvent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NotedEventType& i)
    {
      e << static_cast< const ::xsd::qif30::EventBaseType& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }

      // TimeOccurred
      //
      if (i.TimeOccurred ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeOccurred",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeOccurred ();
      }

      // NotableEventId
      //
      if (i.NotableEventId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NotableEventId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NotableEventId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NotedEventsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NotedEvent
      //
      for (NotedEventsType::NotedEvent_const_iterator
           b (i.NotedEvent ().begin ()), n (i.NotedEvent ().end ());
           b != n; ++b)
      {
        const NotedEventsType::NotedEvent_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NotedEvent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const InspectionStatusEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const InspectionStatusEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const InspectionStatusEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const InspectionStatusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // InspectionStatusEnum
      //
      if (i.InspectionStatusEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InspectionStatusEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.InspectionStatusEnum ();
      }

      // OtherInspectionStatus
      //
      if (i.OtherInspectionStatus ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherInspectionStatus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherInspectionStatus ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EntityExternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EntityId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EntityId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EntityId ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EntitiesExternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Entity
      //
      for (EntitiesExternalType::Entity_const_iterator
           b (i.Entity ().begin ()), n (i.Entity ().end ());
           b != n; ++b)
      {
        const EntitiesExternalType::Entity_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Entity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItemId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureItemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureItemId ();
      }

      // Bonus
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bonus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Bonus ();
      }

      // ReferenceLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferenceLength ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneDataSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ZoneData
      //
      for (ZoneDataSetType::ZoneData_const_iterator
           b (i.ZoneData ().begin ()), n (i.ZoneData ().end ());
           b != n; ++b)
      {
        const ZoneDataSetType::ZoneData_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZoneData",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MaxDualValue
      //
      if (i.MaxDualValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDualValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDualValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // MinDualValue
      //
      if (i.MinDualValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDualValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDualValue ();
      }

      // DefinitionId
      //
      if (i.DefinitionId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefinitionId ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearToleranceDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngularToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinitionId
      //
      if (i.DefinitionId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefinitionId ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngularToleranceDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperatureToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AreaToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ForceToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MassToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PressureToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SpeedToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TimeToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinedAsLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefinedAsLimit ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DimensionModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DimensionModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DimensionModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DimensionDeterminationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DimensionDeterminationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DimensionDeterminationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SignificantDimensionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SignificantDimensionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SignificantDimensionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DimensionModifiersType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DeterminationModifier
      //
      if (i.DeterminationModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeterminationModifier ();
      }

      // SignificanceModifier
      //
      if (i.SignificanceModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignificanceModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SignificanceModifier ();
      }

      // SectionModifier
      //
      if (i.SectionModifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionModifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SectionModifier ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NonToleranceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const NonToleranceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NonToleranceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LimitsAndFitsZoneVarianceType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LimitsAndFitsZoneVarianceType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LimitsAndFitsZoneVarianceType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LimitsAndFitsSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FormVariance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FormVariance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FormVariance ();
      }

      // Grade
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Grade",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Grade ();
      }

      // zoneVariance
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zoneVariance",
            e));

        a << i.zoneVariance ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CommonFileSpecEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CommonFileSpecEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CommonFileSpecEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const FileSpecType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CommonFileSpecEnum
      //
      if (i.CommonFileSpecEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CommonFileSpecEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CommonFileSpecEnum ();
      }

      // OtherFileSpec
      //
      if (i.OtherFileSpec ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherFileSpec",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherFileSpec ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExternalFileReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // URI
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"URI",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.URI ();
      }

      // FileSpec
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FileSpec",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FileSpec ();
      }

      // Description
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Description ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExternalFileReferencesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ExternalFileReference
      //
      for (ExternalFileReferencesType::ExternalFileReference_const_iterator
           b (i.ExternalFileReference ().begin ()), n (i.ExternalFileReference ().end ());
           b != n; ++b)
      {
        const ExternalFileReferencesType::ExternalFileReference_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalFileReference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumTargetDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTarget
      //
      for (DatumTargetDefinitionsType::DatumTarget_const_iterator
           b (i.DatumTarget ().begin ()), n (i.DatumTarget ().end ());
           b != n; ++b)
      {
        const DatumTargetDefinitionsType::DatumTarget_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTarget",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // DatumLabel
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumLabel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumLabel ();
      }

      // DatumTargetIds
      //
      if (i.DatumTargetIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTargetIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumTargetIds ();
      }

      // FeatureNominalIds
      //
      if (i.FeatureNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureNominalIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinition
      //
      for (DatumDefinitionsType::DatumDefinition_const_iterator
           b (i.DatumDefinition ().begin ()), n (i.DatumDefinition ().end ());
           b != n; ++b)
      {
        const DatumDefinitionsType::DatumDefinition_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinition",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DatumTargetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // DatumTargetLabel
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTargetLabel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumTargetLabel ();
      }

      // FeatureNominalId
      //
      if (i.FeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureNominalId ();
      }

      // TargetZoneId
      //
      if (i.TargetZoneId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TargetZoneId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TargetZoneId ();
      }

      // MovableDatumTarget
      //
      if (i.MovableDatumTarget ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MovableDatumTarget",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MovableDatumTarget ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EmployeeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // EmployeeId
      //
      if (i.EmployeeId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EmployeeId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EmployeeId ();
      }

      // Shift
      //
      if (i.Shift ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Shift",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Shift ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FileType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Format
      //
      if (i.Format ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Format",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Format ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SoftwareType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // VendorName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VendorName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VendorName ();
      }

      // ApplicationName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApplicationName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ApplicationName ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // URI
      //
      if (i.URI ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"URI",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.URI ();
      }

      // ReferencedStandardIds
      //
      if (i.ReferencedStandardIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedStandardIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReferencedStandardIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StandardsOrganizationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const StandardsOrganizationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const StandardsOrganizationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const StandardsOrganizationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StandardsOrganizationEnum
      //
      if (i.StandardsOrganizationEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardsOrganizationEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardsOrganizationEnum ();
      }

      // OtherStandardsOrganization
      //
      if (i.OtherStandardsOrganization ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherStandardsOrganization",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherStandardsOrganization ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StandardType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Organization
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Organization",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Organization ();
      }

      // Designator
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Designator",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Designator ();
      }

      // Year
      //
      if (i.Year ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Year",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Year ();
      }

      // Title
      //
      if (i.Title ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Title",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Title ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // URI
      //
      if (i.URI ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"URI",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.URI ();
      }

      // ISBN
      //
      if (i.ISBN ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ISBN",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ISBN ();
      }

      // ReferencedStandardIds
      //
      if (i.ReferencedStandardIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedStandardIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReferencedStandardIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StandardsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Standard
      //
      for (StandardsType::Standard_const_iterator
           b (i.Standard ().begin ()), n (i.Standard ().end ());
           b != n; ++b)
      {
        const StandardsType::Standard_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Standard",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SoftwaresType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Software
      //
      for (SoftwaresType::Software_const_iterator
           b (i.Software ().begin ()), n (i.Software ().end ());
           b != n; ++b)
      {
        const SoftwaresType::Software_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Software",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AlgorithmType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // SoftwareId
      //
      if (i.SoftwareId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SoftwareId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SoftwareId ();
      }

      // Parameters
      //
      if (i.Parameters ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parameters",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Parameters ();
      }

      // StandardId
      //
      if (i.StandardId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardId ();
      }

      // Section
      //
      if (i.Section ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Section",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Section ();
      }

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AlgorithmsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Algorithm
      //
      for (AlgorithmsType::Algorithm_const_iterator
           b (i.Algorithm ().begin ()), n (i.Algorithm ().end ());
           b != n; ++b)
      {
        const AlgorithmsType::Algorithm_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Algorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OrganizationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Address
      //
      if (i.Address ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Address",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Address ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PhysicalAddressType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // InternalLocation
      //
      if (i.InternalLocation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.InternalLocation ();
      }

      // StreetNumber
      //
      if (i.StreetNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StreetNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StreetNumber ();
      }

      // Street
      //
      if (i.Street ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Street",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Street ();
      }

      // PostalBox
      //
      if (i.PostalBox ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PostalBox",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PostalBox ();
      }

      // Town
      //
      if (i.Town ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Town",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Town ();
      }

      // Region
      //
      if (i.Region ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Region",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Region ();
      }

      // PostalCode
      //
      if (i.PostalCode ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PostalCode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PostalCode ();
      }

      // Country
      //
      if (i.Country ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Country",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Country ();
      }

      // FacsimileNumber
      //
      if (i.FacsimileNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FacsimileNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FacsimileNumber ();
      }

      // TelephoneNumber
      //
      if (i.TelephoneNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TelephoneNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TelephoneNumber ();
      }

      // ElectronicMailAddress
      //
      if (i.ElectronicMailAddress ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElectronicMailAddress",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ElectronicMailAddress ();
      }

      // TelexNumber
      //
      if (i.TelexNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TelexNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TelexNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AddressDescriptionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AddressDescriptionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AddressDescriptionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const AddressDescriptionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AddressDescriptionEnum
      //
      if (i.AddressDescriptionEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AddressDescriptionEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AddressDescriptionEnum ();
      }

      // OtherAddressDescription
      //
      if (i.OtherAddressDescription ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherAddressDescription",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherAddressDescription ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LocationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LocationDescription
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocationDescription",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LocationDescription ();
      }

      // Address
      //
      if (i.Address ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Address",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Address ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CustomerOrganizationType& i)
    {
      e << static_cast< const ::xsd::qif30::OrganizationType& > (i);

      // CustomerNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CustomerNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CustomerNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VersionHistoryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EarlierVersion
      //
      for (VersionHistoryType::EarlierVersion_const_iterator
           b (i.EarlierVersion ().begin ()), n (i.EarlierVersion ().end ());
           b != n; ++b)
      {
        const VersionHistoryType::EarlierVersion_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EarlierVersion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VersionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TimeCreated
      //
      if (i.TimeCreated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeCreated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeCreated ();
      }

      // SignOffs
      //
      if (i.SignOffs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignOffs",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SignOffs ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VersionType& i)
    {
      e << static_cast< const ::xsd::qif30::VersionBaseType& > (i);

      // ThisInstanceQPId
      //
      if (i.ThisInstanceQPId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThisInstanceQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThisInstanceQPId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VersionReferenceType& i)
    {
      e << static_cast< const ::xsd::qif30::VersionBaseType& > (i);

      // QPIdReference
      //
      if (i.QPIdReference ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"QPIdReference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.QPIdReference ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignOffsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Employee
      //
      for (SignOffsType::Employee_const_iterator
           b (i.Employee ().begin ()), n (i.Employee ().end ());
           b != n; ++b)
      {
        const SignOffsType::Employee_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Employee",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MaterialClassEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const MaterialClassEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MaterialClassEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MaterialType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // MaterialClassEnum
      //
      if (i.MaterialClassEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaterialClassEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaterialClassEnum ();
      }

      // OtherMaterialClass
      //
      if (i.OtherMaterialClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherMaterialClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherMaterialClass ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // MassDensity
      //
      if (i.MassDensity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassDensity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.MassDensity ());
      }

      // PoissonsRatio
      //
      if (i.PoissonsRatio ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PoissonsRatio",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.PoissonsRatio ());
      }

      // YoungsModulus
      //
      if (i.YoungsModulus ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YoungsModulus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.YoungsModulus ());
      }

      // UltimateTensileStress
      //
      if (i.UltimateTensileStress ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UltimateTensileStress",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.UltimateTensileStress ());
      }

      // CompressiveYieldStress
      //
      if (i.CompressiveYieldStress ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompressiveYieldStress",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.CompressiveYieldStress ());
      }

      // TensileYieldStress
      //
      if (i.TensileYieldStress ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TensileYieldStress",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.TensileYieldStress ());
      }

      // ThermalExpansion
      //
      if (i.ThermalExpansion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThermalExpansion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.ThermalExpansion ());
      }

      // SpecificHeatCapacity
      //
      if (i.SpecificHeatCapacity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpecificHeatCapacity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.SpecificHeatCapacity ());
      }

      // ThermalConductivity
      //
      if (i.ThermalConductivity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThermalConductivity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.ThermalConductivity ());
      }

      // Index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Index",
            e));

        a << i.Index ();
      }

      // MaterialName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"MaterialName",
            e));

        a << i.MaterialName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MaterialsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Material
      //
      for (MaterialsType::Material_const_iterator
           b (i.Material ().begin ()), n (i.Material ().end ());
           b != n; ++b)
      {
        const MaterialsType::Material_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Material",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VirtualMeasurementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetReferenceBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFReferenceType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetReferenceWholeType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSetReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetReferenceRangeType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSetReferenceBaseType& > (i);

      // range
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"range",
            e));

        a << i.range ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetReferenceSingleType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSetReferenceBaseType& > (i);

      // index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

