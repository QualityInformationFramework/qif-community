// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Visualization.hxx"

namespace xsd
{
  namespace qif30
  {
    // VisualizationSetType
    //

    const VisualizationSetType::Fonts_type& VisualizationSetType::
    Fonts () const
    {
      return this->Fonts_.get ();
    }

    VisualizationSetType::Fonts_type& VisualizationSetType::
    Fonts ()
    {
      return this->Fonts_.get ();
    }

    void VisualizationSetType::
    Fonts (const Fonts_type& x)
    {
      this->Fonts_.set (x);
    }

    void VisualizationSetType::
    Fonts (::std::unique_ptr< Fonts_type > x)
    {
      this->Fonts_.set (std::move (x));
    }

    const VisualizationSetType::TrailingZeroDisplay_optional& VisualizationSetType::
    TrailingZeroDisplay () const
    {
      return this->TrailingZeroDisplay_;
    }

    VisualizationSetType::TrailingZeroDisplay_optional& VisualizationSetType::
    TrailingZeroDisplay ()
    {
      return this->TrailingZeroDisplay_;
    }

    void VisualizationSetType::
    TrailingZeroDisplay (const TrailingZeroDisplay_type& x)
    {
      this->TrailingZeroDisplay_.set (x);
    }

    void VisualizationSetType::
    TrailingZeroDisplay (const TrailingZeroDisplay_optional& x)
    {
      this->TrailingZeroDisplay_ = x;
    }

    void VisualizationSetType::
    TrailingZeroDisplay (::std::unique_ptr< TrailingZeroDisplay_type > x)
    {
      this->TrailingZeroDisplay_.set (std::move (x));
    }

    const VisualizationSetType::PMIDisplaySet_type& VisualizationSetType::
    PMIDisplaySet () const
    {
      return this->PMIDisplaySet_.get ();
    }

    VisualizationSetType::PMIDisplaySet_type& VisualizationSetType::
    PMIDisplaySet ()
    {
      return this->PMIDisplaySet_.get ();
    }

    void VisualizationSetType::
    PMIDisplaySet (const PMIDisplaySet_type& x)
    {
      this->PMIDisplaySet_.set (x);
    }

    void VisualizationSetType::
    PMIDisplaySet (::std::unique_ptr< PMIDisplaySet_type > x)
    {
      this->PMIDisplaySet_.set (std::move (x));
    }


    // FontsType
    //

    const FontsType::Font_sequence& FontsType::
    Font () const
    {
      return this->Font_;
    }

    FontsType::Font_sequence& FontsType::
    Font ()
    {
      return this->Font_;
    }

    void FontsType::
    Font (const Font_sequence& s)
    {
      this->Font_ = s;
    }

    const FontsType::n_type& FontsType::
    n () const
    {
      return this->n_.get ();
    }

    FontsType::n_type& FontsType::
    n ()
    {
      return this->n_.get ();
    }

    void FontsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FontsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AlignmentEnumType
    //

    AlignmentEnumType::
    AlignmentEnumType ()
    : ::xml_schema::string ()
    {
    }

    AlignmentEnumType::
    AlignmentEnumType (value v)
    : ::xml_schema::string (_xsd_AlignmentEnumType_literals_[v])
    {
    }

    AlignmentEnumType::
    AlignmentEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    AlignmentEnumType::
    AlignmentEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    AlignmentEnumType::
    AlignmentEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    AlignmentEnumType::
    AlignmentEnumType (const AlignmentEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    AlignmentEnumType& AlignmentEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_AlignmentEnumType_literals_[v]);

      return *this;
    }


    // FontType
    //

    const FontType::Attributes_optional& FontType::
    Attributes () const
    {
      return this->Attributes_;
    }

    FontType::Attributes_optional& FontType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void FontType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void FontType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void FontType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const FontType::Name_type& FontType::
    Name () const
    {
      return this->Name_.get ();
    }

    FontType::Name_type& FontType::
    Name ()
    {
      return this->Name_.get ();
    }

    void FontType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FontType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const FontType::Size_type& FontType::
    Size () const
    {
      return this->Size_.get ();
    }

    FontType::Size_type& FontType::
    Size ()
    {
      return this->Size_.get ();
    }

    void FontType::
    Size (const Size_type& x)
    {
      this->Size_.set (x);
    }

    void FontType::
    Size (::std::unique_ptr< Size_type > x)
    {
      this->Size_.set (std::move (x));
    }

    const FontType::Alignment_optional& FontType::
    Alignment () const
    {
      return this->Alignment_;
    }

    FontType::Alignment_optional& FontType::
    Alignment ()
    {
      return this->Alignment_;
    }

    void FontType::
    Alignment (const Alignment_type& x)
    {
      this->Alignment_.set (x);
    }

    void FontType::
    Alignment (const Alignment_optional& x)
    {
      this->Alignment_ = x;
    }

    void FontType::
    Alignment (::std::unique_ptr< Alignment_type > x)
    {
      this->Alignment_.set (std::move (x));
    }

    const FontType::index_type& FontType::
    index () const
    {
      return this->index_.get ();
    }

    FontType::index_type& FontType::
    index ()
    {
      return this->index_.get ();
    }

    void FontType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    const FontType::bold_type& FontType::
    bold () const
    {
      return this->bold_.get ();
    }

    FontType::bold_type& FontType::
    bold ()
    {
      return this->bold_.get ();
    }

    void FontType::
    bold (const bold_type& x)
    {
      this->bold_.set (x);
    }

    FontType::bold_type FontType::
    bold_default_value ()
    {
      return bold_type (false);
    }

    const FontType::italic_type& FontType::
    italic () const
    {
      return this->italic_.get ();
    }

    FontType::italic_type& FontType::
    italic ()
    {
      return this->italic_.get ();
    }

    void FontType::
    italic (const italic_type& x)
    {
      this->italic_.set (x);
    }

    FontType::italic_type FontType::
    italic_default_value ()
    {
      return italic_type (false);
    }

    const FontType::underline_type& FontType::
    underline () const
    {
      return this->underline_.get ();
    }

    FontType::underline_type& FontType::
    underline ()
    {
      return this->underline_.get ();
    }

    void FontType::
    underline (const underline_type& x)
    {
      this->underline_.set (x);
    }

    FontType::underline_type FontType::
    underline_default_value ()
    {
      return underline_type (false);
    }


    // PMIDisplaySetType
    //

    const PMIDisplaySetType::PMIDisplay_sequence& PMIDisplaySetType::
    PMIDisplay () const
    {
      return this->PMIDisplay_;
    }

    PMIDisplaySetType::PMIDisplay_sequence& PMIDisplaySetType::
    PMIDisplay ()
    {
      return this->PMIDisplay_;
    }

    void PMIDisplaySetType::
    PMIDisplay (const PMIDisplay_sequence& s)
    {
      this->PMIDisplay_ = s;
    }

    const PMIDisplaySetType::n_type& PMIDisplaySetType::
    n () const
    {
      return this->n_.get ();
    }

    PMIDisplaySetType::n_type& PMIDisplaySetType::
    n ()
    {
      return this->n_.get ();
    }

    void PMIDisplaySetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PMIDisplaySetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PMIDisplayType
    //

    const PMIDisplayType::Attributes_optional& PMIDisplayType::
    Attributes () const
    {
      return this->Attributes_;
    }

    PMIDisplayType::Attributes_optional& PMIDisplayType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void PMIDisplayType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void PMIDisplayType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void PMIDisplayType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const PMIDisplayType::Color_optional& PMIDisplayType::
    Color () const
    {
      return this->Color_;
    }

    PMIDisplayType::Color_optional& PMIDisplayType::
    Color ()
    {
      return this->Color_;
    }

    void PMIDisplayType::
    Color (const Color_type& x)
    {
      this->Color_.set (x);
    }

    void PMIDisplayType::
    Color (const Color_optional& x)
    {
      this->Color_ = x;
    }

    void PMIDisplayType::
    Color (::std::unique_ptr< Color_type > x)
    {
      this->Color_.set (std::move (x));
    }

    const PMIDisplayType::Plane_optional& PMIDisplayType::
    Plane () const
    {
      return this->Plane_;
    }

    PMIDisplayType::Plane_optional& PMIDisplayType::
    Plane ()
    {
      return this->Plane_;
    }

    void PMIDisplayType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PMIDisplayType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PMIDisplayType::
    Plane (::std::unique_ptr< Plane_type > x)
    {
      this->Plane_.set (std::move (x));
    }

    const PMIDisplayType::Texts_optional& PMIDisplayType::
    Texts () const
    {
      return this->Texts_;
    }

    PMIDisplayType::Texts_optional& PMIDisplayType::
    Texts ()
    {
      return this->Texts_;
    }

    void PMIDisplayType::
    Texts (const Texts_type& x)
    {
      this->Texts_.set (x);
    }

    void PMIDisplayType::
    Texts (const Texts_optional& x)
    {
      this->Texts_ = x;
    }

    void PMIDisplayType::
    Texts (::std::unique_ptr< Texts_type > x)
    {
      this->Texts_.set (std::move (x));
    }

    const PMIDisplayType::Leader_sequence& PMIDisplayType::
    Leader () const
    {
      return this->Leader_;
    }

    PMIDisplayType::Leader_sequence& PMIDisplayType::
    Leader ()
    {
      return this->Leader_;
    }

    void PMIDisplayType::
    Leader (const Leader_sequence& s)
    {
      this->Leader_ = s;
    }

    const PMIDisplayType::WitnessLines_optional& PMIDisplayType::
    WitnessLines () const
    {
      return this->WitnessLines_;
    }

    PMIDisplayType::WitnessLines_optional& PMIDisplayType::
    WitnessLines ()
    {
      return this->WitnessLines_;
    }

    void PMIDisplayType::
    WitnessLines (const WitnessLines_type& x)
    {
      this->WitnessLines_.set (x);
    }

    void PMIDisplayType::
    WitnessLines (const WitnessLines_optional& x)
    {
      this->WitnessLines_ = x;
    }

    void PMIDisplayType::
    WitnessLines (::std::unique_ptr< WitnessLines_type > x)
    {
      this->WitnessLines_.set (std::move (x));
    }

    const PMIDisplayType::Frames_optional& PMIDisplayType::
    Frames () const
    {
      return this->Frames_;
    }

    PMIDisplayType::Frames_optional& PMIDisplayType::
    Frames ()
    {
      return this->Frames_;
    }

    void PMIDisplayType::
    Frames (const Frames_type& x)
    {
      this->Frames_.set (x);
    }

    void PMIDisplayType::
    Frames (const Frames_optional& x)
    {
      this->Frames_ = x;
    }

    void PMIDisplayType::
    Frames (::std::unique_ptr< Frames_type > x)
    {
      this->Frames_.set (std::move (x));
    }

    const PMIDisplayType::Graphics_optional& PMIDisplayType::
    Graphics () const
    {
      return this->Graphics_;
    }

    PMIDisplayType::Graphics_optional& PMIDisplayType::
    Graphics ()
    {
      return this->Graphics_;
    }

    void PMIDisplayType::
    Graphics (const Graphics_type& x)
    {
      this->Graphics_.set (x);
    }

    void PMIDisplayType::
    Graphics (const Graphics_optional& x)
    {
      this->Graphics_ = x;
    }

    void PMIDisplayType::
    Graphics (::std::unique_ptr< Graphics_type > x)
    {
      this->Graphics_.set (std::move (x));
    }

    const PMIDisplayType::Reference_type& PMIDisplayType::
    Reference () const
    {
      return this->Reference_.get ();
    }

    PMIDisplayType::Reference_type& PMIDisplayType::
    Reference ()
    {
      return this->Reference_.get ();
    }

    void PMIDisplayType::
    Reference (const Reference_type& x)
    {
      this->Reference_.set (x);
    }

    void PMIDisplayType::
    Reference (::std::unique_ptr< Reference_type > x)
    {
      this->Reference_.set (std::move (x));
    }

    const PMIDisplayType::GroupID_optional& PMIDisplayType::
    GroupID () const
    {
      return this->GroupID_;
    }

    PMIDisplayType::GroupID_optional& PMIDisplayType::
    GroupID ()
    {
      return this->GroupID_;
    }

    void PMIDisplayType::
    GroupID (const GroupID_type& x)
    {
      this->GroupID_.set (x);
    }

    void PMIDisplayType::
    GroupID (const GroupID_optional& x)
    {
      this->GroupID_ = x;
    }

    void PMIDisplayType::
    GroupID (::std::unique_ptr< GroupID_type > x)
    {
      this->GroupID_.set (std::move (x));
    }


    // PlanePMIDisplayType
    //

    const PlanePMIDisplayType::AnnotationViewId_type& PlanePMIDisplayType::
    AnnotationViewId () const
    {
      return this->AnnotationViewId_.get ();
    }

    PlanePMIDisplayType::AnnotationViewId_type& PlanePMIDisplayType::
    AnnotationViewId ()
    {
      return this->AnnotationViewId_.get ();
    }

    void PlanePMIDisplayType::
    AnnotationViewId (const AnnotationViewId_type& x)
    {
      this->AnnotationViewId_.set (x);
    }

    void PlanePMIDisplayType::
    AnnotationViewId (::std::unique_ptr< AnnotationViewId_type > x)
    {
      this->AnnotationViewId_.set (std::move (x));
    }

    const PlanePMIDisplayType::Origin_optional& PlanePMIDisplayType::
    Origin () const
    {
      return this->Origin_;
    }

    PlanePMIDisplayType::Origin_optional& PlanePMIDisplayType::
    Origin ()
    {
      return this->Origin_;
    }

    void PlanePMIDisplayType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void PlanePMIDisplayType::
    Origin (const Origin_optional& x)
    {
      this->Origin_ = x;
    }

    void PlanePMIDisplayType::
    Origin (::std::unique_ptr< Origin_type > x)
    {
      this->Origin_.set (std::move (x));
    }

    const PlanePMIDisplayType::Direction_optional& PlanePMIDisplayType::
    Direction () const
    {
      return this->Direction_;
    }

    PlanePMIDisplayType::Direction_optional& PlanePMIDisplayType::
    Direction ()
    {
      return this->Direction_;
    }

    void PlanePMIDisplayType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void PlanePMIDisplayType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void PlanePMIDisplayType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // Polylines2dType
    //

    const Polylines2dType::Polyline_sequence& Polylines2dType::
    Polyline () const
    {
      return this->Polyline_;
    }

    Polylines2dType::Polyline_sequence& Polylines2dType::
    Polyline ()
    {
      return this->Polyline_;
    }

    void Polylines2dType::
    Polyline (const Polyline_sequence& s)
    {
      this->Polyline_ = s;
    }

    const Polylines2dType::n_type& Polylines2dType::
    n () const
    {
      return this->n_.get ();
    }

    Polylines2dType::n_type& Polylines2dType::
    n ()
    {
      return this->n_.get ();
    }

    void Polylines2dType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void Polylines2dType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Polyline2dType
    //

    const Polyline2dType::Points_optional& Polyline2dType::
    Points () const
    {
      return this->Points_;
    }

    Polyline2dType::Points_optional& Polyline2dType::
    Points ()
    {
      return this->Points_;
    }

    void Polyline2dType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void Polyline2dType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void Polyline2dType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const Polyline2dType::PointsBinary_optional& Polyline2dType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    Polyline2dType::PointsBinary_optional& Polyline2dType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void Polyline2dType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void Polyline2dType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void Polyline2dType::
    PointsBinary (::std::unique_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (std::move (x));
    }

    const Polyline2dType::color_optional& Polyline2dType::
    color () const
    {
      return this->color_;
    }

    Polyline2dType::color_optional& Polyline2dType::
    color ()
    {
      return this->color_;
    }

    void Polyline2dType::
    color (const color_type& x)
    {
      this->color_.set (x);
    }

    void Polyline2dType::
    color (const color_optional& x)
    {
      this->color_ = x;
    }

    void Polyline2dType::
    color (::std::unique_ptr< color_type > x)
    {
      this->color_.set (std::move (x));
    }


    // Areas2dType
    //

    const Areas2dType::Area_sequence& Areas2dType::
    Area () const
    {
      return this->Area_;
    }

    Areas2dType::Area_sequence& Areas2dType::
    Area ()
    {
      return this->Area_;
    }

    void Areas2dType::
    Area (const Area_sequence& s)
    {
      this->Area_ = s;
    }

    const Areas2dType::n_type& Areas2dType::
    n () const
    {
      return this->n_.get ();
    }

    Areas2dType::n_type& Areas2dType::
    n ()
    {
      return this->n_.get ();
    }

    void Areas2dType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void Areas2dType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Area2dType
    //

    const Area2dType::Loops_optional& Area2dType::
    Loops () const
    {
      return this->Loops_;
    }

    Area2dType::Loops_optional& Area2dType::
    Loops ()
    {
      return this->Loops_;
    }

    void Area2dType::
    Loops (const Loops_type& x)
    {
      this->Loops_.set (x);
    }

    void Area2dType::
    Loops (const Loops_optional& x)
    {
      this->Loops_ = x;
    }

    void Area2dType::
    Loops (::std::unique_ptr< Loops_type > x)
    {
      this->Loops_.set (std::move (x));
    }

    const Area2dType::Triangulation_optional& Area2dType::
    Triangulation () const
    {
      return this->Triangulation_;
    }

    Area2dType::Triangulation_optional& Area2dType::
    Triangulation ()
    {
      return this->Triangulation_;
    }

    void Area2dType::
    Triangulation (const Triangulation_type& x)
    {
      this->Triangulation_.set (x);
    }

    void Area2dType::
    Triangulation (const Triangulation_optional& x)
    {
      this->Triangulation_ = x;
    }

    void Area2dType::
    Triangulation (::std::unique_ptr< Triangulation_type > x)
    {
      this->Triangulation_.set (std::move (x));
    }


    // Loops2dType
    //

    const Loops2dType::Loop_sequence& Loops2dType::
    Loop () const
    {
      return this->Loop_;
    }

    Loops2dType::Loop_sequence& Loops2dType::
    Loop ()
    {
      return this->Loop_;
    }

    void Loops2dType::
    Loop (const Loop_sequence& s)
    {
      this->Loop_ = s;
    }

    const Loops2dType::n_type& Loops2dType::
    n () const
    {
      return this->n_.get ();
    }

    Loops2dType::n_type& Loops2dType::
    n ()
    {
      return this->n_.get ();
    }

    void Loops2dType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void Loops2dType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Triangulation2dType
    //

    const Triangulation2dType::Vertices_optional& Triangulation2dType::
    Vertices () const
    {
      return this->Vertices_;
    }

    Triangulation2dType::Vertices_optional& Triangulation2dType::
    Vertices ()
    {
      return this->Vertices_;
    }

    void Triangulation2dType::
    Vertices (const Vertices_type& x)
    {
      this->Vertices_.set (x);
    }

    void Triangulation2dType::
    Vertices (const Vertices_optional& x)
    {
      this->Vertices_ = x;
    }

    void Triangulation2dType::
    Vertices (::std::unique_ptr< Vertices_type > x)
    {
      this->Vertices_.set (std::move (x));
    }

    const Triangulation2dType::VerticesBinary_optional& Triangulation2dType::
    VerticesBinary () const
    {
      return this->VerticesBinary_;
    }

    Triangulation2dType::VerticesBinary_optional& Triangulation2dType::
    VerticesBinary ()
    {
      return this->VerticesBinary_;
    }

    void Triangulation2dType::
    VerticesBinary (const VerticesBinary_type& x)
    {
      this->VerticesBinary_.set (x);
    }

    void Triangulation2dType::
    VerticesBinary (const VerticesBinary_optional& x)
    {
      this->VerticesBinary_ = x;
    }

    void Triangulation2dType::
    VerticesBinary (::std::unique_ptr< VerticesBinary_type > x)
    {
      this->VerticesBinary_.set (std::move (x));
    }

    const Triangulation2dType::Triangles_optional& Triangulation2dType::
    Triangles () const
    {
      return this->Triangles_;
    }

    Triangulation2dType::Triangles_optional& Triangulation2dType::
    Triangles ()
    {
      return this->Triangles_;
    }

    void Triangulation2dType::
    Triangles (const Triangles_type& x)
    {
      this->Triangles_.set (x);
    }

    void Triangulation2dType::
    Triangles (const Triangles_optional& x)
    {
      this->Triangles_ = x;
    }

    void Triangulation2dType::
    Triangles (::std::unique_ptr< Triangles_type > x)
    {
      this->Triangles_.set (std::move (x));
    }

    const Triangulation2dType::TrianglesBinary_optional& Triangulation2dType::
    TrianglesBinary () const
    {
      return this->TrianglesBinary_;
    }

    Triangulation2dType::TrianglesBinary_optional& Triangulation2dType::
    TrianglesBinary ()
    {
      return this->TrianglesBinary_;
    }

    void Triangulation2dType::
    TrianglesBinary (const TrianglesBinary_type& x)
    {
      this->TrianglesBinary_.set (x);
    }

    void Triangulation2dType::
    TrianglesBinary (const TrianglesBinary_optional& x)
    {
      this->TrianglesBinary_ = x;
    }

    void Triangulation2dType::
    TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > x)
    {
      this->TrianglesBinary_.set (std::move (x));
    }

    const Triangulation2dType::TrianglesColor_optional& Triangulation2dType::
    TrianglesColor () const
    {
      return this->TrianglesColor_;
    }

    Triangulation2dType::TrianglesColor_optional& Triangulation2dType::
    TrianglesColor ()
    {
      return this->TrianglesColor_;
    }

    void Triangulation2dType::
    TrianglesColor (const TrianglesColor_type& x)
    {
      this->TrianglesColor_.set (x);
    }

    void Triangulation2dType::
    TrianglesColor (const TrianglesColor_optional& x)
    {
      this->TrianglesColor_ = x;
    }

    void Triangulation2dType::
    TrianglesColor (::std::unique_ptr< TrianglesColor_type > x)
    {
      this->TrianglesColor_.set (std::move (x));
    }

    const Triangulation2dType::TrianglesColorBinary_optional& Triangulation2dType::
    TrianglesColorBinary () const
    {
      return this->TrianglesColorBinary_;
    }

    Triangulation2dType::TrianglesColorBinary_optional& Triangulation2dType::
    TrianglesColorBinary ()
    {
      return this->TrianglesColorBinary_;
    }

    void Triangulation2dType::
    TrianglesColorBinary (const TrianglesColorBinary_type& x)
    {
      this->TrianglesColorBinary_.set (x);
    }

    void Triangulation2dType::
    TrianglesColorBinary (const TrianglesColorBinary_optional& x)
    {
      this->TrianglesColorBinary_ = x;
    }

    void Triangulation2dType::
    TrianglesColorBinary (::std::unique_ptr< TrianglesColorBinary_type > x)
    {
      this->TrianglesColorBinary_.set (std::move (x));
    }


    // GraphicsType
    //

    const GraphicsType::Polylines_optional& GraphicsType::
    Polylines () const
    {
      return this->Polylines_;
    }

    GraphicsType::Polylines_optional& GraphicsType::
    Polylines ()
    {
      return this->Polylines_;
    }

    void GraphicsType::
    Polylines (const Polylines_type& x)
    {
      this->Polylines_.set (x);
    }

    void GraphicsType::
    Polylines (const Polylines_optional& x)
    {
      this->Polylines_ = x;
    }

    void GraphicsType::
    Polylines (::std::unique_ptr< Polylines_type > x)
    {
      this->Polylines_.set (std::move (x));
    }

    const GraphicsType::Areas_optional& GraphicsType::
    Areas () const
    {
      return this->Areas_;
    }

    GraphicsType::Areas_optional& GraphicsType::
    Areas ()
    {
      return this->Areas_;
    }

    void GraphicsType::
    Areas (const Areas_type& x)
    {
      this->Areas_.set (x);
    }

    void GraphicsType::
    Areas (const Areas_optional& x)
    {
      this->Areas_ = x;
    }

    void GraphicsType::
    Areas (::std::unique_ptr< Areas_type > x)
    {
      this->Areas_.set (std::move (x));
    }


    // LeaderType
    //

    const LeaderType::HeadForm_type& LeaderType::
    HeadForm () const
    {
      return this->HeadForm_.get ();
    }

    LeaderType::HeadForm_type& LeaderType::
    HeadForm ()
    {
      return this->HeadForm_.get ();
    }

    void LeaderType::
    HeadForm (const HeadForm_type& x)
    {
      this->HeadForm_.set (x);
    }

    void LeaderType::
    HeadForm (::std::unique_ptr< HeadForm_type > x)
    {
      this->HeadForm_.set (std::move (x));
    }

    const LeaderType::HeadHeight_type& LeaderType::
    HeadHeight () const
    {
      return this->HeadHeight_.get ();
    }

    LeaderType::HeadHeight_type& LeaderType::
    HeadHeight ()
    {
      return this->HeadHeight_.get ();
    }

    void LeaderType::
    HeadHeight (const HeadHeight_type& x)
    {
      this->HeadHeight_.set (x);
    }


    // LeaderExtendType
    //

    const LeaderExtendType::PointExtension_type& LeaderExtendType::
    PointExtension () const
    {
      return this->PointExtension_.get ();
    }

    LeaderExtendType::PointExtension_type& LeaderExtendType::
    PointExtension ()
    {
      return this->PointExtension_.get ();
    }

    void LeaderExtendType::
    PointExtension (const PointExtension_type& x)
    {
      this->PointExtension_.set (x);
    }

    void LeaderExtendType::
    PointExtension (::std::unique_ptr< PointExtension_type > x)
    {
      this->PointExtension_.set (std::move (x));
    }

    const LeaderExtendType::Modifier_optional& LeaderExtendType::
    Modifier () const
    {
      return this->Modifier_;
    }

    LeaderExtendType::Modifier_optional& LeaderExtendType::
    Modifier ()
    {
      return this->Modifier_;
    }

    void LeaderExtendType::
    Modifier (const Modifier_type& x)
    {
      this->Modifier_.set (x);
    }

    void LeaderExtendType::
    Modifier (const Modifier_optional& x)
    {
      this->Modifier_ = x;
    }

    void LeaderExtendType::
    Modifier (::std::unique_ptr< Modifier_type > x)
    {
      this->Modifier_.set (std::move (x));
    }


    // LeaderDoubleHeadType
    //

    const LeaderDoubleHeadType::HeadForm2_type& LeaderDoubleHeadType::
    HeadForm2 () const
    {
      return this->HeadForm2_.get ();
    }

    LeaderDoubleHeadType::HeadForm2_type& LeaderDoubleHeadType::
    HeadForm2 ()
    {
      return this->HeadForm2_.get ();
    }

    void LeaderDoubleHeadType::
    HeadForm2 (const HeadForm2_type& x)
    {
      this->HeadForm2_.set (x);
    }

    void LeaderDoubleHeadType::
    HeadForm2 (::std::unique_ptr< HeadForm2_type > x)
    {
      this->HeadForm2_.set (std::move (x));
    }

    const LeaderDoubleHeadType::PointConnection_type& LeaderDoubleHeadType::
    PointConnection () const
    {
      return this->PointConnection_.get ();
    }

    LeaderDoubleHeadType::PointConnection_type& LeaderDoubleHeadType::
    PointConnection ()
    {
      return this->PointConnection_.get ();
    }

    void LeaderDoubleHeadType::
    PointConnection (const PointConnection_type& x)
    {
      this->PointConnection_.set (x);
    }

    void LeaderDoubleHeadType::
    PointConnection (::std::unique_ptr< PointConnection_type > x)
    {
      this->PointConnection_.set (std::move (x));
    }


    // LeaderDoubleHeadExtendType
    //

    const LeaderDoubleHeadExtendType::PointExtension_type& LeaderDoubleHeadExtendType::
    PointExtension () const
    {
      return this->PointExtension_.get ();
    }

    LeaderDoubleHeadExtendType::PointExtension_type& LeaderDoubleHeadExtendType::
    PointExtension ()
    {
      return this->PointExtension_.get ();
    }

    void LeaderDoubleHeadExtendType::
    PointExtension (const PointExtension_type& x)
    {
      this->PointExtension_.set (x);
    }

    void LeaderDoubleHeadExtendType::
    PointExtension (::std::unique_ptr< PointExtension_type > x)
    {
      this->PointExtension_.set (std::move (x));
    }


    // LeaderCircularType
    //

    const LeaderCircularType::Center_type& LeaderCircularType::
    Center () const
    {
      return this->Center_.get ();
    }

    LeaderCircularType::Center_type& LeaderCircularType::
    Center ()
    {
      return this->Center_.get ();
    }

    void LeaderCircularType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void LeaderCircularType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }


    // LeaderDoubleHeadCircularType
    //

    const LeaderDoubleHeadCircularType::Center_type& LeaderDoubleHeadCircularType::
    Center () const
    {
      return this->Center_.get ();
    }

    LeaderDoubleHeadCircularType::Center_type& LeaderDoubleHeadCircularType::
    Center ()
    {
      return this->Center_.get ();
    }

    void LeaderDoubleHeadCircularType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void LeaderDoubleHeadCircularType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }


    // TextsType
    //

    const TextsType::Text_sequence& TextsType::
    Text () const
    {
      return this->Text_;
    }

    TextsType::Text_sequence& TextsType::
    Text ()
    {
      return this->Text_;
    }

    void TextsType::
    Text (const Text_sequence& s)
    {
      this->Text_ = s;
    }

    const TextsType::fontIndex_type& TextsType::
    fontIndex () const
    {
      return this->fontIndex_.get ();
    }

    TextsType::fontIndex_type& TextsType::
    fontIndex ()
    {
      return this->fontIndex_.get ();
    }

    void TextsType::
    fontIndex (const fontIndex_type& x)
    {
      this->fontIndex_.set (x);
    }

    const TextsType::lineHeight_optional& TextsType::
    lineHeight () const
    {
      return this->lineHeight_;
    }

    TextsType::lineHeight_optional& TextsType::
    lineHeight ()
    {
      return this->lineHeight_;
    }

    void TextsType::
    lineHeight (const lineHeight_type& x)
    {
      this->lineHeight_.set (x);
    }

    void TextsType::
    lineHeight (const lineHeight_optional& x)
    {
      this->lineHeight_ = x;
    }

    const TextsType::n_type& TextsType::
    n () const
    {
      return this->n_.get ();
    }

    TextsType::n_type& TextsType::
    n ()
    {
      return this->n_.get ();
    }

    void TextsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TextsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FramesType
    //

    const FramesType::Frame_sequence& FramesType::
    Frame () const
    {
      return this->Frame_;
    }

    FramesType::Frame_sequence& FramesType::
    Frame ()
    {
      return this->Frame_;
    }

    void FramesType::
    Frame (const Frame_sequence& s)
    {
      this->Frame_ = s;
    }

    const FramesType::n_type& FramesType::
    n () const
    {
      return this->n_.get ();
    }

    FramesType::n_type& FramesType::
    n ()
    {
      return this->n_.get ();
    }

    void FramesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FramesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TextType
    //

    const TextType::Data_type& TextType::
    Data () const
    {
      return this->Data_.get ();
    }

    TextType::Data_type& TextType::
    Data ()
    {
      return this->Data_.get ();
    }

    void TextType::
    Data (const Data_type& x)
    {
      this->Data_.set (x);
    }

    void TextType::
    Data (::std::unique_ptr< Data_type > x)
    {
      this->Data_.set (std::move (x));
    }

    const TextType::XY_type& TextType::
    XY () const
    {
      return this->XY_.get ();
    }

    TextType::XY_type& TextType::
    XY ()
    {
      return this->XY_.get ();
    }

    void TextType::
    XY (const XY_type& x)
    {
      this->XY_.set (x);
    }

    void TextType::
    XY (::std::unique_ptr< XY_type > x)
    {
      this->XY_.set (std::move (x));
    }


    // WitnessLinesType
    //

    const WitnessLinesType::Segment1_optional& WitnessLinesType::
    Segment1 () const
    {
      return this->Segment1_;
    }

    WitnessLinesType::Segment1_optional& WitnessLinesType::
    Segment1 ()
    {
      return this->Segment1_;
    }

    void WitnessLinesType::
    Segment1 (const Segment1_type& x)
    {
      this->Segment1_.set (x);
    }

    void WitnessLinesType::
    Segment1 (const Segment1_optional& x)
    {
      this->Segment1_ = x;
    }

    void WitnessLinesType::
    Segment1 (::std::unique_ptr< Segment1_type > x)
    {
      this->Segment1_.set (std::move (x));
    }

    const WitnessLinesType::ZextensionPoint1_optional& WitnessLinesType::
    ZextensionPoint1 () const
    {
      return this->ZextensionPoint1_;
    }

    WitnessLinesType::ZextensionPoint1_optional& WitnessLinesType::
    ZextensionPoint1 ()
    {
      return this->ZextensionPoint1_;
    }

    void WitnessLinesType::
    ZextensionPoint1 (const ZextensionPoint1_type& x)
    {
      this->ZextensionPoint1_.set (x);
    }

    void WitnessLinesType::
    ZextensionPoint1 (const ZextensionPoint1_optional& x)
    {
      this->ZextensionPoint1_ = x;
    }

    void WitnessLinesType::
    ZextensionPoint1 (::std::unique_ptr< ZextensionPoint1_type > x)
    {
      this->ZextensionPoint1_.set (std::move (x));
    }

    const WitnessLinesType::Segment2_optional& WitnessLinesType::
    Segment2 () const
    {
      return this->Segment2_;
    }

    WitnessLinesType::Segment2_optional& WitnessLinesType::
    Segment2 ()
    {
      return this->Segment2_;
    }

    void WitnessLinesType::
    Segment2 (const Segment2_type& x)
    {
      this->Segment2_.set (x);
    }

    void WitnessLinesType::
    Segment2 (const Segment2_optional& x)
    {
      this->Segment2_ = x;
    }

    void WitnessLinesType::
    Segment2 (::std::unique_ptr< Segment2_type > x)
    {
      this->Segment2_.set (std::move (x));
    }

    const WitnessLinesType::ZextensionPoint2_optional& WitnessLinesType::
    ZextensionPoint2 () const
    {
      return this->ZextensionPoint2_;
    }

    WitnessLinesType::ZextensionPoint2_optional& WitnessLinesType::
    ZextensionPoint2 ()
    {
      return this->ZextensionPoint2_;
    }

    void WitnessLinesType::
    ZextensionPoint2 (const ZextensionPoint2_type& x)
    {
      this->ZextensionPoint2_.set (x);
    }

    void WitnessLinesType::
    ZextensionPoint2 (const ZextensionPoint2_optional& x)
    {
      this->ZextensionPoint2_ = x;
    }

    void WitnessLinesType::
    ZextensionPoint2 (::std::unique_ptr< ZextensionPoint2_type > x)
    {
      this->ZextensionPoint2_.set (std::move (x));
    }

    const WitnessLinesType::BeginPoint_optional& WitnessLinesType::
    BeginPoint () const
    {
      return this->BeginPoint_;
    }

    WitnessLinesType::BeginPoint_optional& WitnessLinesType::
    BeginPoint ()
    {
      return this->BeginPoint_;
    }

    void WitnessLinesType::
    BeginPoint (const BeginPoint_type& x)
    {
      this->BeginPoint_.set (x);
    }

    void WitnessLinesType::
    BeginPoint (const BeginPoint_optional& x)
    {
      this->BeginPoint_ = x;
    }

    void WitnessLinesType::
    BeginPoint (::std::unique_ptr< BeginPoint_type > x)
    {
      this->BeginPoint_.set (std::move (x));
    }

    const WitnessLinesType::EndPoint_optional& WitnessLinesType::
    EndPoint () const
    {
      return this->EndPoint_;
    }

    WitnessLinesType::EndPoint_optional& WitnessLinesType::
    EndPoint ()
    {
      return this->EndPoint_;
    }

    void WitnessLinesType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void WitnessLinesType::
    EndPoint (const EndPoint_optional& x)
    {
      this->EndPoint_ = x;
    }

    void WitnessLinesType::
    EndPoint (::std::unique_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (std::move (x));
    }

    const WitnessLinesType::CircleCenter_optional& WitnessLinesType::
    CircleCenter () const
    {
      return this->CircleCenter_;
    }

    WitnessLinesType::CircleCenter_optional& WitnessLinesType::
    CircleCenter ()
    {
      return this->CircleCenter_;
    }

    void WitnessLinesType::
    CircleCenter (const CircleCenter_type& x)
    {
      this->CircleCenter_.set (x);
    }

    void WitnessLinesType::
    CircleCenter (const CircleCenter_optional& x)
    {
      this->CircleCenter_ = x;
    }

    void WitnessLinesType::
    CircleCenter (::std::unique_ptr< CircleCenter_type > x)
    {
      this->CircleCenter_.set (std::move (x));
    }

    const WitnessLinesType::CircleRadius_optional& WitnessLinesType::
    CircleRadius () const
    {
      return this->CircleRadius_;
    }

    WitnessLinesType::CircleRadius_optional& WitnessLinesType::
    CircleRadius ()
    {
      return this->CircleRadius_;
    }

    void WitnessLinesType::
    CircleRadius (const CircleRadius_type& x)
    {
      this->CircleRadius_.set (x);
    }

    void WitnessLinesType::
    CircleRadius (const CircleRadius_optional& x)
    {
      this->CircleRadius_ = x;
    }

    void WitnessLinesType::
    CircleRadius (::std::unique_ptr< CircleRadius_type > x)
    {
      this->CircleRadius_.set (std::move (x));
    }

    const WitnessLinesType::width_type& WitnessLinesType::
    width () const
    {
      return this->width_.get ();
    }

    WitnessLinesType::width_type& WitnessLinesType::
    width ()
    {
      return this->width_.get ();
    }

    void WitnessLinesType::
    width (const width_type& x)
    {
      this->width_.set (x);
    }


    // FrameBaseType
    //


    // FrameRectangularType
    //

    const FrameRectangularType::XY_type& FrameRectangularType::
    XY () const
    {
      return this->XY_.get ();
    }

    FrameRectangularType::XY_type& FrameRectangularType::
    XY ()
    {
      return this->XY_.get ();
    }

    void FrameRectangularType::
    XY (const XY_type& x)
    {
      this->XY_.set (x);
    }

    void FrameRectangularType::
    XY (::std::unique_ptr< XY_type > x)
    {
      this->XY_.set (std::move (x));
    }

    const FrameRectangularType::Width_type& FrameRectangularType::
    Width () const
    {
      return this->Width_.get ();
    }

    FrameRectangularType::Width_type& FrameRectangularType::
    Width ()
    {
      return this->Width_.get ();
    }

    void FrameRectangularType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    const FrameRectangularType::Height_type& FrameRectangularType::
    Height () const
    {
      return this->Height_.get ();
    }

    FrameRectangularType::Height_type& FrameRectangularType::
    Height ()
    {
      return this->Height_.get ();
    }

    void FrameRectangularType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }


    // FrameCircularType
    //

    const FrameCircularType::XY_type& FrameCircularType::
    XY () const
    {
      return this->XY_.get ();
    }

    FrameCircularType::XY_type& FrameCircularType::
    XY ()
    {
      return this->XY_.get ();
    }

    void FrameCircularType::
    XY (const XY_type& x)
    {
      this->XY_.set (x);
    }

    void FrameCircularType::
    XY (::std::unique_ptr< XY_type > x)
    {
      this->XY_.set (std::move (x));
    }

    const FrameCircularType::Radius_type& FrameCircularType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    FrameCircularType::Radius_type& FrameCircularType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void FrameCircularType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    const FrameCircularType::crossed_type& FrameCircularType::
    crossed () const
    {
      return this->crossed_.get ();
    }

    FrameCircularType::crossed_type& FrameCircularType::
    crossed ()
    {
      return this->crossed_.get ();
    }

    void FrameCircularType::
    crossed (const crossed_type& x)
    {
      this->crossed_.set (x);
    }

    FrameCircularType::crossed_type FrameCircularType::
    crossed_default_value ()
    {
      return crossed_type (true);
    }


    // FrameFlagType
    //

    const FrameFlagType::right_type& FrameFlagType::
    right () const
    {
      return this->right_.get ();
    }

    FrameFlagType::right_type& FrameFlagType::
    right ()
    {
      return this->right_.get ();
    }

    void FrameFlagType::
    right (const right_type& x)
    {
      this->right_.set (x);
    }

    FrameFlagType::right_type FrameFlagType::
    right_default_value ()
    {
      return right_type (true);
    }


    // FrameIrregularFormType
    //

    const FrameIrregularFormType::Points_type& FrameIrregularFormType::
    Points () const
    {
      return this->Points_.get ();
    }

    FrameIrregularFormType::Points_type& FrameIrregularFormType::
    Points ()
    {
      return this->Points_.get ();
    }

    void FrameIrregularFormType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void FrameIrregularFormType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }


    // FrameWeldSymbolTailType
    //

    const FrameWeldSymbolTailType::UpperPoint_type& FrameWeldSymbolTailType::
    UpperPoint () const
    {
      return this->UpperPoint_.get ();
    }

    FrameWeldSymbolTailType::UpperPoint_type& FrameWeldSymbolTailType::
    UpperPoint ()
    {
      return this->UpperPoint_.get ();
    }

    void FrameWeldSymbolTailType::
    UpperPoint (const UpperPoint_type& x)
    {
      this->UpperPoint_.set (x);
    }

    void FrameWeldSymbolTailType::
    UpperPoint (::std::unique_ptr< UpperPoint_type > x)
    {
      this->UpperPoint_.set (std::move (x));
    }

    const FrameWeldSymbolTailType::LowerPoint_type& FrameWeldSymbolTailType::
    LowerPoint () const
    {
      return this->LowerPoint_.get ();
    }

    FrameWeldSymbolTailType::LowerPoint_type& FrameWeldSymbolTailType::
    LowerPoint ()
    {
      return this->LowerPoint_.get ();
    }

    void FrameWeldSymbolTailType::
    LowerPoint (const LowerPoint_type& x)
    {
      this->LowerPoint_.set (x);
    }

    void FrameWeldSymbolTailType::
    LowerPoint (::std::unique_ptr< LowerPoint_type > x)
    {
      this->LowerPoint_.set (std::move (x));
    }


    // WeldMainSymbolEnumType
    //

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType ()
    : ::xml_schema::string ()
    {
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (value v)
    : ::xml_schema::string (_xsd_WeldMainSymbolEnumType_literals_[v])
    {
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const WeldMainSymbolEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    WeldMainSymbolEnumType& WeldMainSymbolEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_WeldMainSymbolEnumType_literals_[v]);

      return *this;
    }


    // OriginType
    //

    const OriginType::Origin_type& OriginType::
    Origin () const
    {
      return this->Origin_.get ();
    }

    OriginType::Origin_type& OriginType::
    Origin ()
    {
      return this->Origin_.get ();
    }

    void OriginType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void OriginType::
    Origin (::std::unique_ptr< Origin_type > x)
    {
      this->Origin_.set (std::move (x));
    }


    // WeldMainSymbolType
    //

    const WeldMainSymbolType::Symbol_type& WeldMainSymbolType::
    Symbol () const
    {
      return this->Symbol_.get ();
    }

    WeldMainSymbolType::Symbol_type& WeldMainSymbolType::
    Symbol ()
    {
      return this->Symbol_.get ();
    }

    void WeldMainSymbolType::
    Symbol (const Symbol_type& x)
    {
      this->Symbol_.set (x);
    }

    void WeldMainSymbolType::
    Symbol (::std::unique_ptr< Symbol_type > x)
    {
      this->Symbol_.set (std::move (x));
    }


    // WeldSupplementarySymbolType
    //

    const WeldSupplementarySymbolType::Symbol_type& WeldSupplementarySymbolType::
    Symbol () const
    {
      return this->Symbol_.get ();
    }

    WeldSupplementarySymbolType::Symbol_type& WeldSupplementarySymbolType::
    Symbol ()
    {
      return this->Symbol_.get ();
    }

    void WeldSupplementarySymbolType::
    Symbol (const Symbol_type& x)
    {
      this->Symbol_.set (x);
    }

    void WeldSupplementarySymbolType::
    Symbol (::std::unique_ptr< Symbol_type > x)
    {
      this->Symbol_.set (std::move (x));
    }


    // WeldContourSymbolType
    //

    const WeldContourSymbolType::Symbol_type& WeldContourSymbolType::
    Symbol () const
    {
      return this->Symbol_.get ();
    }

    WeldContourSymbolType::Symbol_type& WeldContourSymbolType::
    Symbol ()
    {
      return this->Symbol_.get ();
    }

    void WeldContourSymbolType::
    Symbol (const Symbol_type& x)
    {
      this->Symbol_.set (x);
    }

    void WeldContourSymbolType::
    Symbol (::std::unique_ptr< Symbol_type > x)
    {
      this->Symbol_.set (std::move (x));
    }


    // FrameWeldSymbolType
    //

    const FrameWeldSymbolType::ReferenceLineBeginPoint_type& FrameWeldSymbolType::
    ReferenceLineBeginPoint () const
    {
      return this->ReferenceLineBeginPoint_.get ();
    }

    FrameWeldSymbolType::ReferenceLineBeginPoint_type& FrameWeldSymbolType::
    ReferenceLineBeginPoint ()
    {
      return this->ReferenceLineBeginPoint_.get ();
    }

    void FrameWeldSymbolType::
    ReferenceLineBeginPoint (const ReferenceLineBeginPoint_type& x)
    {
      this->ReferenceLineBeginPoint_.set (x);
    }

    void FrameWeldSymbolType::
    ReferenceLineBeginPoint (::std::unique_ptr< ReferenceLineBeginPoint_type > x)
    {
      this->ReferenceLineBeginPoint_.set (std::move (x));
    }

    const FrameWeldSymbolType::ReferenceLineEndPoint_type& FrameWeldSymbolType::
    ReferenceLineEndPoint () const
    {
      return this->ReferenceLineEndPoint_.get ();
    }

    FrameWeldSymbolType::ReferenceLineEndPoint_type& FrameWeldSymbolType::
    ReferenceLineEndPoint ()
    {
      return this->ReferenceLineEndPoint_.get ();
    }

    void FrameWeldSymbolType::
    ReferenceLineEndPoint (const ReferenceLineEndPoint_type& x)
    {
      this->ReferenceLineEndPoint_.set (x);
    }

    void FrameWeldSymbolType::
    ReferenceLineEndPoint (::std::unique_ptr< ReferenceLineEndPoint_type > x)
    {
      this->ReferenceLineEndPoint_.set (std::move (x));
    }

    const FrameWeldSymbolType::Tail_optional& FrameWeldSymbolType::
    Tail () const
    {
      return this->Tail_;
    }

    FrameWeldSymbolType::Tail_optional& FrameWeldSymbolType::
    Tail ()
    {
      return this->Tail_;
    }

    void FrameWeldSymbolType::
    Tail (const Tail_type& x)
    {
      this->Tail_.set (x);
    }

    void FrameWeldSymbolType::
    Tail (const Tail_optional& x)
    {
      this->Tail_ = x;
    }

    void FrameWeldSymbolType::
    Tail (::std::unique_ptr< Tail_type > x)
    {
      this->Tail_.set (std::move (x));
    }

    const FrameWeldSymbolType::MainSymbol_optional& FrameWeldSymbolType::
    MainSymbol () const
    {
      return this->MainSymbol_;
    }

    FrameWeldSymbolType::MainSymbol_optional& FrameWeldSymbolType::
    MainSymbol ()
    {
      return this->MainSymbol_;
    }

    void FrameWeldSymbolType::
    MainSymbol (const MainSymbol_type& x)
    {
      this->MainSymbol_.set (x);
    }

    void FrameWeldSymbolType::
    MainSymbol (const MainSymbol_optional& x)
    {
      this->MainSymbol_ = x;
    }

    void FrameWeldSymbolType::
    MainSymbol (::std::unique_ptr< MainSymbol_type > x)
    {
      this->MainSymbol_.set (std::move (x));
    }

    const FrameWeldSymbolType::SupplementarySymbol_optional& FrameWeldSymbolType::
    SupplementarySymbol () const
    {
      return this->SupplementarySymbol_;
    }

    FrameWeldSymbolType::SupplementarySymbol_optional& FrameWeldSymbolType::
    SupplementarySymbol ()
    {
      return this->SupplementarySymbol_;
    }

    void FrameWeldSymbolType::
    SupplementarySymbol (const SupplementarySymbol_type& x)
    {
      this->SupplementarySymbol_.set (x);
    }

    void FrameWeldSymbolType::
    SupplementarySymbol (const SupplementarySymbol_optional& x)
    {
      this->SupplementarySymbol_ = x;
    }

    void FrameWeldSymbolType::
    SupplementarySymbol (::std::unique_ptr< SupplementarySymbol_type > x)
    {
      this->SupplementarySymbol_.set (std::move (x));
    }

    const FrameWeldSymbolType::ArrowSideContourSymbol_optional& FrameWeldSymbolType::
    ArrowSideContourSymbol () const
    {
      return this->ArrowSideContourSymbol_;
    }

    FrameWeldSymbolType::ArrowSideContourSymbol_optional& FrameWeldSymbolType::
    ArrowSideContourSymbol ()
    {
      return this->ArrowSideContourSymbol_;
    }

    void FrameWeldSymbolType::
    ArrowSideContourSymbol (const ArrowSideContourSymbol_type& x)
    {
      this->ArrowSideContourSymbol_.set (x);
    }

    void FrameWeldSymbolType::
    ArrowSideContourSymbol (const ArrowSideContourSymbol_optional& x)
    {
      this->ArrowSideContourSymbol_ = x;
    }

    void FrameWeldSymbolType::
    ArrowSideContourSymbol (::std::unique_ptr< ArrowSideContourSymbol_type > x)
    {
      this->ArrowSideContourSymbol_.set (std::move (x));
    }

    const FrameWeldSymbolType::OtherSideContourSymbol_optional& FrameWeldSymbolType::
    OtherSideContourSymbol () const
    {
      return this->OtherSideContourSymbol_;
    }

    FrameWeldSymbolType::OtherSideContourSymbol_optional& FrameWeldSymbolType::
    OtherSideContourSymbol ()
    {
      return this->OtherSideContourSymbol_;
    }

    void FrameWeldSymbolType::
    OtherSideContourSymbol (const OtherSideContourSymbol_type& x)
    {
      this->OtherSideContourSymbol_.set (x);
    }

    void FrameWeldSymbolType::
    OtherSideContourSymbol (const OtherSideContourSymbol_optional& x)
    {
      this->OtherSideContourSymbol_ = x;
    }

    void FrameWeldSymbolType::
    OtherSideContourSymbol (::std::unique_ptr< OtherSideContourSymbol_type > x)
    {
      this->OtherSideContourSymbol_.set (std::move (x));
    }


    // FrameTriangleType
    //

    const FrameTriangleType::Point_sequence& FrameTriangleType::
    Point () const
    {
      return this->Point_;
    }

    FrameTriangleType::Point_sequence& FrameTriangleType::
    Point ()
    {
      return this->Point_;
    }

    void FrameTriangleType::
    Point (const Point_sequence& s)
    {
      this->Point_ = s;
    }


    // FramePentagonalType
    //

    const FramePentagonalType::Point_sequence& FramePentagonalType::
    Point () const
    {
      return this->Point_;
    }

    FramePentagonalType::Point_sequence& FramePentagonalType::
    Point ()
    {
      return this->Point_;
    }

    void FramePentagonalType::
    Point (const Point_sequence& s)
    {
      this->Point_ = s;
    }


    // FrameOctagonalType
    //

    const FrameOctagonalType::Point_sequence& FrameOctagonalType::
    Point () const
    {
      return this->Point_;
    }

    FrameOctagonalType::Point_sequence& FrameOctagonalType::
    Point ()
    {
      return this->Point_;
    }

    void FrameOctagonalType::
    Point (const Point_sequence& s)
    {
      this->Point_ = s;
    }


    // FrameHexagonalType
    //

    const FrameHexagonalType::Point_sequence& FrameHexagonalType::
    Point () const
    {
      return this->Point_;
    }

    FrameHexagonalType::Point_sequence& FrameHexagonalType::
    Point ()
    {
      return this->Point_;
    }

    void FrameHexagonalType::
    Point (const Point_sequence& s)
    {
      this->Point_ = s;
    }


    // LeaderHeadFormEnumType
    //

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (value v)
    : ::xml_schema::string (_xsd_LeaderHeadFormEnumType_literals_[v])
    {
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const LeaderHeadFormEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LeaderHeadFormEnumType& LeaderHeadFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LeaderHeadFormEnumType_literals_[v]);

      return *this;
    }


    // LeaderHeadFormType
    //

    const LeaderHeadFormType::normal_optional& LeaderHeadFormType::
    normal () const
    {
      return this->normal_;
    }

    LeaderHeadFormType::normal_optional& LeaderHeadFormType::
    normal ()
    {
      return this->normal_;
    }

    void LeaderHeadFormType::
    normal (const normal_type& x)
    {
      this->normal_.set (x);
    }

    void LeaderHeadFormType::
    normal (const normal_optional& x)
    {
      this->normal_ = x;
    }

    void LeaderHeadFormType::
    normal (::std::unique_ptr< normal_type > x)
    {
      this->normal_.set (std::move (x));
    }


    // LeaderModifierEnumType
    //

    LeaderModifierEnumType::
    LeaderModifierEnumType ()
    : ::xml_schema::string ()
    {
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (value v)
    : ::xml_schema::string (_xsd_LeaderModifierEnumType_literals_[v])
    {
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const LeaderModifierEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LeaderModifierEnumType& LeaderModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LeaderModifierEnumType_literals_[v]);

      return *this;
    }


    // ViewSetType
    //

    const ViewSetType::CameraSet_optional& ViewSetType::
    CameraSet () const
    {
      return this->CameraSet_;
    }

    ViewSetType::CameraSet_optional& ViewSetType::
    CameraSet ()
    {
      return this->CameraSet_;
    }

    void ViewSetType::
    CameraSet (const CameraSet_type& x)
    {
      this->CameraSet_.set (x);
    }

    void ViewSetType::
    CameraSet (const CameraSet_optional& x)
    {
      this->CameraSet_ = x;
    }

    void ViewSetType::
    CameraSet (::std::unique_ptr< CameraSet_type > x)
    {
      this->CameraSet_.set (std::move (x));
    }

    const ViewSetType::SavedViewSet_optional& ViewSetType::
    SavedViewSet () const
    {
      return this->SavedViewSet_;
    }

    ViewSetType::SavedViewSet_optional& ViewSetType::
    SavedViewSet ()
    {
      return this->SavedViewSet_;
    }

    void ViewSetType::
    SavedViewSet (const SavedViewSet_type& x)
    {
      this->SavedViewSet_.set (x);
    }

    void ViewSetType::
    SavedViewSet (const SavedViewSet_optional& x)
    {
      this->SavedViewSet_ = x;
    }

    void ViewSetType::
    SavedViewSet (::std::unique_ptr< SavedViewSet_type > x)
    {
      this->SavedViewSet_.set (std::move (x));
    }

    const ViewSetType::AnnotationViewSet_optional& ViewSetType::
    AnnotationViewSet () const
    {
      return this->AnnotationViewSet_;
    }

    ViewSetType::AnnotationViewSet_optional& ViewSetType::
    AnnotationViewSet ()
    {
      return this->AnnotationViewSet_;
    }

    void ViewSetType::
    AnnotationViewSet (const AnnotationViewSet_type& x)
    {
      this->AnnotationViewSet_.set (x);
    }

    void ViewSetType::
    AnnotationViewSet (const AnnotationViewSet_optional& x)
    {
      this->AnnotationViewSet_ = x;
    }

    void ViewSetType::
    AnnotationViewSet (::std::unique_ptr< AnnotationViewSet_type > x)
    {
      this->AnnotationViewSet_.set (std::move (x));
    }

    const ViewSetType::SimplifiedRepresentationSet_optional& ViewSetType::
    SimplifiedRepresentationSet () const
    {
      return this->SimplifiedRepresentationSet_;
    }

    ViewSetType::SimplifiedRepresentationSet_optional& ViewSetType::
    SimplifiedRepresentationSet ()
    {
      return this->SimplifiedRepresentationSet_;
    }

    void ViewSetType::
    SimplifiedRepresentationSet (const SimplifiedRepresentationSet_type& x)
    {
      this->SimplifiedRepresentationSet_.set (x);
    }

    void ViewSetType::
    SimplifiedRepresentationSet (const SimplifiedRepresentationSet_optional& x)
    {
      this->SimplifiedRepresentationSet_ = x;
    }

    void ViewSetType::
    SimplifiedRepresentationSet (::std::unique_ptr< SimplifiedRepresentationSet_type > x)
    {
      this->SimplifiedRepresentationSet_.set (std::move (x));
    }

    const ViewSetType::ExplodedViewSet_optional& ViewSetType::
    ExplodedViewSet () const
    {
      return this->ExplodedViewSet_;
    }

    ViewSetType::ExplodedViewSet_optional& ViewSetType::
    ExplodedViewSet ()
    {
      return this->ExplodedViewSet_;
    }

    void ViewSetType::
    ExplodedViewSet (const ExplodedViewSet_type& x)
    {
      this->ExplodedViewSet_.set (x);
    }

    void ViewSetType::
    ExplodedViewSet (const ExplodedViewSet_optional& x)
    {
      this->ExplodedViewSet_ = x;
    }

    void ViewSetType::
    ExplodedViewSet (::std::unique_ptr< ExplodedViewSet_type > x)
    {
      this->ExplodedViewSet_.set (std::move (x));
    }

    const ViewSetType::DisplayStyleSet_optional& ViewSetType::
    DisplayStyleSet () const
    {
      return this->DisplayStyleSet_;
    }

    ViewSetType::DisplayStyleSet_optional& ViewSetType::
    DisplayStyleSet ()
    {
      return this->DisplayStyleSet_;
    }

    void ViewSetType::
    DisplayStyleSet (const DisplayStyleSet_type& x)
    {
      this->DisplayStyleSet_.set (x);
    }

    void ViewSetType::
    DisplayStyleSet (const DisplayStyleSet_optional& x)
    {
      this->DisplayStyleSet_ = x;
    }

    void ViewSetType::
    DisplayStyleSet (::std::unique_ptr< DisplayStyleSet_type > x)
    {
      this->DisplayStyleSet_.set (std::move (x));
    }

    const ViewSetType::ZoneSectionSet_optional& ViewSetType::
    ZoneSectionSet () const
    {
      return this->ZoneSectionSet_;
    }

    ViewSetType::ZoneSectionSet_optional& ViewSetType::
    ZoneSectionSet ()
    {
      return this->ZoneSectionSet_;
    }

    void ViewSetType::
    ZoneSectionSet (const ZoneSectionSet_type& x)
    {
      this->ZoneSectionSet_.set (x);
    }

    void ViewSetType::
    ZoneSectionSet (const ZoneSectionSet_optional& x)
    {
      this->ZoneSectionSet_ = x;
    }

    void ViewSetType::
    ZoneSectionSet (::std::unique_ptr< ZoneSectionSet_type > x)
    {
      this->ZoneSectionSet_.set (std::move (x));
    }

    const ViewSetType::HatchStyleSet_optional& ViewSetType::
    HatchStyleSet () const
    {
      return this->HatchStyleSet_;
    }

    ViewSetType::HatchStyleSet_optional& ViewSetType::
    HatchStyleSet ()
    {
      return this->HatchStyleSet_;
    }

    void ViewSetType::
    HatchStyleSet (const HatchStyleSet_type& x)
    {
      this->HatchStyleSet_.set (x);
    }

    void ViewSetType::
    HatchStyleSet (const HatchStyleSet_optional& x)
    {
      this->HatchStyleSet_ = x;
    }

    void ViewSetType::
    HatchStyleSet (::std::unique_ptr< HatchStyleSet_type > x)
    {
      this->HatchStyleSet_.set (std::move (x));
    }


    // CameraType
    //

    const CameraType::ViewPlaneOrigin_type& CameraType::
    ViewPlaneOrigin () const
    {
      return this->ViewPlaneOrigin_.get ();
    }

    CameraType::ViewPlaneOrigin_type& CameraType::
    ViewPlaneOrigin ()
    {
      return this->ViewPlaneOrigin_.get ();
    }

    void CameraType::
    ViewPlaneOrigin (const ViewPlaneOrigin_type& x)
    {
      this->ViewPlaneOrigin_.set (x);
    }

    void CameraType::
    ViewPlaneOrigin (::std::unique_ptr< ViewPlaneOrigin_type > x)
    {
      this->ViewPlaneOrigin_.set (std::move (x));
    }

    const CameraType::Orientation_type& CameraType::
    Orientation () const
    {
      return this->Orientation_.get ();
    }

    CameraType::Orientation_type& CameraType::
    Orientation ()
    {
      return this->Orientation_.get ();
    }

    void CameraType::
    Orientation (const Orientation_type& x)
    {
      this->Orientation_.set (x);
    }

    void CameraType::
    Orientation (::std::unique_ptr< Orientation_type > x)
    {
      this->Orientation_.set (std::move (x));
    }

    const CameraType::Ratio_type& CameraType::
    Ratio () const
    {
      return this->Ratio_.get ();
    }

    CameraType::Ratio_type& CameraType::
    Ratio ()
    {
      return this->Ratio_.get ();
    }

    void CameraType::
    Ratio (const Ratio_type& x)
    {
      this->Ratio_.set (x);
    }

    const CameraType::Near_type& CameraType::
    Near () const
    {
      return this->Near_.get ();
    }

    CameraType::Near_type& CameraType::
    Near ()
    {
      return this->Near_.get ();
    }

    void CameraType::
    Near (const Near_type& x)
    {
      this->Near_.set (x);
    }

    void CameraType::
    Near (::std::unique_ptr< Near_type > x)
    {
      this->Near_.set (std::move (x));
    }

    const CameraType::Far_type& CameraType::
    Far () const
    {
      return this->Far_.get ();
    }

    CameraType::Far_type& CameraType::
    Far ()
    {
      return this->Far_.get ();
    }

    void CameraType::
    Far (const Far_type& x)
    {
      this->Far_.set (x);
    }

    void CameraType::
    Far (::std::unique_ptr< Far_type > x)
    {
      this->Far_.set (std::move (x));
    }

    const CameraType::Height_type& CameraType::
    Height () const
    {
      return this->Height_.get ();
    }

    CameraType::Height_type& CameraType::
    Height ()
    {
      return this->Height_.get ();
    }

    void CameraType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    const CameraType::form_type& CameraType::
    form () const
    {
      return this->form_.get ();
    }

    CameraType::form_type& CameraType::
    form ()
    {
      return this->form_.get ();
    }

    void CameraType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void CameraType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const CameraType::form_type& CameraType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // CameraFormEnumType
    //

    CameraFormEnumType::
    CameraFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    CameraFormEnumType::
    CameraFormEnumType (value v)
    : ::xml_schema::string (_xsd_CameraFormEnumType_literals_[v])
    {
    }

    CameraFormEnumType::
    CameraFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    CameraFormEnumType::
    CameraFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    CameraFormEnumType::
    CameraFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    CameraFormEnumType::
    CameraFormEnumType (const CameraFormEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    CameraFormEnumType& CameraFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_CameraFormEnumType_literals_[v]);

      return *this;
    }


    // SavedViewType
    //

    const SavedViewType::ActiveView_optional& SavedViewType::
    ActiveView () const
    {
      return this->ActiveView_;
    }

    SavedViewType::ActiveView_optional& SavedViewType::
    ActiveView ()
    {
      return this->ActiveView_;
    }

    void SavedViewType::
    ActiveView (const ActiveView_type& x)
    {
      this->ActiveView_.set (x);
    }

    void SavedViewType::
    ActiveView (const ActiveView_optional& x)
    {
      this->ActiveView_ = x;
    }

    SavedViewType::ActiveView_type SavedViewType::
    ActiveView_default_value ()
    {
      return ActiveView_type (false);
    }

    const SavedViewType::AnnotationVisibleIds_optional& SavedViewType::
    AnnotationVisibleIds () const
    {
      return this->AnnotationVisibleIds_;
    }

    SavedViewType::AnnotationVisibleIds_optional& SavedViewType::
    AnnotationVisibleIds ()
    {
      return this->AnnotationVisibleIds_;
    }

    void SavedViewType::
    AnnotationVisibleIds (const AnnotationVisibleIds_type& x)
    {
      this->AnnotationVisibleIds_.set (x);
    }

    void SavedViewType::
    AnnotationVisibleIds (const AnnotationVisibleIds_optional& x)
    {
      this->AnnotationVisibleIds_ = x;
    }

    void SavedViewType::
    AnnotationVisibleIds (::std::unique_ptr< AnnotationVisibleIds_type > x)
    {
      this->AnnotationVisibleIds_.set (std::move (x));
    }

    const SavedViewType::AnnotationHiddenIds_optional& SavedViewType::
    AnnotationHiddenIds () const
    {
      return this->AnnotationHiddenIds_;
    }

    SavedViewType::AnnotationHiddenIds_optional& SavedViewType::
    AnnotationHiddenIds ()
    {
      return this->AnnotationHiddenIds_;
    }

    void SavedViewType::
    AnnotationHiddenIds (const AnnotationHiddenIds_type& x)
    {
      this->AnnotationHiddenIds_.set (x);
    }

    void SavedViewType::
    AnnotationHiddenIds (const AnnotationHiddenIds_optional& x)
    {
      this->AnnotationHiddenIds_ = x;
    }

    void SavedViewType::
    AnnotationHiddenIds (::std::unique_ptr< AnnotationHiddenIds_type > x)
    {
      this->AnnotationHiddenIds_.set (std::move (x));
    }

    const SavedViewType::BodyIds_optional& SavedViewType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    SavedViewType::BodyIds_optional& SavedViewType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void SavedViewType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void SavedViewType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void SavedViewType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }

    const SavedViewType::ComponentIds_optional& SavedViewType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    SavedViewType::ComponentIds_optional& SavedViewType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void SavedViewType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void SavedViewType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void SavedViewType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const SavedViewType::SimplifiedRepresentationId_optional& SavedViewType::
    SimplifiedRepresentationId () const
    {
      return this->SimplifiedRepresentationId_;
    }

    SavedViewType::SimplifiedRepresentationId_optional& SavedViewType::
    SimplifiedRepresentationId ()
    {
      return this->SimplifiedRepresentationId_;
    }

    void SavedViewType::
    SimplifiedRepresentationId (const SimplifiedRepresentationId_type& x)
    {
      this->SimplifiedRepresentationId_.set (x);
    }

    void SavedViewType::
    SimplifiedRepresentationId (const SimplifiedRepresentationId_optional& x)
    {
      this->SimplifiedRepresentationId_ = x;
    }

    void SavedViewType::
    SimplifiedRepresentationId (::std::unique_ptr< SimplifiedRepresentationId_type > x)
    {
      this->SimplifiedRepresentationId_.set (std::move (x));
    }

    const SavedViewType::ExplodedViewId_optional& SavedViewType::
    ExplodedViewId () const
    {
      return this->ExplodedViewId_;
    }

    SavedViewType::ExplodedViewId_optional& SavedViewType::
    ExplodedViewId ()
    {
      return this->ExplodedViewId_;
    }

    void SavedViewType::
    ExplodedViewId (const ExplodedViewId_type& x)
    {
      this->ExplodedViewId_.set (x);
    }

    void SavedViewType::
    ExplodedViewId (const ExplodedViewId_optional& x)
    {
      this->ExplodedViewId_ = x;
    }

    void SavedViewType::
    ExplodedViewId (::std::unique_ptr< ExplodedViewId_type > x)
    {
      this->ExplodedViewId_.set (std::move (x));
    }

    const SavedViewType::DisplayStyleId_optional& SavedViewType::
    DisplayStyleId () const
    {
      return this->DisplayStyleId_;
    }

    SavedViewType::DisplayStyleId_optional& SavedViewType::
    DisplayStyleId ()
    {
      return this->DisplayStyleId_;
    }

    void SavedViewType::
    DisplayStyleId (const DisplayStyleId_type& x)
    {
      this->DisplayStyleId_.set (x);
    }

    void SavedViewType::
    DisplayStyleId (const DisplayStyleId_optional& x)
    {
      this->DisplayStyleId_ = x;
    }

    void SavedViewType::
    DisplayStyleId (::std::unique_ptr< DisplayStyleId_type > x)
    {
      this->DisplayStyleId_.set (std::move (x));
    }

    const SavedViewType::ZoneSectionId_optional& SavedViewType::
    ZoneSectionId () const
    {
      return this->ZoneSectionId_;
    }

    SavedViewType::ZoneSectionId_optional& SavedViewType::
    ZoneSectionId ()
    {
      return this->ZoneSectionId_;
    }

    void SavedViewType::
    ZoneSectionId (const ZoneSectionId_type& x)
    {
      this->ZoneSectionId_.set (x);
    }

    void SavedViewType::
    ZoneSectionId (const ZoneSectionId_optional& x)
    {
      this->ZoneSectionId_ = x;
    }

    void SavedViewType::
    ZoneSectionId (::std::unique_ptr< ZoneSectionId_type > x)
    {
      this->ZoneSectionId_.set (std::move (x));
    }

    const SavedViewType::CameraIds_optional& SavedViewType::
    CameraIds () const
    {
      return this->CameraIds_;
    }

    SavedViewType::CameraIds_optional& SavedViewType::
    CameraIds ()
    {
      return this->CameraIds_;
    }

    void SavedViewType::
    CameraIds (const CameraIds_type& x)
    {
      this->CameraIds_.set (x);
    }

    void SavedViewType::
    CameraIds (const CameraIds_optional& x)
    {
      this->CameraIds_ = x;
    }

    void SavedViewType::
    CameraIds (::std::unique_ptr< CameraIds_type > x)
    {
      this->CameraIds_.set (std::move (x));
    }


    // ZoneSectionType
    //

    const ZoneSectionType::SectionPlanes_type& ZoneSectionType::
    SectionPlanes () const
    {
      return this->SectionPlanes_.get ();
    }

    ZoneSectionType::SectionPlanes_type& ZoneSectionType::
    SectionPlanes ()
    {
      return this->SectionPlanes_.get ();
    }

    void ZoneSectionType::
    SectionPlanes (const SectionPlanes_type& x)
    {
      this->SectionPlanes_.set (x);
    }

    void ZoneSectionType::
    SectionPlanes (::std::unique_ptr< SectionPlanes_type > x)
    {
      this->SectionPlanes_.set (std::move (x));
    }

    const ZoneSectionType::LogicalOperations_optional& ZoneSectionType::
    LogicalOperations () const
    {
      return this->LogicalOperations_;
    }

    ZoneSectionType::LogicalOperations_optional& ZoneSectionType::
    LogicalOperations ()
    {
      return this->LogicalOperations_;
    }

    void ZoneSectionType::
    LogicalOperations (const LogicalOperations_type& x)
    {
      this->LogicalOperations_.set (x);
    }

    void ZoneSectionType::
    LogicalOperations (const LogicalOperations_optional& x)
    {
      this->LogicalOperations_ = x;
    }

    void ZoneSectionType::
    LogicalOperations (::std::unique_ptr< LogicalOperations_type > x)
    {
      this->LogicalOperations_.set (std::move (x));
    }

    const ZoneSectionType::hatching_type& ZoneSectionType::
    hatching () const
    {
      return this->hatching_.get ();
    }

    ZoneSectionType::hatching_type& ZoneSectionType::
    hatching ()
    {
      return this->hatching_.get ();
    }

    void ZoneSectionType::
    hatching (const hatching_type& x)
    {
      this->hatching_.set (x);
    }

    ZoneSectionType::hatching_type ZoneSectionType::
    hatching_default_value ()
    {
      return hatching_type (true);
    }


    // LogicalOperationType
    //

    const LogicalOperationType::Action_type& LogicalOperationType::
    Action () const
    {
      return this->Action_.get ();
    }

    LogicalOperationType::Action_type& LogicalOperationType::
    Action ()
    {
      return this->Action_.get ();
    }

    void LogicalOperationType::
    Action (const Action_type& x)
    {
      this->Action_.set (x);
    }

    void LogicalOperationType::
    Action (::std::unique_ptr< Action_type > x)
    {
      this->Action_.set (std::move (x));
    }

    const LogicalOperationType::SectionPlane_sequence& LogicalOperationType::
    SectionPlane () const
    {
      return this->SectionPlane_;
    }

    LogicalOperationType::SectionPlane_sequence& LogicalOperationType::
    SectionPlane ()
    {
      return this->SectionPlane_;
    }

    void LogicalOperationType::
    SectionPlane (const SectionPlane_sequence& s)
    {
      this->SectionPlane_ = s;
    }

    const LogicalOperationType::LogicalOperationResult_sequence& LogicalOperationType::
    LogicalOperationResult () const
    {
      return this->LogicalOperationResult_;
    }

    LogicalOperationType::LogicalOperationResult_sequence& LogicalOperationType::
    LogicalOperationResult ()
    {
      return this->LogicalOperationResult_;
    }

    void LogicalOperationType::
    LogicalOperationResult (const LogicalOperationResult_sequence& s)
    {
      this->LogicalOperationResult_ = s;
    }

    const LogicalOperationType::index_type& LogicalOperationType::
    index () const
    {
      return this->index_.get ();
    }

    LogicalOperationType::index_type& LogicalOperationType::
    index ()
    {
      return this->index_.get ();
    }

    void LogicalOperationType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }


    // LogicalOperationsType
    //

    const LogicalOperationsType::LogicalOperation_sequence& LogicalOperationsType::
    LogicalOperation () const
    {
      return this->LogicalOperation_;
    }

    LogicalOperationsType::LogicalOperation_sequence& LogicalOperationsType::
    LogicalOperation ()
    {
      return this->LogicalOperation_;
    }

    void LogicalOperationsType::
    LogicalOperation (const LogicalOperation_sequence& s)
    {
      this->LogicalOperation_ = s;
    }

    const LogicalOperationsType::n_type& LogicalOperationsType::
    n () const
    {
      return this->n_.get ();
    }

    LogicalOperationsType::n_type& LogicalOperationsType::
    n ()
    {
      return this->n_.get ();
    }

    void LogicalOperationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LogicalOperationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LogicalOperationEnumType
    //

    LogicalOperationEnumType::
    LogicalOperationEnumType ()
    : ::xml_schema::string ()
    {
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (value v)
    : ::xml_schema::string (_xsd_LogicalOperationEnumType_literals_[v])
    {
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const LogicalOperationEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LogicalOperationEnumType& LogicalOperationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LogicalOperationEnumType_literals_[v]);

      return *this;
    }


    // ZoneSectionPlanesType
    //

    const ZoneSectionPlanesType::SectionPlane_sequence& ZoneSectionPlanesType::
    SectionPlane () const
    {
      return this->SectionPlane_;
    }

    ZoneSectionPlanesType::SectionPlane_sequence& ZoneSectionPlanesType::
    SectionPlane ()
    {
      return this->SectionPlane_;
    }

    void ZoneSectionPlanesType::
    SectionPlane (const SectionPlane_sequence& s)
    {
      this->SectionPlane_ = s;
    }

    const ZoneSectionPlanesType::n_type& ZoneSectionPlanesType::
    n () const
    {
      return this->n_.get ();
    }

    ZoneSectionPlanesType::n_type& ZoneSectionPlanesType::
    n ()
    {
      return this->n_.get ();
    }

    void ZoneSectionPlanesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ZoneSectionPlanesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ZoneSectionPlaneType
    //

    const ZoneSectionPlaneType::Plane_type& ZoneSectionPlaneType::
    Plane () const
    {
      return this->Plane_.get ();
    }

    ZoneSectionPlaneType::Plane_type& ZoneSectionPlaneType::
    Plane ()
    {
      return this->Plane_.get ();
    }

    void ZoneSectionPlaneType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void ZoneSectionPlaneType::
    Plane (::std::unique_ptr< Plane_type > x)
    {
      this->Plane_.set (std::move (x));
    }

    const ZoneSectionPlaneType::SectionGroups_optional& ZoneSectionPlaneType::
    SectionGroups () const
    {
      return this->SectionGroups_;
    }

    ZoneSectionPlaneType::SectionGroups_optional& ZoneSectionPlaneType::
    SectionGroups ()
    {
      return this->SectionGroups_;
    }

    void ZoneSectionPlaneType::
    SectionGroups (const SectionGroups_type& x)
    {
      this->SectionGroups_.set (x);
    }

    void ZoneSectionPlaneType::
    SectionGroups (const SectionGroups_optional& x)
    {
      this->SectionGroups_ = x;
    }

    void ZoneSectionPlaneType::
    SectionGroups (::std::unique_ptr< SectionGroups_type > x)
    {
      this->SectionGroups_.set (std::move (x));
    }

    const ZoneSectionPlaneType::index_type& ZoneSectionPlaneType::
    index () const
    {
      return this->index_.get ();
    }

    ZoneSectionPlaneType::index_type& ZoneSectionPlaneType::
    index ()
    {
      return this->index_.get ();
    }

    void ZoneSectionPlaneType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }


    // SectionGroupsType
    //

    const SectionGroupsType::SectionGroup_sequence& SectionGroupsType::
    SectionGroup () const
    {
      return this->SectionGroup_;
    }

    SectionGroupsType::SectionGroup_sequence& SectionGroupsType::
    SectionGroup ()
    {
      return this->SectionGroup_;
    }

    void SectionGroupsType::
    SectionGroup (const SectionGroup_sequence& s)
    {
      this->SectionGroup_ = s;
    }

    const SectionGroupsType::n_type& SectionGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    SectionGroupsType::n_type& SectionGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void SectionGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SectionGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SectionGroupType
    //

    const SectionGroupType::BodyId_optional& SectionGroupType::
    BodyId () const
    {
      return this->BodyId_;
    }

    SectionGroupType::BodyId_optional& SectionGroupType::
    BodyId ()
    {
      return this->BodyId_;
    }

    void SectionGroupType::
    BodyId (const BodyId_type& x)
    {
      this->BodyId_.set (x);
    }

    void SectionGroupType::
    BodyId (const BodyId_optional& x)
    {
      this->BodyId_ = x;
    }

    void SectionGroupType::
    BodyId (::std::unique_ptr< BodyId_type > x)
    {
      this->BodyId_.set (std::move (x));
    }

    const SectionGroupType::Areas_optional& SectionGroupType::
    Areas () const
    {
      return this->Areas_;
    }

    SectionGroupType::Areas_optional& SectionGroupType::
    Areas ()
    {
      return this->Areas_;
    }

    void SectionGroupType::
    Areas (const Areas_type& x)
    {
      this->Areas_.set (x);
    }

    void SectionGroupType::
    Areas (const Areas_optional& x)
    {
      this->Areas_ = x;
    }

    void SectionGroupType::
    Areas (::std::unique_ptr< Areas_type > x)
    {
      this->Areas_.set (std::move (x));
    }

    const SectionGroupType::Paths_optional& SectionGroupType::
    Paths () const
    {
      return this->Paths_;
    }

    SectionGroupType::Paths_optional& SectionGroupType::
    Paths ()
    {
      return this->Paths_;
    }

    void SectionGroupType::
    Paths (const Paths_type& x)
    {
      this->Paths_.set (x);
    }

    void SectionGroupType::
    Paths (const Paths_optional& x)
    {
      this->Paths_ = x;
    }

    void SectionGroupType::
    Paths (::std::unique_ptr< Paths_type > x)
    {
      this->Paths_.set (std::move (x));
    }

    const SectionGroupType::Vertices_optional& SectionGroupType::
    Vertices () const
    {
      return this->Vertices_;
    }

    SectionGroupType::Vertices_optional& SectionGroupType::
    Vertices ()
    {
      return this->Vertices_;
    }

    void SectionGroupType::
    Vertices (const Vertices_type& x)
    {
      this->Vertices_.set (x);
    }

    void SectionGroupType::
    Vertices (const Vertices_optional& x)
    {
      this->Vertices_ = x;
    }

    void SectionGroupType::
    Vertices (::std::unique_ptr< Vertices_type > x)
    {
      this->Vertices_.set (std::move (x));
    }


    // SectionPathsType
    //

    const SectionPathsType::Path_sequence& SectionPathsType::
    Path () const
    {
      return this->Path_;
    }

    SectionPathsType::Path_sequence& SectionPathsType::
    Path ()
    {
      return this->Path_;
    }

    void SectionPathsType::
    Path (const Path_sequence& s)
    {
      this->Path_ = s;
    }

    const SectionPathsType::n_type& SectionPathsType::
    n () const
    {
      return this->n_.get ();
    }

    SectionPathsType::n_type& SectionPathsType::
    n ()
    {
      return this->n_.get ();
    }

    void SectionPathsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SectionPathsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SectionLoopsType
    //

    const SectionLoopsType::Loop_sequence& SectionLoopsType::
    Loop () const
    {
      return this->Loop_;
    }

    SectionLoopsType::Loop_sequence& SectionLoopsType::
    Loop ()
    {
      return this->Loop_;
    }

    void SectionLoopsType::
    Loop (const Loop_sequence& s)
    {
      this->Loop_ = s;
    }

    const SectionLoopsType::n_type& SectionLoopsType::
    n () const
    {
      return this->n_.get ();
    }

    SectionLoopsType::n_type& SectionLoopsType::
    n ()
    {
      return this->n_.get ();
    }

    void SectionLoopsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SectionLoopsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SectionAreasType
    //

    const SectionAreasType::Area_sequence& SectionAreasType::
    Area () const
    {
      return this->Area_;
    }

    SectionAreasType::Area_sequence& SectionAreasType::
    Area ()
    {
      return this->Area_;
    }

    void SectionAreasType::
    Area (const Area_sequence& s)
    {
      this->Area_ = s;
    }

    const SectionAreasType::n_type& SectionAreasType::
    n () const
    {
      return this->n_.get ();
    }

    SectionAreasType::n_type& SectionAreasType::
    n ()
    {
      return this->n_.get ();
    }

    void SectionAreasType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SectionAreasType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SectionAreaType
    //

    const SectionAreaType::HatchStyleId_optional& SectionAreaType::
    HatchStyleId () const
    {
      return this->HatchStyleId_;
    }

    SectionAreaType::HatchStyleId_optional& SectionAreaType::
    HatchStyleId ()
    {
      return this->HatchStyleId_;
    }

    void SectionAreaType::
    HatchStyleId (const HatchStyleId_type& x)
    {
      this->HatchStyleId_.set (x);
    }

    void SectionAreaType::
    HatchStyleId (const HatchStyleId_optional& x)
    {
      this->HatchStyleId_ = x;
    }

    void SectionAreaType::
    HatchStyleId (::std::unique_ptr< HatchStyleId_type > x)
    {
      this->HatchStyleId_.set (std::move (x));
    }

    const SectionAreaType::Loops_type& SectionAreaType::
    Loops () const
    {
      return this->Loops_.get ();
    }

    SectionAreaType::Loops_type& SectionAreaType::
    Loops ()
    {
      return this->Loops_.get ();
    }

    void SectionAreaType::
    Loops (const Loops_type& x)
    {
      this->Loops_.set (x);
    }

    void SectionAreaType::
    Loops (::std::unique_ptr< Loops_type > x)
    {
      this->Loops_.set (std::move (x));
    }


    // SectionEdgesType
    //

    const SectionEdgesType::Edge_sequence& SectionEdgesType::
    Edge () const
    {
      return this->Edge_;
    }

    SectionEdgesType::Edge_sequence& SectionEdgesType::
    Edge ()
    {
      return this->Edge_;
    }

    void SectionEdgesType::
    Edge (const Edge_sequence& s)
    {
      this->Edge_ = s;
    }

    const SectionEdgesType::n_type& SectionEdgesType::
    n () const
    {
      return this->n_.get ();
    }

    SectionEdgesType::n_type& SectionEdgesType::
    n ()
    {
      return this->n_.get ();
    }

    void SectionEdgesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SectionEdgesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SectionPathType
    //

    const SectionPathType::Edges_type& SectionPathType::
    Edges () const
    {
      return this->Edges_.get ();
    }

    SectionPathType::Edges_type& SectionPathType::
    Edges ()
    {
      return this->Edges_.get ();
    }

    void SectionPathType::
    Edges (const Edges_type& x)
    {
      this->Edges_.set (x);
    }

    void SectionPathType::
    Edges (::std::unique_ptr< Edges_type > x)
    {
      this->Edges_.set (std::move (x));
    }


    // HatchPatternsType
    //

    const HatchPatternsType::Pattern_sequence& HatchPatternsType::
    Pattern () const
    {
      return this->Pattern_;
    }

    HatchPatternsType::Pattern_sequence& HatchPatternsType::
    Pattern ()
    {
      return this->Pattern_;
    }

    void HatchPatternsType::
    Pattern (const Pattern_sequence& s)
    {
      this->Pattern_ = s;
    }

    const HatchPatternsType::n_type& HatchPatternsType::
    n () const
    {
      return this->n_.get ();
    }

    HatchPatternsType::n_type& HatchPatternsType::
    n ()
    {
      return this->n_.get ();
    }

    void HatchPatternsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void HatchPatternsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // HatchStyleType
    //

    const HatchStyleType::Form_type& HatchStyleType::
    Form () const
    {
      return this->Form_.get ();
    }

    HatchStyleType::Form_type& HatchStyleType::
    Form ()
    {
      return this->Form_.get ();
    }

    void HatchStyleType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void HatchStyleType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const HatchStyleType::Color_optional& HatchStyleType::
    Color () const
    {
      return this->Color_;
    }

    HatchStyleType::Color_optional& HatchStyleType::
    Color ()
    {
      return this->Color_;
    }

    void HatchStyleType::
    Color (const Color_type& x)
    {
      this->Color_.set (x);
    }

    void HatchStyleType::
    Color (const Color_optional& x)
    {
      this->Color_ = x;
    }

    void HatchStyleType::
    Color (::std::unique_ptr< Color_type > x)
    {
      this->Color_.set (std::move (x));
    }

    const HatchStyleType::Patterns_optional& HatchStyleType::
    Patterns () const
    {
      return this->Patterns_;
    }

    HatchStyleType::Patterns_optional& HatchStyleType::
    Patterns ()
    {
      return this->Patterns_;
    }

    void HatchStyleType::
    Patterns (const Patterns_type& x)
    {
      this->Patterns_.set (x);
    }

    void HatchStyleType::
    Patterns (const Patterns_optional& x)
    {
      this->Patterns_ = x;
    }

    void HatchStyleType::
    Patterns (::std::unique_ptr< Patterns_type > x)
    {
      this->Patterns_.set (std::move (x));
    }


    // HatchStyleFormEnumType
    //

    HatchStyleFormEnumType::
    HatchStyleFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (value v)
    : ::xml_schema::string (_xsd_HatchStyleFormEnumType_literals_[v])
    {
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const HatchStyleFormEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    HatchStyleFormEnumType& HatchStyleFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_HatchStyleFormEnumType_literals_[v]);

      return *this;
    }


    // HatchPatternType
    //

    const HatchPatternType::LineStyle_optional& HatchPatternType::
    LineStyle () const
    {
      return this->LineStyle_;
    }

    HatchPatternType::LineStyle_optional& HatchPatternType::
    LineStyle ()
    {
      return this->LineStyle_;
    }

    void HatchPatternType::
    LineStyle (const LineStyle_type& x)
    {
      this->LineStyle_.set (x);
    }

    void HatchPatternType::
    LineStyle (const LineStyle_optional& x)
    {
      this->LineStyle_ = x;
    }

    void HatchPatternType::
    LineStyle (::std::unique_ptr< LineStyle_type > x)
    {
      this->LineStyle_.set (std::move (x));
    }

    const HatchPatternType::FirstLineOrigin_type& HatchPatternType::
    FirstLineOrigin () const
    {
      return this->FirstLineOrigin_.get ();
    }

    HatchPatternType::FirstLineOrigin_type& HatchPatternType::
    FirstLineOrigin ()
    {
      return this->FirstLineOrigin_.get ();
    }

    void HatchPatternType::
    FirstLineOrigin (const FirstLineOrigin_type& x)
    {
      this->FirstLineOrigin_.set (x);
    }

    void HatchPatternType::
    FirstLineOrigin (::std::unique_ptr< FirstLineOrigin_type > x)
    {
      this->FirstLineOrigin_.set (std::move (x));
    }

    const HatchPatternType::SecondLineOrigin_type& HatchPatternType::
    SecondLineOrigin () const
    {
      return this->SecondLineOrigin_.get ();
    }

    HatchPatternType::SecondLineOrigin_type& HatchPatternType::
    SecondLineOrigin ()
    {
      return this->SecondLineOrigin_.get ();
    }

    void HatchPatternType::
    SecondLineOrigin (const SecondLineOrigin_type& x)
    {
      this->SecondLineOrigin_.set (x);
    }

    void HatchPatternType::
    SecondLineOrigin (::std::unique_ptr< SecondLineOrigin_type > x)
    {
      this->SecondLineOrigin_.set (std::move (x));
    }

    const HatchPatternType::Angle_type& HatchPatternType::
    Angle () const
    {
      return this->Angle_.get ();
    }

    HatchPatternType::Angle_type& HatchPatternType::
    Angle ()
    {
      return this->Angle_.get ();
    }

    void HatchPatternType::
    Angle (const Angle_type& x)
    {
      this->Angle_.set (x);
    }

    void HatchPatternType::
    Angle (::std::unique_ptr< Angle_type > x)
    {
      this->Angle_.set (std::move (x));
    }

    const HatchPatternType::Color_optional& HatchPatternType::
    Color () const
    {
      return this->Color_;
    }

    HatchPatternType::Color_optional& HatchPatternType::
    Color ()
    {
      return this->Color_;
    }

    void HatchPatternType::
    Color (const Color_type& x)
    {
      this->Color_.set (x);
    }

    void HatchPatternType::
    Color (const Color_optional& x)
    {
      this->Color_ = x;
    }

    void HatchPatternType::
    Color (::std::unique_ptr< Color_type > x)
    {
      this->Color_.set (std::move (x));
    }


    // DisplayStyleType
    //

    const DisplayStyleType::Mode_type& DisplayStyleType::
    Mode () const
    {
      return this->Mode_.get ();
    }

    DisplayStyleType::Mode_type& DisplayStyleType::
    Mode ()
    {
      return this->Mode_.get ();
    }

    void DisplayStyleType::
    Mode (const Mode_type& x)
    {
      this->Mode_.set (x);
    }

    void DisplayStyleType::
    Mode (::std::unique_ptr< Mode_type > x)
    {
      this->Mode_.set (std::move (x));
    }

    const DisplayStyleType::DisplayStyleGroups_optional& DisplayStyleType::
    DisplayStyleGroups () const
    {
      return this->DisplayStyleGroups_;
    }

    DisplayStyleType::DisplayStyleGroups_optional& DisplayStyleType::
    DisplayStyleGroups ()
    {
      return this->DisplayStyleGroups_;
    }

    void DisplayStyleType::
    DisplayStyleGroups (const DisplayStyleGroups_type& x)
    {
      this->DisplayStyleGroups_.set (x);
    }

    void DisplayStyleType::
    DisplayStyleGroups (const DisplayStyleGroups_optional& x)
    {
      this->DisplayStyleGroups_ = x;
    }

    void DisplayStyleType::
    DisplayStyleGroups (::std::unique_ptr< DisplayStyleGroups_type > x)
    {
      this->DisplayStyleGroups_.set (std::move (x));
    }


    // DisplayStyleGroupsType
    //

    const DisplayStyleGroupsType::DisplayStyleGroup_sequence& DisplayStyleGroupsType::
    DisplayStyleGroup () const
    {
      return this->DisplayStyleGroup_;
    }

    DisplayStyleGroupsType::DisplayStyleGroup_sequence& DisplayStyleGroupsType::
    DisplayStyleGroup ()
    {
      return this->DisplayStyleGroup_;
    }

    void DisplayStyleGroupsType::
    DisplayStyleGroup (const DisplayStyleGroup_sequence& s)
    {
      this->DisplayStyleGroup_ = s;
    }

    const DisplayStyleGroupsType::n_type& DisplayStyleGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    DisplayStyleGroupsType::n_type& DisplayStyleGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void DisplayStyleGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DisplayStyleGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DisplayStyleModeType
    //

    const DisplayStyleModeType::Form_type& DisplayStyleModeType::
    Form () const
    {
      return this->Form_.get ();
    }

    DisplayStyleModeType::Form_type& DisplayStyleModeType::
    Form ()
    {
      return this->Form_.get ();
    }

    void DisplayStyleModeType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void DisplayStyleModeType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const DisplayStyleModeType::Color_optional& DisplayStyleModeType::
    Color () const
    {
      return this->Color_;
    }

    DisplayStyleModeType::Color_optional& DisplayStyleModeType::
    Color ()
    {
      return this->Color_;
    }

    void DisplayStyleModeType::
    Color (const Color_type& x)
    {
      this->Color_.set (x);
    }

    void DisplayStyleModeType::
    Color (const Color_optional& x)
    {
      this->Color_ = x;
    }

    void DisplayStyleModeType::
    Color (::std::unique_ptr< Color_type > x)
    {
      this->Color_.set (std::move (x));
    }

    const DisplayStyleModeType::Transparency_optional& DisplayStyleModeType::
    Transparency () const
    {
      return this->Transparency_;
    }

    DisplayStyleModeType::Transparency_optional& DisplayStyleModeType::
    Transparency ()
    {
      return this->Transparency_;
    }

    void DisplayStyleModeType::
    Transparency (const Transparency_type& x)
    {
      this->Transparency_.set (x);
    }

    void DisplayStyleModeType::
    Transparency (const Transparency_optional& x)
    {
      this->Transparency_ = x;
    }

    void DisplayStyleModeType::
    Transparency (::std::unique_ptr< Transparency_type > x)
    {
      this->Transparency_.set (std::move (x));
    }

    DisplayStyleModeType::Transparency_type DisplayStyleModeType::
    Transparency_default_value ()
    {
      return Transparency_type (0.0);
    }


    // DisplayStyleGroupType
    //

    const DisplayStyleGroupType::Mode_type& DisplayStyleGroupType::
    Mode () const
    {
      return this->Mode_.get ();
    }

    DisplayStyleGroupType::Mode_type& DisplayStyleGroupType::
    Mode ()
    {
      return this->Mode_.get ();
    }

    void DisplayStyleGroupType::
    Mode (const Mode_type& x)
    {
      this->Mode_.set (x);
    }

    void DisplayStyleGroupType::
    Mode (::std::unique_ptr< Mode_type > x)
    {
      this->Mode_.set (std::move (x));
    }

    const DisplayStyleGroupType::ComponentIds_optional& DisplayStyleGroupType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    DisplayStyleGroupType::ComponentIds_optional& DisplayStyleGroupType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void DisplayStyleGroupType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void DisplayStyleGroupType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void DisplayStyleGroupType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const DisplayStyleGroupType::BodyIds_optional& DisplayStyleGroupType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    DisplayStyleGroupType::BodyIds_optional& DisplayStyleGroupType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void DisplayStyleGroupType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void DisplayStyleGroupType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void DisplayStyleGroupType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }


    // DisplayStyleFormEnumType
    //

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (value v)
    : ::xml_schema::string (_xsd_DisplayStyleFormEnumType_literals_[v])
    {
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const DisplayStyleFormEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    DisplayStyleFormEnumType& DisplayStyleFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_DisplayStyleFormEnumType_literals_[v]);

      return *this;
    }


    // ExplodedViewType
    //

    const ExplodedViewType::MoveGroups_type& ExplodedViewType::
    MoveGroups () const
    {
      return this->MoveGroups_.get ();
    }

    ExplodedViewType::MoveGroups_type& ExplodedViewType::
    MoveGroups ()
    {
      return this->MoveGroups_.get ();
    }

    void ExplodedViewType::
    MoveGroups (const MoveGroups_type& x)
    {
      this->MoveGroups_.set (x);
    }

    void ExplodedViewType::
    MoveGroups (::std::unique_ptr< MoveGroups_type > x)
    {
      this->MoveGroups_.set (std::move (x));
    }


    // ExplodedViewMoveGroupsType
    //

    const ExplodedViewMoveGroupsType::MoveGroup_sequence& ExplodedViewMoveGroupsType::
    MoveGroup () const
    {
      return this->MoveGroup_;
    }

    ExplodedViewMoveGroupsType::MoveGroup_sequence& ExplodedViewMoveGroupsType::
    MoveGroup ()
    {
      return this->MoveGroup_;
    }

    void ExplodedViewMoveGroupsType::
    MoveGroup (const MoveGroup_sequence& s)
    {
      this->MoveGroup_ = s;
    }

    const ExplodedViewMoveGroupsType::n_type& ExplodedViewMoveGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    ExplodedViewMoveGroupsType::n_type& ExplodedViewMoveGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void ExplodedViewMoveGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExplodedViewMoveGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ExplodedViewMoveGroupType
    //

    const ExplodedViewMoveGroupType::Translate_optional& ExplodedViewMoveGroupType::
    Translate () const
    {
      return this->Translate_;
    }

    ExplodedViewMoveGroupType::Translate_optional& ExplodedViewMoveGroupType::
    Translate ()
    {
      return this->Translate_;
    }

    void ExplodedViewMoveGroupType::
    Translate (const Translate_type& x)
    {
      this->Translate_.set (x);
    }

    void ExplodedViewMoveGroupType::
    Translate (const Translate_optional& x)
    {
      this->Translate_ = x;
    }

    void ExplodedViewMoveGroupType::
    Translate (::std::unique_ptr< Translate_type > x)
    {
      this->Translate_.set (std::move (x));
    }

    const ExplodedViewMoveGroupType::Rotate_optional& ExplodedViewMoveGroupType::
    Rotate () const
    {
      return this->Rotate_;
    }

    ExplodedViewMoveGroupType::Rotate_optional& ExplodedViewMoveGroupType::
    Rotate ()
    {
      return this->Rotate_;
    }

    void ExplodedViewMoveGroupType::
    Rotate (const Rotate_type& x)
    {
      this->Rotate_.set (x);
    }

    void ExplodedViewMoveGroupType::
    Rotate (const Rotate_optional& x)
    {
      this->Rotate_ = x;
    }

    void ExplodedViewMoveGroupType::
    Rotate (::std::unique_ptr< Rotate_type > x)
    {
      this->Rotate_.set (std::move (x));
    }

    const ExplodedViewMoveGroupType::ComponentIds_optional& ExplodedViewMoveGroupType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    ExplodedViewMoveGroupType::ComponentIds_optional& ExplodedViewMoveGroupType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void ExplodedViewMoveGroupType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void ExplodedViewMoveGroupType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void ExplodedViewMoveGroupType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const ExplodedViewMoveGroupType::BodyIds_optional& ExplodedViewMoveGroupType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    ExplodedViewMoveGroupType::BodyIds_optional& ExplodedViewMoveGroupType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void ExplodedViewMoveGroupType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void ExplodedViewMoveGroupType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void ExplodedViewMoveGroupType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }


    // ExplodedViewTranslateType
    //

    const ExplodedViewTranslateType::Direction_type& ExplodedViewTranslateType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    ExplodedViewTranslateType::Direction_type& ExplodedViewTranslateType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void ExplodedViewTranslateType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExplodedViewTranslateType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }

    const ExplodedViewTranslateType::Value_type& ExplodedViewTranslateType::
    Value () const
    {
      return this->Value_.get ();
    }

    ExplodedViewTranslateType::Value_type& ExplodedViewTranslateType::
    Value ()
    {
      return this->Value_.get ();
    }

    void ExplodedViewTranslateType::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void ExplodedViewTranslateType::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }


    // ExplodedViewRotateType
    //

    const ExplodedViewRotateType::Axis_type& ExplodedViewRotateType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ExplodedViewRotateType::Axis_type& ExplodedViewRotateType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ExplodedViewRotateType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ExplodedViewRotateType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ExplodedViewRotateType::Angle_type& ExplodedViewRotateType::
    Angle () const
    {
      return this->Angle_.get ();
    }

    ExplodedViewRotateType::Angle_type& ExplodedViewRotateType::
    Angle ()
    {
      return this->Angle_.get ();
    }

    void ExplodedViewRotateType::
    Angle (const Angle_type& x)
    {
      this->Angle_.set (x);
    }

    void ExplodedViewRotateType::
    Angle (::std::unique_ptr< Angle_type > x)
    {
      this->Angle_.set (std::move (x));
    }


    // SimplifiedRepresentationFormEnumType
    //

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (value v)
    : ::xml_schema::string (_xsd_SimplifiedRepresentationFormEnumType_literals_[v])
    {
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const SimplifiedRepresentationFormEnumType& v,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    SimplifiedRepresentationFormEnumType& SimplifiedRepresentationFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_SimplifiedRepresentationFormEnumType_literals_[v]);

      return *this;
    }


    // SimplifiedRepresentationType
    //

    const SimplifiedRepresentationType::Form_type& SimplifiedRepresentationType::
    Form () const
    {
      return this->Form_.get ();
    }

    SimplifiedRepresentationType::Form_type& SimplifiedRepresentationType::
    Form ()
    {
      return this->Form_.get ();
    }

    void SimplifiedRepresentationType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SimplifiedRepresentationType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const SimplifiedRepresentationType::SimplifiedRepresentationGroups_optional& SimplifiedRepresentationType::
    SimplifiedRepresentationGroups () const
    {
      return this->SimplifiedRepresentationGroups_;
    }

    SimplifiedRepresentationType::SimplifiedRepresentationGroups_optional& SimplifiedRepresentationType::
    SimplifiedRepresentationGroups ()
    {
      return this->SimplifiedRepresentationGroups_;
    }

    void SimplifiedRepresentationType::
    SimplifiedRepresentationGroups (const SimplifiedRepresentationGroups_type& x)
    {
      this->SimplifiedRepresentationGroups_.set (x);
    }

    void SimplifiedRepresentationType::
    SimplifiedRepresentationGroups (const SimplifiedRepresentationGroups_optional& x)
    {
      this->SimplifiedRepresentationGroups_ = x;
    }

    void SimplifiedRepresentationType::
    SimplifiedRepresentationGroups (::std::unique_ptr< SimplifiedRepresentationGroups_type > x)
    {
      this->SimplifiedRepresentationGroups_.set (std::move (x));
    }


    // SimplifiedRepresentationGroupsType
    //

    const SimplifiedRepresentationGroupsType::SimplifiedRepresentationGroup_sequence& SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroup () const
    {
      return this->SimplifiedRepresentationGroup_;
    }

    SimplifiedRepresentationGroupsType::SimplifiedRepresentationGroup_sequence& SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroup ()
    {
      return this->SimplifiedRepresentationGroup_;
    }

    void SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroup (const SimplifiedRepresentationGroup_sequence& s)
    {
      this->SimplifiedRepresentationGroup_ = s;
    }

    const SimplifiedRepresentationGroupsType::n_type& SimplifiedRepresentationGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    SimplifiedRepresentationGroupsType::n_type& SimplifiedRepresentationGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void SimplifiedRepresentationGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SimplifiedRepresentationGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SimplifiedRepresentationGroupType
    //

    const SimplifiedRepresentationGroupType::Form_type& SimplifiedRepresentationGroupType::
    Form () const
    {
      return this->Form_.get ();
    }

    SimplifiedRepresentationGroupType::Form_type& SimplifiedRepresentationGroupType::
    Form ()
    {
      return this->Form_.get ();
    }

    void SimplifiedRepresentationGroupType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SimplifiedRepresentationGroupType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const SimplifiedRepresentationGroupType::ComponentIds_optional& SimplifiedRepresentationGroupType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    SimplifiedRepresentationGroupType::ComponentIds_optional& SimplifiedRepresentationGroupType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void SimplifiedRepresentationGroupType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void SimplifiedRepresentationGroupType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void SimplifiedRepresentationGroupType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const SimplifiedRepresentationGroupType::BodyIds_optional& SimplifiedRepresentationGroupType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    SimplifiedRepresentationGroupType::BodyIds_optional& SimplifiedRepresentationGroupType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void SimplifiedRepresentationGroupType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void SimplifiedRepresentationGroupType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void SimplifiedRepresentationGroupType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }


    // AnnotationViewType
    //

    const AnnotationViewType::Normal_type& AnnotationViewType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    AnnotationViewType::Normal_type& AnnotationViewType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void AnnotationViewType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void AnnotationViewType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const AnnotationViewType::Direction_type& AnnotationViewType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    AnnotationViewType::Direction_type& AnnotationViewType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void AnnotationViewType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void AnnotationViewType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // CameraSetType
    //

    const CameraSetType::Camera_sequence& CameraSetType::
    Camera () const
    {
      return this->Camera_;
    }

    CameraSetType::Camera_sequence& CameraSetType::
    Camera ()
    {
      return this->Camera_;
    }

    void CameraSetType::
    Camera (const Camera_sequence& s)
    {
      this->Camera_ = s;
    }

    const CameraSetType::n_type& CameraSetType::
    n () const
    {
      return this->n_.get ();
    }

    CameraSetType::n_type& CameraSetType::
    n ()
    {
      return this->n_.get ();
    }

    void CameraSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CameraSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SavedViewSetType
    //

    const SavedViewSetType::SavedView_sequence& SavedViewSetType::
    SavedView () const
    {
      return this->SavedView_;
    }

    SavedViewSetType::SavedView_sequence& SavedViewSetType::
    SavedView ()
    {
      return this->SavedView_;
    }

    void SavedViewSetType::
    SavedView (const SavedView_sequence& s)
    {
      this->SavedView_ = s;
    }

    const SavedViewSetType::n_type& SavedViewSetType::
    n () const
    {
      return this->n_.get ();
    }

    SavedViewSetType::n_type& SavedViewSetType::
    n ()
    {
      return this->n_.get ();
    }

    void SavedViewSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SavedViewSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AnnotationViewSetType
    //

    const AnnotationViewSetType::AnnotationView_sequence& AnnotationViewSetType::
    AnnotationView () const
    {
      return this->AnnotationView_;
    }

    AnnotationViewSetType::AnnotationView_sequence& AnnotationViewSetType::
    AnnotationView ()
    {
      return this->AnnotationView_;
    }

    void AnnotationViewSetType::
    AnnotationView (const AnnotationView_sequence& s)
    {
      this->AnnotationView_ = s;
    }

    const AnnotationViewSetType::n_type& AnnotationViewSetType::
    n () const
    {
      return this->n_.get ();
    }

    AnnotationViewSetType::n_type& AnnotationViewSetType::
    n ()
    {
      return this->n_.get ();
    }

    void AnnotationViewSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AnnotationViewSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DisplayStyleSetType
    //

    const DisplayStyleSetType::DisplayStyle_sequence& DisplayStyleSetType::
    DisplayStyle () const
    {
      return this->DisplayStyle_;
    }

    DisplayStyleSetType::DisplayStyle_sequence& DisplayStyleSetType::
    DisplayStyle ()
    {
      return this->DisplayStyle_;
    }

    void DisplayStyleSetType::
    DisplayStyle (const DisplayStyle_sequence& s)
    {
      this->DisplayStyle_ = s;
    }

    const DisplayStyleSetType::n_type& DisplayStyleSetType::
    n () const
    {
      return this->n_.get ();
    }

    DisplayStyleSetType::n_type& DisplayStyleSetType::
    n ()
    {
      return this->n_.get ();
    }

    void DisplayStyleSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DisplayStyleSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ExplodedViewSetType
    //

    const ExplodedViewSetType::ExplodedView_sequence& ExplodedViewSetType::
    ExplodedView () const
    {
      return this->ExplodedView_;
    }

    ExplodedViewSetType::ExplodedView_sequence& ExplodedViewSetType::
    ExplodedView ()
    {
      return this->ExplodedView_;
    }

    void ExplodedViewSetType::
    ExplodedView (const ExplodedView_sequence& s)
    {
      this->ExplodedView_ = s;
    }

    const ExplodedViewSetType::n_type& ExplodedViewSetType::
    n () const
    {
      return this->n_.get ();
    }

    ExplodedViewSetType::n_type& ExplodedViewSetType::
    n ()
    {
      return this->n_.get ();
    }

    void ExplodedViewSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExplodedViewSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SimplifiedRepresentationSetType
    //

    const SimplifiedRepresentationSetType::SimplifiedRepresentation_sequence& SimplifiedRepresentationSetType::
    SimplifiedRepresentation () const
    {
      return this->SimplifiedRepresentation_;
    }

    SimplifiedRepresentationSetType::SimplifiedRepresentation_sequence& SimplifiedRepresentationSetType::
    SimplifiedRepresentation ()
    {
      return this->SimplifiedRepresentation_;
    }

    void SimplifiedRepresentationSetType::
    SimplifiedRepresentation (const SimplifiedRepresentation_sequence& s)
    {
      this->SimplifiedRepresentation_ = s;
    }

    const SimplifiedRepresentationSetType::n_type& SimplifiedRepresentationSetType::
    n () const
    {
      return this->n_.get ();
    }

    SimplifiedRepresentationSetType::n_type& SimplifiedRepresentationSetType::
    n ()
    {
      return this->n_.get ();
    }

    void SimplifiedRepresentationSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SimplifiedRepresentationSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ZoneSectionSetType
    //

    const ZoneSectionSetType::ZoneSection_sequence& ZoneSectionSetType::
    ZoneSection () const
    {
      return this->ZoneSection_;
    }

    ZoneSectionSetType::ZoneSection_sequence& ZoneSectionSetType::
    ZoneSection ()
    {
      return this->ZoneSection_;
    }

    void ZoneSectionSetType::
    ZoneSection (const ZoneSection_sequence& s)
    {
      this->ZoneSection_ = s;
    }

    const ZoneSectionSetType::n_type& ZoneSectionSetType::
    n () const
    {
      return this->n_.get ();
    }

    ZoneSectionSetType::n_type& ZoneSectionSetType::
    n ()
    {
      return this->n_.get ();
    }

    void ZoneSectionSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ZoneSectionSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // HatchStyleSetType
    //

    const HatchStyleSetType::HatchStyle_sequence& HatchStyleSetType::
    HatchStyle () const
    {
      return this->HatchStyle_;
    }

    HatchStyleSetType::HatchStyle_sequence& HatchStyleSetType::
    HatchStyle ()
    {
      return this->HatchStyle_;
    }

    void HatchStyleSetType::
    HatchStyle (const HatchStyle_sequence& s)
    {
      this->HatchStyle_ = s;
    }

    const HatchStyleSetType::n_type& HatchStyleSetType::
    n () const
    {
      return this->n_.get ();
    }

    HatchStyleSetType::n_type& HatchStyleSetType::
    n ()
    {
      return this->n_.get ();
    }

    void HatchStyleSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void HatchStyleSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TrailingZeroDisplayType
    //

    const TrailingZeroDisplayType::DimensionalCharacteristicValueTarget_optional& TrailingZeroDisplayType::
    DimensionalCharacteristicValueTarget () const
    {
      return this->DimensionalCharacteristicValueTarget_;
    }

    TrailingZeroDisplayType::DimensionalCharacteristicValueTarget_optional& TrailingZeroDisplayType::
    DimensionalCharacteristicValueTarget ()
    {
      return this->DimensionalCharacteristicValueTarget_;
    }

    void TrailingZeroDisplayType::
    DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_type& x)
    {
      this->DimensionalCharacteristicValueTarget_.set (x);
    }

    void TrailingZeroDisplayType::
    DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_optional& x)
    {
      this->DimensionalCharacteristicValueTarget_ = x;
    }

    const TrailingZeroDisplayType::DimensionalCharacteristicValueLimits_optional& TrailingZeroDisplayType::
    DimensionalCharacteristicValueLimits () const
    {
      return this->DimensionalCharacteristicValueLimits_;
    }

    TrailingZeroDisplayType::DimensionalCharacteristicValueLimits_optional& TrailingZeroDisplayType::
    DimensionalCharacteristicValueLimits ()
    {
      return this->DimensionalCharacteristicValueLimits_;
    }

    void TrailingZeroDisplayType::
    DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_type& x)
    {
      this->DimensionalCharacteristicValueLimits_.set (x);
    }

    void TrailingZeroDisplayType::
    DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_optional& x)
    {
      this->DimensionalCharacteristicValueLimits_ = x;
    }

    const TrailingZeroDisplayType::GeometricCharacteristicValue_optional& TrailingZeroDisplayType::
    GeometricCharacteristicValue () const
    {
      return this->GeometricCharacteristicValue_;
    }

    TrailingZeroDisplayType::GeometricCharacteristicValue_optional& TrailingZeroDisplayType::
    GeometricCharacteristicValue ()
    {
      return this->GeometricCharacteristicValue_;
    }

    void TrailingZeroDisplayType::
    GeometricCharacteristicValue (const GeometricCharacteristicValue_type& x)
    {
      this->GeometricCharacteristicValue_.set (x);
    }

    void TrailingZeroDisplayType::
    GeometricCharacteristicValue (const GeometricCharacteristicValue_optional& x)
    {
      this->GeometricCharacteristicValue_ = x;
    }

    const TrailingZeroDisplayType::TrailingZeroDimensionalCharacteristicDisplayGroups_optional& TrailingZeroDisplayType::
    TrailingZeroDimensionalCharacteristicDisplayGroups () const
    {
      return this->TrailingZeroDimensionalCharacteristicDisplayGroups_;
    }

    TrailingZeroDisplayType::TrailingZeroDimensionalCharacteristicDisplayGroups_optional& TrailingZeroDisplayType::
    TrailingZeroDimensionalCharacteristicDisplayGroups ()
    {
      return this->TrailingZeroDimensionalCharacteristicDisplayGroups_;
    }

    void TrailingZeroDisplayType::
    TrailingZeroDimensionalCharacteristicDisplayGroups (const TrailingZeroDimensionalCharacteristicDisplayGroups_type& x)
    {
      this->TrailingZeroDimensionalCharacteristicDisplayGroups_.set (x);
    }

    void TrailingZeroDisplayType::
    TrailingZeroDimensionalCharacteristicDisplayGroups (const TrailingZeroDimensionalCharacteristicDisplayGroups_optional& x)
    {
      this->TrailingZeroDimensionalCharacteristicDisplayGroups_ = x;
    }

    void TrailingZeroDisplayType::
    TrailingZeroDimensionalCharacteristicDisplayGroups (::std::unique_ptr< TrailingZeroDimensionalCharacteristicDisplayGroups_type > x)
    {
      this->TrailingZeroDimensionalCharacteristicDisplayGroups_.set (std::move (x));
    }

    const TrailingZeroDisplayType::TrailingZeroGeometricCharacteristicDisplayGroups_optional& TrailingZeroDisplayType::
    TrailingZeroGeometricCharacteristicDisplayGroups () const
    {
      return this->TrailingZeroGeometricCharacteristicDisplayGroups_;
    }

    TrailingZeroDisplayType::TrailingZeroGeometricCharacteristicDisplayGroups_optional& TrailingZeroDisplayType::
    TrailingZeroGeometricCharacteristicDisplayGroups ()
    {
      return this->TrailingZeroGeometricCharacteristicDisplayGroups_;
    }

    void TrailingZeroDisplayType::
    TrailingZeroGeometricCharacteristicDisplayGroups (const TrailingZeroGeometricCharacteristicDisplayGroups_type& x)
    {
      this->TrailingZeroGeometricCharacteristicDisplayGroups_.set (x);
    }

    void TrailingZeroDisplayType::
    TrailingZeroGeometricCharacteristicDisplayGroups (const TrailingZeroGeometricCharacteristicDisplayGroups_optional& x)
    {
      this->TrailingZeroGeometricCharacteristicDisplayGroups_ = x;
    }

    void TrailingZeroDisplayType::
    TrailingZeroGeometricCharacteristicDisplayGroups (::std::unique_ptr< TrailingZeroGeometricCharacteristicDisplayGroups_type > x)
    {
      this->TrailingZeroGeometricCharacteristicDisplayGroups_.set (std::move (x));
    }


    // TrailingZeroDimensionalCharacteristicDisplayGroupsType
    //

    const TrailingZeroDimensionalCharacteristicDisplayGroupsType::TrailingZeroDimensionalCharacteristicDisplayGroup_sequence& TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroup () const
    {
      return this->TrailingZeroDimensionalCharacteristicDisplayGroup_;
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::TrailingZeroDimensionalCharacteristicDisplayGroup_sequence& TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroup ()
    {
      return this->TrailingZeroDimensionalCharacteristicDisplayGroup_;
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroup (const TrailingZeroDimensionalCharacteristicDisplayGroup_sequence& s)
    {
      this->TrailingZeroDimensionalCharacteristicDisplayGroup_ = s;
    }

    const TrailingZeroDimensionalCharacteristicDisplayGroupsType::n_type& TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::n_type& TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TrailingZeroDimensionalCharacteristicDisplayGroupType
    //

    const TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicValueTarget_optional& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueTarget () const
    {
      return this->DimensionalCharacteristicValueTarget_;
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicValueTarget_optional& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueTarget ()
    {
      return this->DimensionalCharacteristicValueTarget_;
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_type& x)
    {
      this->DimensionalCharacteristicValueTarget_.set (x);
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_optional& x)
    {
      this->DimensionalCharacteristicValueTarget_ = x;
    }

    const TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicValueLimits_optional& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueLimits () const
    {
      return this->DimensionalCharacteristicValueLimits_;
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicValueLimits_optional& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueLimits ()
    {
      return this->DimensionalCharacteristicValueLimits_;
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_type& x)
    {
      this->DimensionalCharacteristicValueLimits_.set (x);
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_optional& x)
    {
      this->DimensionalCharacteristicValueLimits_ = x;
    }

    const TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicIds_type& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicIds () const
    {
      return this->DimensionalCharacteristicIds_.get ();
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::DimensionalCharacteristicIds_type& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicIds ()
    {
      return this->DimensionalCharacteristicIds_.get ();
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicIds (const DimensionalCharacteristicIds_type& x)
    {
      this->DimensionalCharacteristicIds_.set (x);
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    DimensionalCharacteristicIds (::std::unique_ptr< DimensionalCharacteristicIds_type > x)
    {
      this->DimensionalCharacteristicIds_.set (std::move (x));
    }


    // TrailingZeroGeometricCharacteristicDisplayGroupsType
    //

    const TrailingZeroGeometricCharacteristicDisplayGroupsType::TrailingZeroGeometricCharacteristicDisplayGroup_sequence& TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroup () const
    {
      return this->TrailingZeroGeometricCharacteristicDisplayGroup_;
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::TrailingZeroGeometricCharacteristicDisplayGroup_sequence& TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroup ()
    {
      return this->TrailingZeroGeometricCharacteristicDisplayGroup_;
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroup (const TrailingZeroGeometricCharacteristicDisplayGroup_sequence& s)
    {
      this->TrailingZeroGeometricCharacteristicDisplayGroup_ = s;
    }

    const TrailingZeroGeometricCharacteristicDisplayGroupsType::n_type& TrailingZeroGeometricCharacteristicDisplayGroupsType::
    n () const
    {
      return this->n_.get ();
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::n_type& TrailingZeroGeometricCharacteristicDisplayGroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TrailingZeroGeometricCharacteristicDisplayGroupType
    //

    const TrailingZeroGeometricCharacteristicDisplayGroupType::GeometricCharacteristicValue_type& TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicValue () const
    {
      return this->GeometricCharacteristicValue_.get ();
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::GeometricCharacteristicValue_type& TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicValue ()
    {
      return this->GeometricCharacteristicValue_.get ();
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicValue (const GeometricCharacteristicValue_type& x)
    {
      this->GeometricCharacteristicValue_.set (x);
    }

    const TrailingZeroGeometricCharacteristicDisplayGroupType::GeometricCharacteristicIds_type& TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicIds () const
    {
      return this->GeometricCharacteristicIds_.get ();
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::GeometricCharacteristicIds_type& TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicIds ()
    {
      return this->GeometricCharacteristicIds_.get ();
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicIds (const GeometricCharacteristicIds_type& x)
    {
      this->GeometricCharacteristicIds_.set (x);
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupType::
    GeometricCharacteristicIds (::std::unique_ptr< GeometricCharacteristicIds_type > x)
    {
      this->GeometricCharacteristicIds_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // VisualizationSetType
    //

    VisualizationSetType::
    VisualizationSetType ()
    : ::xml_schema::type (),
      Fonts_ (this),
      TrailingZeroDisplay_ (this),
      PMIDisplaySet_ (this)
    {
    }

    VisualizationSetType::
    VisualizationSetType (const Fonts_type& Fonts,
                          const PMIDisplaySet_type& PMIDisplaySet)
    : ::xml_schema::type (),
      Fonts_ (Fonts, this),
      TrailingZeroDisplay_ (this),
      PMIDisplaySet_ (PMIDisplaySet, this)
    {
    }

    VisualizationSetType::
    VisualizationSetType (::std::unique_ptr< Fonts_type > Fonts,
                          ::std::unique_ptr< PMIDisplaySet_type > PMIDisplaySet)
    : ::xml_schema::type (),
      Fonts_ (std::move (Fonts), this),
      TrailingZeroDisplay_ (this),
      PMIDisplaySet_ (std::move (PMIDisplaySet), this)
    {
    }

    VisualizationSetType::
    VisualizationSetType (const VisualizationSetType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Fonts_ (x.Fonts_, f, this),
      TrailingZeroDisplay_ (x.TrailingZeroDisplay_, f, this),
      PMIDisplaySet_ (x.PMIDisplaySet_, f, this)
    {
    }

    VisualizationSetType::
    VisualizationSetType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Fonts_ (this),
      TrailingZeroDisplay_ (this),
      PMIDisplaySet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VisualizationSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Fonts
        //
        if (n.name () == L"Fonts" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Fonts_type > r (
            Fonts_traits::create (i, f, this));

          if (!Fonts_.present ())
          {
            this->Fonts_.set (::std::move (r));
            continue;
          }
        }

        // TrailingZeroDisplay
        //
        if (n.name () == L"TrailingZeroDisplay" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrailingZeroDisplay_type > r (
            TrailingZeroDisplay_traits::create (i, f, this));

          if (!this->TrailingZeroDisplay_)
          {
            this->TrailingZeroDisplay_.set (::std::move (r));
            continue;
          }
        }

        // PMIDisplaySet
        //
        if (n.name () == L"PMIDisplaySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PMIDisplaySet_type > r (
            PMIDisplaySet_traits::create (i, f, this));

          if (!PMIDisplaySet_.present ())
          {
            this->PMIDisplaySet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Fonts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Fonts",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PMIDisplaySet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PMIDisplaySet",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VisualizationSetType* VisualizationSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VisualizationSetType (*this, f, c);
    }

    VisualizationSetType& VisualizationSetType::
    operator= (const VisualizationSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Fonts_ = x.Fonts_;
        this->TrailingZeroDisplay_ = x.TrailingZeroDisplay_;
        this->PMIDisplaySet_ = x.PMIDisplaySet_;
      }

      return *this;
    }

    VisualizationSetType::
    ~VisualizationSetType ()
    {
    }

    // FontsType
    //

    FontsType::
    FontsType ()
    : ::xml_schema::type (),
      Font_ (this),
      n_ (this)
    {
    }

    FontsType::
    FontsType (const n_type& n)
    : ::xml_schema::type (),
      Font_ (this),
      n_ (n, this)
    {
    }

    FontsType::
    FontsType (const FontsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Font_ (x.Font_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FontsType::
    FontsType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Font_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FontsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Font
        //
        if (n.name () == L"Font" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Font_type > r (
            Font_traits::create (i, f, this));

          this->Font_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FontsType* FontsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FontsType (*this, f, c);
    }

    FontsType& FontsType::
    operator= (const FontsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Font_ = x.Font_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FontsType::
    ~FontsType ()
    {
    }

    // AlignmentEnumType
    //

    AlignmentEnumType::
    AlignmentEnumType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_AlignmentEnumType_convert ();
    }

    AlignmentEnumType::
    AlignmentEnumType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_AlignmentEnumType_convert ();
    }

    AlignmentEnumType::
    AlignmentEnumType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_AlignmentEnumType_convert ();
    }

    AlignmentEnumType* AlignmentEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentEnumType (*this, f, c);
    }

    AlignmentEnumType::value AlignmentEnumType::
    _xsd_AlignmentEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AlignmentEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AlignmentEnumType_indexes_,
                        _xsd_AlignmentEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_AlignmentEnumType_indexes_ + 3 || _xsd_AlignmentEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AlignmentEnumType::
    _xsd_AlignmentEnumType_literals_[3] =
    {
      L"ALIGNMENT_LEFT",
      L"ALIGNMENT_RIGHT",
      L"ALIGNMENT_CENTER"
    };

    const AlignmentEnumType::value AlignmentEnumType::
    _xsd_AlignmentEnumType_indexes_[3] =
    {
      ::xsd::qif30::AlignmentEnumType::ALIGNMENT_CENTER,
      ::xsd::qif30::AlignmentEnumType::ALIGNMENT_LEFT,
      ::xsd::qif30::AlignmentEnumType::ALIGNMENT_RIGHT
    };

    // FontType
    //

    FontType::
    FontType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Name_ (this),
      Size_ (this),
      Alignment_ (this),
      index_ (this),
      bold_ (bold_default_value (), this),
      italic_ (italic_default_value (), this),
      underline_ (underline_default_value (), this)
    {
    }

    FontType::
    FontType (const Name_type& Name,
              const Size_type& Size,
              const index_type& index)
    : ::xml_schema::type (),
      Attributes_ (this),
      Name_ (Name, this),
      Size_ (Size, this),
      Alignment_ (this),
      index_ (index, this),
      bold_ (bold_default_value (), this),
      italic_ (italic_default_value (), this),
      underline_ (underline_default_value (), this)
    {
    }

    FontType::
    FontType (const FontType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      Size_ (x.Size_, f, this),
      Alignment_ (x.Alignment_, f, this),
      index_ (x.index_, f, this),
      bold_ (x.bold_, f, this),
      italic_ (x.italic_, f, this),
      underline_ (x.underline_, f, this)
    {
    }

    FontType::
    FontType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Name_ (this),
      Size_ (this),
      Alignment_ (this),
      index_ (this),
      bold_ (this),
      italic_ (this),
      underline_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FontType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Size
        //
        if (n.name () == L"Size" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Size_type > r (
            Size_traits::create (i, f, this));

          if (!Size_.present ())
          {
            this->Size_.set (::std::move (r));
            continue;
          }
        }

        // Alignment
        //
        if (n.name () == L"Alignment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Alignment_type > r (
            Alignment_traits::create (i, f, this));

          if (!this->Alignment_)
          {
            this->Alignment_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Size_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Size",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"bold" && n.namespace_ ().empty ())
        {
          this->bold_.set (bold_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"italic" && n.namespace_ ().empty ())
        {
          this->italic_.set (italic_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"underline" && n.namespace_ ().empty ())
        {
          this->underline_.set (underline_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }

      if (!bold_.present ())
      {
        this->bold_.set (bold_default_value ());
      }

      if (!italic_.present ())
      {
        this->italic_.set (italic_default_value ());
      }

      if (!underline_.present ())
      {
        this->underline_.set (underline_default_value ());
      }
    }

    FontType* FontType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FontType (*this, f, c);
    }

    FontType& FontType::
    operator= (const FontType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Name_ = x.Name_;
        this->Size_ = x.Size_;
        this->Alignment_ = x.Alignment_;
        this->index_ = x.index_;
        this->bold_ = x.bold_;
        this->italic_ = x.italic_;
        this->underline_ = x.underline_;
      }

      return *this;
    }

    FontType::
    ~FontType ()
    {
    }

    // PMIDisplaySetType
    //

    PMIDisplaySetType::
    PMIDisplaySetType ()
    : ::xml_schema::type (),
      PMIDisplay_ (this),
      n_ (this)
    {
    }

    PMIDisplaySetType::
    PMIDisplaySetType (const n_type& n)
    : ::xml_schema::type (),
      PMIDisplay_ (this),
      n_ (n, this)
    {
    }

    PMIDisplaySetType::
    PMIDisplaySetType (const PMIDisplaySetType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PMIDisplay_ (x.PMIDisplay_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PMIDisplaySetType::
    PMIDisplaySetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PMIDisplay_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PMIDisplaySetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PMIDisplay
        //
        if (n.name () == L"PMIDisplay" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PMIDisplay_type > r (
            PMIDisplay_traits::create (i, f, this));

          this->PMIDisplay_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PMIDisplaySetType* PMIDisplaySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PMIDisplaySetType (*this, f, c);
    }

    PMIDisplaySetType& PMIDisplaySetType::
    operator= (const PMIDisplaySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PMIDisplay_ = x.PMIDisplay_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PMIDisplaySetType::
    ~PMIDisplaySetType ()
    {
    }

    // PMIDisplayType
    //

    PMIDisplayType::
    PMIDisplayType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Color_ (this),
      Plane_ (this),
      Texts_ (this),
      Leader_ (this),
      WitnessLines_ (this),
      Frames_ (this),
      Graphics_ (this),
      Reference_ (this),
      GroupID_ (this)
    {
    }

    PMIDisplayType::
    PMIDisplayType (const Reference_type& Reference)
    : ::xml_schema::type (),
      Attributes_ (this),
      Color_ (this),
      Plane_ (this),
      Texts_ (this),
      Leader_ (this),
      WitnessLines_ (this),
      Frames_ (this),
      Graphics_ (this),
      Reference_ (Reference, this),
      GroupID_ (this)
    {
    }

    PMIDisplayType::
    PMIDisplayType (::std::unique_ptr< Reference_type > Reference)
    : ::xml_schema::type (),
      Attributes_ (this),
      Color_ (this),
      Plane_ (this),
      Texts_ (this),
      Leader_ (this),
      WitnessLines_ (this),
      Frames_ (this),
      Graphics_ (this),
      Reference_ (std::move (Reference), this),
      GroupID_ (this)
    {
    }

    PMIDisplayType::
    PMIDisplayType (const PMIDisplayType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Color_ (x.Color_, f, this),
      Plane_ (x.Plane_, f, this),
      Texts_ (x.Texts_, f, this),
      Leader_ (x.Leader_, f, this),
      WitnessLines_ (x.WitnessLines_, f, this),
      Frames_ (x.Frames_, f, this),
      Graphics_ (x.Graphics_, f, this),
      Reference_ (x.Reference_, f, this),
      GroupID_ (x.GroupID_, f, this)
    {
    }

    PMIDisplayType::
    PMIDisplayType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Color_ (this),
      Plane_ (this),
      Texts_ (this),
      Leader_ (this),
      WitnessLines_ (this),
      Frames_ (this),
      Graphics_ (this),
      Reference_ (this),
      GroupID_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PMIDisplayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Color
        //
        if (n.name () == L"Color" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Color_type > r (
            Color_traits::create (i, f, this));

          if (!this->Color_)
          {
            this->Color_.set (::std::move (r));
            continue;
          }
        }

        // Plane
        //
        if (n.name () == L"Plane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (::std::move (r));
            continue;
          }
        }

        // Texts
        //
        if (n.name () == L"Texts" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Texts_type > r (
            Texts_traits::create (i, f, this));

          if (!this->Texts_)
          {
            this->Texts_.set (::std::move (r));
            continue;
          }
        }

        // Leader
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Leader",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Leader_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Leader_type > r (
              dynamic_cast< Leader_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Leader_.push_back (::std::move (r));
            continue;
          }
        }

        // WitnessLines
        //
        if (n.name () == L"WitnessLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WitnessLines_type > r (
            WitnessLines_traits::create (i, f, this));

          if (!this->WitnessLines_)
          {
            this->WitnessLines_.set (::std::move (r));
            continue;
          }
        }

        // Frames
        //
        if (n.name () == L"Frames" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Frames_type > r (
            Frames_traits::create (i, f, this));

          if (!this->Frames_)
          {
            this->Frames_.set (::std::move (r));
            continue;
          }
        }

        // Graphics
        //
        if (n.name () == L"Graphics" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Graphics_type > r (
            Graphics_traits::create (i, f, this));

          if (!this->Graphics_)
          {
            this->Graphics_.set (::std::move (r));
            continue;
          }
        }

        // Reference
        //
        if (n.name () == L"Reference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Reference_type > r (
            Reference_traits::create (i, f, this));

          if (!Reference_.present ())
          {
            this->Reference_.set (::std::move (r));
            continue;
          }
        }

        // GroupID
        //
        if (n.name () == L"GroupID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< GroupID_type > r (
            GroupID_traits::create (i, f, this));

          if (!this->GroupID_)
          {
            this->GroupID_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Reference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Reference",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PMIDisplayType* PMIDisplayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PMIDisplayType (*this, f, c);
    }

    PMIDisplayType& PMIDisplayType::
    operator= (const PMIDisplayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Color_ = x.Color_;
        this->Plane_ = x.Plane_;
        this->Texts_ = x.Texts_;
        this->Leader_ = x.Leader_;
        this->WitnessLines_ = x.WitnessLines_;
        this->Frames_ = x.Frames_;
        this->Graphics_ = x.Graphics_;
        this->Reference_ = x.Reference_;
        this->GroupID_ = x.GroupID_;
      }

      return *this;
    }

    PMIDisplayType::
    ~PMIDisplayType ()
    {
    }

    // PlanePMIDisplayType
    //

    PlanePMIDisplayType::
    PlanePMIDisplayType ()
    : ::xml_schema::type (),
      AnnotationViewId_ (this),
      Origin_ (this),
      Direction_ (this)
    {
    }

    PlanePMIDisplayType::
    PlanePMIDisplayType (const AnnotationViewId_type& AnnotationViewId)
    : ::xml_schema::type (),
      AnnotationViewId_ (AnnotationViewId, this),
      Origin_ (this),
      Direction_ (this)
    {
    }

    PlanePMIDisplayType::
    PlanePMIDisplayType (::std::unique_ptr< AnnotationViewId_type > AnnotationViewId)
    : ::xml_schema::type (),
      AnnotationViewId_ (std::move (AnnotationViewId), this),
      Origin_ (this),
      Direction_ (this)
    {
    }

    PlanePMIDisplayType::
    PlanePMIDisplayType (const PlanePMIDisplayType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AnnotationViewId_ (x.AnnotationViewId_, f, this),
      Origin_ (x.Origin_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    PlanePMIDisplayType::
    PlanePMIDisplayType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AnnotationViewId_ (this),
      Origin_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanePMIDisplayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AnnotationViewId
        //
        if (n.name () == L"AnnotationViewId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AnnotationViewId_type > r (
            AnnotationViewId_traits::create (i, f, this));

          if (!AnnotationViewId_.present ())
          {
            this->AnnotationViewId_.set (::std::move (r));
            continue;
          }
        }

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!this->Origin_)
          {
            this->Origin_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AnnotationViewId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AnnotationViewId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlanePMIDisplayType* PlanePMIDisplayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePMIDisplayType (*this, f, c);
    }

    PlanePMIDisplayType& PlanePMIDisplayType::
    operator= (const PlanePMIDisplayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AnnotationViewId_ = x.AnnotationViewId_;
        this->Origin_ = x.Origin_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    PlanePMIDisplayType::
    ~PlanePMIDisplayType ()
    {
    }

    // Polylines2dType
    //

    Polylines2dType::
    Polylines2dType ()
    : ::xml_schema::type (),
      Polyline_ (this),
      n_ (this)
    {
    }

    Polylines2dType::
    Polylines2dType (const n_type& n)
    : ::xml_schema::type (),
      Polyline_ (this),
      n_ (n, this)
    {
    }

    Polylines2dType::
    Polylines2dType (const Polylines2dType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Polyline_ (x.Polyline_, f, this),
      n_ (x.n_, f, this)
    {
    }

    Polylines2dType::
    Polylines2dType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Polyline_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polylines2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Polyline
        //
        if (n.name () == L"Polyline" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Polyline_type > r (
            Polyline_traits::create (i, f, this));

          this->Polyline_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    Polylines2dType* Polylines2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polylines2dType (*this, f, c);
    }

    Polylines2dType& Polylines2dType::
    operator= (const Polylines2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Polyline_ = x.Polyline_;
        this->n_ = x.n_;
      }

      return *this;
    }

    Polylines2dType::
    ~Polylines2dType ()
    {
    }

    // Polyline2dType
    //

    Polyline2dType::
    Polyline2dType ()
    : ::xml_schema::type (),
      Points_ (this),
      PointsBinary_ (this),
      color_ (this)
    {
    }

    Polyline2dType::
    Polyline2dType (const Polyline2dType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this),
      color_ (x.color_, f, this)
    {
    }

    Polyline2dType::
    Polyline2dType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this),
      color_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polyline2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == L"PointsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"color" && n.namespace_ ().empty ())
        {
          this->color_.set (color_traits::create (i, f, this));
          continue;
        }
      }
    }

    Polyline2dType* Polyline2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polyline2dType (*this, f, c);
    }

    Polyline2dType& Polyline2dType::
    operator= (const Polyline2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
        this->color_ = x.color_;
      }

      return *this;
    }

    Polyline2dType::
    ~Polyline2dType ()
    {
    }

    // Areas2dType
    //

    Areas2dType::
    Areas2dType ()
    : ::xml_schema::type (),
      Area_ (this),
      n_ (this)
    {
    }

    Areas2dType::
    Areas2dType (const n_type& n)
    : ::xml_schema::type (),
      Area_ (this),
      n_ (n, this)
    {
    }

    Areas2dType::
    Areas2dType (const Areas2dType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Area_ (x.Area_, f, this),
      n_ (x.n_, f, this)
    {
    }

    Areas2dType::
    Areas2dType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Area_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Areas2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Area
        //
        if (n.name () == L"Area" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Area_type > r (
            Area_traits::create (i, f, this));

          this->Area_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    Areas2dType* Areas2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Areas2dType (*this, f, c);
    }

    Areas2dType& Areas2dType::
    operator= (const Areas2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Area_ = x.Area_;
        this->n_ = x.n_;
      }

      return *this;
    }

    Areas2dType::
    ~Areas2dType ()
    {
    }

    // Area2dType
    //

    Area2dType::
    Area2dType ()
    : ::xml_schema::type (),
      Loops_ (this),
      Triangulation_ (this)
    {
    }

    Area2dType::
    Area2dType (const Area2dType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Loops_ (x.Loops_, f, this),
      Triangulation_ (x.Triangulation_, f, this)
    {
    }

    Area2dType::
    Area2dType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Loops_ (this),
      Triangulation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Area2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Loops
        //
        if (n.name () == L"Loops" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Loops_type > r (
            Loops_traits::create (i, f, this));

          if (!this->Loops_)
          {
            this->Loops_.set (::std::move (r));
            continue;
          }
        }

        // Triangulation
        //
        if (n.name () == L"Triangulation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Triangulation_type > r (
            Triangulation_traits::create (i, f, this));

          if (!this->Triangulation_)
          {
            this->Triangulation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Area2dType* Area2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Area2dType (*this, f, c);
    }

    Area2dType& Area2dType::
    operator= (const Area2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Loops_ = x.Loops_;
        this->Triangulation_ = x.Triangulation_;
      }

      return *this;
    }

    Area2dType::
    ~Area2dType ()
    {
    }

    // Loops2dType
    //

    Loops2dType::
    Loops2dType ()
    : ::xml_schema::type (),
      Loop_ (this),
      n_ (this)
    {
    }

    Loops2dType::
    Loops2dType (const n_type& n)
    : ::xml_schema::type (),
      Loop_ (this),
      n_ (n, this)
    {
    }

    Loops2dType::
    Loops2dType (const Loops2dType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Loop_ (x.Loop_, f, this),
      n_ (x.n_, f, this)
    {
    }

    Loops2dType::
    Loops2dType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Loop_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Loops2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Loop
        //
        if (n.name () == L"Loop" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Loop_type > r (
            Loop_traits::create (i, f, this));

          this->Loop_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    Loops2dType* Loops2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Loops2dType (*this, f, c);
    }

    Loops2dType& Loops2dType::
    operator= (const Loops2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Loop_ = x.Loop_;
        this->n_ = x.n_;
      }

      return *this;
    }

    Loops2dType::
    ~Loops2dType ()
    {
    }

    // Triangulation2dType
    //

    Triangulation2dType::
    Triangulation2dType ()
    : ::xml_schema::type (),
      Vertices_ (this),
      VerticesBinary_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    Triangulation2dType::
    Triangulation2dType (const Triangulation2dType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Vertices_ (x.Vertices_, f, this),
      VerticesBinary_ (x.VerticesBinary_, f, this),
      Triangles_ (x.Triangles_, f, this),
      TrianglesBinary_ (x.TrianglesBinary_, f, this),
      TrianglesColor_ (x.TrianglesColor_, f, this),
      TrianglesColorBinary_ (x.TrianglesColorBinary_, f, this)
    {
    }

    Triangulation2dType::
    Triangulation2dType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Vertices_ (this),
      VerticesBinary_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Triangulation2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Vertices
        //
        if (n.name () == L"Vertices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vertices_type > r (
            Vertices_traits::create (i, f, this));

          if (!this->Vertices_)
          {
            this->Vertices_.set (::std::move (r));
            continue;
          }
        }

        // VerticesBinary
        //
        if (n.name () == L"VerticesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VerticesBinary_type > r (
            VerticesBinary_traits::create (i, f, this));

          if (!this->VerticesBinary_)
          {
            this->VerticesBinary_.set (::std::move (r));
            continue;
          }
        }

        // Triangles
        //
        if (n.name () == L"Triangles" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Triangles_type > r (
            Triangles_traits::create (i, f, this));

          if (!this->Triangles_)
          {
            this->Triangles_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesBinary
        //
        if (n.name () == L"TrianglesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesBinary_type > r (
            TrianglesBinary_traits::create (i, f, this));

          if (!this->TrianglesBinary_)
          {
            this->TrianglesBinary_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesColor
        //
        if (n.name () == L"TrianglesColor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesColor_type > r (
            TrianglesColor_traits::create (i, f, this));

          if (!this->TrianglesColor_)
          {
            this->TrianglesColor_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesColorBinary
        //
        if (n.name () == L"TrianglesColorBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesColorBinary_type > r (
            TrianglesColorBinary_traits::create (i, f, this));

          if (!this->TrianglesColorBinary_)
          {
            this->TrianglesColorBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Triangulation2dType* Triangulation2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Triangulation2dType (*this, f, c);
    }

    Triangulation2dType& Triangulation2dType::
    operator= (const Triangulation2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Vertices_ = x.Vertices_;
        this->VerticesBinary_ = x.VerticesBinary_;
        this->Triangles_ = x.Triangles_;
        this->TrianglesBinary_ = x.TrianglesBinary_;
        this->TrianglesColor_ = x.TrianglesColor_;
        this->TrianglesColorBinary_ = x.TrianglesColorBinary_;
      }

      return *this;
    }

    Triangulation2dType::
    ~Triangulation2dType ()
    {
    }

    // GraphicsType
    //

    GraphicsType::
    GraphicsType ()
    : ::xml_schema::type (),
      Polylines_ (this),
      Areas_ (this)
    {
    }

    GraphicsType::
    GraphicsType (const GraphicsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Polylines_ (x.Polylines_, f, this),
      Areas_ (x.Areas_, f, this)
    {
    }

    GraphicsType::
    GraphicsType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Polylines_ (this),
      Areas_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void GraphicsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Polylines
        //
        if (n.name () == L"Polylines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Polylines_type > r (
            Polylines_traits::create (i, f, this));

          if (!this->Polylines_)
          {
            this->Polylines_.set (::std::move (r));
            continue;
          }
        }

        // Areas
        //
        if (n.name () == L"Areas" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Areas_type > r (
            Areas_traits::create (i, f, this));

          if (!this->Areas_)
          {
            this->Areas_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    GraphicsType* GraphicsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GraphicsType (*this, f, c);
    }

    GraphicsType& GraphicsType::
    operator= (const GraphicsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Polylines_ = x.Polylines_;
        this->Areas_ = x.Areas_;
      }

      return *this;
    }

    GraphicsType::
    ~GraphicsType ()
    {
    }

    // LeaderType
    //

    LeaderType::
    LeaderType ()
    : ::xsd::qif30::LineSegment2dType (),
      HeadForm_ (this),
      HeadHeight_ (this)
    {
    }

    LeaderType::
    LeaderType (const StartPoint_type& StartPoint,
                const EndPoint_type& EndPoint,
                const HeadForm_type& HeadForm,
                const HeadHeight_type& HeadHeight)
    : ::xsd::qif30::LineSegment2dType (StartPoint,
                                       EndPoint),
      HeadForm_ (HeadForm, this),
      HeadHeight_ (HeadHeight, this)
    {
    }

    LeaderType::
    LeaderType (const StartPoint_type& StartPoint,
                const EndPoint_type& EndPoint,
                ::std::unique_ptr< HeadForm_type > HeadForm,
                const HeadHeight_type& HeadHeight)
    : ::xsd::qif30::LineSegment2dType (StartPoint,
                                       EndPoint),
      HeadForm_ (std::move (HeadForm), this),
      HeadHeight_ (HeadHeight, this)
    {
    }

    LeaderType::
    LeaderType (const LeaderType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::LineSegment2dType (x, f, c),
      HeadForm_ (x.HeadForm_, f, this),
      HeadHeight_ (x.HeadHeight_, f, this)
    {
    }

    LeaderType::
    LeaderType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::LineSegment2dType (e, f | ::xml_schema::flags::base, c),
      HeadForm_ (this),
      HeadHeight_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LineSegment2dType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HeadForm
        //
        if (n.name () == L"HeadForm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HeadForm_type > r (
            HeadForm_traits::create (i, f, this));

          if (!HeadForm_.present ())
          {
            this->HeadForm_.set (::std::move (r));
            continue;
          }
        }

        // HeadHeight
        //
        if (n.name () == L"HeadHeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!HeadHeight_.present ())
          {
            this->HeadHeight_.set (HeadHeight_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!HeadForm_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"HeadForm",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!HeadHeight_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"HeadHeight",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderType* LeaderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderType (*this, f, c);
    }

    LeaderType& LeaderType::
    operator= (const LeaderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LineSegment2dType& > (*this) = x;
        this->HeadForm_ = x.HeadForm_;
        this->HeadHeight_ = x.HeadHeight_;
      }

      return *this;
    }

    LeaderType::
    ~LeaderType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderType >
    _xsd_LeaderType_type_factory_init (
      L"LeaderType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderExtendType
    //

    LeaderExtendType::
    LeaderExtendType ()
    : ::xsd::qif30::LeaderType (),
      PointExtension_ (this),
      Modifier_ (this)
    {
    }

    LeaderExtendType::
    LeaderExtendType (const StartPoint_type& StartPoint,
                      const EndPoint_type& EndPoint,
                      const HeadForm_type& HeadForm,
                      const HeadHeight_type& HeadHeight,
                      const PointExtension_type& PointExtension)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                HeadForm,
                                HeadHeight),
      PointExtension_ (PointExtension, this),
      Modifier_ (this)
    {
    }

    LeaderExtendType::
    LeaderExtendType (const StartPoint_type& StartPoint,
                      const EndPoint_type& EndPoint,
                      ::std::unique_ptr< HeadForm_type > HeadForm,
                      const HeadHeight_type& HeadHeight,
                      const PointExtension_type& PointExtension)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                std::move (HeadForm),
                                HeadHeight),
      PointExtension_ (PointExtension, this),
      Modifier_ (this)
    {
    }

    LeaderExtendType::
    LeaderExtendType (const LeaderExtendType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (x, f, c),
      PointExtension_ (x.PointExtension_, f, this),
      Modifier_ (x.Modifier_, f, this)
    {
    }

    LeaderExtendType::
    LeaderExtendType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (e, f | ::xml_schema::flags::base, c),
      PointExtension_ (this),
      Modifier_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderExtendType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LeaderType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointExtension
        //
        if (n.name () == L"PointExtension" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointExtension_type > r (
            PointExtension_traits::create (i, f, this));

          if (!PointExtension_.present ())
          {
            this->PointExtension_.set (::std::move (r));
            continue;
          }
        }

        // Modifier
        //
        if (n.name () == L"Modifier" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Modifier_type > r (
            Modifier_traits::create (i, f, this));

          if (!this->Modifier_)
          {
            this->Modifier_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PointExtension_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointExtension",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderExtendType* LeaderExtendType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderExtendType (*this, f, c);
    }

    LeaderExtendType& LeaderExtendType::
    operator= (const LeaderExtendType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderType& > (*this) = x;
        this->PointExtension_ = x.PointExtension_;
        this->Modifier_ = x.Modifier_;
      }

      return *this;
    }

    LeaderExtendType::
    ~LeaderExtendType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderExtendType >
    _xsd_LeaderExtendType_type_factory_init (
      L"LeaderExtendType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderDoubleHeadType
    //

    LeaderDoubleHeadType::
    LeaderDoubleHeadType ()
    : ::xsd::qif30::LeaderType (),
      HeadForm2_ (this),
      PointConnection_ (this)
    {
    }

    LeaderDoubleHeadType::
    LeaderDoubleHeadType (const StartPoint_type& StartPoint,
                          const EndPoint_type& EndPoint,
                          const HeadForm_type& HeadForm,
                          const HeadHeight_type& HeadHeight,
                          const HeadForm2_type& HeadForm2,
                          const PointConnection_type& PointConnection)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                HeadForm,
                                HeadHeight),
      HeadForm2_ (HeadForm2, this),
      PointConnection_ (PointConnection, this)
    {
    }

    LeaderDoubleHeadType::
    LeaderDoubleHeadType (const StartPoint_type& StartPoint,
                          const EndPoint_type& EndPoint,
                          ::std::unique_ptr< HeadForm_type > HeadForm,
                          const HeadHeight_type& HeadHeight,
                          const HeadForm2_type& HeadForm2,
                          const PointConnection_type& PointConnection)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                std::move (HeadForm),
                                HeadHeight),
      HeadForm2_ (HeadForm2, this),
      PointConnection_ (PointConnection, this)
    {
    }

    LeaderDoubleHeadType::
    LeaderDoubleHeadType (const LeaderDoubleHeadType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (x, f, c),
      HeadForm2_ (x.HeadForm2_, f, this),
      PointConnection_ (x.PointConnection_, f, this)
    {
    }

    LeaderDoubleHeadType::
    LeaderDoubleHeadType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (e, f | ::xml_schema::flags::base, c),
      HeadForm2_ (this),
      PointConnection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderDoubleHeadType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LeaderType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HeadForm2
        //
        if (n.name () == L"HeadForm2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HeadForm2_type > r (
            HeadForm2_traits::create (i, f, this));

          if (!HeadForm2_.present ())
          {
            this->HeadForm2_.set (::std::move (r));
            continue;
          }
        }

        // PointConnection
        //
        if (n.name () == L"PointConnection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointConnection_type > r (
            PointConnection_traits::create (i, f, this));

          if (!PointConnection_.present ())
          {
            this->PointConnection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!HeadForm2_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"HeadForm2",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointConnection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointConnection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderDoubleHeadType* LeaderDoubleHeadType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderDoubleHeadType (*this, f, c);
    }

    LeaderDoubleHeadType& LeaderDoubleHeadType::
    operator= (const LeaderDoubleHeadType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderType& > (*this) = x;
        this->HeadForm2_ = x.HeadForm2_;
        this->PointConnection_ = x.PointConnection_;
      }

      return *this;
    }

    LeaderDoubleHeadType::
    ~LeaderDoubleHeadType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderDoubleHeadType >
    _xsd_LeaderDoubleHeadType_type_factory_init (
      L"LeaderDoubleHeadType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderDoubleHeadExtendType
    //

    LeaderDoubleHeadExtendType::
    LeaderDoubleHeadExtendType ()
    : ::xsd::qif30::LeaderDoubleHeadType (),
      PointExtension_ (this)
    {
    }

    LeaderDoubleHeadExtendType::
    LeaderDoubleHeadExtendType (const StartPoint_type& StartPoint,
                                const EndPoint_type& EndPoint,
                                const HeadForm_type& HeadForm,
                                const HeadHeight_type& HeadHeight,
                                const HeadForm2_type& HeadForm2,
                                const PointConnection_type& PointConnection,
                                const PointExtension_type& PointExtension)
    : ::xsd::qif30::LeaderDoubleHeadType (StartPoint,
                                          EndPoint,
                                          HeadForm,
                                          HeadHeight,
                                          HeadForm2,
                                          PointConnection),
      PointExtension_ (PointExtension, this)
    {
    }

    LeaderDoubleHeadExtendType::
    LeaderDoubleHeadExtendType (const StartPoint_type& StartPoint,
                                const EndPoint_type& EndPoint,
                                ::std::unique_ptr< HeadForm_type > HeadForm,
                                const HeadHeight_type& HeadHeight,
                                const HeadForm2_type& HeadForm2,
                                const PointConnection_type& PointConnection,
                                const PointExtension_type& PointExtension)
    : ::xsd::qif30::LeaderDoubleHeadType (StartPoint,
                                          EndPoint,
                                          std::move (HeadForm),
                                          HeadHeight,
                                          HeadForm2,
                                          PointConnection),
      PointExtension_ (PointExtension, this)
    {
    }

    LeaderDoubleHeadExtendType::
    LeaderDoubleHeadExtendType (const LeaderDoubleHeadExtendType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::LeaderDoubleHeadType (x, f, c),
      PointExtension_ (x.PointExtension_, f, this)
    {
    }

    LeaderDoubleHeadExtendType::
    LeaderDoubleHeadExtendType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::LeaderDoubleHeadType (e, f | ::xml_schema::flags::base, c),
      PointExtension_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderDoubleHeadExtendType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LeaderDoubleHeadType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointExtension
        //
        if (n.name () == L"PointExtension" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointExtension_type > r (
            PointExtension_traits::create (i, f, this));

          if (!PointExtension_.present ())
          {
            this->PointExtension_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PointExtension_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointExtension",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderDoubleHeadExtendType* LeaderDoubleHeadExtendType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderDoubleHeadExtendType (*this, f, c);
    }

    LeaderDoubleHeadExtendType& LeaderDoubleHeadExtendType::
    operator= (const LeaderDoubleHeadExtendType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderDoubleHeadType& > (*this) = x;
        this->PointExtension_ = x.PointExtension_;
      }

      return *this;
    }

    LeaderDoubleHeadExtendType::
    ~LeaderDoubleHeadExtendType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderDoubleHeadExtendType >
    _xsd_LeaderDoubleHeadExtendType_type_factory_init (
      L"LeaderDoubleHeadExtendType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderCircularType
    //

    LeaderCircularType::
    LeaderCircularType ()
    : ::xsd::qif30::LeaderType (),
      Center_ (this)
    {
    }

    LeaderCircularType::
    LeaderCircularType (const StartPoint_type& StartPoint,
                        const EndPoint_type& EndPoint,
                        const HeadForm_type& HeadForm,
                        const HeadHeight_type& HeadHeight,
                        const Center_type& Center)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                HeadForm,
                                HeadHeight),
      Center_ (Center, this)
    {
    }

    LeaderCircularType::
    LeaderCircularType (const StartPoint_type& StartPoint,
                        const EndPoint_type& EndPoint,
                        ::std::unique_ptr< HeadForm_type > HeadForm,
                        const HeadHeight_type& HeadHeight,
                        const Center_type& Center)
    : ::xsd::qif30::LeaderType (StartPoint,
                                EndPoint,
                                std::move (HeadForm),
                                HeadHeight),
      Center_ (Center, this)
    {
    }

    LeaderCircularType::
    LeaderCircularType (const LeaderCircularType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (x, f, c),
      Center_ (x.Center_, f, this)
    {
    }

    LeaderCircularType::
    LeaderCircularType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::LeaderType (e, f | ::xml_schema::flags::base, c),
      Center_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderCircularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LeaderType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderCircularType* LeaderCircularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderCircularType (*this, f, c);
    }

    LeaderCircularType& LeaderCircularType::
    operator= (const LeaderCircularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderType& > (*this) = x;
        this->Center_ = x.Center_;
      }

      return *this;
    }

    LeaderCircularType::
    ~LeaderCircularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderCircularType >
    _xsd_LeaderCircularType_type_factory_init (
      L"LeaderCircularType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderDoubleHeadCircularType
    //

    LeaderDoubleHeadCircularType::
    LeaderDoubleHeadCircularType ()
    : ::xsd::qif30::LeaderDoubleHeadType (),
      Center_ (this)
    {
    }

    LeaderDoubleHeadCircularType::
    LeaderDoubleHeadCircularType (const StartPoint_type& StartPoint,
                                  const EndPoint_type& EndPoint,
                                  const HeadForm_type& HeadForm,
                                  const HeadHeight_type& HeadHeight,
                                  const HeadForm2_type& HeadForm2,
                                  const PointConnection_type& PointConnection,
                                  const Center_type& Center)
    : ::xsd::qif30::LeaderDoubleHeadType (StartPoint,
                                          EndPoint,
                                          HeadForm,
                                          HeadHeight,
                                          HeadForm2,
                                          PointConnection),
      Center_ (Center, this)
    {
    }

    LeaderDoubleHeadCircularType::
    LeaderDoubleHeadCircularType (const StartPoint_type& StartPoint,
                                  const EndPoint_type& EndPoint,
                                  ::std::unique_ptr< HeadForm_type > HeadForm,
                                  const HeadHeight_type& HeadHeight,
                                  const HeadForm2_type& HeadForm2,
                                  const PointConnection_type& PointConnection,
                                  const Center_type& Center)
    : ::xsd::qif30::LeaderDoubleHeadType (StartPoint,
                                          EndPoint,
                                          std::move (HeadForm),
                                          HeadHeight,
                                          HeadForm2,
                                          PointConnection),
      Center_ (Center, this)
    {
    }

    LeaderDoubleHeadCircularType::
    LeaderDoubleHeadCircularType (const LeaderDoubleHeadCircularType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::LeaderDoubleHeadType (x, f, c),
      Center_ (x.Center_, f, this)
    {
    }

    LeaderDoubleHeadCircularType::
    LeaderDoubleHeadCircularType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::LeaderDoubleHeadType (e, f | ::xml_schema::flags::base, c),
      Center_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LeaderDoubleHeadCircularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LeaderDoubleHeadType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LeaderDoubleHeadCircularType* LeaderDoubleHeadCircularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderDoubleHeadCircularType (*this, f, c);
    }

    LeaderDoubleHeadCircularType& LeaderDoubleHeadCircularType::
    operator= (const LeaderDoubleHeadCircularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderDoubleHeadType& > (*this) = x;
        this->Center_ = x.Center_;
      }

      return *this;
    }

    LeaderDoubleHeadCircularType::
    ~LeaderDoubleHeadCircularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LeaderDoubleHeadCircularType >
    _xsd_LeaderDoubleHeadCircularType_type_factory_init (
      L"LeaderDoubleHeadCircularType",
      L"http://qifstandards.org/xsd/qif3");

    // TextsType
    //

    TextsType::
    TextsType ()
    : ::xml_schema::type (),
      Text_ (this),
      fontIndex_ (this),
      lineHeight_ (this),
      n_ (this)
    {
    }

    TextsType::
    TextsType (const fontIndex_type& fontIndex,
               const n_type& n)
    : ::xml_schema::type (),
      Text_ (this),
      fontIndex_ (fontIndex, this),
      lineHeight_ (this),
      n_ (n, this)
    {
    }

    TextsType::
    TextsType (const TextsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Text_ (x.Text_, f, this),
      fontIndex_ (x.fontIndex_, f, this),
      lineHeight_ (x.lineHeight_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TextsType::
    TextsType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Text_ (this),
      fontIndex_ (this),
      lineHeight_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Text
        //
        if (n.name () == L"Text" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          this->Text_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"fontIndex" && n.namespace_ ().empty ())
        {
          this->fontIndex_.set (fontIndex_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"lineHeight" && n.namespace_ ().empty ())
        {
          this->lineHeight_.set (lineHeight_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!fontIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"fontIndex",
          L"");
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TextsType* TextsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextsType (*this, f, c);
    }

    TextsType& TextsType::
    operator= (const TextsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Text_ = x.Text_;
        this->fontIndex_ = x.fontIndex_;
        this->lineHeight_ = x.lineHeight_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TextsType::
    ~TextsType ()
    {
    }

    // FramesType
    //

    FramesType::
    FramesType ()
    : ::xml_schema::type (),
      Frame_ (this),
      n_ (this)
    {
    }

    FramesType::
    FramesType (const n_type& n)
    : ::xml_schema::type (),
      Frame_ (this),
      n_ (n, this)
    {
    }

    FramesType::
    FramesType (const FramesType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Frame_ (x.Frame_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FramesType::
    FramesType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Frame_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FramesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Frame
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Frame",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Frame_type > r (
              dynamic_cast< Frame_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Frame_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FramesType* FramesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FramesType (*this, f, c);
    }

    FramesType& FramesType::
    operator= (const FramesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Frame_ = x.Frame_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FramesType::
    ~FramesType ()
    {
    }

    // TextType
    //

    TextType::
    TextType ()
    : ::xml_schema::type (),
      Data_ (this),
      XY_ (this)
    {
    }

    TextType::
    TextType (const Data_type& Data,
              const XY_type& XY)
    : ::xml_schema::type (),
      Data_ (Data, this),
      XY_ (XY, this)
    {
    }

    TextType::
    TextType (const TextType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Data_ (x.Data_, f, this),
      XY_ (x.XY_, f, this)
    {
    }

    TextType::
    TextType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Data_ (this),
      XY_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TextType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Data
        //
        if (n.name () == L"Data" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Data_type > r (
            Data_traits::create (i, f, this));

          if (!Data_.present ())
          {
            this->Data_.set (::std::move (r));
            continue;
          }
        }

        // XY
        //
        if (n.name () == L"XY" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XY_type > r (
            XY_traits::create (i, f, this));

          if (!XY_.present ())
          {
            this->XY_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Data",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XY",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TextType* TextType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextType (*this, f, c);
    }

    TextType& TextType::
    operator= (const TextType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Data_ = x.Data_;
        this->XY_ = x.XY_;
      }

      return *this;
    }

    TextType::
    ~TextType ()
    {
    }

    // WitnessLinesType
    //

    WitnessLinesType::
    WitnessLinesType ()
    : ::xml_schema::type (),
      Segment1_ (this),
      ZextensionPoint1_ (this),
      Segment2_ (this),
      ZextensionPoint2_ (this),
      BeginPoint_ (this),
      EndPoint_ (this),
      CircleCenter_ (this),
      CircleRadius_ (this),
      width_ (this)
    {
    }

    WitnessLinesType::
    WitnessLinesType (const width_type& width)
    : ::xml_schema::type (),
      Segment1_ (this),
      ZextensionPoint1_ (this),
      Segment2_ (this),
      ZextensionPoint2_ (this),
      BeginPoint_ (this),
      EndPoint_ (this),
      CircleCenter_ (this),
      CircleRadius_ (this),
      width_ (width, this)
    {
    }

    WitnessLinesType::
    WitnessLinesType (const WitnessLinesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Segment1_ (x.Segment1_, f, this),
      ZextensionPoint1_ (x.ZextensionPoint1_, f, this),
      Segment2_ (x.Segment2_, f, this),
      ZextensionPoint2_ (x.ZextensionPoint2_, f, this),
      BeginPoint_ (x.BeginPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this),
      CircleCenter_ (x.CircleCenter_, f, this),
      CircleRadius_ (x.CircleRadius_, f, this),
      width_ (x.width_, f, this)
    {
    }

    WitnessLinesType::
    WitnessLinesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Segment1_ (this),
      ZextensionPoint1_ (this),
      Segment2_ (this),
      ZextensionPoint2_ (this),
      BeginPoint_ (this),
      EndPoint_ (this),
      CircleCenter_ (this),
      CircleRadius_ (this),
      width_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void WitnessLinesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Segment1
        //
        if (n.name () == L"Segment1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Segment1_type > r (
            Segment1_traits::create (i, f, this));

          if (!this->Segment1_)
          {
            this->Segment1_.set (::std::move (r));
            continue;
          }
        }

        // ZextensionPoint1
        //
        if (n.name () == L"ZextensionPoint1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZextensionPoint1_type > r (
            ZextensionPoint1_traits::create (i, f, this));

          if (!this->ZextensionPoint1_)
          {
            this->ZextensionPoint1_.set (::std::move (r));
            continue;
          }
        }

        // Segment2
        //
        if (n.name () == L"Segment2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Segment2_type > r (
            Segment2_traits::create (i, f, this));

          if (!this->Segment2_)
          {
            this->Segment2_.set (::std::move (r));
            continue;
          }
        }

        // ZextensionPoint2
        //
        if (n.name () == L"ZextensionPoint2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZextensionPoint2_type > r (
            ZextensionPoint2_traits::create (i, f, this));

          if (!this->ZextensionPoint2_)
          {
            this->ZextensionPoint2_.set (::std::move (r));
            continue;
          }
        }

        // BeginPoint
        //
        if (n.name () == L"BeginPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BeginPoint_type > r (
            BeginPoint_traits::create (i, f, this));

          if (!this->BeginPoint_)
          {
            this->BeginPoint_.set (::std::move (r));
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == L"EndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!this->EndPoint_)
          {
            this->EndPoint_.set (::std::move (r));
            continue;
          }
        }

        // CircleCenter
        //
        if (n.name () == L"CircleCenter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CircleCenter_type > r (
            CircleCenter_traits::create (i, f, this));

          if (!this->CircleCenter_)
          {
            this->CircleCenter_.set (::std::move (r));
            continue;
          }
        }

        // CircleRadius
        //
        if (n.name () == L"CircleRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CircleRadius_type > r (
            CircleRadius_traits::create (i, f, this));

          if (!this->CircleRadius_)
          {
            this->CircleRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"width" && n.namespace_ ().empty ())
        {
          this->width_.set (width_traits::create (i, f, this));
          continue;
        }
      }

      if (!width_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"width",
          L"");
      }
    }

    WitnessLinesType* WitnessLinesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WitnessLinesType (*this, f, c);
    }

    WitnessLinesType& WitnessLinesType::
    operator= (const WitnessLinesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Segment1_ = x.Segment1_;
        this->ZextensionPoint1_ = x.ZextensionPoint1_;
        this->Segment2_ = x.Segment2_;
        this->ZextensionPoint2_ = x.ZextensionPoint2_;
        this->BeginPoint_ = x.BeginPoint_;
        this->EndPoint_ = x.EndPoint_;
        this->CircleCenter_ = x.CircleCenter_;
        this->CircleRadius_ = x.CircleRadius_;
        this->width_ = x.width_;
      }

      return *this;
    }

    WitnessLinesType::
    ~WitnessLinesType ()
    {
    }

    // FrameBaseType
    //

    FrameBaseType::
    FrameBaseType ()
    : ::xml_schema::type ()
    {
    }

    FrameBaseType::
    FrameBaseType (const FrameBaseType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    FrameBaseType::
    FrameBaseType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    FrameBaseType::
    FrameBaseType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    FrameBaseType::
    FrameBaseType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    FrameBaseType::
    ~FrameBaseType ()
    {
    }

    // FrameRectangularType
    //

    FrameRectangularType::
    FrameRectangularType ()
    : ::xsd::qif30::FrameBaseType (),
      XY_ (this),
      Width_ (this),
      Height_ (this)
    {
    }

    FrameRectangularType::
    FrameRectangularType (const XY_type& XY,
                          const Width_type& Width,
                          const Height_type& Height)
    : ::xsd::qif30::FrameBaseType (),
      XY_ (XY, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    FrameRectangularType::
    FrameRectangularType (const FrameRectangularType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      XY_ (x.XY_, f, this),
      Width_ (x.Width_, f, this),
      Height_ (x.Height_, f, this)
    {
    }

    FrameRectangularType::
    FrameRectangularType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      XY_ (this),
      Width_ (this),
      Height_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameRectangularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XY
        //
        if (n.name () == L"XY" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XY_type > r (
            XY_traits::create (i, f, this));

          if (!XY_.present ())
          {
            this->XY_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Width_.present ())
          {
            this->Width_.set (Width_traits::create (i, f, this));
            continue;
          }
        }

        // Height
        //
        if (n.name () == L"Height" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Height_.present ())
          {
            this->Height_.set (Height_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!XY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XY",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Height",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FrameRectangularType* FrameRectangularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameRectangularType (*this, f, c);
    }

    FrameRectangularType& FrameRectangularType::
    operator= (const FrameRectangularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->XY_ = x.XY_;
        this->Width_ = x.Width_;
        this->Height_ = x.Height_;
      }

      return *this;
    }

    FrameRectangularType::
    ~FrameRectangularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameRectangularType >
    _xsd_FrameRectangularType_type_factory_init (
      L"FrameRectangularType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameCircularType
    //

    FrameCircularType::
    FrameCircularType ()
    : ::xsd::qif30::FrameBaseType (),
      XY_ (this),
      Radius_ (this),
      crossed_ (crossed_default_value (), this)
    {
    }

    FrameCircularType::
    FrameCircularType (const XY_type& XY,
                       const Radius_type& Radius)
    : ::xsd::qif30::FrameBaseType (),
      XY_ (XY, this),
      Radius_ (Radius, this),
      crossed_ (crossed_default_value (), this)
    {
    }

    FrameCircularType::
    FrameCircularType (const FrameCircularType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      XY_ (x.XY_, f, this),
      Radius_ (x.Radius_, f, this),
      crossed_ (x.crossed_, f, this)
    {
    }

    FrameCircularType::
    FrameCircularType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      XY_ (this),
      Radius_ (this),
      crossed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FrameCircularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XY
        //
        if (n.name () == L"XY" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XY_type > r (
            XY_traits::create (i, f, this));

          if (!XY_.present ())
          {
            this->XY_.set (::std::move (r));
            continue;
          }
        }

        // Radius
        //
        if (n.name () == L"Radius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Radius_.present ())
          {
            this->Radius_.set (Radius_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!XY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XY",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Radius",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"crossed" && n.namespace_ ().empty ())
        {
          this->crossed_.set (crossed_traits::create (i, f, this));
          continue;
        }
      }

      if (!crossed_.present ())
      {
        this->crossed_.set (crossed_default_value ());
      }
    }

    FrameCircularType* FrameCircularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameCircularType (*this, f, c);
    }

    FrameCircularType& FrameCircularType::
    operator= (const FrameCircularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->XY_ = x.XY_;
        this->Radius_ = x.Radius_;
        this->crossed_ = x.crossed_;
      }

      return *this;
    }

    FrameCircularType::
    ~FrameCircularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameCircularType >
    _xsd_FrameCircularType_type_factory_init (
      L"FrameCircularType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameFlagType
    //

    FrameFlagType::
    FrameFlagType ()
    : ::xsd::qif30::FrameRectangularType (),
      right_ (right_default_value (), this)
    {
    }

    FrameFlagType::
    FrameFlagType (const XY_type& XY,
                   const Width_type& Width,
                   const Height_type& Height)
    : ::xsd::qif30::FrameRectangularType (XY,
                                          Width,
                                          Height),
      right_ (right_default_value (), this)
    {
    }

    FrameFlagType::
    FrameFlagType (const FrameFlagType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::FrameRectangularType (x, f, c),
      right_ (x.right_, f, this)
    {
    }

    FrameFlagType::
    FrameFlagType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::FrameRectangularType (e, f | ::xml_schema::flags::base, c),
      right_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FrameFlagType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FrameRectangularType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"right" && n.namespace_ ().empty ())
        {
          this->right_.set (right_traits::create (i, f, this));
          continue;
        }
      }

      if (!right_.present ())
      {
        this->right_.set (right_default_value ());
      }
    }

    FrameFlagType* FrameFlagType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameFlagType (*this, f, c);
    }

    FrameFlagType& FrameFlagType::
    operator= (const FrameFlagType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameRectangularType& > (*this) = x;
        this->right_ = x.right_;
      }

      return *this;
    }

    FrameFlagType::
    ~FrameFlagType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameFlagType >
    _xsd_FrameFlagType_type_factory_init (
      L"FrameFlagType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameIrregularFormType
    //

    FrameIrregularFormType::
    FrameIrregularFormType ()
    : ::xsd::qif30::FrameBaseType (),
      Points_ (this)
    {
    }

    FrameIrregularFormType::
    FrameIrregularFormType (const Points_type& Points)
    : ::xsd::qif30::FrameBaseType (),
      Points_ (Points, this)
    {
    }

    FrameIrregularFormType::
    FrameIrregularFormType (::std::unique_ptr< Points_type > Points)
    : ::xsd::qif30::FrameBaseType (),
      Points_ (std::move (Points), this)
    {
    }

    FrameIrregularFormType::
    FrameIrregularFormType (const FrameIrregularFormType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      Points_ (x.Points_, f, this)
    {
    }

    FrameIrregularFormType::
    FrameIrregularFormType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameIrregularFormType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!Points_.present ())
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Points_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Points",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FrameIrregularFormType* FrameIrregularFormType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameIrregularFormType (*this, f, c);
    }

    FrameIrregularFormType& FrameIrregularFormType::
    operator= (const FrameIrregularFormType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->Points_ = x.Points_;
      }

      return *this;
    }

    FrameIrregularFormType::
    ~FrameIrregularFormType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameIrregularFormType >
    _xsd_FrameIrregularFormType_type_factory_init (
      L"FrameIrregularFormType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameWeldSymbolTailType
    //

    FrameWeldSymbolTailType::
    FrameWeldSymbolTailType ()
    : ::xml_schema::type (),
      UpperPoint_ (this),
      LowerPoint_ (this)
    {
    }

    FrameWeldSymbolTailType::
    FrameWeldSymbolTailType (const UpperPoint_type& UpperPoint,
                             const LowerPoint_type& LowerPoint)
    : ::xml_schema::type (),
      UpperPoint_ (UpperPoint, this),
      LowerPoint_ (LowerPoint, this)
    {
    }

    FrameWeldSymbolTailType::
    FrameWeldSymbolTailType (const FrameWeldSymbolTailType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UpperPoint_ (x.UpperPoint_, f, this),
      LowerPoint_ (x.LowerPoint_, f, this)
    {
    }

    FrameWeldSymbolTailType::
    FrameWeldSymbolTailType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UpperPoint_ (this),
      LowerPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameWeldSymbolTailType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UpperPoint
        //
        if (n.name () == L"UpperPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UpperPoint_type > r (
            UpperPoint_traits::create (i, f, this));

          if (!UpperPoint_.present ())
          {
            this->UpperPoint_.set (::std::move (r));
            continue;
          }
        }

        // LowerPoint
        //
        if (n.name () == L"LowerPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LowerPoint_type > r (
            LowerPoint_traits::create (i, f, this));

          if (!LowerPoint_.present ())
          {
            this->LowerPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UpperPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UpperPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LowerPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LowerPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FrameWeldSymbolTailType* FrameWeldSymbolTailType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameWeldSymbolTailType (*this, f, c);
    }

    FrameWeldSymbolTailType& FrameWeldSymbolTailType::
    operator= (const FrameWeldSymbolTailType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->UpperPoint_ = x.UpperPoint_;
        this->LowerPoint_ = x.LowerPoint_;
      }

      return *this;
    }

    FrameWeldSymbolTailType::
    ~FrameWeldSymbolTailType ()
    {
    }

    // WeldMainSymbolEnumType
    //

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_WeldMainSymbolEnumType_convert ();
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_WeldMainSymbolEnumType_convert ();
    }

    WeldMainSymbolEnumType::
    WeldMainSymbolEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_WeldMainSymbolEnumType_convert ();
    }

    WeldMainSymbolEnumType* WeldMainSymbolEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldMainSymbolEnumType (*this, f, c);
    }

    WeldMainSymbolEnumType::value WeldMainSymbolEnumType::
    _xsd_WeldMainSymbolEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_WeldMainSymbolEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_WeldMainSymbolEnumType_indexes_,
                        _xsd_WeldMainSymbolEnumType_indexes_ + 47,
                        *this,
                        c));

      if (i == _xsd_WeldMainSymbolEnumType_indexes_ + 47 || _xsd_WeldMainSymbolEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const WeldMainSymbolEnumType::
    _xsd_WeldMainSymbolEnumType_literals_[47] =
    {
      L"WELD_FILLET_ARROW_SIDE",
      L"WELD_FILLET_OTHER_SIDE",
      L"WELD_FILLET_BOTH",
      L"WELD_SPOT_ARROW_SIDE",
      L"WELD_SPOT_OTHER_SIDE",
      L"WELD_SPOT_NO_SIDE",
      L"WELD_STUD_ARROW_SIDE",
      L"WELD_SEAM_ARROW_SIDE",
      L"WELD_SEAM_OTHER_SIDE",
      L"WELD_SEAM_NO_SIDE",
      L"WELD_SURFACING_ARROW_SIDE",
      L"WELD_EDGE_ARROW_SIDE",
      L"WELD_EDGE_OTHER_SIDE",
      L"WELD_SQUARE_ARROW_SIDE",
      L"WELD_SQUARE_OTHER_SIDE",
      L"WELD_SQUARE_BOTH",
      L"WELD_V_ARROW_SIDE",
      L"WELD_V_OTHER_SIDE",
      L"WELD_V_BOTH",
      L"WELD_BEVEL_ARROW_SIDE",
      L"WELD_BEVEL_OTHER_SIDE",
      L"WELD_BEVEL_BOTH",
      L"WELD_U_ARROW_SIDE",
      L"WELD_U_OTHER_SIDE",
      L"WELD_U_BOTH",
      L"WELD_J_ARROW_SIDE",
      L"WELD_J_OTHER_SIDE",
      L"WELD_J_BOTH",
      L"WELD_FLARE_V_ARROW_SIDE",
      L"WELD_FLARE_V_OTHER_SIDE",
      L"WELD_FLARE_V_BOTH",
      L"WELD_FLARE_BEVEL_ARROW_SIDE",
      L"WELD_FLARE_BEVEL_OTHER_SIDE",
      L"WELD_FLARE_BEVEL_BOTH",
      L"WELD_SCARF_V_ARROW_SIDE",
      L"WELD_SCARF_V_OTHER_SIDE",
      L"WELD_SCARF_V_BOTH",
      L"WELD_V_SPACER",
      L"WELD_BEVEL_SPACER",
      L"WELD_U_SPACER",
      L"WELD_J_SPACER",
      L"WELD_FLARE_V_SPACER",
      L"WELD_FLARE_BEVEL_SPACER",
      L"BACK_WELD",
      L"MELT_THROUGH",
      L"CONSUMABLE_INSERT",
      L"REMOVABLE_BACKING"
    };

    const WeldMainSymbolEnumType::value WeldMainSymbolEnumType::
    _xsd_WeldMainSymbolEnumType_indexes_[47] =
    {
      ::xsd::qif30::WeldMainSymbolEnumType::BACK_WELD,
      ::xsd::qif30::WeldMainSymbolEnumType::CONSUMABLE_INSERT,
      ::xsd::qif30::WeldMainSymbolEnumType::MELT_THROUGH,
      ::xsd::qif30::WeldMainSymbolEnumType::REMOVABLE_BACKING,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_BEVEL_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_BEVEL_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_BEVEL_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_BEVEL_SPACER,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_EDGE_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_EDGE_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FILLET_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FILLET_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FILLET_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_BEVEL_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_BEVEL_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_BEVEL_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_BEVEL_SPACER,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_V_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_V_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_V_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_FLARE_V_SPACER,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_J_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_J_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_J_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_J_SPACER,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SCARF_V_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SCARF_V_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SCARF_V_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SEAM_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SEAM_NO_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SEAM_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SPOT_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SPOT_NO_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SPOT_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SQUARE_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SQUARE_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SQUARE_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_STUD_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_SURFACING_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_U_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_U_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_U_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_U_SPACER,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_V_ARROW_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_V_BOTH,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_V_OTHER_SIDE,
      ::xsd::qif30::WeldMainSymbolEnumType::WELD_V_SPACER
    };

    // OriginType
    //

    OriginType::
    OriginType ()
    : ::xml_schema::type (),
      Origin_ (this)
    {
    }

    OriginType::
    OriginType (const Origin_type& Origin)
    : ::xml_schema::type (),
      Origin_ (Origin, this)
    {
    }

    OriginType::
    OriginType (const OriginType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Origin_ (x.Origin_, f, this)
    {
    }

    OriginType::
    OriginType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Origin_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OriginType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!Origin_.present ())
          {
            this->Origin_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Origin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Origin",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OriginType& OriginType::
    operator= (const OriginType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Origin_ = x.Origin_;
      }

      return *this;
    }

    OriginType::
    ~OriginType ()
    {
    }

    // WeldMainSymbolType
    //

    WeldMainSymbolType::
    WeldMainSymbolType ()
    : ::xsd::qif30::OriginType (),
      Symbol_ (this)
    {
    }

    WeldMainSymbolType::
    WeldMainSymbolType (const Origin_type& Origin,
                        const Symbol_type& Symbol)
    : ::xsd::qif30::OriginType (Origin),
      Symbol_ (Symbol, this)
    {
    }

    WeldMainSymbolType::
    WeldMainSymbolType (const WeldMainSymbolType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (x, f, c),
      Symbol_ (x.Symbol_, f, this)
    {
    }

    WeldMainSymbolType::
    WeldMainSymbolType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (e, f | ::xml_schema::flags::base, c),
      Symbol_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WeldMainSymbolType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::OriginType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Symbol
        //
        if (n.name () == L"Symbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Symbol_type > r (
            Symbol_traits::create (i, f, this));

          if (!Symbol_.present ())
          {
            this->Symbol_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Symbol_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Symbol",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    WeldMainSymbolType* WeldMainSymbolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldMainSymbolType (*this, f, c);
    }

    WeldMainSymbolType& WeldMainSymbolType::
    operator= (const WeldMainSymbolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::OriginType& > (*this) = x;
        this->Symbol_ = x.Symbol_;
      }

      return *this;
    }

    WeldMainSymbolType::
    ~WeldMainSymbolType ()
    {
    }

    // WeldSupplementarySymbolType
    //

    WeldSupplementarySymbolType::
    WeldSupplementarySymbolType ()
    : ::xsd::qif30::OriginType (),
      Symbol_ (this)
    {
    }

    WeldSupplementarySymbolType::
    WeldSupplementarySymbolType (const Origin_type& Origin,
                                 const Symbol_type& Symbol)
    : ::xsd::qif30::OriginType (Origin),
      Symbol_ (Symbol, this)
    {
    }

    WeldSupplementarySymbolType::
    WeldSupplementarySymbolType (const WeldSupplementarySymbolType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (x, f, c),
      Symbol_ (x.Symbol_, f, this)
    {
    }

    WeldSupplementarySymbolType::
    WeldSupplementarySymbolType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (e, f | ::xml_schema::flags::base, c),
      Symbol_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WeldSupplementarySymbolType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::OriginType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Symbol
        //
        if (n.name () == L"Symbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Symbol_type > r (
            Symbol_traits::create (i, f, this));

          if (!Symbol_.present ())
          {
            this->Symbol_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Symbol_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Symbol",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    WeldSupplementarySymbolType* WeldSupplementarySymbolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSupplementarySymbolType (*this, f, c);
    }

    WeldSupplementarySymbolType& WeldSupplementarySymbolType::
    operator= (const WeldSupplementarySymbolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::OriginType& > (*this) = x;
        this->Symbol_ = x.Symbol_;
      }

      return *this;
    }

    WeldSupplementarySymbolType::
    ~WeldSupplementarySymbolType ()
    {
    }

    // WeldContourSymbolType
    //

    WeldContourSymbolType::
    WeldContourSymbolType ()
    : ::xsd::qif30::OriginType (),
      Symbol_ (this)
    {
    }

    WeldContourSymbolType::
    WeldContourSymbolType (const Origin_type& Origin,
                           const Symbol_type& Symbol)
    : ::xsd::qif30::OriginType (Origin),
      Symbol_ (Symbol, this)
    {
    }

    WeldContourSymbolType::
    WeldContourSymbolType (const WeldContourSymbolType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (x, f, c),
      Symbol_ (x.Symbol_, f, this)
    {
    }

    WeldContourSymbolType::
    WeldContourSymbolType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::OriginType (e, f | ::xml_schema::flags::base, c),
      Symbol_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WeldContourSymbolType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::OriginType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Symbol
        //
        if (n.name () == L"Symbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Symbol_type > r (
            Symbol_traits::create (i, f, this));

          if (!Symbol_.present ())
          {
            this->Symbol_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Symbol_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Symbol",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    WeldContourSymbolType* WeldContourSymbolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldContourSymbolType (*this, f, c);
    }

    WeldContourSymbolType& WeldContourSymbolType::
    operator= (const WeldContourSymbolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::OriginType& > (*this) = x;
        this->Symbol_ = x.Symbol_;
      }

      return *this;
    }

    WeldContourSymbolType::
    ~WeldContourSymbolType ()
    {
    }

    // FrameWeldSymbolType
    //

    FrameWeldSymbolType::
    FrameWeldSymbolType ()
    : ::xsd::qif30::FrameBaseType (),
      ReferenceLineBeginPoint_ (this),
      ReferenceLineEndPoint_ (this),
      Tail_ (this),
      MainSymbol_ (this),
      SupplementarySymbol_ (this),
      ArrowSideContourSymbol_ (this),
      OtherSideContourSymbol_ (this)
    {
    }

    FrameWeldSymbolType::
    FrameWeldSymbolType (const ReferenceLineBeginPoint_type& ReferenceLineBeginPoint,
                         const ReferenceLineEndPoint_type& ReferenceLineEndPoint)
    : ::xsd::qif30::FrameBaseType (),
      ReferenceLineBeginPoint_ (ReferenceLineBeginPoint, this),
      ReferenceLineEndPoint_ (ReferenceLineEndPoint, this),
      Tail_ (this),
      MainSymbol_ (this),
      SupplementarySymbol_ (this),
      ArrowSideContourSymbol_ (this),
      OtherSideContourSymbol_ (this)
    {
    }

    FrameWeldSymbolType::
    FrameWeldSymbolType (const FrameWeldSymbolType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      ReferenceLineBeginPoint_ (x.ReferenceLineBeginPoint_, f, this),
      ReferenceLineEndPoint_ (x.ReferenceLineEndPoint_, f, this),
      Tail_ (x.Tail_, f, this),
      MainSymbol_ (x.MainSymbol_, f, this),
      SupplementarySymbol_ (x.SupplementarySymbol_, f, this),
      ArrowSideContourSymbol_ (x.ArrowSideContourSymbol_, f, this),
      OtherSideContourSymbol_ (x.OtherSideContourSymbol_, f, this)
    {
    }

    FrameWeldSymbolType::
    FrameWeldSymbolType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      ReferenceLineBeginPoint_ (this),
      ReferenceLineEndPoint_ (this),
      Tail_ (this),
      MainSymbol_ (this),
      SupplementarySymbol_ (this),
      ArrowSideContourSymbol_ (this),
      OtherSideContourSymbol_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameWeldSymbolType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ReferenceLineBeginPoint
        //
        if (n.name () == L"ReferenceLineBeginPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceLineBeginPoint_type > r (
            ReferenceLineBeginPoint_traits::create (i, f, this));

          if (!ReferenceLineBeginPoint_.present ())
          {
            this->ReferenceLineBeginPoint_.set (::std::move (r));
            continue;
          }
        }

        // ReferenceLineEndPoint
        //
        if (n.name () == L"ReferenceLineEndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceLineEndPoint_type > r (
            ReferenceLineEndPoint_traits::create (i, f, this));

          if (!ReferenceLineEndPoint_.present ())
          {
            this->ReferenceLineEndPoint_.set (::std::move (r));
            continue;
          }
        }

        // Tail
        //
        if (n.name () == L"Tail" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Tail_type > r (
            Tail_traits::create (i, f, this));

          if (!this->Tail_)
          {
            this->Tail_.set (::std::move (r));
            continue;
          }
        }

        // MainSymbol
        //
        if (n.name () == L"MainSymbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MainSymbol_type > r (
            MainSymbol_traits::create (i, f, this));

          if (!this->MainSymbol_)
          {
            this->MainSymbol_.set (::std::move (r));
            continue;
          }
        }

        // SupplementarySymbol
        //
        if (n.name () == L"SupplementarySymbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SupplementarySymbol_type > r (
            SupplementarySymbol_traits::create (i, f, this));

          if (!this->SupplementarySymbol_)
          {
            this->SupplementarySymbol_.set (::std::move (r));
            continue;
          }
        }

        // ArrowSideContourSymbol
        //
        if (n.name () == L"ArrowSideContourSymbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ArrowSideContourSymbol_type > r (
            ArrowSideContourSymbol_traits::create (i, f, this));

          if (!this->ArrowSideContourSymbol_)
          {
            this->ArrowSideContourSymbol_.set (::std::move (r));
            continue;
          }
        }

        // OtherSideContourSymbol
        //
        if (n.name () == L"OtherSideContourSymbol" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherSideContourSymbol_type > r (
            OtherSideContourSymbol_traits::create (i, f, this));

          if (!this->OtherSideContourSymbol_)
          {
            this->OtherSideContourSymbol_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ReferenceLineBeginPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferenceLineBeginPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ReferenceLineEndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferenceLineEndPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FrameWeldSymbolType* FrameWeldSymbolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameWeldSymbolType (*this, f, c);
    }

    FrameWeldSymbolType& FrameWeldSymbolType::
    operator= (const FrameWeldSymbolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->ReferenceLineBeginPoint_ = x.ReferenceLineBeginPoint_;
        this->ReferenceLineEndPoint_ = x.ReferenceLineEndPoint_;
        this->Tail_ = x.Tail_;
        this->MainSymbol_ = x.MainSymbol_;
        this->SupplementarySymbol_ = x.SupplementarySymbol_;
        this->ArrowSideContourSymbol_ = x.ArrowSideContourSymbol_;
        this->OtherSideContourSymbol_ = x.OtherSideContourSymbol_;
      }

      return *this;
    }

    FrameWeldSymbolType::
    ~FrameWeldSymbolType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameWeldSymbolType >
    _xsd_FrameWeldSymbolType_type_factory_init (
      L"FrameWeldSymbolType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameTriangleType
    //

    FrameTriangleType::
    FrameTriangleType ()
    : ::xsd::qif30::FrameBaseType (),
      Point_ (this)
    {
    }

    FrameTriangleType::
    FrameTriangleType (const FrameTriangleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      Point_ (x.Point_, f, this)
    {
    }

    FrameTriangleType::
    FrameTriangleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameTriangleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          this->Point_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FrameTriangleType* FrameTriangleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameTriangleType (*this, f, c);
    }

    FrameTriangleType& FrameTriangleType::
    operator= (const FrameTriangleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    FrameTriangleType::
    ~FrameTriangleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameTriangleType >
    _xsd_FrameTriangleType_type_factory_init (
      L"FrameTriangleType",
      L"http://qifstandards.org/xsd/qif3");

    // FramePentagonalType
    //

    FramePentagonalType::
    FramePentagonalType ()
    : ::xsd::qif30::FrameBaseType (),
      Point_ (this)
    {
    }

    FramePentagonalType::
    FramePentagonalType (const FramePentagonalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      Point_ (x.Point_, f, this)
    {
    }

    FramePentagonalType::
    FramePentagonalType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FramePentagonalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          this->Point_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FramePentagonalType* FramePentagonalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FramePentagonalType (*this, f, c);
    }

    FramePentagonalType& FramePentagonalType::
    operator= (const FramePentagonalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    FramePentagonalType::
    ~FramePentagonalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FramePentagonalType >
    _xsd_FramePentagonalType_type_factory_init (
      L"FramePentagonalType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameOctagonalType
    //

    FrameOctagonalType::
    FrameOctagonalType ()
    : ::xsd::qif30::FrameBaseType (),
      Point_ (this)
    {
    }

    FrameOctagonalType::
    FrameOctagonalType (const FrameOctagonalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      Point_ (x.Point_, f, this)
    {
    }

    FrameOctagonalType::
    FrameOctagonalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameOctagonalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          this->Point_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FrameOctagonalType* FrameOctagonalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameOctagonalType (*this, f, c);
    }

    FrameOctagonalType& FrameOctagonalType::
    operator= (const FrameOctagonalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    FrameOctagonalType::
    ~FrameOctagonalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameOctagonalType >
    _xsd_FrameOctagonalType_type_factory_init (
      L"FrameOctagonalType",
      L"http://qifstandards.org/xsd/qif3");

    // FrameHexagonalType
    //

    FrameHexagonalType::
    FrameHexagonalType ()
    : ::xsd::qif30::FrameBaseType (),
      Point_ (this)
    {
    }

    FrameHexagonalType::
    FrameHexagonalType (const FrameHexagonalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (x, f, c),
      Point_ (x.Point_, f, this)
    {
    }

    FrameHexagonalType::
    FrameHexagonalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FrameBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FrameHexagonalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          this->Point_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    FrameHexagonalType* FrameHexagonalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FrameHexagonalType (*this, f, c);
    }

    FrameHexagonalType& FrameHexagonalType::
    operator= (const FrameHexagonalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FrameBaseType& > (*this) = x;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    FrameHexagonalType::
    ~FrameHexagonalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FrameHexagonalType >
    _xsd_FrameHexagonalType_type_factory_init (
      L"FrameHexagonalType",
      L"http://qifstandards.org/xsd/qif3");

    // LeaderHeadFormEnumType
    //

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LeaderHeadFormEnumType_convert ();
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LeaderHeadFormEnumType_convert ();
    }

    LeaderHeadFormEnumType::
    LeaderHeadFormEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LeaderHeadFormEnumType_convert ();
    }

    LeaderHeadFormEnumType* LeaderHeadFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderHeadFormEnumType (*this, f, c);
    }

    LeaderHeadFormEnumType::value LeaderHeadFormEnumType::
    _xsd_LeaderHeadFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LeaderHeadFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LeaderHeadFormEnumType_indexes_,
                        _xsd_LeaderHeadFormEnumType_indexes_ + 15,
                        *this,
                        c));

      if (i == _xsd_LeaderHeadFormEnumType_indexes_ + 15 || _xsd_LeaderHeadFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LeaderHeadFormEnumType::
    _xsd_LeaderHeadFormEnumType_literals_[15] =
    {
      L"NONE",
      L"ARROW_OPEN",
      L"ARROW_UNFILLED",
      L"ARROW_BLANKED",
      L"ARROW_FILLED",
      L"TRIANGLE_BLANKED",
      L"TRIANGLE_FILLED",
      L"DOT_BLANKED",
      L"DOT_FILLED",
      L"BOX_BLANKED",
      L"BOX_FILLED",
      L"DIMENSION_ORIGIN",
      L"SYMBOL_SLASH",
      L"SYMBOL_INTEGRAL",
      L"SYMBOL_CROSS"
    };

    const LeaderHeadFormEnumType::value LeaderHeadFormEnumType::
    _xsd_LeaderHeadFormEnumType_indexes_[15] =
    {
      ::xsd::qif30::LeaderHeadFormEnumType::ARROW_BLANKED,
      ::xsd::qif30::LeaderHeadFormEnumType::ARROW_FILLED,
      ::xsd::qif30::LeaderHeadFormEnumType::ARROW_OPEN,
      ::xsd::qif30::LeaderHeadFormEnumType::ARROW_UNFILLED,
      ::xsd::qif30::LeaderHeadFormEnumType::BOX_BLANKED,
      ::xsd::qif30::LeaderHeadFormEnumType::BOX_FILLED,
      ::xsd::qif30::LeaderHeadFormEnumType::DIMENSION_ORIGIN,
      ::xsd::qif30::LeaderHeadFormEnumType::DOT_BLANKED,
      ::xsd::qif30::LeaderHeadFormEnumType::DOT_FILLED,
      ::xsd::qif30::LeaderHeadFormEnumType::NONE,
      ::xsd::qif30::LeaderHeadFormEnumType::SYMBOL_CROSS,
      ::xsd::qif30::LeaderHeadFormEnumType::SYMBOL_INTEGRAL,
      ::xsd::qif30::LeaderHeadFormEnumType::SYMBOL_SLASH,
      ::xsd::qif30::LeaderHeadFormEnumType::TRIANGLE_BLANKED,
      ::xsd::qif30::LeaderHeadFormEnumType::TRIANGLE_FILLED
    };

    // LeaderHeadFormType
    //

    LeaderHeadFormType::
    LeaderHeadFormType ()
    : ::xsd::qif30::LeaderHeadFormEnumType (),
      normal_ (this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (::xsd::qif30::LeaderHeadFormEnumType::value _xsd_LeaderHeadFormEnumType_base)
    : ::xsd::qif30::LeaderHeadFormEnumType (_xsd_LeaderHeadFormEnumType_base),
      normal_ (this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (const wchar_t* _xsd_string_base)
    : ::xsd::qif30::LeaderHeadFormEnumType (_xsd_string_base),
      normal_ (this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (const ::std::wstring& _xsd_string_base)
    : ::xsd::qif30::LeaderHeadFormEnumType (_xsd_string_base),
      normal_ (this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (const ::xsd::qif30::LeaderHeadFormEnumType& _xsd_LeaderHeadFormEnumType_base)
    : ::xsd::qif30::LeaderHeadFormEnumType (_xsd_LeaderHeadFormEnumType_base),
      normal_ (this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (const LeaderHeadFormType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::LeaderHeadFormEnumType (x, f, c),
      normal_ (x.normal_, f, this)
    {
    }

    LeaderHeadFormType::
    LeaderHeadFormType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::LeaderHeadFormEnumType (e, f | ::xml_schema::flags::base, c),
      normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LeaderHeadFormType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"normal" && n.namespace_ ().empty ())
        {
          this->normal_.set (normal_traits::create (i, f, this));
          continue;
        }
      }
    }

    LeaderHeadFormType* LeaderHeadFormType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderHeadFormType (*this, f, c);
    }

    LeaderHeadFormType& LeaderHeadFormType::
    operator= (const LeaderHeadFormType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LeaderHeadFormEnumType& > (*this) = x;
        this->normal_ = x.normal_;
      }

      return *this;
    }

    LeaderHeadFormType::
    ~LeaderHeadFormType ()
    {
    }

    // LeaderModifierEnumType
    //

    LeaderModifierEnumType::
    LeaderModifierEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LeaderModifierEnumType_convert ();
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LeaderModifierEnumType_convert ();
    }

    LeaderModifierEnumType::
    LeaderModifierEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LeaderModifierEnumType_convert ();
    }

    LeaderModifierEnumType* LeaderModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LeaderModifierEnumType (*this, f, c);
    }

    LeaderModifierEnumType::value LeaderModifierEnumType::
    _xsd_LeaderModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LeaderModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LeaderModifierEnumType_indexes_,
                        _xsd_LeaderModifierEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_LeaderModifierEnumType_indexes_ + 4 || _xsd_LeaderModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LeaderModifierEnumType::
    _xsd_LeaderModifierEnumType_literals_[4] =
    {
      L"ALL_AROUND",
      L"ALL_OVER",
      L"FLAG",
      L"ALL_AROUND_FLAG"
    };

    const LeaderModifierEnumType::value LeaderModifierEnumType::
    _xsd_LeaderModifierEnumType_indexes_[4] =
    {
      ::xsd::qif30::LeaderModifierEnumType::ALL_AROUND,
      ::xsd::qif30::LeaderModifierEnumType::ALL_AROUND_FLAG,
      ::xsd::qif30::LeaderModifierEnumType::ALL_OVER,
      ::xsd::qif30::LeaderModifierEnumType::FLAG
    };

    // ViewSetType
    //

    ViewSetType::
    ViewSetType ()
    : ::xml_schema::type (),
      CameraSet_ (this),
      SavedViewSet_ (this),
      AnnotationViewSet_ (this),
      SimplifiedRepresentationSet_ (this),
      ExplodedViewSet_ (this),
      DisplayStyleSet_ (this),
      ZoneSectionSet_ (this),
      HatchStyleSet_ (this)
    {
    }

    ViewSetType::
    ViewSetType (const ViewSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CameraSet_ (x.CameraSet_, f, this),
      SavedViewSet_ (x.SavedViewSet_, f, this),
      AnnotationViewSet_ (x.AnnotationViewSet_, f, this),
      SimplifiedRepresentationSet_ (x.SimplifiedRepresentationSet_, f, this),
      ExplodedViewSet_ (x.ExplodedViewSet_, f, this),
      DisplayStyleSet_ (x.DisplayStyleSet_, f, this),
      ZoneSectionSet_ (x.ZoneSectionSet_, f, this),
      HatchStyleSet_ (x.HatchStyleSet_, f, this)
    {
    }

    ViewSetType::
    ViewSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CameraSet_ (this),
      SavedViewSet_ (this),
      AnnotationViewSet_ (this),
      SimplifiedRepresentationSet_ (this),
      ExplodedViewSet_ (this),
      DisplayStyleSet_ (this),
      ZoneSectionSet_ (this),
      HatchStyleSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ViewSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CameraSet
        //
        if (n.name () == L"CameraSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CameraSet_type > r (
            CameraSet_traits::create (i, f, this));

          if (!this->CameraSet_)
          {
            this->CameraSet_.set (::std::move (r));
            continue;
          }
        }

        // SavedViewSet
        //
        if (n.name () == L"SavedViewSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SavedViewSet_type > r (
            SavedViewSet_traits::create (i, f, this));

          if (!this->SavedViewSet_)
          {
            this->SavedViewSet_.set (::std::move (r));
            continue;
          }
        }

        // AnnotationViewSet
        //
        if (n.name () == L"AnnotationViewSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AnnotationViewSet_type > r (
            AnnotationViewSet_traits::create (i, f, this));

          if (!this->AnnotationViewSet_)
          {
            this->AnnotationViewSet_.set (::std::move (r));
            continue;
          }
        }

        // SimplifiedRepresentationSet
        //
        if (n.name () == L"SimplifiedRepresentationSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimplifiedRepresentationSet_type > r (
            SimplifiedRepresentationSet_traits::create (i, f, this));

          if (!this->SimplifiedRepresentationSet_)
          {
            this->SimplifiedRepresentationSet_.set (::std::move (r));
            continue;
          }
        }

        // ExplodedViewSet
        //
        if (n.name () == L"ExplodedViewSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExplodedViewSet_type > r (
            ExplodedViewSet_traits::create (i, f, this));

          if (!this->ExplodedViewSet_)
          {
            this->ExplodedViewSet_.set (::std::move (r));
            continue;
          }
        }

        // DisplayStyleSet
        //
        if (n.name () == L"DisplayStyleSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DisplayStyleSet_type > r (
            DisplayStyleSet_traits::create (i, f, this));

          if (!this->DisplayStyleSet_)
          {
            this->DisplayStyleSet_.set (::std::move (r));
            continue;
          }
        }

        // ZoneSectionSet
        //
        if (n.name () == L"ZoneSectionSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZoneSectionSet_type > r (
            ZoneSectionSet_traits::create (i, f, this));

          if (!this->ZoneSectionSet_)
          {
            this->ZoneSectionSet_.set (::std::move (r));
            continue;
          }
        }

        // HatchStyleSet
        //
        if (n.name () == L"HatchStyleSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HatchStyleSet_type > r (
            HatchStyleSet_traits::create (i, f, this));

          if (!this->HatchStyleSet_)
          {
            this->HatchStyleSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ViewSetType* ViewSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ViewSetType (*this, f, c);
    }

    ViewSetType& ViewSetType::
    operator= (const ViewSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CameraSet_ = x.CameraSet_;
        this->SavedViewSet_ = x.SavedViewSet_;
        this->AnnotationViewSet_ = x.AnnotationViewSet_;
        this->SimplifiedRepresentationSet_ = x.SimplifiedRepresentationSet_;
        this->ExplodedViewSet_ = x.ExplodedViewSet_;
        this->DisplayStyleSet_ = x.DisplayStyleSet_;
        this->ZoneSectionSet_ = x.ZoneSectionSet_;
        this->HatchStyleSet_ = x.HatchStyleSet_;
      }

      return *this;
    }

    ViewSetType::
    ~ViewSetType ()
    {
    }

    // CameraType
    //

    const CameraType::form_type CameraType::form_default_value_ (
      L"ORTHOGRAPHIC");

    CameraType::
    CameraType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      ViewPlaneOrigin_ (this),
      Orientation_ (this),
      Ratio_ (this),
      Near_ (this),
      Far_ (this),
      Height_ (this),
      form_ (form_default_value (), this)
    {
    }

    CameraType::
    CameraType (const id_type& id,
                const ViewPlaneOrigin_type& ViewPlaneOrigin,
                const Orientation_type& Orientation,
                const Ratio_type& Ratio,
                const Near_type& Near,
                const Far_type& Far,
                const Height_type& Height)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      ViewPlaneOrigin_ (ViewPlaneOrigin, this),
      Orientation_ (Orientation, this),
      Ratio_ (Ratio, this),
      Near_ (Near, this),
      Far_ (Far, this),
      Height_ (Height, this),
      form_ (form_default_value (), this)
    {
    }

    CameraType::
    CameraType (const id_type& id,
                const ViewPlaneOrigin_type& ViewPlaneOrigin,
                ::std::unique_ptr< Orientation_type > Orientation,
                const Ratio_type& Ratio,
                ::std::unique_ptr< Near_type > Near,
                ::std::unique_ptr< Far_type > Far,
                const Height_type& Height)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      ViewPlaneOrigin_ (ViewPlaneOrigin, this),
      Orientation_ (std::move (Orientation), this),
      Ratio_ (Ratio, this),
      Near_ (std::move (Near), this),
      Far_ (std::move (Far), this),
      Height_ (Height, this),
      form_ (form_default_value (), this)
    {
    }

    CameraType::
    CameraType (const CameraType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      ViewPlaneOrigin_ (x.ViewPlaneOrigin_, f, this),
      Orientation_ (x.Orientation_, f, this),
      Ratio_ (x.Ratio_, f, this),
      Near_ (x.Near_, f, this),
      Far_ (x.Far_, f, this),
      Height_ (x.Height_, f, this),
      form_ (x.form_, f, this)
    {
    }

    CameraType::
    CameraType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      ViewPlaneOrigin_ (this),
      Orientation_ (this),
      Ratio_ (this),
      Near_ (this),
      Far_ (this),
      Height_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CameraType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ViewPlaneOrigin
        //
        if (n.name () == L"ViewPlaneOrigin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ViewPlaneOrigin_type > r (
            ViewPlaneOrigin_traits::create (i, f, this));

          if (!ViewPlaneOrigin_.present ())
          {
            this->ViewPlaneOrigin_.set (::std::move (r));
            continue;
          }
        }

        // Orientation
        //
        if (n.name () == L"Orientation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Orientation_type > r (
            Orientation_traits::create (i, f, this));

          if (!Orientation_.present ())
          {
            this->Orientation_.set (::std::move (r));
            continue;
          }
        }

        // Ratio
        //
        if (n.name () == L"Ratio" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Ratio_.present ())
          {
            this->Ratio_.set (Ratio_traits::create (i, f, this));
            continue;
          }
        }

        // Near
        //
        if (n.name () == L"Near" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Near_type > r (
            Near_traits::create (i, f, this));

          if (!Near_.present ())
          {
            this->Near_.set (::std::move (r));
            continue;
          }
        }

        // Far
        //
        if (n.name () == L"Far" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Far_type > r (
            Far_traits::create (i, f, this));

          if (!Far_.present ())
          {
            this->Far_.set (::std::move (r));
            continue;
          }
        }

        // Height
        //
        if (n.name () == L"Height" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Height_.present ())
          {
            this->Height_.set (Height_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ViewPlaneOrigin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ViewPlaneOrigin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Orientation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Orientation",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Ratio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Ratio",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Near_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Near",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Far_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Far",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Height",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    CameraType* CameraType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CameraType (*this, f, c);
    }

    CameraType& CameraType::
    operator= (const CameraType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->ViewPlaneOrigin_ = x.ViewPlaneOrigin_;
        this->Orientation_ = x.Orientation_;
        this->Ratio_ = x.Ratio_;
        this->Near_ = x.Near_;
        this->Far_ = x.Far_;
        this->Height_ = x.Height_;
        this->form_ = x.form_;
      }

      return *this;
    }

    CameraType::
    ~CameraType ()
    {
    }

    // CameraFormEnumType
    //

    CameraFormEnumType::
    CameraFormEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_CameraFormEnumType_convert ();
    }

    CameraFormEnumType::
    CameraFormEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_CameraFormEnumType_convert ();
    }

    CameraFormEnumType::
    CameraFormEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_CameraFormEnumType_convert ();
    }

    CameraFormEnumType* CameraFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CameraFormEnumType (*this, f, c);
    }

    CameraFormEnumType::value CameraFormEnumType::
    _xsd_CameraFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CameraFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CameraFormEnumType_indexes_,
                        _xsd_CameraFormEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_CameraFormEnumType_indexes_ + 2 || _xsd_CameraFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CameraFormEnumType::
    _xsd_CameraFormEnumType_literals_[2] =
    {
      L"ORTHOGRAPHIC",
      L"PERSPECTIVE"
    };

    const CameraFormEnumType::value CameraFormEnumType::
    _xsd_CameraFormEnumType_indexes_[2] =
    {
      ::xsd::qif30::CameraFormEnumType::ORTHOGRAPHIC,
      ::xsd::qif30::CameraFormEnumType::PERSPECTIVE
    };

    // SavedViewType
    //

    SavedViewType::
    SavedViewType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      ActiveView_ (this),
      AnnotationVisibleIds_ (this),
      AnnotationHiddenIds_ (this),
      BodyIds_ (this),
      ComponentIds_ (this),
      SimplifiedRepresentationId_ (this),
      ExplodedViewId_ (this),
      DisplayStyleId_ (this),
      ZoneSectionId_ (this),
      CameraIds_ (this)
    {
    }

    SavedViewType::
    SavedViewType (const id_type& id)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      ActiveView_ (this),
      AnnotationVisibleIds_ (this),
      AnnotationHiddenIds_ (this),
      BodyIds_ (this),
      ComponentIds_ (this),
      SimplifiedRepresentationId_ (this),
      ExplodedViewId_ (this),
      DisplayStyleId_ (this),
      ZoneSectionId_ (this),
      CameraIds_ (this)
    {
    }

    SavedViewType::
    SavedViewType (const SavedViewType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      ActiveView_ (x.ActiveView_, f, this),
      AnnotationVisibleIds_ (x.AnnotationVisibleIds_, f, this),
      AnnotationHiddenIds_ (x.AnnotationHiddenIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this),
      ComponentIds_ (x.ComponentIds_, f, this),
      SimplifiedRepresentationId_ (x.SimplifiedRepresentationId_, f, this),
      ExplodedViewId_ (x.ExplodedViewId_, f, this),
      DisplayStyleId_ (x.DisplayStyleId_, f, this),
      ZoneSectionId_ (x.ZoneSectionId_, f, this),
      CameraIds_ (x.CameraIds_, f, this)
    {
    }

    SavedViewType::
    SavedViewType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      ActiveView_ (this),
      AnnotationVisibleIds_ (this),
      AnnotationHiddenIds_ (this),
      BodyIds_ (this),
      ComponentIds_ (this),
      SimplifiedRepresentationId_ (this),
      ExplodedViewId_ (this),
      DisplayStyleId_ (this),
      ZoneSectionId_ (this),
      CameraIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SavedViewType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ActiveView
        //
        if (n.name () == L"ActiveView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ActiveView_)
          {
            this->ActiveView_.set (ActiveView_traits::create (i, f, this));
            continue;
          }
        }

        // AnnotationVisibleIds
        //
        if (n.name () == L"AnnotationVisibleIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AnnotationVisibleIds_type > r (
            AnnotationVisibleIds_traits::create (i, f, this));

          if (!this->AnnotationVisibleIds_)
          {
            this->AnnotationVisibleIds_.set (::std::move (r));
            continue;
          }
        }

        // AnnotationHiddenIds
        //
        if (n.name () == L"AnnotationHiddenIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AnnotationHiddenIds_type > r (
            AnnotationHiddenIds_traits::create (i, f, this));

          if (!this->AnnotationHiddenIds_)
          {
            this->AnnotationHiddenIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        // SimplifiedRepresentationId
        //
        if (n.name () == L"SimplifiedRepresentationId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimplifiedRepresentationId_type > r (
            SimplifiedRepresentationId_traits::create (i, f, this));

          if (!this->SimplifiedRepresentationId_)
          {
            this->SimplifiedRepresentationId_.set (::std::move (r));
            continue;
          }
        }

        // ExplodedViewId
        //
        if (n.name () == L"ExplodedViewId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExplodedViewId_type > r (
            ExplodedViewId_traits::create (i, f, this));

          if (!this->ExplodedViewId_)
          {
            this->ExplodedViewId_.set (::std::move (r));
            continue;
          }
        }

        // DisplayStyleId
        //
        if (n.name () == L"DisplayStyleId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DisplayStyleId_type > r (
            DisplayStyleId_traits::create (i, f, this));

          if (!this->DisplayStyleId_)
          {
            this->DisplayStyleId_.set (::std::move (r));
            continue;
          }
        }

        // ZoneSectionId
        //
        if (n.name () == L"ZoneSectionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZoneSectionId_type > r (
            ZoneSectionId_traits::create (i, f, this));

          if (!this->ZoneSectionId_)
          {
            this->ZoneSectionId_.set (::std::move (r));
            continue;
          }
        }

        // CameraIds
        //
        if (n.name () == L"CameraIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CameraIds_type > r (
            CameraIds_traits::create (i, f, this));

          if (!this->CameraIds_)
          {
            this->CameraIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SavedViewType* SavedViewType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SavedViewType (*this, f, c);
    }

    SavedViewType& SavedViewType::
    operator= (const SavedViewType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->ActiveView_ = x.ActiveView_;
        this->AnnotationVisibleIds_ = x.AnnotationVisibleIds_;
        this->AnnotationHiddenIds_ = x.AnnotationHiddenIds_;
        this->BodyIds_ = x.BodyIds_;
        this->ComponentIds_ = x.ComponentIds_;
        this->SimplifiedRepresentationId_ = x.SimplifiedRepresentationId_;
        this->ExplodedViewId_ = x.ExplodedViewId_;
        this->DisplayStyleId_ = x.DisplayStyleId_;
        this->ZoneSectionId_ = x.ZoneSectionId_;
        this->CameraIds_ = x.CameraIds_;
      }

      return *this;
    }

    SavedViewType::
    ~SavedViewType ()
    {
    }

    // ZoneSectionType
    //

    ZoneSectionType::
    ZoneSectionType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      SectionPlanes_ (this),
      LogicalOperations_ (this),
      hatching_ (hatching_default_value (), this)
    {
    }

    ZoneSectionType::
    ZoneSectionType (const id_type& id,
                     const SectionPlanes_type& SectionPlanes)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      SectionPlanes_ (SectionPlanes, this),
      LogicalOperations_ (this),
      hatching_ (hatching_default_value (), this)
    {
    }

    ZoneSectionType::
    ZoneSectionType (const id_type& id,
                     ::std::unique_ptr< SectionPlanes_type > SectionPlanes)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      SectionPlanes_ (std::move (SectionPlanes), this),
      LogicalOperations_ (this),
      hatching_ (hatching_default_value (), this)
    {
    }

    ZoneSectionType::
    ZoneSectionType (const ZoneSectionType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      SectionPlanes_ (x.SectionPlanes_, f, this),
      LogicalOperations_ (x.LogicalOperations_, f, this),
      hatching_ (x.hatching_, f, this)
    {
    }

    ZoneSectionType::
    ZoneSectionType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      SectionPlanes_ (this),
      LogicalOperations_ (this),
      hatching_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ZoneSectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SectionPlanes
        //
        if (n.name () == L"SectionPlanes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionPlanes_type > r (
            SectionPlanes_traits::create (i, f, this));

          if (!SectionPlanes_.present ())
          {
            this->SectionPlanes_.set (::std::move (r));
            continue;
          }
        }

        // LogicalOperations
        //
        if (n.name () == L"LogicalOperations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LogicalOperations_type > r (
            LogicalOperations_traits::create (i, f, this));

          if (!this->LogicalOperations_)
          {
            this->LogicalOperations_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SectionPlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SectionPlanes",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"hatching" && n.namespace_ ().empty ())
        {
          this->hatching_.set (hatching_traits::create (i, f, this));
          continue;
        }
      }

      if (!hatching_.present ())
      {
        this->hatching_.set (hatching_default_value ());
      }
    }

    ZoneSectionType* ZoneSectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneSectionType (*this, f, c);
    }

    ZoneSectionType& ZoneSectionType::
    operator= (const ZoneSectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->SectionPlanes_ = x.SectionPlanes_;
        this->LogicalOperations_ = x.LogicalOperations_;
        this->hatching_ = x.hatching_;
      }

      return *this;
    }

    ZoneSectionType::
    ~ZoneSectionType ()
    {
    }

    // LogicalOperationType
    //

    LogicalOperationType::
    LogicalOperationType ()
    : ::xml_schema::type (),
      Action_ (this),
      SectionPlane_ (this),
      LogicalOperationResult_ (this),
      index_ (this)
    {
    }

    LogicalOperationType::
    LogicalOperationType (const Action_type& Action,
                          const index_type& index)
    : ::xml_schema::type (),
      Action_ (Action, this),
      SectionPlane_ (this),
      LogicalOperationResult_ (this),
      index_ (index, this)
    {
    }

    LogicalOperationType::
    LogicalOperationType (const LogicalOperationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Action_ (x.Action_, f, this),
      SectionPlane_ (x.SectionPlane_, f, this),
      LogicalOperationResult_ (x.LogicalOperationResult_, f, this),
      index_ (x.index_, f, this)
    {
    }

    LogicalOperationType::
    LogicalOperationType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Action_ (this),
      SectionPlane_ (this),
      LogicalOperationResult_ (this),
      index_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LogicalOperationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Action
        //
        if (n.name () == L"Action" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Action_type > r (
            Action_traits::create (i, f, this));

          if (!Action_.present ())
          {
            this->Action_.set (::std::move (r));
            continue;
          }
        }

        // SectionPlane
        //
        if (n.name () == L"SectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          this->SectionPlane_.push_back (SectionPlane_traits::create (i, f, this));
          continue;
        }

        // LogicalOperationResult
        //
        if (n.name () == L"LogicalOperationResult" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          this->LogicalOperationResult_.push_back (LogicalOperationResult_traits::create (i, f, this));
          continue;
        }

        break;
      }

      if (!Action_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Action",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    LogicalOperationType* LogicalOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LogicalOperationType (*this, f, c);
    }

    LogicalOperationType& LogicalOperationType::
    operator= (const LogicalOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Action_ = x.Action_;
        this->SectionPlane_ = x.SectionPlane_;
        this->LogicalOperationResult_ = x.LogicalOperationResult_;
        this->index_ = x.index_;
      }

      return *this;
    }

    LogicalOperationType::
    ~LogicalOperationType ()
    {
    }

    // LogicalOperationsType
    //

    LogicalOperationsType::
    LogicalOperationsType ()
    : ::xml_schema::type (),
      LogicalOperation_ (this),
      n_ (this)
    {
    }

    LogicalOperationsType::
    LogicalOperationsType (const n_type& n)
    : ::xml_schema::type (),
      LogicalOperation_ (this),
      n_ (n, this)
    {
    }

    LogicalOperationsType::
    LogicalOperationsType (const LogicalOperationsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LogicalOperation_ (x.LogicalOperation_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LogicalOperationsType::
    LogicalOperationsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LogicalOperation_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LogicalOperationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LogicalOperation
        //
        if (n.name () == L"LogicalOperation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LogicalOperation_type > r (
            LogicalOperation_traits::create (i, f, this));

          this->LogicalOperation_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LogicalOperationsType* LogicalOperationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LogicalOperationsType (*this, f, c);
    }

    LogicalOperationsType& LogicalOperationsType::
    operator= (const LogicalOperationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LogicalOperation_ = x.LogicalOperation_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LogicalOperationsType::
    ~LogicalOperationsType ()
    {
    }

    // LogicalOperationEnumType
    //

    LogicalOperationEnumType::
    LogicalOperationEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LogicalOperationEnumType_convert ();
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LogicalOperationEnumType_convert ();
    }

    LogicalOperationEnumType::
    LogicalOperationEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LogicalOperationEnumType_convert ();
    }

    LogicalOperationEnumType* LogicalOperationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LogicalOperationEnumType (*this, f, c);
    }

    LogicalOperationEnumType::value LogicalOperationEnumType::
    _xsd_LogicalOperationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LogicalOperationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LogicalOperationEnumType_indexes_,
                        _xsd_LogicalOperationEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_LogicalOperationEnumType_indexes_ + 2 || _xsd_LogicalOperationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LogicalOperationEnumType::
    _xsd_LogicalOperationEnumType_literals_[2] =
    {
      L"LOGICAL_AND",
      L"LOGICAL_OR"
    };

    const LogicalOperationEnumType::value LogicalOperationEnumType::
    _xsd_LogicalOperationEnumType_indexes_[2] =
    {
      ::xsd::qif30::LogicalOperationEnumType::LOGICAL_AND,
      ::xsd::qif30::LogicalOperationEnumType::LOGICAL_OR
    };

    // ZoneSectionPlanesType
    //

    ZoneSectionPlanesType::
    ZoneSectionPlanesType ()
    : ::xml_schema::type (),
      SectionPlane_ (this),
      n_ (this)
    {
    }

    ZoneSectionPlanesType::
    ZoneSectionPlanesType (const n_type& n)
    : ::xml_schema::type (),
      SectionPlane_ (this),
      n_ (n, this)
    {
    }

    ZoneSectionPlanesType::
    ZoneSectionPlanesType (const ZoneSectionPlanesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SectionPlane_ (x.SectionPlane_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ZoneSectionPlanesType::
    ZoneSectionPlanesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SectionPlane_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ZoneSectionPlanesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SectionPlane
        //
        if (n.name () == L"SectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionPlane_type > r (
            SectionPlane_traits::create (i, f, this));

          this->SectionPlane_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ZoneSectionPlanesType* ZoneSectionPlanesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneSectionPlanesType (*this, f, c);
    }

    ZoneSectionPlanesType& ZoneSectionPlanesType::
    operator= (const ZoneSectionPlanesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SectionPlane_ = x.SectionPlane_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ZoneSectionPlanesType::
    ~ZoneSectionPlanesType ()
    {
    }

    // ZoneSectionPlaneType
    //

    ZoneSectionPlaneType::
    ZoneSectionPlaneType ()
    : ::xml_schema::type (),
      Plane_ (this),
      SectionGroups_ (this),
      index_ (this)
    {
    }

    ZoneSectionPlaneType::
    ZoneSectionPlaneType (const Plane_type& Plane,
                          const index_type& index)
    : ::xml_schema::type (),
      Plane_ (Plane, this),
      SectionGroups_ (this),
      index_ (index, this)
    {
    }

    ZoneSectionPlaneType::
    ZoneSectionPlaneType (::std::unique_ptr< Plane_type > Plane,
                          const index_type& index)
    : ::xml_schema::type (),
      Plane_ (std::move (Plane), this),
      SectionGroups_ (this),
      index_ (index, this)
    {
    }

    ZoneSectionPlaneType::
    ZoneSectionPlaneType (const ZoneSectionPlaneType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Plane_ (x.Plane_, f, this),
      SectionGroups_ (x.SectionGroups_, f, this),
      index_ (x.index_, f, this)
    {
    }

    ZoneSectionPlaneType::
    ZoneSectionPlaneType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Plane_ (this),
      SectionGroups_ (this),
      index_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ZoneSectionPlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Plane
        //
        if (n.name () == L"Plane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!Plane_.present ())
          {
            this->Plane_.set (::std::move (r));
            continue;
          }
        }

        // SectionGroups
        //
        if (n.name () == L"SectionGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionGroups_type > r (
            SectionGroups_traits::create (i, f, this));

          if (!this->SectionGroups_)
          {
            this->SectionGroups_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Plane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Plane",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    ZoneSectionPlaneType* ZoneSectionPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneSectionPlaneType (*this, f, c);
    }

    ZoneSectionPlaneType& ZoneSectionPlaneType::
    operator= (const ZoneSectionPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Plane_ = x.Plane_;
        this->SectionGroups_ = x.SectionGroups_;
        this->index_ = x.index_;
      }

      return *this;
    }

    ZoneSectionPlaneType::
    ~ZoneSectionPlaneType ()
    {
    }

    // SectionGroupsType
    //

    SectionGroupsType::
    SectionGroupsType ()
    : ::xml_schema::type (),
      SectionGroup_ (this),
      n_ (this)
    {
    }

    SectionGroupsType::
    SectionGroupsType (const n_type& n)
    : ::xml_schema::type (),
      SectionGroup_ (this),
      n_ (n, this)
    {
    }

    SectionGroupsType::
    SectionGroupsType (const SectionGroupsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SectionGroup_ (x.SectionGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SectionGroupsType::
    SectionGroupsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SectionGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SectionGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SectionGroup
        //
        if (n.name () == L"SectionGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SectionGroup_type > r (
            SectionGroup_traits::create (i, f, this));

          this->SectionGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SectionGroupsType* SectionGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionGroupsType (*this, f, c);
    }

    SectionGroupsType& SectionGroupsType::
    operator= (const SectionGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SectionGroup_ = x.SectionGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SectionGroupsType::
    ~SectionGroupsType ()
    {
    }

    // SectionGroupType
    //

    SectionGroupType::
    SectionGroupType ()
    : ::xml_schema::type (),
      BodyId_ (this),
      Areas_ (this),
      Paths_ (this),
      Vertices_ (this)
    {
    }

    SectionGroupType::
    SectionGroupType (const SectionGroupType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BodyId_ (x.BodyId_, f, this),
      Areas_ (x.Areas_, f, this),
      Paths_ (x.Paths_, f, this),
      Vertices_ (x.Vertices_, f, this)
    {
    }

    SectionGroupType::
    SectionGroupType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BodyId_ (this),
      Areas_ (this),
      Paths_ (this),
      Vertices_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SectionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BodyId
        //
        if (n.name () == L"BodyId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyId_type > r (
            BodyId_traits::create (i, f, this));

          if (!this->BodyId_)
          {
            this->BodyId_.set (::std::move (r));
            continue;
          }
        }

        // Areas
        //
        if (n.name () == L"Areas" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Areas_type > r (
            Areas_traits::create (i, f, this));

          if (!this->Areas_)
          {
            this->Areas_.set (::std::move (r));
            continue;
          }
        }

        // Paths
        //
        if (n.name () == L"Paths" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Paths_type > r (
            Paths_traits::create (i, f, this));

          if (!this->Paths_)
          {
            this->Paths_.set (::std::move (r));
            continue;
          }
        }

        // Vertices
        //
        if (n.name () == L"Vertices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vertices_type > r (
            Vertices_traits::create (i, f, this));

          if (!this->Vertices_)
          {
            this->Vertices_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SectionGroupType* SectionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionGroupType (*this, f, c);
    }

    SectionGroupType& SectionGroupType::
    operator= (const SectionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BodyId_ = x.BodyId_;
        this->Areas_ = x.Areas_;
        this->Paths_ = x.Paths_;
        this->Vertices_ = x.Vertices_;
      }

      return *this;
    }

    SectionGroupType::
    ~SectionGroupType ()
    {
    }

    // SectionPathsType
    //

    SectionPathsType::
    SectionPathsType ()
    : ::xml_schema::type (),
      Path_ (this),
      n_ (this)
    {
    }

    SectionPathsType::
    SectionPathsType (const n_type& n)
    : ::xml_schema::type (),
      Path_ (this),
      n_ (n, this)
    {
    }

    SectionPathsType::
    SectionPathsType (const SectionPathsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Path_ (x.Path_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SectionPathsType::
    SectionPathsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Path_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SectionPathsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Path
        //
        if (n.name () == L"Path" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Path_type > r (
            Path_traits::create (i, f, this));

          this->Path_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SectionPathsType* SectionPathsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionPathsType (*this, f, c);
    }

    SectionPathsType& SectionPathsType::
    operator= (const SectionPathsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Path_ = x.Path_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SectionPathsType::
    ~SectionPathsType ()
    {
    }

    // SectionLoopsType
    //

    SectionLoopsType::
    SectionLoopsType ()
    : ::xml_schema::type (),
      Loop_ (this),
      n_ (this)
    {
    }

    SectionLoopsType::
    SectionLoopsType (const n_type& n)
    : ::xml_schema::type (),
      Loop_ (this),
      n_ (n, this)
    {
    }

    SectionLoopsType::
    SectionLoopsType (const SectionLoopsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Loop_ (x.Loop_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SectionLoopsType::
    SectionLoopsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Loop_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SectionLoopsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Loop
        //
        if (n.name () == L"Loop" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Loop_type > r (
            Loop_traits::create (i, f, this));

          this->Loop_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SectionLoopsType* SectionLoopsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionLoopsType (*this, f, c);
    }

    SectionLoopsType& SectionLoopsType::
    operator= (const SectionLoopsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Loop_ = x.Loop_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SectionLoopsType::
    ~SectionLoopsType ()
    {
    }

    // SectionAreasType
    //

    SectionAreasType::
    SectionAreasType ()
    : ::xml_schema::type (),
      Area_ (this),
      n_ (this)
    {
    }

    SectionAreasType::
    SectionAreasType (const n_type& n)
    : ::xml_schema::type (),
      Area_ (this),
      n_ (n, this)
    {
    }

    SectionAreasType::
    SectionAreasType (const SectionAreasType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Area_ (x.Area_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SectionAreasType::
    SectionAreasType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Area_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SectionAreasType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Area
        //
        if (n.name () == L"Area" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Area_type > r (
            Area_traits::create (i, f, this));

          this->Area_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SectionAreasType* SectionAreasType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionAreasType (*this, f, c);
    }

    SectionAreasType& SectionAreasType::
    operator= (const SectionAreasType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Area_ = x.Area_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SectionAreasType::
    ~SectionAreasType ()
    {
    }

    // SectionAreaType
    //

    SectionAreaType::
    SectionAreaType ()
    : ::xml_schema::type (),
      HatchStyleId_ (this),
      Loops_ (this)
    {
    }

    SectionAreaType::
    SectionAreaType (const Loops_type& Loops)
    : ::xml_schema::type (),
      HatchStyleId_ (this),
      Loops_ (Loops, this)
    {
    }

    SectionAreaType::
    SectionAreaType (::std::unique_ptr< Loops_type > Loops)
    : ::xml_schema::type (),
      HatchStyleId_ (this),
      Loops_ (std::move (Loops), this)
    {
    }

    SectionAreaType::
    SectionAreaType (const SectionAreaType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      HatchStyleId_ (x.HatchStyleId_, f, this),
      Loops_ (x.Loops_, f, this)
    {
    }

    SectionAreaType::
    SectionAreaType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      HatchStyleId_ (this),
      Loops_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SectionAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HatchStyleId
        //
        if (n.name () == L"HatchStyleId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HatchStyleId_type > r (
            HatchStyleId_traits::create (i, f, this));

          if (!this->HatchStyleId_)
          {
            this->HatchStyleId_.set (::std::move (r));
            continue;
          }
        }

        // Loops
        //
        if (n.name () == L"Loops" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Loops_type > r (
            Loops_traits::create (i, f, this));

          if (!Loops_.present ())
          {
            this->Loops_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Loops_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Loops",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SectionAreaType* SectionAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionAreaType (*this, f, c);
    }

    SectionAreaType& SectionAreaType::
    operator= (const SectionAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->HatchStyleId_ = x.HatchStyleId_;
        this->Loops_ = x.Loops_;
      }

      return *this;
    }

    SectionAreaType::
    ~SectionAreaType ()
    {
    }

    // SectionEdgesType
    //

    SectionEdgesType::
    SectionEdgesType ()
    : ::xml_schema::type (),
      Edge_ (this),
      n_ (this)
    {
    }

    SectionEdgesType::
    SectionEdgesType (const n_type& n)
    : ::xml_schema::type (),
      Edge_ (this),
      n_ (n, this)
    {
    }

    SectionEdgesType::
    SectionEdgesType (const SectionEdgesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edge_ (x.Edge_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SectionEdgesType::
    SectionEdgesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edge_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SectionEdgesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Edge
        //
        if (n.name () == L"Edge" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Edge_type > r (
            Edge_traits::create (i, f, this));

          this->Edge_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SectionEdgesType* SectionEdgesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionEdgesType (*this, f, c);
    }

    SectionEdgesType& SectionEdgesType::
    operator= (const SectionEdgesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Edge_ = x.Edge_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SectionEdgesType::
    ~SectionEdgesType ()
    {
    }

    // SectionPathType
    //

    SectionPathType::
    SectionPathType ()
    : ::xml_schema::type (),
      Edges_ (this)
    {
    }

    SectionPathType::
    SectionPathType (const Edges_type& Edges)
    : ::xml_schema::type (),
      Edges_ (Edges, this)
    {
    }

    SectionPathType::
    SectionPathType (::std::unique_ptr< Edges_type > Edges)
    : ::xml_schema::type (),
      Edges_ (std::move (Edges), this)
    {
    }

    SectionPathType::
    SectionPathType (const SectionPathType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edges_ (x.Edges_, f, this)
    {
    }

    SectionPathType::
    SectionPathType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edges_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SectionPathType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Edges
        //
        if (n.name () == L"Edges" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Edges_type > r (
            Edges_traits::create (i, f, this));

          if (!Edges_.present ())
          {
            this->Edges_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Edges_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Edges",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SectionPathType* SectionPathType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionPathType (*this, f, c);
    }

    SectionPathType& SectionPathType::
    operator= (const SectionPathType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Edges_ = x.Edges_;
      }

      return *this;
    }

    SectionPathType::
    ~SectionPathType ()
    {
    }

    // HatchPatternsType
    //

    HatchPatternsType::
    HatchPatternsType ()
    : ::xml_schema::type (),
      Pattern_ (this),
      n_ (this)
    {
    }

    HatchPatternsType::
    HatchPatternsType (const n_type& n)
    : ::xml_schema::type (),
      Pattern_ (this),
      n_ (n, this)
    {
    }

    HatchPatternsType::
    HatchPatternsType (const HatchPatternsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Pattern_ (x.Pattern_, f, this),
      n_ (x.n_, f, this)
    {
    }

    HatchPatternsType::
    HatchPatternsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Pattern_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void HatchPatternsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Pattern
        //
        if (n.name () == L"Pattern" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Pattern_type > r (
            Pattern_traits::create (i, f, this));

          this->Pattern_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    HatchPatternsType* HatchPatternsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HatchPatternsType (*this, f, c);
    }

    HatchPatternsType& HatchPatternsType::
    operator= (const HatchPatternsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Pattern_ = x.Pattern_;
        this->n_ = x.n_;
      }

      return *this;
    }

    HatchPatternsType::
    ~HatchPatternsType ()
    {
    }

    // HatchStyleType
    //

    HatchStyleType::
    HatchStyleType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      Form_ (this),
      Color_ (this),
      Patterns_ (this)
    {
    }

    HatchStyleType::
    HatchStyleType (const id_type& id,
                    const Form_type& Form)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Form_ (Form, this),
      Color_ (this),
      Patterns_ (this)
    {
    }

    HatchStyleType::
    HatchStyleType (const HatchStyleType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      Form_ (x.Form_, f, this),
      Color_ (x.Color_, f, this),
      Patterns_ (x.Patterns_, f, this)
    {
    }

    HatchStyleType::
    HatchStyleType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      Form_ (this),
      Color_ (this),
      Patterns_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void HatchStyleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!Form_.present ())
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // Color
        //
        if (n.name () == L"Color" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Color_type > r (
            Color_traits::create (i, f, this));

          if (!this->Color_)
          {
            this->Color_.set (::std::move (r));
            continue;
          }
        }

        // Patterns
        //
        if (n.name () == L"Patterns" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Patterns_type > r (
            Patterns_traits::create (i, f, this));

          if (!this->Patterns_)
          {
            this->Patterns_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Form_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Form",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    HatchStyleType* HatchStyleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HatchStyleType (*this, f, c);
    }

    HatchStyleType& HatchStyleType::
    operator= (const HatchStyleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->Form_ = x.Form_;
        this->Color_ = x.Color_;
        this->Patterns_ = x.Patterns_;
      }

      return *this;
    }

    HatchStyleType::
    ~HatchStyleType ()
    {
    }

    // HatchStyleFormEnumType
    //

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_HatchStyleFormEnumType_convert ();
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_HatchStyleFormEnumType_convert ();
    }

    HatchStyleFormEnumType::
    HatchStyleFormEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_HatchStyleFormEnumType_convert ();
    }

    HatchStyleFormEnumType* HatchStyleFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HatchStyleFormEnumType (*this, f, c);
    }

    HatchStyleFormEnumType::value HatchStyleFormEnumType::
    _xsd_HatchStyleFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_HatchStyleFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_HatchStyleFormEnumType_indexes_,
                        _xsd_HatchStyleFormEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_HatchStyleFormEnumType_indexes_ + 4 || _xsd_HatchStyleFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const HatchStyleFormEnumType::
    _xsd_HatchStyleFormEnumType_literals_[4] =
    {
      L"NONE",
      L"PATTERN",
      L"FILL",
      L"ERASED"
    };

    const HatchStyleFormEnumType::value HatchStyleFormEnumType::
    _xsd_HatchStyleFormEnumType_indexes_[4] =
    {
      ::xsd::qif30::HatchStyleFormEnumType::ERASED,
      ::xsd::qif30::HatchStyleFormEnumType::FILL,
      ::xsd::qif30::HatchStyleFormEnumType::NONE,
      ::xsd::qif30::HatchStyleFormEnumType::PATTERN
    };

    // HatchPatternType
    //

    HatchPatternType::
    HatchPatternType ()
    : ::xml_schema::type (),
      LineStyle_ (this),
      FirstLineOrigin_ (this),
      SecondLineOrigin_ (this),
      Angle_ (this),
      Color_ (this)
    {
    }

    HatchPatternType::
    HatchPatternType (const FirstLineOrigin_type& FirstLineOrigin,
                      const SecondLineOrigin_type& SecondLineOrigin,
                      const Angle_type& Angle)
    : ::xml_schema::type (),
      LineStyle_ (this),
      FirstLineOrigin_ (FirstLineOrigin, this),
      SecondLineOrigin_ (SecondLineOrigin, this),
      Angle_ (Angle, this),
      Color_ (this)
    {
    }

    HatchPatternType::
    HatchPatternType (const FirstLineOrigin_type& FirstLineOrigin,
                      const SecondLineOrigin_type& SecondLineOrigin,
                      ::std::unique_ptr< Angle_type > Angle)
    : ::xml_schema::type (),
      LineStyle_ (this),
      FirstLineOrigin_ (FirstLineOrigin, this),
      SecondLineOrigin_ (SecondLineOrigin, this),
      Angle_ (std::move (Angle), this),
      Color_ (this)
    {
    }

    HatchPatternType::
    HatchPatternType (const HatchPatternType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LineStyle_ (x.LineStyle_, f, this),
      FirstLineOrigin_ (x.FirstLineOrigin_, f, this),
      SecondLineOrigin_ (x.SecondLineOrigin_, f, this),
      Angle_ (x.Angle_, f, this),
      Color_ (x.Color_, f, this)
    {
    }

    HatchPatternType::
    HatchPatternType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LineStyle_ (this),
      FirstLineOrigin_ (this),
      SecondLineOrigin_ (this),
      Angle_ (this),
      Color_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HatchPatternType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LineStyle
        //
        if (n.name () == L"LineStyle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LineStyle_type > r (
            LineStyle_traits::create (i, f, this));

          if (!this->LineStyle_)
          {
            this->LineStyle_.set (::std::move (r));
            continue;
          }
        }

        // FirstLineOrigin
        //
        if (n.name () == L"FirstLineOrigin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstLineOrigin_type > r (
            FirstLineOrigin_traits::create (i, f, this));

          if (!FirstLineOrigin_.present ())
          {
            this->FirstLineOrigin_.set (::std::move (r));
            continue;
          }
        }

        // SecondLineOrigin
        //
        if (n.name () == L"SecondLineOrigin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondLineOrigin_type > r (
            SecondLineOrigin_traits::create (i, f, this));

          if (!SecondLineOrigin_.present ())
          {
            this->SecondLineOrigin_.set (::std::move (r));
            continue;
          }
        }

        // Angle
        //
        if (n.name () == L"Angle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Angle_type > r (
            Angle_traits::create (i, f, this));

          if (!Angle_.present ())
          {
            this->Angle_.set (::std::move (r));
            continue;
          }
        }

        // Color
        //
        if (n.name () == L"Color" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Color_type > r (
            Color_traits::create (i, f, this));

          if (!this->Color_)
          {
            this->Color_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FirstLineOrigin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstLineOrigin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SecondLineOrigin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondLineOrigin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Angle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Angle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    HatchPatternType* HatchPatternType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HatchPatternType (*this, f, c);
    }

    HatchPatternType& HatchPatternType::
    operator= (const HatchPatternType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LineStyle_ = x.LineStyle_;
        this->FirstLineOrigin_ = x.FirstLineOrigin_;
        this->SecondLineOrigin_ = x.SecondLineOrigin_;
        this->Angle_ = x.Angle_;
        this->Color_ = x.Color_;
      }

      return *this;
    }

    HatchPatternType::
    ~HatchPatternType ()
    {
    }

    // DisplayStyleType
    //

    DisplayStyleType::
    DisplayStyleType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      Mode_ (this),
      DisplayStyleGroups_ (this)
    {
    }

    DisplayStyleType::
    DisplayStyleType (const id_type& id,
                      const Mode_type& Mode)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Mode_ (Mode, this),
      DisplayStyleGroups_ (this)
    {
    }

    DisplayStyleType::
    DisplayStyleType (const id_type& id,
                      ::std::unique_ptr< Mode_type > Mode)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Mode_ (std::move (Mode), this),
      DisplayStyleGroups_ (this)
    {
    }

    DisplayStyleType::
    DisplayStyleType (const DisplayStyleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      Mode_ (x.Mode_, f, this),
      DisplayStyleGroups_ (x.DisplayStyleGroups_, f, this)
    {
    }

    DisplayStyleType::
    DisplayStyleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      Mode_ (this),
      DisplayStyleGroups_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DisplayStyleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Mode
        //
        if (n.name () == L"Mode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Mode_type > r (
            Mode_traits::create (i, f, this));

          if (!Mode_.present ())
          {
            this->Mode_.set (::std::move (r));
            continue;
          }
        }

        // DisplayStyleGroups
        //
        if (n.name () == L"DisplayStyleGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DisplayStyleGroups_type > r (
            DisplayStyleGroups_traits::create (i, f, this));

          if (!this->DisplayStyleGroups_)
          {
            this->DisplayStyleGroups_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Mode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Mode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DisplayStyleType* DisplayStyleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleType (*this, f, c);
    }

    DisplayStyleType& DisplayStyleType::
    operator= (const DisplayStyleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->Mode_ = x.Mode_;
        this->DisplayStyleGroups_ = x.DisplayStyleGroups_;
      }

      return *this;
    }

    DisplayStyleType::
    ~DisplayStyleType ()
    {
    }

    // DisplayStyleGroupsType
    //

    DisplayStyleGroupsType::
    DisplayStyleGroupsType ()
    : ::xml_schema::type (),
      DisplayStyleGroup_ (this),
      n_ (this)
    {
    }

    DisplayStyleGroupsType::
    DisplayStyleGroupsType (const n_type& n)
    : ::xml_schema::type (),
      DisplayStyleGroup_ (this),
      n_ (n, this)
    {
    }

    DisplayStyleGroupsType::
    DisplayStyleGroupsType (const DisplayStyleGroupsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DisplayStyleGroup_ (x.DisplayStyleGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DisplayStyleGroupsType::
    DisplayStyleGroupsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DisplayStyleGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DisplayStyleGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DisplayStyleGroup
        //
        if (n.name () == L"DisplayStyleGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DisplayStyleGroup_type > r (
            DisplayStyleGroup_traits::create (i, f, this));

          this->DisplayStyleGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DisplayStyleGroupsType* DisplayStyleGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleGroupsType (*this, f, c);
    }

    DisplayStyleGroupsType& DisplayStyleGroupsType::
    operator= (const DisplayStyleGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DisplayStyleGroup_ = x.DisplayStyleGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DisplayStyleGroupsType::
    ~DisplayStyleGroupsType ()
    {
    }

    // DisplayStyleModeType
    //

    DisplayStyleModeType::
    DisplayStyleModeType ()
    : ::xml_schema::type (),
      Form_ (this),
      Color_ (this),
      Transparency_ (this)
    {
    }

    DisplayStyleModeType::
    DisplayStyleModeType (const Form_type& Form)
    : ::xml_schema::type (),
      Form_ (Form, this),
      Color_ (this),
      Transparency_ (this)
    {
    }

    DisplayStyleModeType::
    DisplayStyleModeType (const DisplayStyleModeType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Form_ (x.Form_, f, this),
      Color_ (x.Color_, f, this),
      Transparency_ (x.Transparency_, f, this)
    {
    }

    DisplayStyleModeType::
    DisplayStyleModeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Form_ (this),
      Color_ (this),
      Transparency_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DisplayStyleModeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!Form_.present ())
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // Color
        //
        if (n.name () == L"Color" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Color_type > r (
            Color_traits::create (i, f, this));

          if (!this->Color_)
          {
            this->Color_.set (::std::move (r));
            continue;
          }
        }

        // Transparency
        //
        if (n.name () == L"Transparency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transparency_type > r (
            Transparency_traits::create (i, f, this));

          if (!this->Transparency_)
          {
            this->Transparency_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Form_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Form",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DisplayStyleModeType* DisplayStyleModeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleModeType (*this, f, c);
    }

    DisplayStyleModeType& DisplayStyleModeType::
    operator= (const DisplayStyleModeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Form_ = x.Form_;
        this->Color_ = x.Color_;
        this->Transparency_ = x.Transparency_;
      }

      return *this;
    }

    DisplayStyleModeType::
    ~DisplayStyleModeType ()
    {
    }

    // DisplayStyleGroupType
    //

    DisplayStyleGroupType::
    DisplayStyleGroupType ()
    : ::xml_schema::type (),
      Mode_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    DisplayStyleGroupType::
    DisplayStyleGroupType (const Mode_type& Mode)
    : ::xml_schema::type (),
      Mode_ (Mode, this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    DisplayStyleGroupType::
    DisplayStyleGroupType (::std::unique_ptr< Mode_type > Mode)
    : ::xml_schema::type (),
      Mode_ (std::move (Mode), this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    DisplayStyleGroupType::
    DisplayStyleGroupType (const DisplayStyleGroupType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Mode_ (x.Mode_, f, this),
      ComponentIds_ (x.ComponentIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this)
    {
    }

    DisplayStyleGroupType::
    DisplayStyleGroupType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Mode_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DisplayStyleGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Mode
        //
        if (n.name () == L"Mode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Mode_type > r (
            Mode_traits::create (i, f, this));

          if (!Mode_.present ())
          {
            this->Mode_.set (::std::move (r));
            continue;
          }
        }

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Mode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Mode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DisplayStyleGroupType* DisplayStyleGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleGroupType (*this, f, c);
    }

    DisplayStyleGroupType& DisplayStyleGroupType::
    operator= (const DisplayStyleGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Mode_ = x.Mode_;
        this->ComponentIds_ = x.ComponentIds_;
        this->BodyIds_ = x.BodyIds_;
      }

      return *this;
    }

    DisplayStyleGroupType::
    ~DisplayStyleGroupType ()
    {
    }

    // DisplayStyleFormEnumType
    //

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_DisplayStyleFormEnumType_convert ();
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_DisplayStyleFormEnumType_convert ();
    }

    DisplayStyleFormEnumType::
    DisplayStyleFormEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_DisplayStyleFormEnumType_convert ();
    }

    DisplayStyleFormEnumType* DisplayStyleFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleFormEnumType (*this, f, c);
    }

    DisplayStyleFormEnumType::value DisplayStyleFormEnumType::
    _xsd_DisplayStyleFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DisplayStyleFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DisplayStyleFormEnumType_indexes_,
                        _xsd_DisplayStyleFormEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_DisplayStyleFormEnumType_indexes_ + 5 || _xsd_DisplayStyleFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DisplayStyleFormEnumType::
    _xsd_DisplayStyleFormEnumType_literals_[5] =
    {
      L"WIREFRAME",
      L"ISOLINES",
      L"ISOLINES_WITH_EDGES",
      L"SHADING",
      L"SHADING_WITH_EDGES"
    };

    const DisplayStyleFormEnumType::value DisplayStyleFormEnumType::
    _xsd_DisplayStyleFormEnumType_indexes_[5] =
    {
      ::xsd::qif30::DisplayStyleFormEnumType::ISOLINES,
      ::xsd::qif30::DisplayStyleFormEnumType::ISOLINES_WITH_EDGES,
      ::xsd::qif30::DisplayStyleFormEnumType::SHADING,
      ::xsd::qif30::DisplayStyleFormEnumType::SHADING_WITH_EDGES,
      ::xsd::qif30::DisplayStyleFormEnumType::WIREFRAME
    };

    // ExplodedViewType
    //

    ExplodedViewType::
    ExplodedViewType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      MoveGroups_ (this)
    {
    }

    ExplodedViewType::
    ExplodedViewType (const id_type& id,
                      const MoveGroups_type& MoveGroups)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      MoveGroups_ (MoveGroups, this)
    {
    }

    ExplodedViewType::
    ExplodedViewType (const id_type& id,
                      ::std::unique_ptr< MoveGroups_type > MoveGroups)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      MoveGroups_ (std::move (MoveGroups), this)
    {
    }

    ExplodedViewType::
    ExplodedViewType (const ExplodedViewType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      MoveGroups_ (x.MoveGroups_, f, this)
    {
    }

    ExplodedViewType::
    ExplodedViewType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      MoveGroups_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExplodedViewType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MoveGroups
        //
        if (n.name () == L"MoveGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MoveGroups_type > r (
            MoveGroups_traits::create (i, f, this));

          if (!MoveGroups_.present ())
          {
            this->MoveGroups_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MoveGroups_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MoveGroups",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExplodedViewType* ExplodedViewType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewType (*this, f, c);
    }

    ExplodedViewType& ExplodedViewType::
    operator= (const ExplodedViewType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->MoveGroups_ = x.MoveGroups_;
      }

      return *this;
    }

    ExplodedViewType::
    ~ExplodedViewType ()
    {
    }

    // ExplodedViewMoveGroupsType
    //

    ExplodedViewMoveGroupsType::
    ExplodedViewMoveGroupsType ()
    : ::xml_schema::type (),
      MoveGroup_ (this),
      n_ (this)
    {
    }

    ExplodedViewMoveGroupsType::
    ExplodedViewMoveGroupsType (const n_type& n)
    : ::xml_schema::type (),
      MoveGroup_ (this),
      n_ (n, this)
    {
    }

    ExplodedViewMoveGroupsType::
    ExplodedViewMoveGroupsType (const ExplodedViewMoveGroupsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MoveGroup_ (x.MoveGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExplodedViewMoveGroupsType::
    ExplodedViewMoveGroupsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MoveGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExplodedViewMoveGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MoveGroup
        //
        if (n.name () == L"MoveGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MoveGroup_type > r (
            MoveGroup_traits::create (i, f, this));

          this->MoveGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExplodedViewMoveGroupsType* ExplodedViewMoveGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewMoveGroupsType (*this, f, c);
    }

    ExplodedViewMoveGroupsType& ExplodedViewMoveGroupsType::
    operator= (const ExplodedViewMoveGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MoveGroup_ = x.MoveGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExplodedViewMoveGroupsType::
    ~ExplodedViewMoveGroupsType ()
    {
    }

    // ExplodedViewMoveGroupType
    //

    ExplodedViewMoveGroupType::
    ExplodedViewMoveGroupType ()
    : ::xml_schema::type (),
      Translate_ (this),
      Rotate_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    ExplodedViewMoveGroupType::
    ExplodedViewMoveGroupType (const ExplodedViewMoveGroupType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Translate_ (x.Translate_, f, this),
      Rotate_ (x.Rotate_, f, this),
      ComponentIds_ (x.ComponentIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this)
    {
    }

    ExplodedViewMoveGroupType::
    ExplodedViewMoveGroupType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Translate_ (this),
      Rotate_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExplodedViewMoveGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Translate
        //
        if (n.name () == L"Translate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Translate_type > r (
            Translate_traits::create (i, f, this));

          if (!this->Translate_)
          {
            this->Translate_.set (::std::move (r));
            continue;
          }
        }

        // Rotate
        //
        if (n.name () == L"Rotate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Rotate_type > r (
            Rotate_traits::create (i, f, this));

          if (!this->Rotate_)
          {
            this->Rotate_.set (::std::move (r));
            continue;
          }
        }

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExplodedViewMoveGroupType* ExplodedViewMoveGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewMoveGroupType (*this, f, c);
    }

    ExplodedViewMoveGroupType& ExplodedViewMoveGroupType::
    operator= (const ExplodedViewMoveGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Translate_ = x.Translate_;
        this->Rotate_ = x.Rotate_;
        this->ComponentIds_ = x.ComponentIds_;
        this->BodyIds_ = x.BodyIds_;
      }

      return *this;
    }

    ExplodedViewMoveGroupType::
    ~ExplodedViewMoveGroupType ()
    {
    }

    // ExplodedViewTranslateType
    //

    ExplodedViewTranslateType::
    ExplodedViewTranslateType ()
    : ::xml_schema::type (),
      Direction_ (this),
      Value_ (this)
    {
    }

    ExplodedViewTranslateType::
    ExplodedViewTranslateType (const Direction_type& Direction,
                               const Value_type& Value)
    : ::xml_schema::type (),
      Direction_ (Direction, this),
      Value_ (Value, this)
    {
    }

    ExplodedViewTranslateType::
    ExplodedViewTranslateType (::std::unique_ptr< Direction_type > Direction,
                               ::std::unique_ptr< Value_type > Value)
    : ::xml_schema::type (),
      Direction_ (std::move (Direction), this),
      Value_ (std::move (Value), this)
    {
    }

    ExplodedViewTranslateType::
    ExplodedViewTranslateType (const ExplodedViewTranslateType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Direction_ (x.Direction_, f, this),
      Value_ (x.Value_, f, this)
    {
    }

    ExplodedViewTranslateType::
    ExplodedViewTranslateType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Direction_ (this),
      Value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExplodedViewTranslateType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        // Value
        //
        if (n.name () == L"Value" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExplodedViewTranslateType* ExplodedViewTranslateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewTranslateType (*this, f, c);
    }

    ExplodedViewTranslateType& ExplodedViewTranslateType::
    operator= (const ExplodedViewTranslateType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Direction_ = x.Direction_;
        this->Value_ = x.Value_;
      }

      return *this;
    }

    ExplodedViewTranslateType::
    ~ExplodedViewTranslateType ()
    {
    }

    // ExplodedViewRotateType
    //

    ExplodedViewRotateType::
    ExplodedViewRotateType ()
    : ::xml_schema::type (),
      Axis_ (this),
      Angle_ (this)
    {
    }

    ExplodedViewRotateType::
    ExplodedViewRotateType (const Axis_type& Axis,
                            const Angle_type& Angle)
    : ::xml_schema::type (),
      Axis_ (Axis, this),
      Angle_ (Angle, this)
    {
    }

    ExplodedViewRotateType::
    ExplodedViewRotateType (::std::unique_ptr< Axis_type > Axis,
                            ::std::unique_ptr< Angle_type > Angle)
    : ::xml_schema::type (),
      Axis_ (std::move (Axis), this),
      Angle_ (std::move (Angle), this)
    {
    }

    ExplodedViewRotateType::
    ExplodedViewRotateType (const ExplodedViewRotateType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Axis_ (x.Axis_, f, this),
      Angle_ (x.Angle_, f, this)
    {
    }

    ExplodedViewRotateType::
    ExplodedViewRotateType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Angle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExplodedViewRotateType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Angle
        //
        if (n.name () == L"Angle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Angle_type > r (
            Angle_traits::create (i, f, this));

          if (!Angle_.present ())
          {
            this->Angle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Angle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Angle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExplodedViewRotateType* ExplodedViewRotateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewRotateType (*this, f, c);
    }

    ExplodedViewRotateType& ExplodedViewRotateType::
    operator= (const ExplodedViewRotateType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Angle_ = x.Angle_;
      }

      return *this;
    }

    ExplodedViewRotateType::
    ~ExplodedViewRotateType ()
    {
    }

    // SimplifiedRepresentationFormEnumType
    //

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_SimplifiedRepresentationFormEnumType_convert ();
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_SimplifiedRepresentationFormEnumType_convert ();
    }

    SimplifiedRepresentationFormEnumType::
    SimplifiedRepresentationFormEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_SimplifiedRepresentationFormEnumType_convert ();
    }

    SimplifiedRepresentationFormEnumType* SimplifiedRepresentationFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimplifiedRepresentationFormEnumType (*this, f, c);
    }

    SimplifiedRepresentationFormEnumType::value SimplifiedRepresentationFormEnumType::
    _xsd_SimplifiedRepresentationFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SimplifiedRepresentationFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SimplifiedRepresentationFormEnumType_indexes_,
                        _xsd_SimplifiedRepresentationFormEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_SimplifiedRepresentationFormEnumType_indexes_ + 3 || _xsd_SimplifiedRepresentationFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SimplifiedRepresentationFormEnumType::
    _xsd_SimplifiedRepresentationFormEnumType_literals_[3] =
    {
      L"MASTER",
      L"HIDE",
      L"BOUNDING_BOX"
    };

    const SimplifiedRepresentationFormEnumType::value SimplifiedRepresentationFormEnumType::
    _xsd_SimplifiedRepresentationFormEnumType_indexes_[3] =
    {
      ::xsd::qif30::SimplifiedRepresentationFormEnumType::BOUNDING_BOX,
      ::xsd::qif30::SimplifiedRepresentationFormEnumType::HIDE,
      ::xsd::qif30::SimplifiedRepresentationFormEnumType::MASTER
    };

    // SimplifiedRepresentationType
    //

    SimplifiedRepresentationType::
    SimplifiedRepresentationType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      Form_ (this),
      SimplifiedRepresentationGroups_ (this)
    {
    }

    SimplifiedRepresentationType::
    SimplifiedRepresentationType (const id_type& id,
                                  const Form_type& Form)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Form_ (Form, this),
      SimplifiedRepresentationGroups_ (this)
    {
    }

    SimplifiedRepresentationType::
    SimplifiedRepresentationType (const SimplifiedRepresentationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      Form_ (x.Form_, f, this),
      SimplifiedRepresentationGroups_ (x.SimplifiedRepresentationGroups_, f, this)
    {
    }

    SimplifiedRepresentationType::
    SimplifiedRepresentationType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      Form_ (this),
      SimplifiedRepresentationGroups_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SimplifiedRepresentationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!Form_.present ())
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // SimplifiedRepresentationGroups
        //
        if (n.name () == L"SimplifiedRepresentationGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimplifiedRepresentationGroups_type > r (
            SimplifiedRepresentationGroups_traits::create (i, f, this));

          if (!this->SimplifiedRepresentationGroups_)
          {
            this->SimplifiedRepresentationGroups_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Form_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Form",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SimplifiedRepresentationType* SimplifiedRepresentationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimplifiedRepresentationType (*this, f, c);
    }

    SimplifiedRepresentationType& SimplifiedRepresentationType::
    operator= (const SimplifiedRepresentationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->Form_ = x.Form_;
        this->SimplifiedRepresentationGroups_ = x.SimplifiedRepresentationGroups_;
      }

      return *this;
    }

    SimplifiedRepresentationType::
    ~SimplifiedRepresentationType ()
    {
    }

    // SimplifiedRepresentationGroupsType
    //

    SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroupsType ()
    : ::xml_schema::type (),
      SimplifiedRepresentationGroup_ (this),
      n_ (this)
    {
    }

    SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroupsType (const n_type& n)
    : ::xml_schema::type (),
      SimplifiedRepresentationGroup_ (this),
      n_ (n, this)
    {
    }

    SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroupsType (const SimplifiedRepresentationGroupsType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimplifiedRepresentationGroup_ (x.SimplifiedRepresentationGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SimplifiedRepresentationGroupsType::
    SimplifiedRepresentationGroupsType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimplifiedRepresentationGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SimplifiedRepresentationGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SimplifiedRepresentationGroup
        //
        if (n.name () == L"SimplifiedRepresentationGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimplifiedRepresentationGroup_type > r (
            SimplifiedRepresentationGroup_traits::create (i, f, this));

          this->SimplifiedRepresentationGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SimplifiedRepresentationGroupsType* SimplifiedRepresentationGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimplifiedRepresentationGroupsType (*this, f, c);
    }

    SimplifiedRepresentationGroupsType& SimplifiedRepresentationGroupsType::
    operator= (const SimplifiedRepresentationGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimplifiedRepresentationGroup_ = x.SimplifiedRepresentationGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SimplifiedRepresentationGroupsType::
    ~SimplifiedRepresentationGroupsType ()
    {
    }

    // SimplifiedRepresentationGroupType
    //

    SimplifiedRepresentationGroupType::
    SimplifiedRepresentationGroupType ()
    : ::xml_schema::type (),
      Form_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    SimplifiedRepresentationGroupType::
    SimplifiedRepresentationGroupType (const Form_type& Form)
    : ::xml_schema::type (),
      Form_ (Form, this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
    }

    SimplifiedRepresentationGroupType::
    SimplifiedRepresentationGroupType (const SimplifiedRepresentationGroupType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Form_ (x.Form_, f, this),
      ComponentIds_ (x.ComponentIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this)
    {
    }

    SimplifiedRepresentationGroupType::
    SimplifiedRepresentationGroupType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Form_ (this),
      ComponentIds_ (this),
      BodyIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SimplifiedRepresentationGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!Form_.present ())
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Form_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Form",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SimplifiedRepresentationGroupType* SimplifiedRepresentationGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimplifiedRepresentationGroupType (*this, f, c);
    }

    SimplifiedRepresentationGroupType& SimplifiedRepresentationGroupType::
    operator= (const SimplifiedRepresentationGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Form_ = x.Form_;
        this->ComponentIds_ = x.ComponentIds_;
        this->BodyIds_ = x.BodyIds_;
      }

      return *this;
    }

    SimplifiedRepresentationGroupType::
    ~SimplifiedRepresentationGroupType ()
    {
    }

    // AnnotationViewType
    //

    AnnotationViewType::
    AnnotationViewType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      Normal_ (this),
      Direction_ (this)
    {
    }

    AnnotationViewType::
    AnnotationViewType (const id_type& id,
                        const Normal_type& Normal,
                        const Direction_type& Direction)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Normal_ (Normal, this),
      Direction_ (Direction, this)
    {
    }

    AnnotationViewType::
    AnnotationViewType (const id_type& id,
                        ::std::unique_ptr< Normal_type > Normal,
                        ::std::unique_ptr< Direction_type > Direction)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      Normal_ (std::move (Normal), this),
      Direction_ (std::move (Direction), this)
    {
    }

    AnnotationViewType::
    AnnotationViewType (const AnnotationViewType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      Normal_ (x.Normal_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    AnnotationViewType::
    AnnotationViewType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      Normal_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AnnotationViewType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AnnotationViewType* AnnotationViewType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AnnotationViewType (*this, f, c);
    }

    AnnotationViewType& AnnotationViewType::
    operator= (const AnnotationViewType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->Normal_ = x.Normal_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    AnnotationViewType::
    ~AnnotationViewType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameRectangular_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameRectangular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameRectangularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameCircular_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameCircularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameFlag_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameFlag",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameFlagType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameIrregularForm_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameIrregularForm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameIrregularFormType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameTriangle_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameTriangle",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameTriangleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameHexagonal_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameHexagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameHexagonalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FramePentagonal_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FramePentagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FramePentagonalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameOctagonal_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameOctagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameOctagonalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FrameWeldSymbol_element_factory_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameWeldSymbol",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FrameWeldSymbolType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LeaderExtend_element_factory_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderExtend",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LeaderExtendType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LeaderCircular_element_factory_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LeaderCircularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LeaderDoubleHead_element_factory_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHead",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LeaderDoubleHeadType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LeaderDoubleHeadCircular_element_factory_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHeadCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LeaderDoubleHeadCircularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LeaderDoubleHeadExtend_element_factory_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHeadExtend",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LeaderDoubleHeadExtendType >);


    // CameraSetType
    //

    CameraSetType::
    CameraSetType ()
    : ::xml_schema::type (),
      Camera_ (this),
      n_ (this)
    {
    }

    CameraSetType::
    CameraSetType (const n_type& n)
    : ::xml_schema::type (),
      Camera_ (this),
      n_ (n, this)
    {
    }

    CameraSetType::
    CameraSetType (const CameraSetType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Camera_ (x.Camera_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CameraSetType::
    CameraSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Camera_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CameraSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Camera
        //
        if (n.name () == L"Camera" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Camera_type > r (
            Camera_traits::create (i, f, this));

          this->Camera_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CameraSetType* CameraSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CameraSetType (*this, f, c);
    }

    CameraSetType& CameraSetType::
    operator= (const CameraSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Camera_ = x.Camera_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CameraSetType::
    ~CameraSetType ()
    {
    }

    // SavedViewSetType
    //

    SavedViewSetType::
    SavedViewSetType ()
    : ::xml_schema::type (),
      SavedView_ (this),
      n_ (this)
    {
    }

    SavedViewSetType::
    SavedViewSetType (const n_type& n)
    : ::xml_schema::type (),
      SavedView_ (this),
      n_ (n, this)
    {
    }

    SavedViewSetType::
    SavedViewSetType (const SavedViewSetType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SavedView_ (x.SavedView_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SavedViewSetType::
    SavedViewSetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SavedView_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SavedViewSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SavedView
        //
        if (n.name () == L"SavedView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SavedView_type > r (
            SavedView_traits::create (i, f, this));

          this->SavedView_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SavedViewSetType* SavedViewSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SavedViewSetType (*this, f, c);
    }

    SavedViewSetType& SavedViewSetType::
    operator= (const SavedViewSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SavedView_ = x.SavedView_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SavedViewSetType::
    ~SavedViewSetType ()
    {
    }

    // AnnotationViewSetType
    //

    AnnotationViewSetType::
    AnnotationViewSetType ()
    : ::xml_schema::type (),
      AnnotationView_ (this),
      n_ (this)
    {
    }

    AnnotationViewSetType::
    AnnotationViewSetType (const n_type& n)
    : ::xml_schema::type (),
      AnnotationView_ (this),
      n_ (n, this)
    {
    }

    AnnotationViewSetType::
    AnnotationViewSetType (const AnnotationViewSetType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AnnotationView_ (x.AnnotationView_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AnnotationViewSetType::
    AnnotationViewSetType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AnnotationView_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AnnotationViewSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AnnotationView
        //
        if (n.name () == L"AnnotationView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AnnotationView_type > r (
            AnnotationView_traits::create (i, f, this));

          this->AnnotationView_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AnnotationViewSetType* AnnotationViewSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AnnotationViewSetType (*this, f, c);
    }

    AnnotationViewSetType& AnnotationViewSetType::
    operator= (const AnnotationViewSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AnnotationView_ = x.AnnotationView_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AnnotationViewSetType::
    ~AnnotationViewSetType ()
    {
    }

    // DisplayStyleSetType
    //

    DisplayStyleSetType::
    DisplayStyleSetType ()
    : ::xml_schema::type (),
      DisplayStyle_ (this),
      n_ (this)
    {
    }

    DisplayStyleSetType::
    DisplayStyleSetType (const n_type& n)
    : ::xml_schema::type (),
      DisplayStyle_ (this),
      n_ (n, this)
    {
    }

    DisplayStyleSetType::
    DisplayStyleSetType (const DisplayStyleSetType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DisplayStyle_ (x.DisplayStyle_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DisplayStyleSetType::
    DisplayStyleSetType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DisplayStyle_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DisplayStyleSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DisplayStyle
        //
        if (n.name () == L"DisplayStyle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DisplayStyle_type > r (
            DisplayStyle_traits::create (i, f, this));

          this->DisplayStyle_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DisplayStyleSetType* DisplayStyleSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DisplayStyleSetType (*this, f, c);
    }

    DisplayStyleSetType& DisplayStyleSetType::
    operator= (const DisplayStyleSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DisplayStyle_ = x.DisplayStyle_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DisplayStyleSetType::
    ~DisplayStyleSetType ()
    {
    }

    // ExplodedViewSetType
    //

    ExplodedViewSetType::
    ExplodedViewSetType ()
    : ::xml_schema::type (),
      ExplodedView_ (this),
      n_ (this)
    {
    }

    ExplodedViewSetType::
    ExplodedViewSetType (const n_type& n)
    : ::xml_schema::type (),
      ExplodedView_ (this),
      n_ (n, this)
    {
    }

    ExplodedViewSetType::
    ExplodedViewSetType (const ExplodedViewSetType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ExplodedView_ (x.ExplodedView_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExplodedViewSetType::
    ExplodedViewSetType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ExplodedView_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExplodedViewSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExplodedView
        //
        if (n.name () == L"ExplodedView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExplodedView_type > r (
            ExplodedView_traits::create (i, f, this));

          this->ExplodedView_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExplodedViewSetType* ExplodedViewSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExplodedViewSetType (*this, f, c);
    }

    ExplodedViewSetType& ExplodedViewSetType::
    operator= (const ExplodedViewSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ExplodedView_ = x.ExplodedView_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExplodedViewSetType::
    ~ExplodedViewSetType ()
    {
    }

    // SimplifiedRepresentationSetType
    //

    SimplifiedRepresentationSetType::
    SimplifiedRepresentationSetType ()
    : ::xml_schema::type (),
      SimplifiedRepresentation_ (this),
      n_ (this)
    {
    }

    SimplifiedRepresentationSetType::
    SimplifiedRepresentationSetType (const n_type& n)
    : ::xml_schema::type (),
      SimplifiedRepresentation_ (this),
      n_ (n, this)
    {
    }

    SimplifiedRepresentationSetType::
    SimplifiedRepresentationSetType (const SimplifiedRepresentationSetType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimplifiedRepresentation_ (x.SimplifiedRepresentation_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SimplifiedRepresentationSetType::
    SimplifiedRepresentationSetType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimplifiedRepresentation_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SimplifiedRepresentationSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SimplifiedRepresentation
        //
        if (n.name () == L"SimplifiedRepresentation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SimplifiedRepresentation_type > r (
            SimplifiedRepresentation_traits::create (i, f, this));

          this->SimplifiedRepresentation_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SimplifiedRepresentationSetType* SimplifiedRepresentationSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimplifiedRepresentationSetType (*this, f, c);
    }

    SimplifiedRepresentationSetType& SimplifiedRepresentationSetType::
    operator= (const SimplifiedRepresentationSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimplifiedRepresentation_ = x.SimplifiedRepresentation_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SimplifiedRepresentationSetType::
    ~SimplifiedRepresentationSetType ()
    {
    }

    // ZoneSectionSetType
    //

    ZoneSectionSetType::
    ZoneSectionSetType ()
    : ::xml_schema::type (),
      ZoneSection_ (this),
      n_ (this)
    {
    }

    ZoneSectionSetType::
    ZoneSectionSetType (const n_type& n)
    : ::xml_schema::type (),
      ZoneSection_ (this),
      n_ (n, this)
    {
    }

    ZoneSectionSetType::
    ZoneSectionSetType (const ZoneSectionSetType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ZoneSection_ (x.ZoneSection_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ZoneSectionSetType::
    ZoneSectionSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ZoneSection_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ZoneSectionSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ZoneSection
        //
        if (n.name () == L"ZoneSection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZoneSection_type > r (
            ZoneSection_traits::create (i, f, this));

          this->ZoneSection_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ZoneSectionSetType* ZoneSectionSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneSectionSetType (*this, f, c);
    }

    ZoneSectionSetType& ZoneSectionSetType::
    operator= (const ZoneSectionSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ZoneSection_ = x.ZoneSection_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ZoneSectionSetType::
    ~ZoneSectionSetType ()
    {
    }

    // HatchStyleSetType
    //

    HatchStyleSetType::
    HatchStyleSetType ()
    : ::xml_schema::type (),
      HatchStyle_ (this),
      n_ (this)
    {
    }

    HatchStyleSetType::
    HatchStyleSetType (const n_type& n)
    : ::xml_schema::type (),
      HatchStyle_ (this),
      n_ (n, this)
    {
    }

    HatchStyleSetType::
    HatchStyleSetType (const HatchStyleSetType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      HatchStyle_ (x.HatchStyle_, f, this),
      n_ (x.n_, f, this)
    {
    }

    HatchStyleSetType::
    HatchStyleSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      HatchStyle_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void HatchStyleSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HatchStyle
        //
        if (n.name () == L"HatchStyle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HatchStyle_type > r (
            HatchStyle_traits::create (i, f, this));

          this->HatchStyle_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    HatchStyleSetType* HatchStyleSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HatchStyleSetType (*this, f, c);
    }

    HatchStyleSetType& HatchStyleSetType::
    operator= (const HatchStyleSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->HatchStyle_ = x.HatchStyle_;
        this->n_ = x.n_;
      }

      return *this;
    }

    HatchStyleSetType::
    ~HatchStyleSetType ()
    {
    }

    // TrailingZeroDisplayType
    //

    TrailingZeroDisplayType::
    TrailingZeroDisplayType ()
    : ::xml_schema::type (),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      GeometricCharacteristicValue_ (this),
      TrailingZeroDimensionalCharacteristicDisplayGroups_ (this),
      TrailingZeroGeometricCharacteristicDisplayGroups_ (this)
    {
    }

    TrailingZeroDisplayType::
    TrailingZeroDisplayType (const TrailingZeroDisplayType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DimensionalCharacteristicValueTarget_ (x.DimensionalCharacteristicValueTarget_, f, this),
      DimensionalCharacteristicValueLimits_ (x.DimensionalCharacteristicValueLimits_, f, this),
      GeometricCharacteristicValue_ (x.GeometricCharacteristicValue_, f, this),
      TrailingZeroDimensionalCharacteristicDisplayGroups_ (x.TrailingZeroDimensionalCharacteristicDisplayGroups_, f, this),
      TrailingZeroGeometricCharacteristicDisplayGroups_ (x.TrailingZeroGeometricCharacteristicDisplayGroups_, f, this)
    {
    }

    TrailingZeroDisplayType::
    TrailingZeroDisplayType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      GeometricCharacteristicValue_ (this),
      TrailingZeroDimensionalCharacteristicDisplayGroups_ (this),
      TrailingZeroGeometricCharacteristicDisplayGroups_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TrailingZeroDisplayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DimensionalCharacteristicValueTarget
        //
        if (n.name () == L"DimensionalCharacteristicValueTarget" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DimensionalCharacteristicValueTarget_)
          {
            this->DimensionalCharacteristicValueTarget_.set (DimensionalCharacteristicValueTarget_traits::create (i, f, this));
            continue;
          }
        }

        // DimensionalCharacteristicValueLimits
        //
        if (n.name () == L"DimensionalCharacteristicValueLimits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DimensionalCharacteristicValueLimits_)
          {
            this->DimensionalCharacteristicValueLimits_.set (DimensionalCharacteristicValueLimits_traits::create (i, f, this));
            continue;
          }
        }

        // GeometricCharacteristicValue
        //
        if (n.name () == L"GeometricCharacteristicValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->GeometricCharacteristicValue_)
          {
            this->GeometricCharacteristicValue_.set (GeometricCharacteristicValue_traits::create (i, f, this));
            continue;
          }
        }

        // TrailingZeroDimensionalCharacteristicDisplayGroups
        //
        if (n.name () == L"TrailingZeroDimensionalCharacteristicDisplayGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrailingZeroDimensionalCharacteristicDisplayGroups_type > r (
            TrailingZeroDimensionalCharacteristicDisplayGroups_traits::create (i, f, this));

          if (!this->TrailingZeroDimensionalCharacteristicDisplayGroups_)
          {
            this->TrailingZeroDimensionalCharacteristicDisplayGroups_.set (::std::move (r));
            continue;
          }
        }

        // TrailingZeroGeometricCharacteristicDisplayGroups
        //
        if (n.name () == L"TrailingZeroGeometricCharacteristicDisplayGroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrailingZeroGeometricCharacteristicDisplayGroups_type > r (
            TrailingZeroGeometricCharacteristicDisplayGroups_traits::create (i, f, this));

          if (!this->TrailingZeroGeometricCharacteristicDisplayGroups_)
          {
            this->TrailingZeroGeometricCharacteristicDisplayGroups_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TrailingZeroDisplayType* TrailingZeroDisplayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TrailingZeroDisplayType (*this, f, c);
    }

    TrailingZeroDisplayType& TrailingZeroDisplayType::
    operator= (const TrailingZeroDisplayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DimensionalCharacteristicValueTarget_ = x.DimensionalCharacteristicValueTarget_;
        this->DimensionalCharacteristicValueLimits_ = x.DimensionalCharacteristicValueLimits_;
        this->GeometricCharacteristicValue_ = x.GeometricCharacteristicValue_;
        this->TrailingZeroDimensionalCharacteristicDisplayGroups_ = x.TrailingZeroDimensionalCharacteristicDisplayGroups_;
        this->TrailingZeroGeometricCharacteristicDisplayGroups_ = x.TrailingZeroGeometricCharacteristicDisplayGroups_;
      }

      return *this;
    }

    TrailingZeroDisplayType::
    ~TrailingZeroDisplayType ()
    {
    }

    // TrailingZeroDimensionalCharacteristicDisplayGroupsType
    //

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroupsType ()
    : ::xml_schema::type (),
      TrailingZeroDimensionalCharacteristicDisplayGroup_ (this),
      n_ (this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroupsType (const n_type& n)
    : ::xml_schema::type (),
      TrailingZeroDimensionalCharacteristicDisplayGroup_ (this),
      n_ (n, this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroupsType (const TrailingZeroDimensionalCharacteristicDisplayGroupsType& x,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TrailingZeroDimensionalCharacteristicDisplayGroup_ (x.TrailingZeroDimensionalCharacteristicDisplayGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    TrailingZeroDimensionalCharacteristicDisplayGroupsType (const xercesc::DOMElement& e,
                                                            ::xml_schema::flags f,
                                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TrailingZeroDimensionalCharacteristicDisplayGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TrailingZeroDimensionalCharacteristicDisplayGroup
        //
        if (n.name () == L"TrailingZeroDimensionalCharacteristicDisplayGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrailingZeroDimensionalCharacteristicDisplayGroup_type > r (
            TrailingZeroDimensionalCharacteristicDisplayGroup_traits::create (i, f, this));

          this->TrailingZeroDimensionalCharacteristicDisplayGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType* TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TrailingZeroDimensionalCharacteristicDisplayGroupsType (*this, f, c);
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType& TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    operator= (const TrailingZeroDimensionalCharacteristicDisplayGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TrailingZeroDimensionalCharacteristicDisplayGroup_ = x.TrailingZeroDimensionalCharacteristicDisplayGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupsType::
    ~TrailingZeroDimensionalCharacteristicDisplayGroupsType ()
    {
    }

    // TrailingZeroDimensionalCharacteristicDisplayGroupType
    //

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    TrailingZeroDimensionalCharacteristicDisplayGroupType ()
    : ::xml_schema::type (),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      DimensionalCharacteristicIds_ (this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    TrailingZeroDimensionalCharacteristicDisplayGroupType (const DimensionalCharacteristicIds_type& DimensionalCharacteristicIds)
    : ::xml_schema::type (),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      DimensionalCharacteristicIds_ (DimensionalCharacteristicIds, this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    TrailingZeroDimensionalCharacteristicDisplayGroupType (::std::unique_ptr< DimensionalCharacteristicIds_type > DimensionalCharacteristicIds)
    : ::xml_schema::type (),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      DimensionalCharacteristicIds_ (std::move (DimensionalCharacteristicIds), this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    TrailingZeroDimensionalCharacteristicDisplayGroupType (const TrailingZeroDimensionalCharacteristicDisplayGroupType& x,
                                                           ::xml_schema::flags f,
                                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DimensionalCharacteristicValueTarget_ (x.DimensionalCharacteristicValueTarget_, f, this),
      DimensionalCharacteristicValueLimits_ (x.DimensionalCharacteristicValueLimits_, f, this),
      DimensionalCharacteristicIds_ (x.DimensionalCharacteristicIds_, f, this)
    {
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    TrailingZeroDimensionalCharacteristicDisplayGroupType (const xercesc::DOMElement& e,
                                                           ::xml_schema::flags f,
                                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DimensionalCharacteristicValueTarget_ (this),
      DimensionalCharacteristicValueLimits_ (this),
      DimensionalCharacteristicIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TrailingZeroDimensionalCharacteristicDisplayGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DimensionalCharacteristicValueTarget
        //
        if (n.name () == L"DimensionalCharacteristicValueTarget" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DimensionalCharacteristicValueTarget_)
          {
            this->DimensionalCharacteristicValueTarget_.set (DimensionalCharacteristicValueTarget_traits::create (i, f, this));
            continue;
          }
        }

        // DimensionalCharacteristicValueLimits
        //
        if (n.name () == L"DimensionalCharacteristicValueLimits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DimensionalCharacteristicValueLimits_)
          {
            this->DimensionalCharacteristicValueLimits_.set (DimensionalCharacteristicValueLimits_traits::create (i, f, this));
            continue;
          }
        }

        // DimensionalCharacteristicIds
        //
        if (n.name () == L"DimensionalCharacteristicIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DimensionalCharacteristicIds_type > r (
            DimensionalCharacteristicIds_traits::create (i, f, this));

          if (!DimensionalCharacteristicIds_.present ())
          {
            this->DimensionalCharacteristicIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DimensionalCharacteristicIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DimensionalCharacteristicIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType* TrailingZeroDimensionalCharacteristicDisplayGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TrailingZeroDimensionalCharacteristicDisplayGroupType (*this, f, c);
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType& TrailingZeroDimensionalCharacteristicDisplayGroupType::
    operator= (const TrailingZeroDimensionalCharacteristicDisplayGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DimensionalCharacteristicValueTarget_ = x.DimensionalCharacteristicValueTarget_;
        this->DimensionalCharacteristicValueLimits_ = x.DimensionalCharacteristicValueLimits_;
        this->DimensionalCharacteristicIds_ = x.DimensionalCharacteristicIds_;
      }

      return *this;
    }

    TrailingZeroDimensionalCharacteristicDisplayGroupType::
    ~TrailingZeroDimensionalCharacteristicDisplayGroupType ()
    {
    }

    // TrailingZeroGeometricCharacteristicDisplayGroupsType
    //

    TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroupsType ()
    : ::xml_schema::type (),
      TrailingZeroGeometricCharacteristicDisplayGroup_ (this),
      n_ (this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroupsType (const n_type& n)
    : ::xml_schema::type (),
      TrailingZeroGeometricCharacteristicDisplayGroup_ (this),
      n_ (n, this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroupsType (const TrailingZeroGeometricCharacteristicDisplayGroupsType& x,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TrailingZeroGeometricCharacteristicDisplayGroup_ (x.TrailingZeroGeometricCharacteristicDisplayGroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::
    TrailingZeroGeometricCharacteristicDisplayGroupsType (const xercesc::DOMElement& e,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TrailingZeroGeometricCharacteristicDisplayGroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TrailingZeroGeometricCharacteristicDisplayGroup
        //
        if (n.name () == L"TrailingZeroGeometricCharacteristicDisplayGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrailingZeroGeometricCharacteristicDisplayGroup_type > r (
            TrailingZeroGeometricCharacteristicDisplayGroup_traits::create (i, f, this));

          this->TrailingZeroGeometricCharacteristicDisplayGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType* TrailingZeroGeometricCharacteristicDisplayGroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TrailingZeroGeometricCharacteristicDisplayGroupsType (*this, f, c);
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType& TrailingZeroGeometricCharacteristicDisplayGroupsType::
    operator= (const TrailingZeroGeometricCharacteristicDisplayGroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TrailingZeroGeometricCharacteristicDisplayGroup_ = x.TrailingZeroGeometricCharacteristicDisplayGroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TrailingZeroGeometricCharacteristicDisplayGroupsType::
    ~TrailingZeroGeometricCharacteristicDisplayGroupsType ()
    {
    }

    // TrailingZeroGeometricCharacteristicDisplayGroupType
    //

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    TrailingZeroGeometricCharacteristicDisplayGroupType ()
    : ::xml_schema::type (),
      GeometricCharacteristicValue_ (this),
      GeometricCharacteristicIds_ (this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    TrailingZeroGeometricCharacteristicDisplayGroupType (const GeometricCharacteristicValue_type& GeometricCharacteristicValue,
                                                         const GeometricCharacteristicIds_type& GeometricCharacteristicIds)
    : ::xml_schema::type (),
      GeometricCharacteristicValue_ (GeometricCharacteristicValue, this),
      GeometricCharacteristicIds_ (GeometricCharacteristicIds, this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    TrailingZeroGeometricCharacteristicDisplayGroupType (const GeometricCharacteristicValue_type& GeometricCharacteristicValue,
                                                         ::std::unique_ptr< GeometricCharacteristicIds_type > GeometricCharacteristicIds)
    : ::xml_schema::type (),
      GeometricCharacteristicValue_ (GeometricCharacteristicValue, this),
      GeometricCharacteristicIds_ (std::move (GeometricCharacteristicIds), this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    TrailingZeroGeometricCharacteristicDisplayGroupType (const TrailingZeroGeometricCharacteristicDisplayGroupType& x,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      GeometricCharacteristicValue_ (x.GeometricCharacteristicValue_, f, this),
      GeometricCharacteristicIds_ (x.GeometricCharacteristicIds_, f, this)
    {
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    TrailingZeroGeometricCharacteristicDisplayGroupType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      GeometricCharacteristicValue_ (this),
      GeometricCharacteristicIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TrailingZeroGeometricCharacteristicDisplayGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // GeometricCharacteristicValue
        //
        if (n.name () == L"GeometricCharacteristicValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!GeometricCharacteristicValue_.present ())
          {
            this->GeometricCharacteristicValue_.set (GeometricCharacteristicValue_traits::create (i, f, this));
            continue;
          }
        }

        // GeometricCharacteristicIds
        //
        if (n.name () == L"GeometricCharacteristicIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< GeometricCharacteristicIds_type > r (
            GeometricCharacteristicIds_traits::create (i, f, this));

          if (!GeometricCharacteristicIds_.present ())
          {
            this->GeometricCharacteristicIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!GeometricCharacteristicValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"GeometricCharacteristicValue",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!GeometricCharacteristicIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"GeometricCharacteristicIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType* TrailingZeroGeometricCharacteristicDisplayGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TrailingZeroGeometricCharacteristicDisplayGroupType (*this, f, c);
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType& TrailingZeroGeometricCharacteristicDisplayGroupType::
    operator= (const TrailingZeroGeometricCharacteristicDisplayGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->GeometricCharacteristicValue_ = x.GeometricCharacteristicValue_;
        this->GeometricCharacteristicIds_ = x.GeometricCharacteristicIds_;
      }

      return *this;
    }

    TrailingZeroGeometricCharacteristicDisplayGroupType::
    ~TrailingZeroGeometricCharacteristicDisplayGroupType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const VisualizationSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Fonts
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Fonts",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Fonts ();
      }

      // TrailingZeroDisplay
      //
      if (i.TrailingZeroDisplay ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrailingZeroDisplay",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrailingZeroDisplay ();
      }

      // PMIDisplaySet
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PMIDisplaySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PMIDisplaySet ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FontsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Font
      //
      for (FontsType::Font_const_iterator
           b (i.Font ().begin ()), n (i.Font ().end ());
           b != n; ++b)
      {
        const FontsType::Font_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Font",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AlignmentEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AlignmentEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AlignmentEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const FontType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Size
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Size",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Size ();
      }

      // Alignment
      //
      if (i.Alignment ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Alignment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Alignment ();
      }

      // index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }

      // bold
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"bold",
            e));

        a << i.bold ();
      }

      // italic
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"italic",
            e));

        a << i.italic ();
      }

      // underline
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"underline",
            e));

        a << i.underline ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PMIDisplaySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PMIDisplay
      //
      for (PMIDisplaySetType::PMIDisplay_const_iterator
           b (i.PMIDisplay ().begin ()), n (i.PMIDisplay ().end ());
           b != n; ++b)
      {
        const PMIDisplaySetType::PMIDisplay_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PMIDisplay",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PMIDisplayType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Color
      //
      if (i.Color ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Color",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Color ();
      }

      // Plane
      //
      if (i.Plane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Plane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Plane ();
      }

      // Texts
      //
      if (i.Texts ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Texts",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Texts ();
      }

      // Leader
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PMIDisplayType::Leader_const_iterator
             b (i.Leader ().begin ()), n (i.Leader ().end ());
             b != n; ++b)
        {
          const PMIDisplayType::Leader_type& x (*b);

          if (typeid (PMIDisplayType::Leader_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Leader",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Leader",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // WitnessLines
      //
      if (i.WitnessLines ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WitnessLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WitnessLines ();
      }

      // Frames
      //
      if (i.Frames ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Frames",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Frames ();
      }

      // Graphics
      //
      if (i.Graphics ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Graphics",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Graphics ();
      }

      // Reference
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Reference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Reference ();
      }

      // GroupID
      //
      if (i.GroupID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GroupID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.GroupID ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlanePMIDisplayType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AnnotationViewId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AnnotationViewId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AnnotationViewId ();
      }

      // Origin
      //
      if (i.Origin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Origin ();
      }

      // Direction
      //
      if (i.Direction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Direction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Polylines2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Polyline
      //
      for (Polylines2dType::Polyline_const_iterator
           b (i.Polyline ().begin ()), n (i.Polyline ().end ());
           b != n; ++b)
      {
        const Polylines2dType::Polyline_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Polyline",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Polyline2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsBinary ();
      }

      // color
      //
      if (i.color ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"color",
            e));

        a << *i.color ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Areas2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Area
      //
      for (Areas2dType::Area_const_iterator
           b (i.Area ().begin ()), n (i.Area ().end ());
           b != n; ++b)
      {
        const Areas2dType::Area_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Area",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Area2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Loops
      //
      if (i.Loops ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Loops",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Loops ();
      }

      // Triangulation
      //
      if (i.Triangulation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Triangulation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Triangulation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Loops2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Loop
      //
      for (Loops2dType::Loop_const_iterator
           b (i.Loop ().begin ()), n (i.Loop ().end ());
           b != n; ++b)
      {
        const Loops2dType::Loop_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Loop",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Triangulation2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Vertices
      //
      if (i.Vertices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vertices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Vertices ();
      }

      // VerticesBinary
      //
      if (i.VerticesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VerticesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VerticesBinary ();
      }

      // Triangles
      //
      if (i.Triangles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Triangles",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Triangles ();
      }

      // TrianglesBinary
      //
      if (i.TrianglesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesBinary ();
      }

      // TrianglesColor
      //
      if (i.TrianglesColor ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesColor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesColor ();
      }

      // TrianglesColorBinary
      //
      if (i.TrianglesColorBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesColorBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesColorBinary ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GraphicsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Polylines
      //
      if (i.Polylines ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Polylines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Polylines ();
      }

      // Areas
      //
      if (i.Areas ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Areas",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Areas ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LeaderType& i)
    {
      e << static_cast< const ::xsd::qif30::LineSegment2dType& > (i);

      // HeadForm
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HeadForm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.HeadForm ();
      }

      // HeadHeight
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HeadHeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.HeadHeight ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderType >
    _xsd_LeaderType_type_serializer_init (
      L"LeaderType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderExtendType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderType& > (i);

      // PointExtension
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointExtension",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointExtension ();
      }

      // Modifier
      //
      if (i.Modifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Modifier",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Modifier ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderExtendType >
    _xsd_LeaderExtendType_type_serializer_init (
      L"LeaderExtendType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderDoubleHeadType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderType& > (i);

      // HeadForm2
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HeadForm2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.HeadForm2 ();
      }

      // PointConnection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointConnection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointConnection ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderDoubleHeadType >
    _xsd_LeaderDoubleHeadType_type_serializer_init (
      L"LeaderDoubleHeadType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderDoubleHeadExtendType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderDoubleHeadType& > (i);

      // PointExtension
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointExtension",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointExtension ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderDoubleHeadExtendType >
    _xsd_LeaderDoubleHeadExtendType_type_serializer_init (
      L"LeaderDoubleHeadExtendType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderCircularType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderType& > (i);

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderCircularType >
    _xsd_LeaderCircularType_type_serializer_init (
      L"LeaderCircularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderDoubleHeadCircularType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderDoubleHeadType& > (i);

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LeaderDoubleHeadCircularType >
    _xsd_LeaderDoubleHeadCircularType_type_serializer_init (
      L"LeaderDoubleHeadCircularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TextsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Text
      //
      for (TextsType::Text_const_iterator
           b (i.Text ().begin ()), n (i.Text ().end ());
           b != n; ++b)
      {
        const TextsType::Text_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Text",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // fontIndex
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"fontIndex",
            e));

        a << i.fontIndex ();
      }

      // lineHeight
      //
      if (i.lineHeight ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"lineHeight",
            e));

        a << ::xml_schema::as_double(*i.lineHeight ());
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FramesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Frame
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FramesType::Frame_const_iterator
             b (i.Frame ().begin ()), n (i.Frame ().end ());
             b != n; ++b)
        {
          const FramesType::Frame_type& x (*b);

          if (typeid (FramesType::Frame_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Frame",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Frame",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TextType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Data
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Data",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Data ();
      }

      // XY
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XY",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XY ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WitnessLinesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Segment1
      //
      if (i.Segment1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Segment1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Segment1 ();
      }

      // ZextensionPoint1
      //
      if (i.ZextensionPoint1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZextensionPoint1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZextensionPoint1 ();
      }

      // Segment2
      //
      if (i.Segment2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Segment2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Segment2 ();
      }

      // ZextensionPoint2
      //
      if (i.ZextensionPoint2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZextensionPoint2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZextensionPoint2 ();
      }

      // BeginPoint
      //
      if (i.BeginPoint ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BeginPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BeginPoint ();
      }

      // EndPoint
      //
      if (i.EndPoint ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndPoint ();
      }

      // CircleCenter
      //
      if (i.CircleCenter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CircleCenter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CircleCenter ();
      }

      // CircleRadius
      //
      if (i.CircleRadius ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CircleRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CircleRadius ();
      }

      // width
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"width",
            e));

        a << ::xml_schema::as_double(i.width ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FrameBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const FrameBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const FrameBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const FrameRectangularType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // XY
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XY",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XY ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Width ());
      }

      // Height
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Height",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Height ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameRectangularType >
    _xsd_FrameRectangularType_type_serializer_init (
      L"FrameRectangularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameCircularType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // XY
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XY",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XY ();
      }

      // Radius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Radius ());
      }

      // crossed
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"crossed",
            e));

        a << i.crossed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameCircularType >
    _xsd_FrameCircularType_type_serializer_init (
      L"FrameCircularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameFlagType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameRectangularType& > (i);

      // right
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"right",
            e));

        a << i.right ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameFlagType >
    _xsd_FrameFlagType_type_serializer_init (
      L"FrameFlagType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameIrregularFormType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // Points
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Points ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameIrregularFormType >
    _xsd_FrameIrregularFormType_type_serializer_init (
      L"FrameIrregularFormType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameWeldSymbolTailType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // UpperPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UpperPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UpperPoint ();
      }

      // LowerPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LowerPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LowerPoint ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WeldMainSymbolEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const WeldMainSymbolEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const WeldMainSymbolEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const OriginType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Origin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Origin ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WeldMainSymbolType& i)
    {
      e << static_cast< const ::xsd::qif30::OriginType& > (i);

      // Symbol
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Symbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Symbol ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WeldSupplementarySymbolType& i)
    {
      e << static_cast< const ::xsd::qif30::OriginType& > (i);

      // Symbol
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Symbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Symbol ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WeldContourSymbolType& i)
    {
      e << static_cast< const ::xsd::qif30::OriginType& > (i);

      // Symbol
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Symbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Symbol ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FrameWeldSymbolType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // ReferenceLineBeginPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceLineBeginPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferenceLineBeginPoint ();
      }

      // ReferenceLineEndPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceLineEndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferenceLineEndPoint ();
      }

      // Tail
      //
      if (i.Tail ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Tail",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Tail ();
      }

      // MainSymbol
      //
      if (i.MainSymbol ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MainSymbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MainSymbol ();
      }

      // SupplementarySymbol
      //
      if (i.SupplementarySymbol ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SupplementarySymbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SupplementarySymbol ();
      }

      // ArrowSideContourSymbol
      //
      if (i.ArrowSideContourSymbol ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ArrowSideContourSymbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ArrowSideContourSymbol ();
      }

      // OtherSideContourSymbol
      //
      if (i.OtherSideContourSymbol ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherSideContourSymbol",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherSideContourSymbol ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameWeldSymbolType >
    _xsd_FrameWeldSymbolType_type_serializer_init (
      L"FrameWeldSymbolType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameTriangleType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // Point
      //
      for (FrameTriangleType::Point_const_iterator
           b (i.Point ().begin ()), n (i.Point ().end ());
           b != n; ++b)
      {
        const FrameTriangleType::Point_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameTriangleType >
    _xsd_FrameTriangleType_type_serializer_init (
      L"FrameTriangleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FramePentagonalType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // Point
      //
      for (FramePentagonalType::Point_const_iterator
           b (i.Point ().begin ()), n (i.Point ().end ());
           b != n; ++b)
      {
        const FramePentagonalType::Point_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FramePentagonalType >
    _xsd_FramePentagonalType_type_serializer_init (
      L"FramePentagonalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameOctagonalType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // Point
      //
      for (FrameOctagonalType::Point_const_iterator
           b (i.Point ().begin ()), n (i.Point ().end ());
           b != n; ++b)
      {
        const FrameOctagonalType::Point_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameOctagonalType >
    _xsd_FrameOctagonalType_type_serializer_init (
      L"FrameOctagonalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FrameHexagonalType& i)
    {
      e << static_cast< const ::xsd::qif30::FrameBaseType& > (i);

      // Point
      //
      for (FrameHexagonalType::Point_const_iterator
           b (i.Point ().begin ()), n (i.Point ().end ());
           b != n; ++b)
      {
        const FrameHexagonalType::Point_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FrameHexagonalType >
    _xsd_FrameHexagonalType_type_serializer_init (
      L"FrameHexagonalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LeaderHeadFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LeaderHeadFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LeaderHeadFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LeaderHeadFormType& i)
    {
      e << static_cast< const ::xsd::qif30::LeaderHeadFormEnumType& > (i);

      // normal
      //
      if (i.normal ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"normal",
            e));

        a << *i.normal ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LeaderModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LeaderModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LeaderModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ViewSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CameraSet
      //
      if (i.CameraSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CameraSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CameraSet ();
      }

      // SavedViewSet
      //
      if (i.SavedViewSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SavedViewSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SavedViewSet ();
      }

      // AnnotationViewSet
      //
      if (i.AnnotationViewSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AnnotationViewSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AnnotationViewSet ();
      }

      // SimplifiedRepresentationSet
      //
      if (i.SimplifiedRepresentationSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimplifiedRepresentationSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SimplifiedRepresentationSet ();
      }

      // ExplodedViewSet
      //
      if (i.ExplodedViewSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExplodedViewSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExplodedViewSet ();
      }

      // DisplayStyleSet
      //
      if (i.DisplayStyleSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DisplayStyleSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DisplayStyleSet ();
      }

      // ZoneSectionSet
      //
      if (i.ZoneSectionSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZoneSectionSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZoneSectionSet ();
      }

      // HatchStyleSet
      //
      if (i.HatchStyleSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HatchStyleSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HatchStyleSet ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CameraType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // ViewPlaneOrigin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ViewPlaneOrigin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ViewPlaneOrigin ();
      }

      // Orientation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Orientation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Orientation ();
      }

      // Ratio
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Ratio",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Ratio ());
      }

      // Near
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Near",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Near ();
      }

      // Far
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Far",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Far ();
      }

      // Height
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Height",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Height ());
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CameraFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CameraFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CameraFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SavedViewType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // ActiveView
      //
      if (i.ActiveView ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActiveView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActiveView ();
      }

      // AnnotationVisibleIds
      //
      if (i.AnnotationVisibleIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AnnotationVisibleIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AnnotationVisibleIds ();
      }

      // AnnotationHiddenIds
      //
      if (i.AnnotationHiddenIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AnnotationHiddenIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AnnotationHiddenIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }

      // ComponentIds
      //
      if (i.ComponentIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentIds ();
      }

      // SimplifiedRepresentationId
      //
      if (i.SimplifiedRepresentationId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimplifiedRepresentationId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SimplifiedRepresentationId ();
      }

      // ExplodedViewId
      //
      if (i.ExplodedViewId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExplodedViewId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExplodedViewId ();
      }

      // DisplayStyleId
      //
      if (i.DisplayStyleId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DisplayStyleId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DisplayStyleId ();
      }

      // ZoneSectionId
      //
      if (i.ZoneSectionId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZoneSectionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZoneSectionId ();
      }

      // CameraIds
      //
      if (i.CameraIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CameraIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CameraIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneSectionType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // SectionPlanes
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionPlanes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SectionPlanes ();
      }

      // LogicalOperations
      //
      if (i.LogicalOperations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LogicalOperations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LogicalOperations ();
      }

      // hatching
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"hatching",
            e));

        a << i.hatching ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LogicalOperationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Action
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Action",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Action ();
      }

      // SectionPlane
      //
      for (LogicalOperationType::SectionPlane_const_iterator
           b (i.SectionPlane ().begin ()), n (i.SectionPlane ().end ());
           b != n; ++b)
      {
        const LogicalOperationType::SectionPlane_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // LogicalOperationResult
      //
      for (LogicalOperationType::LogicalOperationResult_const_iterator
           b (i.LogicalOperationResult ().begin ()), n (i.LogicalOperationResult ().end ());
           b != n; ++b)
      {
        const LogicalOperationType::LogicalOperationResult_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LogicalOperationResult",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LogicalOperationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LogicalOperation
      //
      for (LogicalOperationsType::LogicalOperation_const_iterator
           b (i.LogicalOperation ().begin ()), n (i.LogicalOperation ().end ());
           b != n; ++b)
      {
        const LogicalOperationsType::LogicalOperation_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LogicalOperation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LogicalOperationEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LogicalOperationEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LogicalOperationEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneSectionPlanesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SectionPlane
      //
      for (ZoneSectionPlanesType::SectionPlane_const_iterator
           b (i.SectionPlane ().begin ()), n (i.SectionPlane ().end ());
           b != n; ++b)
      {
        const ZoneSectionPlanesType::SectionPlane_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneSectionPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Plane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Plane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Plane ();
      }

      // SectionGroups
      //
      if (i.SectionGroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SectionGroups ();
      }

      // index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SectionGroup
      //
      for (SectionGroupsType::SectionGroup_const_iterator
           b (i.SectionGroup ().begin ()), n (i.SectionGroup ().end ());
           b != n; ++b)
      {
        const SectionGroupsType::SectionGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SectionGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BodyId
      //
      if (i.BodyId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyId ();
      }

      // Areas
      //
      if (i.Areas ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Areas",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Areas ();
      }

      // Paths
      //
      if (i.Paths ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Paths",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Paths ();
      }

      // Vertices
      //
      if (i.Vertices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vertices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Vertices ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionPathsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Path
      //
      for (SectionPathsType::Path_const_iterator
           b (i.Path ().begin ()), n (i.Path ().end ());
           b != n; ++b)
      {
        const SectionPathsType::Path_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Path",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionLoopsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Loop
      //
      for (SectionLoopsType::Loop_const_iterator
           b (i.Loop ().begin ()), n (i.Loop ().end ());
           b != n; ++b)
      {
        const SectionLoopsType::Loop_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Loop",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionAreasType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Area
      //
      for (SectionAreasType::Area_const_iterator
           b (i.Area ().begin ()), n (i.Area ().end ());
           b != n; ++b)
      {
        const SectionAreasType::Area_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Area",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // HatchStyleId
      //
      if (i.HatchStyleId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HatchStyleId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HatchStyleId ();
      }

      // Loops
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Loops",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Loops ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionEdgesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Edge
      //
      for (SectionEdgesType::Edge_const_iterator
           b (i.Edge ().begin ()), n (i.Edge ().end ());
           b != n; ++b)
      {
        const SectionEdgesType::Edge_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Edge",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SectionPathType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Edges
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Edges",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Edges ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HatchPatternsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Pattern
      //
      for (HatchPatternsType::Pattern_const_iterator
           b (i.Pattern ().begin ()), n (i.Pattern ().end ());
           b != n; ++b)
      {
        const HatchPatternsType::Pattern_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Pattern",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HatchStyleType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // Form
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Form ();
      }

      // Color
      //
      if (i.Color ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Color",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Color ();
      }

      // Patterns
      //
      if (i.Patterns ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Patterns",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Patterns ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HatchStyleFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const HatchStyleFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const HatchStyleFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const HatchPatternType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LineStyle
      //
      if (i.LineStyle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LineStyle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LineStyle ();
      }

      // FirstLineOrigin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstLineOrigin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstLineOrigin ();
      }

      // SecondLineOrigin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondLineOrigin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondLineOrigin ();
      }

      // Angle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Angle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Angle ();
      }

      // Color
      //
      if (i.Color ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Color",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Color ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // Mode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Mode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Mode ();
      }

      // DisplayStyleGroups
      //
      if (i.DisplayStyleGroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DisplayStyleGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DisplayStyleGroups ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DisplayStyleGroup
      //
      for (DisplayStyleGroupsType::DisplayStyleGroup_const_iterator
           b (i.DisplayStyleGroup ().begin ()), n (i.DisplayStyleGroup ().end ());
           b != n; ++b)
      {
        const DisplayStyleGroupsType::DisplayStyleGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DisplayStyleGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleModeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Form
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Form ();
      }

      // Color
      //
      if (i.Color ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Color",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Color ();
      }

      // Transparency
      //
      if (i.Transparency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transparency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transparency ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Mode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Mode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Mode ();
      }

      // ComponentIds
      //
      if (i.ComponentIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DisplayStyleFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DisplayStyleFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // MoveGroups
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MoveGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MoveGroups ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewMoveGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MoveGroup
      //
      for (ExplodedViewMoveGroupsType::MoveGroup_const_iterator
           b (i.MoveGroup ().begin ()), n (i.MoveGroup ().end ());
           b != n; ++b)
      {
        const ExplodedViewMoveGroupsType::MoveGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MoveGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewMoveGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Translate
      //
      if (i.Translate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Translate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Translate ();
      }

      // Rotate
      //
      if (i.Rotate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Rotate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Rotate ();
      }

      // ComponentIds
      //
      if (i.ComponentIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewTranslateType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }

      // Value
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Value",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Value ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewRotateType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Angle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Angle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Angle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SimplifiedRepresentationFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SimplifiedRepresentationFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SimplifiedRepresentationFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SimplifiedRepresentationType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // Form
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Form ();
      }

      // SimplifiedRepresentationGroups
      //
      if (i.SimplifiedRepresentationGroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimplifiedRepresentationGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SimplifiedRepresentationGroups ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SimplifiedRepresentationGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimplifiedRepresentationGroup
      //
      for (SimplifiedRepresentationGroupsType::SimplifiedRepresentationGroup_const_iterator
           b (i.SimplifiedRepresentationGroup ().begin ()), n (i.SimplifiedRepresentationGroup ().end ());
           b != n; ++b)
      {
        const SimplifiedRepresentationGroupsType::SimplifiedRepresentationGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimplifiedRepresentationGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SimplifiedRepresentationGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Form
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Form ();
      }

      // ComponentIds
      //
      if (i.ComponentIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AnnotationViewType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameRectangularType >
    _xsd_FrameRectangular_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameRectangular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameRectangularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameCircularType >
    _xsd_FrameCircular_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameCircularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameFlagType >
    _xsd_FrameFlag_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameFlag",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameFlagType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameIrregularFormType >
    _xsd_FrameIrregularForm_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameIrregularForm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameIrregularFormType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameTriangleType >
    _xsd_FrameTriangle_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameTriangle",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameTriangleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameHexagonalType >
    _xsd_FrameHexagonal_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameHexagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameHexagonalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FramePentagonalType >
    _xsd_FramePentagonal_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FramePentagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FramePentagonalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameOctagonalType >
    _xsd_FrameOctagonal_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameOctagonal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameOctagonalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FrameWeldSymbolType >
    _xsd_FrameWeldSymbol_element_serializer_init (
      L"Frame",
      L"http://qifstandards.org/xsd/qif3",
      L"FrameWeldSymbol",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FrameWeldSymbolType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LeaderExtendType >
    _xsd_LeaderExtend_element_serializer_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderExtend",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LeaderExtendType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LeaderCircularType >
    _xsd_LeaderCircular_element_serializer_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LeaderCircularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LeaderDoubleHeadType >
    _xsd_LeaderDoubleHead_element_serializer_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHead",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LeaderDoubleHeadType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LeaderDoubleHeadCircularType >
    _xsd_LeaderDoubleHeadCircular_element_serializer_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHeadCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LeaderDoubleHeadCircularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LeaderDoubleHeadExtendType >
    _xsd_LeaderDoubleHeadExtend_element_serializer_init (
      L"Leader",
      L"http://qifstandards.org/xsd/qif3",
      L"LeaderDoubleHeadExtend",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LeaderDoubleHeadExtendType >);


    void
    operator<< (xercesc::DOMElement& e, const CameraSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Camera
      //
      for (CameraSetType::Camera_const_iterator
           b (i.Camera ().begin ()), n (i.Camera ().end ());
           b != n; ++b)
      {
        const CameraSetType::Camera_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Camera",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SavedViewSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SavedView
      //
      for (SavedViewSetType::SavedView_const_iterator
           b (i.SavedView ().begin ()), n (i.SavedView ().end ());
           b != n; ++b)
      {
        const SavedViewSetType::SavedView_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SavedView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AnnotationViewSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AnnotationView
      //
      for (AnnotationViewSetType::AnnotationView_const_iterator
           b (i.AnnotationView ().begin ()), n (i.AnnotationView ().end ());
           b != n; ++b)
      {
        const AnnotationViewSetType::AnnotationView_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AnnotationView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DisplayStyleSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DisplayStyle
      //
      for (DisplayStyleSetType::DisplayStyle_const_iterator
           b (i.DisplayStyle ().begin ()), n (i.DisplayStyle ().end ());
           b != n; ++b)
      {
        const DisplayStyleSetType::DisplayStyle_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DisplayStyle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExplodedViewSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ExplodedView
      //
      for (ExplodedViewSetType::ExplodedView_const_iterator
           b (i.ExplodedView ().begin ()), n (i.ExplodedView ().end ());
           b != n; ++b)
      {
        const ExplodedViewSetType::ExplodedView_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExplodedView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SimplifiedRepresentationSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimplifiedRepresentation
      //
      for (SimplifiedRepresentationSetType::SimplifiedRepresentation_const_iterator
           b (i.SimplifiedRepresentation ().begin ()), n (i.SimplifiedRepresentation ().end ());
           b != n; ++b)
      {
        const SimplifiedRepresentationSetType::SimplifiedRepresentation_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SimplifiedRepresentation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneSectionSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ZoneSection
      //
      for (ZoneSectionSetType::ZoneSection_const_iterator
           b (i.ZoneSection ().begin ()), n (i.ZoneSection ().end ());
           b != n; ++b)
      {
        const ZoneSectionSetType::ZoneSection_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZoneSection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HatchStyleSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // HatchStyle
      //
      for (HatchStyleSetType::HatchStyle_const_iterator
           b (i.HatchStyle ().begin ()), n (i.HatchStyle ().end ());
           b != n; ++b)
      {
        const HatchStyleSetType::HatchStyle_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HatchStyle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TrailingZeroDisplayType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DimensionalCharacteristicValueTarget
      //
      if (i.DimensionalCharacteristicValueTarget ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DimensionalCharacteristicValueTarget",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DimensionalCharacteristicValueTarget ();
      }

      // DimensionalCharacteristicValueLimits
      //
      if (i.DimensionalCharacteristicValueLimits ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DimensionalCharacteristicValueLimits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DimensionalCharacteristicValueLimits ();
      }

      // GeometricCharacteristicValue
      //
      if (i.GeometricCharacteristicValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GeometricCharacteristicValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.GeometricCharacteristicValue ();
      }

      // TrailingZeroDimensionalCharacteristicDisplayGroups
      //
      if (i.TrailingZeroDimensionalCharacteristicDisplayGroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrailingZeroDimensionalCharacteristicDisplayGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrailingZeroDimensionalCharacteristicDisplayGroups ();
      }

      // TrailingZeroGeometricCharacteristicDisplayGroups
      //
      if (i.TrailingZeroGeometricCharacteristicDisplayGroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrailingZeroGeometricCharacteristicDisplayGroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrailingZeroGeometricCharacteristicDisplayGroups ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TrailingZeroDimensionalCharacteristicDisplayGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TrailingZeroDimensionalCharacteristicDisplayGroup
      //
      for (TrailingZeroDimensionalCharacteristicDisplayGroupsType::TrailingZeroDimensionalCharacteristicDisplayGroup_const_iterator
           b (i.TrailingZeroDimensionalCharacteristicDisplayGroup ().begin ()), n (i.TrailingZeroDimensionalCharacteristicDisplayGroup ().end ());
           b != n; ++b)
      {
        const TrailingZeroDimensionalCharacteristicDisplayGroupsType::TrailingZeroDimensionalCharacteristicDisplayGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrailingZeroDimensionalCharacteristicDisplayGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TrailingZeroDimensionalCharacteristicDisplayGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DimensionalCharacteristicValueTarget
      //
      if (i.DimensionalCharacteristicValueTarget ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DimensionalCharacteristicValueTarget",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DimensionalCharacteristicValueTarget ();
      }

      // DimensionalCharacteristicValueLimits
      //
      if (i.DimensionalCharacteristicValueLimits ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DimensionalCharacteristicValueLimits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DimensionalCharacteristicValueLimits ();
      }

      // DimensionalCharacteristicIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DimensionalCharacteristicIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DimensionalCharacteristicIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TrailingZeroGeometricCharacteristicDisplayGroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TrailingZeroGeometricCharacteristicDisplayGroup
      //
      for (TrailingZeroGeometricCharacteristicDisplayGroupsType::TrailingZeroGeometricCharacteristicDisplayGroup_const_iterator
           b (i.TrailingZeroGeometricCharacteristicDisplayGroup ().begin ()), n (i.TrailingZeroGeometricCharacteristicDisplayGroup ().end ());
           b != n; ++b)
      {
        const TrailingZeroGeometricCharacteristicDisplayGroupsType::TrailingZeroGeometricCharacteristicDisplayGroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrailingZeroGeometricCharacteristicDisplayGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TrailingZeroGeometricCharacteristicDisplayGroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // GeometricCharacteristicValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GeometricCharacteristicValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.GeometricCharacteristicValue ();
      }

      // GeometricCharacteristicIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GeometricCharacteristicIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.GeometricCharacteristicIds ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

