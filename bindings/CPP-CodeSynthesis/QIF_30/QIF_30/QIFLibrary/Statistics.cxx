// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Statistics.hxx"

namespace xsd
{
  namespace qif30
  {
    // LimitingNumberType
    //

    const LimitingNumberType::Count_optional& LimitingNumberType::
    Count () const
    {
      return this->Count_;
    }

    LimitingNumberType::Count_optional& LimitingNumberType::
    Count ()
    {
      return this->Count_;
    }

    void LimitingNumberType::
    Count (const Count_type& x)
    {
      this->Count_.set (x);
    }

    void LimitingNumberType::
    Count (const Count_optional& x)
    {
      this->Count_ = x;
    }

    const LimitingNumberType::Fraction_optional& LimitingNumberType::
    Fraction () const
    {
      return this->Fraction_;
    }

    LimitingNumberType::Fraction_optional& LimitingNumberType::
    Fraction ()
    {
      return this->Fraction_;
    }

    void LimitingNumberType::
    Fraction (const Fraction_type& x)
    {
      this->Fraction_.set (x);
    }

    void LimitingNumberType::
    Fraction (const Fraction_optional& x)
    {
      this->Fraction_ = x;
    }


    // CriterionDecimalType
    //

    const CriterionDecimalType::Limit_type& CriterionDecimalType::
    Limit () const
    {
      return this->Limit_.get ();
    }

    CriterionDecimalType::Limit_type& CriterionDecimalType::
    Limit ()
    {
      return this->Limit_.get ();
    }

    void CriterionDecimalType::
    Limit (const Limit_type& x)
    {
      this->Limit_.set (x);
    }

    const CriterionDecimalType::NumberAllowedExceptions_optional& CriterionDecimalType::
    NumberAllowedExceptions () const
    {
      return this->NumberAllowedExceptions_;
    }

    CriterionDecimalType::NumberAllowedExceptions_optional& CriterionDecimalType::
    NumberAllowedExceptions ()
    {
      return this->NumberAllowedExceptions_;
    }

    void CriterionDecimalType::
    NumberAllowedExceptions (const NumberAllowedExceptions_type& x)
    {
      this->NumberAllowedExceptions_.set (x);
    }

    void CriterionDecimalType::
    NumberAllowedExceptions (const NumberAllowedExceptions_optional& x)
    {
      this->NumberAllowedExceptions_ = x;
    }

    void CriterionDecimalType::
    NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > x)
    {
      this->NumberAllowedExceptions_.set (std::move (x));
    }

    const CriterionDecimalType::ExtremeLimit_optional& CriterionDecimalType::
    ExtremeLimit () const
    {
      return this->ExtremeLimit_;
    }

    CriterionDecimalType::ExtremeLimit_optional& CriterionDecimalType::
    ExtremeLimit ()
    {
      return this->ExtremeLimit_;
    }

    void CriterionDecimalType::
    ExtremeLimit (const ExtremeLimit_type& x)
    {
      this->ExtremeLimit_.set (x);
    }

    void CriterionDecimalType::
    ExtremeLimit (const ExtremeLimit_optional& x)
    {
      this->ExtremeLimit_ = x;
    }


    // CriterionLinearType
    //

    const CriterionLinearType::linearUnit_optional& CriterionLinearType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    CriterionLinearType::linearUnit_optional& CriterionLinearType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void CriterionLinearType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void CriterionLinearType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void CriterionLinearType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // CriterionAngularType
    //

    const CriterionAngularType::angularUnit_optional& CriterionAngularType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    CriterionAngularType::angularUnit_optional& CriterionAngularType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void CriterionAngularType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void CriterionAngularType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void CriterionAngularType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // CriterionAreaType
    //

    const CriterionAreaType::areaUnit_optional& CriterionAreaType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    CriterionAreaType::areaUnit_optional& CriterionAreaType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void CriterionAreaType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void CriterionAreaType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void CriterionAreaType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // CriterionForceType
    //

    const CriterionForceType::forceUnit_optional& CriterionForceType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    CriterionForceType::forceUnit_optional& CriterionForceType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void CriterionForceType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void CriterionForceType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void CriterionForceType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // CriterionMassType
    //

    const CriterionMassType::massUnit_optional& CriterionMassType::
    massUnit () const
    {
      return this->massUnit_;
    }

    CriterionMassType::massUnit_optional& CriterionMassType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void CriterionMassType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void CriterionMassType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void CriterionMassType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // CriterionPressureType
    //

    const CriterionPressureType::pressureUnit_optional& CriterionPressureType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    CriterionPressureType::pressureUnit_optional& CriterionPressureType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void CriterionPressureType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void CriterionPressureType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void CriterionPressureType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // CriterionSpeedType
    //

    const CriterionSpeedType::speedUnit_optional& CriterionSpeedType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    CriterionSpeedType::speedUnit_optional& CriterionSpeedType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void CriterionSpeedType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void CriterionSpeedType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void CriterionSpeedType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // CriterionTemperatureType
    //

    const CriterionTemperatureType::temperatureUnit_optional& CriterionTemperatureType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    CriterionTemperatureType::temperatureUnit_optional& CriterionTemperatureType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void CriterionTemperatureType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void CriterionTemperatureType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void CriterionTemperatureType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // CriterionTimeType
    //

    const CriterionTimeType::timeUnit_optional& CriterionTimeType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    CriterionTimeType::timeUnit_optional& CriterionTimeType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void CriterionTimeType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void CriterionTimeType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void CriterionTimeType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // CriterionUserDefinedUnitType
    //

    const CriterionUserDefinedUnitType::unitName_type& CriterionUserDefinedUnitType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    CriterionUserDefinedUnitType::unitName_type& CriterionUserDefinedUnitType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void CriterionUserDefinedUnitType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void CriterionUserDefinedUnitType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // CriterionIntegerType
    //

    const CriterionIntegerType::Limit_type& CriterionIntegerType::
    Limit () const
    {
      return this->Limit_.get ();
    }

    CriterionIntegerType::Limit_type& CriterionIntegerType::
    Limit ()
    {
      return this->Limit_.get ();
    }

    void CriterionIntegerType::
    Limit (const Limit_type& x)
    {
      this->Limit_.set (x);
    }

    const CriterionIntegerType::NumberAllowedExceptions_optional& CriterionIntegerType::
    NumberAllowedExceptions () const
    {
      return this->NumberAllowedExceptions_;
    }

    CriterionIntegerType::NumberAllowedExceptions_optional& CriterionIntegerType::
    NumberAllowedExceptions ()
    {
      return this->NumberAllowedExceptions_;
    }

    void CriterionIntegerType::
    NumberAllowedExceptions (const NumberAllowedExceptions_type& x)
    {
      this->NumberAllowedExceptions_.set (x);
    }

    void CriterionIntegerType::
    NumberAllowedExceptions (const NumberAllowedExceptions_optional& x)
    {
      this->NumberAllowedExceptions_ = x;
    }

    void CriterionIntegerType::
    NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > x)
    {
      this->NumberAllowedExceptions_.set (std::move (x));
    }

    const CriterionIntegerType::ExtremeLimit_optional& CriterionIntegerType::
    ExtremeLimit () const
    {
      return this->ExtremeLimit_;
    }

    CriterionIntegerType::ExtremeLimit_optional& CriterionIntegerType::
    ExtremeLimit ()
    {
      return this->ExtremeLimit_;
    }

    void CriterionIntegerType::
    ExtremeLimit (const ExtremeLimit_type& x)
    {
      this->ExtremeLimit_.set (x);
    }

    void CriterionIntegerType::
    ExtremeLimit (const ExtremeLimit_optional& x)
    {
      this->ExtremeLimit_ = x;
    }


    // CriterionOutOfType
    //

    const CriterionOutOfType::Numerator_type& CriterionOutOfType::
    Numerator () const
    {
      return this->Numerator_.get ();
    }

    CriterionOutOfType::Numerator_type& CriterionOutOfType::
    Numerator ()
    {
      return this->Numerator_.get ();
    }

    void CriterionOutOfType::
    Numerator (const Numerator_type& x)
    {
      this->Numerator_.set (x);
    }

    const CriterionOutOfType::Denominator_type& CriterionOutOfType::
    Denominator () const
    {
      return this->Denominator_.get ();
    }

    CriterionOutOfType::Denominator_type& CriterionOutOfType::
    Denominator ()
    {
      return this->Denominator_.get ();
    }

    void CriterionOutOfType::
    Denominator (const Denominator_type& x)
    {
      this->Denominator_.set (x);
    }

    const CriterionOutOfType::NumberAllowedExceptions_optional& CriterionOutOfType::
    NumberAllowedExceptions () const
    {
      return this->NumberAllowedExceptions_;
    }

    CriterionOutOfType::NumberAllowedExceptions_optional& CriterionOutOfType::
    NumberAllowedExceptions ()
    {
      return this->NumberAllowedExceptions_;
    }

    void CriterionOutOfType::
    NumberAllowedExceptions (const NumberAllowedExceptions_type& x)
    {
      this->NumberAllowedExceptions_.set (x);
    }

    void CriterionOutOfType::
    NumberAllowedExceptions (const NumberAllowedExceptions_optional& x)
    {
      this->NumberAllowedExceptions_ = x;
    }

    void CriterionOutOfType::
    NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > x)
    {
      this->NumberAllowedExceptions_.set (std::move (x));
    }


    // SamplingMethodType
    //

    const SamplingMethodType::SampleSize_type& SamplingMethodType::
    SampleSize () const
    {
      return this->SampleSize_.get ();
    }

    SamplingMethodType::SampleSize_type& SamplingMethodType::
    SampleSize ()
    {
      return this->SampleSize_.get ();
    }

    void SamplingMethodType::
    SampleSize (const SampleSize_type& x)
    {
      this->SampleSize_.set (x);
    }

    const SamplingMethodType::SamplingPeriod_optional& SamplingMethodType::
    SamplingPeriod () const
    {
      return this->SamplingPeriod_;
    }

    SamplingMethodType::SamplingPeriod_optional& SamplingMethodType::
    SamplingPeriod ()
    {
      return this->SamplingPeriod_;
    }

    void SamplingMethodType::
    SamplingPeriod (const SamplingPeriod_type& x)
    {
      this->SamplingPeriod_.set (x);
    }

    void SamplingMethodType::
    SamplingPeriod (const SamplingPeriod_optional& x)
    {
      this->SamplingPeriod_ = x;
    }

    const SamplingMethodType::SamplingFrequency_optional& SamplingMethodType::
    SamplingFrequency () const
    {
      return this->SamplingFrequency_;
    }

    SamplingMethodType::SamplingFrequency_optional& SamplingMethodType::
    SamplingFrequency ()
    {
      return this->SamplingFrequency_;
    }

    void SamplingMethodType::
    SamplingFrequency (const SamplingFrequency_type& x)
    {
      this->SamplingFrequency_.set (x);
    }

    void SamplingMethodType::
    SamplingFrequency (const SamplingFrequency_optional& x)
    {
      this->SamplingFrequency_ = x;
    }

    const SamplingMethodType::SamplingInterval_optional& SamplingMethodType::
    SamplingInterval () const
    {
      return this->SamplingInterval_;
    }

    SamplingMethodType::SamplingInterval_optional& SamplingMethodType::
    SamplingInterval ()
    {
      return this->SamplingInterval_;
    }

    void SamplingMethodType::
    SamplingInterval (const SamplingInterval_type& x)
    {
      this->SamplingInterval_.set (x);
    }

    void SamplingMethodType::
    SamplingInterval (const SamplingInterval_optional& x)
    {
      this->SamplingInterval_ = x;
    }

    void SamplingMethodType::
    SamplingInterval (::std::unique_ptr< SamplingInterval_type > x)
    {
      this->SamplingInterval_.set (std::move (x));
    }


    // SamplingIntervalEnumType
    //

    SamplingIntervalEnumType::
    SamplingIntervalEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SamplingIntervalEnumType_literals_[v])
    {
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const SamplingIntervalEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SamplingIntervalEnumType& SamplingIntervalEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SamplingIntervalEnumType_literals_[v]);

      return *this;
    }


    // SamplingIntervalType
    //

    const SamplingIntervalType::SamplingIntervalEnum_optional& SamplingIntervalType::
    SamplingIntervalEnum () const
    {
      return this->SamplingIntervalEnum_;
    }

    SamplingIntervalType::SamplingIntervalEnum_optional& SamplingIntervalType::
    SamplingIntervalEnum ()
    {
      return this->SamplingIntervalEnum_;
    }

    void SamplingIntervalType::
    SamplingIntervalEnum (const SamplingIntervalEnum_type& x)
    {
      this->SamplingIntervalEnum_.set (x);
    }

    void SamplingIntervalType::
    SamplingIntervalEnum (const SamplingIntervalEnum_optional& x)
    {
      this->SamplingIntervalEnum_ = x;
    }

    void SamplingIntervalType::
    SamplingIntervalEnum (::std::unique_ptr< SamplingIntervalEnum_type > x)
    {
      this->SamplingIntervalEnum_.set (std::move (x));
    }

    const SamplingIntervalType::OtherSamplingInterval_optional& SamplingIntervalType::
    OtherSamplingInterval () const
    {
      return this->OtherSamplingInterval_;
    }

    SamplingIntervalType::OtherSamplingInterval_optional& SamplingIntervalType::
    OtherSamplingInterval ()
    {
      return this->OtherSamplingInterval_;
    }

    void SamplingIntervalType::
    OtherSamplingInterval (const OtherSamplingInterval_type& x)
    {
      this->OtherSamplingInterval_.set (x);
    }

    void SamplingIntervalType::
    OtherSamplingInterval (const OtherSamplingInterval_optional& x)
    {
      this->OtherSamplingInterval_ = x;
    }

    void SamplingIntervalType::
    OtherSamplingInterval (::std::unique_ptr< OtherSamplingInterval_type > x)
    {
      this->OtherSamplingInterval_.set (std::move (x));
    }


    // ExclusionEnumType
    //

    ExclusionEnumType::
    ExclusionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ExclusionEnumType::
    ExclusionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ExclusionEnumType_literals_[v])
    {
    }

    ExclusionEnumType::
    ExclusionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ExclusionEnumType::
    ExclusionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ExclusionEnumType::
    ExclusionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ExclusionEnumType::
    ExclusionEnumType (const ExclusionEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ExclusionEnumType& ExclusionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ExclusionEnumType_literals_[v]);

      return *this;
    }


    // ExclusionReasonType
    //

    const ExclusionReasonType::ExclusionReasonEnum_optional& ExclusionReasonType::
    ExclusionReasonEnum () const
    {
      return this->ExclusionReasonEnum_;
    }

    ExclusionReasonType::ExclusionReasonEnum_optional& ExclusionReasonType::
    ExclusionReasonEnum ()
    {
      return this->ExclusionReasonEnum_;
    }

    void ExclusionReasonType::
    ExclusionReasonEnum (const ExclusionReasonEnum_type& x)
    {
      this->ExclusionReasonEnum_.set (x);
    }

    void ExclusionReasonType::
    ExclusionReasonEnum (const ExclusionReasonEnum_optional& x)
    {
      this->ExclusionReasonEnum_ = x;
    }

    void ExclusionReasonType::
    ExclusionReasonEnum (::std::unique_ptr< ExclusionReasonEnum_type > x)
    {
      this->ExclusionReasonEnum_.set (std::move (x));
    }

    const ExclusionReasonType::OtherExclusionReason_optional& ExclusionReasonType::
    OtherExclusionReason () const
    {
      return this->OtherExclusionReason_;
    }

    ExclusionReasonType::OtherExclusionReason_optional& ExclusionReasonType::
    OtherExclusionReason ()
    {
      return this->OtherExclusionReason_;
    }

    void ExclusionReasonType::
    OtherExclusionReason (const OtherExclusionReason_type& x)
    {
      this->OtherExclusionReason_.set (x);
    }

    void ExclusionReasonType::
    OtherExclusionReason (const OtherExclusionReason_optional& x)
    {
      this->OtherExclusionReason_ = x;
    }

    void ExclusionReasonType::
    OtherExclusionReason (::std::unique_ptr< OtherExclusionReason_type > x)
    {
      this->OtherExclusionReason_.set (std::move (x));
    }


    // ExclusionIdType
    //

    const ExclusionIdType::Id_type& ExclusionIdType::
    Id () const
    {
      return this->Id_.get ();
    }

    ExclusionIdType::Id_type& ExclusionIdType::
    Id ()
    {
      return this->Id_.get ();
    }

    void ExclusionIdType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ExclusionIdType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }

    const ExclusionIdType::Reason_type& ExclusionIdType::
    Reason () const
    {
      return this->Reason_.get ();
    }

    ExclusionIdType::Reason_type& ExclusionIdType::
    Reason ()
    {
      return this->Reason_.get ();
    }

    void ExclusionIdType::
    Reason (const Reason_type& x)
    {
      this->Reason_.set (x);
    }

    void ExclusionIdType::
    Reason (::std::unique_ptr< Reason_type > x)
    {
      this->Reason_.set (std::move (x));
    }


    // ExclusionIndexType
    //

    const ExclusionIndexType::Index_type& ExclusionIndexType::
    Index () const
    {
      return this->Index_.get ();
    }

    ExclusionIndexType::Index_type& ExclusionIndexType::
    Index ()
    {
      return this->Index_.get ();
    }

    void ExclusionIndexType::
    Index (const Index_type& x)
    {
      this->Index_.set (x);
    }

    const ExclusionIndexType::Reason_type& ExclusionIndexType::
    Reason () const
    {
      return this->Reason_.get ();
    }

    ExclusionIndexType::Reason_type& ExclusionIndexType::
    Reason ()
    {
      return this->Reason_.get ();
    }

    void ExclusionIndexType::
    Reason (const Reason_type& x)
    {
      this->Reason_.set (x);
    }

    void ExclusionIndexType::
    Reason (::std::unique_ptr< Reason_type > x)
    {
      this->Reason_.set (std::move (x));
    }


    // ExclusionsIdType
    //

    const ExclusionsIdType::Exclusion_sequence& ExclusionsIdType::
    Exclusion () const
    {
      return this->Exclusion_;
    }

    ExclusionsIdType::Exclusion_sequence& ExclusionsIdType::
    Exclusion ()
    {
      return this->Exclusion_;
    }

    void ExclusionsIdType::
    Exclusion (const Exclusion_sequence& s)
    {
      this->Exclusion_ = s;
    }

    const ExclusionsIdType::n_type& ExclusionsIdType::
    n () const
    {
      return this->n_.get ();
    }

    ExclusionsIdType::n_type& ExclusionsIdType::
    n ()
    {
      return this->n_.get ();
    }

    void ExclusionsIdType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExclusionsIdType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ExclusionsIndexType
    //

    const ExclusionsIndexType::Exclusion_sequence& ExclusionsIndexType::
    Exclusion () const
    {
      return this->Exclusion_;
    }

    ExclusionsIndexType::Exclusion_sequence& ExclusionsIndexType::
    Exclusion ()
    {
      return this->Exclusion_;
    }

    void ExclusionsIndexType::
    Exclusion (const Exclusion_sequence& s)
    {
      this->Exclusion_ = s;
    }

    const ExclusionsIndexType::n_type& ExclusionsIndexType::
    n () const
    {
      return this->n_.get ();
    }

    ExclusionsIndexType::n_type& ExclusionsIndexType::
    n ()
    {
      return this->n_.get ();
    }

    void ExclusionsIndexType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExclusionsIndexType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // StatsArrayIdType
    //

    const StatsArrayIdType::Ids_type& StatsArrayIdType::
    Ids () const
    {
      return this->Ids_.get ();
    }

    StatsArrayIdType::Ids_type& StatsArrayIdType::
    Ids ()
    {
      return this->Ids_.get ();
    }

    void StatsArrayIdType::
    Ids (const Ids_type& x)
    {
      this->Ids_.set (x);
    }

    void StatsArrayIdType::
    Ids (::std::unique_ptr< Ids_type > x)
    {
      this->Ids_.set (std::move (x));
    }

    const StatsArrayIdType::Exclusions_optional& StatsArrayIdType::
    Exclusions () const
    {
      return this->Exclusions_;
    }

    StatsArrayIdType::Exclusions_optional& StatsArrayIdType::
    Exclusions ()
    {
      return this->Exclusions_;
    }

    void StatsArrayIdType::
    Exclusions (const Exclusions_type& x)
    {
      this->Exclusions_.set (x);
    }

    void StatsArrayIdType::
    Exclusions (const Exclusions_optional& x)
    {
      this->Exclusions_ = x;
    }

    void StatsArrayIdType::
    Exclusions (::std::unique_ptr< Exclusions_type > x)
    {
      this->Exclusions_.set (std::move (x));
    }


    // StatsValuesType
    //

    const StatsValuesType::Values_type& StatsValuesType::
    Values () const
    {
      return this->Values_.get ();
    }

    StatsValuesType::Values_type& StatsValuesType::
    Values ()
    {
      return this->Values_.get ();
    }

    void StatsValuesType::
    Values (const Values_type& x)
    {
      this->Values_.set (x);
    }

    void StatsValuesType::
    Values (::std::unique_ptr< Values_type > x)
    {
      this->Values_.set (std::move (x));
    }

    const StatsValuesType::Exclusions_optional& StatsValuesType::
    Exclusions () const
    {
      return this->Exclusions_;
    }

    StatsValuesType::Exclusions_optional& StatsValuesType::
    Exclusions ()
    {
      return this->Exclusions_;
    }

    void StatsValuesType::
    Exclusions (const Exclusions_type& x)
    {
      this->Exclusions_.set (x);
    }

    void StatsValuesType::
    Exclusions (const Exclusions_optional& x)
    {
      this->Exclusions_ = x;
    }

    void StatsValuesType::
    Exclusions (::std::unique_ptr< Exclusions_type > x)
    {
      this->Exclusions_.set (std::move (x));
    }


    // StatsEvalStatusEnumType
    //

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_StatsEvalStatusEnumType_literals_[v])
    {
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const StatsEvalStatusEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    StatsEvalStatusEnumType& StatsEvalStatusEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_StatsEvalStatusEnumType_literals_[v]);

      return *this;
    }


    // StatsEvalStatusType
    //

    const StatsEvalStatusType::StatsEvalStatusEnum_optional& StatsEvalStatusType::
    StatsEvalStatusEnum () const
    {
      return this->StatsEvalStatusEnum_;
    }

    StatsEvalStatusType::StatsEvalStatusEnum_optional& StatsEvalStatusType::
    StatsEvalStatusEnum ()
    {
      return this->StatsEvalStatusEnum_;
    }

    void StatsEvalStatusType::
    StatsEvalStatusEnum (const StatsEvalStatusEnum_type& x)
    {
      this->StatsEvalStatusEnum_.set (x);
    }

    void StatsEvalStatusType::
    StatsEvalStatusEnum (const StatsEvalStatusEnum_optional& x)
    {
      this->StatsEvalStatusEnum_ = x;
    }

    void StatsEvalStatusType::
    StatsEvalStatusEnum (::std::unique_ptr< StatsEvalStatusEnum_type > x)
    {
      this->StatsEvalStatusEnum_.set (std::move (x));
    }

    const StatsEvalStatusType::OtherStatsEvalStatus_optional& StatsEvalStatusType::
    OtherStatsEvalStatus () const
    {
      return this->OtherStatsEvalStatus_;
    }

    StatsEvalStatusType::OtherStatsEvalStatus_optional& StatsEvalStatusType::
    OtherStatsEvalStatus ()
    {
      return this->OtherStatsEvalStatus_;
    }

    void StatsEvalStatusType::
    OtherStatsEvalStatus (const OtherStatsEvalStatus_type& x)
    {
      this->OtherStatsEvalStatus_.set (x);
    }

    void StatsEvalStatusType::
    OtherStatsEvalStatus (const OtherStatsEvalStatus_optional& x)
    {
      this->OtherStatsEvalStatus_ = x;
    }

    void StatsEvalStatusType::
    OtherStatsEvalStatus (::std::unique_ptr< OtherStatsEvalStatus_type > x)
    {
      this->OtherStatsEvalStatus_.set (std::move (x));
    }


    // StudyIssuesType
    //

    const StudyIssuesType::StudyIssue_sequence& StudyIssuesType::
    StudyIssue () const
    {
      return this->StudyIssue_;
    }

    StudyIssuesType::StudyIssue_sequence& StudyIssuesType::
    StudyIssue ()
    {
      return this->StudyIssue_;
    }

    void StudyIssuesType::
    StudyIssue (const StudyIssue_sequence& s)
    {
      this->StudyIssue_ = s;
    }

    const StudyIssuesType::n_type& StudyIssuesType::
    n () const
    {
      return this->n_.get ();
    }

    StudyIssuesType::n_type& StudyIssuesType::
    n ()
    {
      return this->n_.get ();
    }

    void StudyIssuesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void StudyIssuesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OneSidedCapabilityCalculationEnumType
    //

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_OneSidedCapabilityCalculationEnumType_literals_[v])
    {
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const OneSidedCapabilityCalculationEnumType& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    OneSidedCapabilityCalculationEnumType& OneSidedCapabilityCalculationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_OneSidedCapabilityCalculationEnumType_literals_[v]);

      return *this;
    }


    // PositionCapabilityCalculationEnumType
    //

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_PositionCapabilityCalculationEnumType_literals_[v])
    {
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const PositionCapabilityCalculationEnumType& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    PositionCapabilityCalculationEnumType& PositionCapabilityCalculationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_PositionCapabilityCalculationEnumType_literals_[v]);

      return *this;
    }


    // DistributionTransformationEnumType
    //

    DistributionTransformationEnumType::
    DistributionTransformationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DistributionTransformationEnumType_literals_[v])
    {
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const DistributionTransformationEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DistributionTransformationEnumType& DistributionTransformationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DistributionTransformationEnumType_literals_[v]);

      return *this;
    }


    // DistributionTransformationType
    //

    const DistributionTransformationType::DistributionTransformationEnum_optional& DistributionTransformationType::
    DistributionTransformationEnum () const
    {
      return this->DistributionTransformationEnum_;
    }

    DistributionTransformationType::DistributionTransformationEnum_optional& DistributionTransformationType::
    DistributionTransformationEnum ()
    {
      return this->DistributionTransformationEnum_;
    }

    void DistributionTransformationType::
    DistributionTransformationEnum (const DistributionTransformationEnum_type& x)
    {
      this->DistributionTransformationEnum_.set (x);
    }

    void DistributionTransformationType::
    DistributionTransformationEnum (const DistributionTransformationEnum_optional& x)
    {
      this->DistributionTransformationEnum_ = x;
    }

    void DistributionTransformationType::
    DistributionTransformationEnum (::std::unique_ptr< DistributionTransformationEnum_type > x)
    {
      this->DistributionTransformationEnum_.set (std::move (x));
    }

    const DistributionTransformationType::BoxCoxTransformation_optional& DistributionTransformationType::
    BoxCoxTransformation () const
    {
      return this->BoxCoxTransformation_;
    }

    DistributionTransformationType::BoxCoxTransformation_optional& DistributionTransformationType::
    BoxCoxTransformation ()
    {
      return this->BoxCoxTransformation_;
    }

    void DistributionTransformationType::
    BoxCoxTransformation (const BoxCoxTransformation_type& x)
    {
      this->BoxCoxTransformation_.set (x);
    }

    void DistributionTransformationType::
    BoxCoxTransformation (const BoxCoxTransformation_optional& x)
    {
      this->BoxCoxTransformation_ = x;
    }

    const DistributionTransformationType::OtherDistributionTransformation_optional& DistributionTransformationType::
    OtherDistributionTransformation () const
    {
      return this->OtherDistributionTransformation_;
    }

    DistributionTransformationType::OtherDistributionTransformation_optional& DistributionTransformationType::
    OtherDistributionTransformation ()
    {
      return this->OtherDistributionTransformation_;
    }

    void DistributionTransformationType::
    OtherDistributionTransformation (const OtherDistributionTransformation_type& x)
    {
      this->OtherDistributionTransformation_.set (x);
    }

    void DistributionTransformationType::
    OtherDistributionTransformation (const OtherDistributionTransformation_optional& x)
    {
      this->OtherDistributionTransformation_ = x;
    }

    void DistributionTransformationType::
    OtherDistributionTransformation (::std::unique_ptr< OtherDistributionTransformation_type > x)
    {
      this->OtherDistributionTransformation_.set (std::move (x));
    }


    // SubgroupType
    //

    const SubgroupType::MeasuredIds_type& SubgroupType::
    MeasuredIds () const
    {
      return this->MeasuredIds_.get ();
    }

    SubgroupType::MeasuredIds_type& SubgroupType::
    MeasuredIds ()
    {
      return this->MeasuredIds_.get ();
    }

    void SubgroupType::
    MeasuredIds (const MeasuredIds_type& x)
    {
      this->MeasuredIds_.set (x);
    }

    void SubgroupType::
    MeasuredIds (::std::unique_ptr< MeasuredIds_type > x)
    {
      this->MeasuredIds_.set (std::move (x));
    }

    const SubgroupType::id_type& SubgroupType::
    id () const
    {
      return this->id_.get ();
    }

    SubgroupType::id_type& SubgroupType::
    id ()
    {
      return this->id_.get ();
    }

    void SubgroupType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void SubgroupType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // SubgroupsType
    //

    const SubgroupsType::Subgroup_sequence& SubgroupsType::
    Subgroup () const
    {
      return this->Subgroup_;
    }

    SubgroupsType::Subgroup_sequence& SubgroupsType::
    Subgroup ()
    {
      return this->Subgroup_;
    }

    void SubgroupsType::
    Subgroup (const Subgroup_sequence& s)
    {
      this->Subgroup_ = s;
    }

    const SubgroupsType::n_type& SubgroupsType::
    n () const
    {
      return this->n_.get ();
    }

    SubgroupsType::n_type& SubgroupsType::
    n ()
    {
      return this->n_.get ();
    }

    void SubgroupsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SubgroupsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SubgroupValuesType
    //

    const SubgroupValuesType::Subgroup_sequence& SubgroupValuesType::
    Subgroup () const
    {
      return this->Subgroup_;
    }

    SubgroupValuesType::Subgroup_sequence& SubgroupValuesType::
    Subgroup ()
    {
      return this->Subgroup_;
    }

    void SubgroupValuesType::
    Subgroup (const Subgroup_sequence& s)
    {
      this->Subgroup_ = s;
    }

    const SubgroupValuesType::n_type& SubgroupValuesType::
    n () const
    {
      return this->n_.get ();
    }

    SubgroupValuesType::n_type& SubgroupValuesType::
    n ()
    {
      return this->n_.get ();
    }

    void SubgroupValuesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SubgroupValuesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CharacteristicStatsEvalBaseType
    //

    const CharacteristicStatsEvalBaseType::Attributes_optional& CharacteristicStatsEvalBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    CharacteristicStatsEvalBaseType::Attributes_optional& CharacteristicStatsEvalBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void CharacteristicStatsEvalBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::SoftwareId_optional& CharacteristicStatsEvalBaseType::
    SoftwareId () const
    {
      return this->SoftwareId_;
    }

    CharacteristicStatsEvalBaseType::SoftwareId_optional& CharacteristicStatsEvalBaseType::
    SoftwareId ()
    {
      return this->SoftwareId_;
    }

    void CharacteristicStatsEvalBaseType::
    SoftwareId (const SoftwareId_type& x)
    {
      this->SoftwareId_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    SoftwareId (const SoftwareId_optional& x)
    {
      this->SoftwareId_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    SoftwareId (::std::unique_ptr< SoftwareId_type > x)
    {
      this->SoftwareId_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::StandardId_optional& CharacteristicStatsEvalBaseType::
    StandardId () const
    {
      return this->StandardId_;
    }

    CharacteristicStatsEvalBaseType::StandardId_optional& CharacteristicStatsEvalBaseType::
    StandardId ()
    {
      return this->StandardId_;
    }

    void CharacteristicStatsEvalBaseType::
    StandardId (const StandardId_type& x)
    {
      this->StandardId_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    StandardId (const StandardId_optional& x)
    {
      this->StandardId_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    StandardId (::std::unique_ptr< StandardId_type > x)
    {
      this->StandardId_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::AlgorithmId_optional& CharacteristicStatsEvalBaseType::
    AlgorithmId () const
    {
      return this->AlgorithmId_;
    }

    CharacteristicStatsEvalBaseType::AlgorithmId_optional& CharacteristicStatsEvalBaseType::
    AlgorithmId ()
    {
      return this->AlgorithmId_;
    }

    void CharacteristicStatsEvalBaseType::
    AlgorithmId (const AlgorithmId_type& x)
    {
      this->AlgorithmId_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    AlgorithmId (const AlgorithmId_optional& x)
    {
      this->AlgorithmId_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    AlgorithmId (::std::unique_ptr< AlgorithmId_type > x)
    {
      this->AlgorithmId_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::MeasuredIds_optional& CharacteristicStatsEvalBaseType::
    MeasuredIds () const
    {
      return this->MeasuredIds_;
    }

    CharacteristicStatsEvalBaseType::MeasuredIds_optional& CharacteristicStatsEvalBaseType::
    MeasuredIds ()
    {
      return this->MeasuredIds_;
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredIds (const MeasuredIds_type& x)
    {
      this->MeasuredIds_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredIds (const MeasuredIds_optional& x)
    {
      this->MeasuredIds_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredIds (::std::unique_ptr< MeasuredIds_type > x)
    {
      this->MeasuredIds_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::Subgroups_optional& CharacteristicStatsEvalBaseType::
    Subgroups () const
    {
      return this->Subgroups_;
    }

    CharacteristicStatsEvalBaseType::Subgroups_optional& CharacteristicStatsEvalBaseType::
    Subgroups ()
    {
      return this->Subgroups_;
    }

    void CharacteristicStatsEvalBaseType::
    Subgroups (const Subgroups_type& x)
    {
      this->Subgroups_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    Subgroups (const Subgroups_optional& x)
    {
      this->Subgroups_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    Subgroups (::std::unique_ptr< Subgroups_type > x)
    {
      this->Subgroups_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::MeasuredValues_optional& CharacteristicStatsEvalBaseType::
    MeasuredValues () const
    {
      return this->MeasuredValues_;
    }

    CharacteristicStatsEvalBaseType::MeasuredValues_optional& CharacteristicStatsEvalBaseType::
    MeasuredValues ()
    {
      return this->MeasuredValues_;
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredValues (const MeasuredValues_type& x)
    {
      this->MeasuredValues_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredValues (const MeasuredValues_optional& x)
    {
      this->MeasuredValues_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    MeasuredValues (::std::unique_ptr< MeasuredValues_type > x)
    {
      this->MeasuredValues_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::SubgroupValues_optional& CharacteristicStatsEvalBaseType::
    SubgroupValues () const
    {
      return this->SubgroupValues_;
    }

    CharacteristicStatsEvalBaseType::SubgroupValues_optional& CharacteristicStatsEvalBaseType::
    SubgroupValues ()
    {
      return this->SubgroupValues_;
    }

    void CharacteristicStatsEvalBaseType::
    SubgroupValues (const SubgroupValues_type& x)
    {
      this->SubgroupValues_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    SubgroupValues (const SubgroupValues_optional& x)
    {
      this->SubgroupValues_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    SubgroupValues (::std::unique_ptr< SubgroupValues_type > x)
    {
      this->SubgroupValues_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::Status_type& CharacteristicStatsEvalBaseType::
    Status () const
    {
      return this->Status_.get ();
    }

    CharacteristicStatsEvalBaseType::Status_type& CharacteristicStatsEvalBaseType::
    Status ()
    {
      return this->Status_.get ();
    }

    void CharacteristicStatsEvalBaseType::
    Status (const Status_type& x)
    {
      this->Status_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    Status (::std::unique_ptr< Status_type > x)
    {
      this->Status_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::StudyIssues_optional& CharacteristicStatsEvalBaseType::
    StudyIssues () const
    {
      return this->StudyIssues_;
    }

    CharacteristicStatsEvalBaseType::StudyIssues_optional& CharacteristicStatsEvalBaseType::
    StudyIssues ()
    {
      return this->StudyIssues_;
    }

    void CharacteristicStatsEvalBaseType::
    StudyIssues (const StudyIssues_type& x)
    {
      this->StudyIssues_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    StudyIssues (const StudyIssues_optional& x)
    {
      this->StudyIssues_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    StudyIssues (::std::unique_ptr< StudyIssues_type > x)
    {
      this->StudyIssues_.set (std::move (x));
    }

    const CharacteristicStatsEvalBaseType::DistributionTransformation_optional& CharacteristicStatsEvalBaseType::
    DistributionTransformation () const
    {
      return this->DistributionTransformation_;
    }

    CharacteristicStatsEvalBaseType::DistributionTransformation_optional& CharacteristicStatsEvalBaseType::
    DistributionTransformation ()
    {
      return this->DistributionTransformation_;
    }

    void CharacteristicStatsEvalBaseType::
    DistributionTransformation (const DistributionTransformation_type& x)
    {
      this->DistributionTransformation_.set (x);
    }

    void CharacteristicStatsEvalBaseType::
    DistributionTransformation (const DistributionTransformation_optional& x)
    {
      this->DistributionTransformation_ = x;
    }

    void CharacteristicStatsEvalBaseType::
    DistributionTransformation (::std::unique_ptr< DistributionTransformation_type > x)
    {
      this->DistributionTransformation_.set (std::move (x));
    }


    // StatsBaseType
    //

    const StatsBaseType::Attributes_optional& StatsBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StatsBaseType::Attributes_optional& StatsBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StatsBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StatsBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StatsBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StatsBaseType::CommonStatsValue_sequence& StatsBaseType::
    CommonStatsValue () const
    {
      return this->CommonStatsValue_;
    }

    StatsBaseType::CommonStatsValue_sequence& StatsBaseType::
    CommonStatsValue ()
    {
      return this->CommonStatsValue_;
    }

    void StatsBaseType::
    CommonStatsValue (const CommonStatsValue_sequence& s)
    {
      this->CommonStatsValue_ = s;
    }


    // StatsNumericalBaseType
    //

    const StatsNumericalBaseType::Attributes_optional& StatsNumericalBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StatsNumericalBaseType::Attributes_optional& StatsNumericalBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StatsNumericalBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StatsNumericalBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StatsNumericalBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StatsNumericalBaseType::NumericCharacteristicStatsValue_sequence& StatsNumericalBaseType::
    NumericCharacteristicStatsValue () const
    {
      return this->NumericCharacteristicStatsValue_;
    }

    StatsNumericalBaseType::NumericCharacteristicStatsValue_sequence& StatsNumericalBaseType::
    NumericCharacteristicStatsValue ()
    {
      return this->NumericCharacteristicStatsValue_;
    }

    void StatsNumericalBaseType::
    NumericCharacteristicStatsValue (const NumericCharacteristicStatsValue_sequence& s)
    {
      this->NumericCharacteristicStatsValue_ = s;
    }


    // StatsWithTolNumericalBaseType
    //

    const StatsWithTolNumericalBaseType::Attributes_optional& StatsWithTolNumericalBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StatsWithTolNumericalBaseType::Attributes_optional& StatsWithTolNumericalBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StatsWithTolNumericalBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StatsWithTolNumericalBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StatsWithTolNumericalBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StatsWithTolNumericalBaseType::NumericCharacteristicWithTolStatsValue_sequence& StatsWithTolNumericalBaseType::
    NumericCharacteristicWithTolStatsValue () const
    {
      return this->NumericCharacteristicWithTolStatsValue_;
    }

    StatsWithTolNumericalBaseType::NumericCharacteristicWithTolStatsValue_sequence& StatsWithTolNumericalBaseType::
    NumericCharacteristicWithTolStatsValue ()
    {
      return this->NumericCharacteristicWithTolStatsValue_;
    }

    void StatsWithTolNumericalBaseType::
    NumericCharacteristicWithTolStatsValue (const NumericCharacteristicWithTolStatsValue_sequence& s)
    {
      this->NumericCharacteristicWithTolStatsValue_ = s;
    }


    // StatsWithTolLinearType
    //

    const StatsWithTolLinearType::linearUnit_optional& StatsWithTolLinearType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    StatsWithTolLinearType::linearUnit_optional& StatsWithTolLinearType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void StatsWithTolLinearType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void StatsWithTolLinearType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void StatsWithTolLinearType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // StatsWithTolAngularType
    //

    const StatsWithTolAngularType::angularUnit_optional& StatsWithTolAngularType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    StatsWithTolAngularType::angularUnit_optional& StatsWithTolAngularType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void StatsWithTolAngularType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void StatsWithTolAngularType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void StatsWithTolAngularType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // StatsWithTolAreaType
    //

    const StatsWithTolAreaType::areaUnit_optional& StatsWithTolAreaType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    StatsWithTolAreaType::areaUnit_optional& StatsWithTolAreaType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void StatsWithTolAreaType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void StatsWithTolAreaType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void StatsWithTolAreaType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // StatsWithTolForceType
    //

    const StatsWithTolForceType::forceUnit_optional& StatsWithTolForceType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    StatsWithTolForceType::forceUnit_optional& StatsWithTolForceType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void StatsWithTolForceType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void StatsWithTolForceType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void StatsWithTolForceType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // StatsWithTolMassType
    //

    const StatsWithTolMassType::massUnit_optional& StatsWithTolMassType::
    massUnit () const
    {
      return this->massUnit_;
    }

    StatsWithTolMassType::massUnit_optional& StatsWithTolMassType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void StatsWithTolMassType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void StatsWithTolMassType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void StatsWithTolMassType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // StatsWithTolPressureType
    //

    const StatsWithTolPressureType::pressureUnit_optional& StatsWithTolPressureType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    StatsWithTolPressureType::pressureUnit_optional& StatsWithTolPressureType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void StatsWithTolPressureType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void StatsWithTolPressureType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void StatsWithTolPressureType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // StatsWithTolSpeedType
    //

    const StatsWithTolSpeedType::speedUnit_optional& StatsWithTolSpeedType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    StatsWithTolSpeedType::speedUnit_optional& StatsWithTolSpeedType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void StatsWithTolSpeedType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void StatsWithTolSpeedType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void StatsWithTolSpeedType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // StatsWithTolTemperatureType
    //

    const StatsWithTolTemperatureType::temperatureUnit_optional& StatsWithTolTemperatureType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    StatsWithTolTemperatureType::temperatureUnit_optional& StatsWithTolTemperatureType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void StatsWithTolTemperatureType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void StatsWithTolTemperatureType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void StatsWithTolTemperatureType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // StatsWithTolTimeType
    //

    const StatsWithTolTimeType::timeUnit_optional& StatsWithTolTimeType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    StatsWithTolTimeType::timeUnit_optional& StatsWithTolTimeType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void StatsWithTolTimeType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void StatsWithTolTimeType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void StatsWithTolTimeType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // StatsWithTolUserDefinedUnitType
    //

    const StatsWithTolUserDefinedUnitType::unitName_type& StatsWithTolUserDefinedUnitType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    StatsWithTolUserDefinedUnitType::unitName_type& StatsWithTolUserDefinedUnitType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void StatsWithTolUserDefinedUnitType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void StatsWithTolUserDefinedUnitType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // StatsLinearType
    //

    const StatsLinearType::linearUnit_optional& StatsLinearType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    StatsLinearType::linearUnit_optional& StatsLinearType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void StatsLinearType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void StatsLinearType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void StatsLinearType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // StatsAngularType
    //

    const StatsAngularType::angularUnit_optional& StatsAngularType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    StatsAngularType::angularUnit_optional& StatsAngularType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void StatsAngularType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void StatsAngularType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void StatsAngularType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // StatsAreaType
    //

    const StatsAreaType::areaUnit_optional& StatsAreaType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    StatsAreaType::areaUnit_optional& StatsAreaType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void StatsAreaType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void StatsAreaType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void StatsAreaType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // StatsForceType
    //

    const StatsForceType::forceUnit_optional& StatsForceType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    StatsForceType::forceUnit_optional& StatsForceType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void StatsForceType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void StatsForceType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void StatsForceType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // StatsMassType
    //

    const StatsMassType::massUnit_optional& StatsMassType::
    massUnit () const
    {
      return this->massUnit_;
    }

    StatsMassType::massUnit_optional& StatsMassType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void StatsMassType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void StatsMassType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void StatsMassType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // StatsPressureType
    //

    const StatsPressureType::pressureUnit_optional& StatsPressureType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    StatsPressureType::pressureUnit_optional& StatsPressureType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void StatsPressureType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void StatsPressureType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void StatsPressureType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // StatsSpeedType
    //

    const StatsSpeedType::speedUnit_optional& StatsSpeedType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    StatsSpeedType::speedUnit_optional& StatsSpeedType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void StatsSpeedType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void StatsSpeedType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void StatsSpeedType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // StatsTemperatureType
    //

    const StatsTemperatureType::temperatureUnit_optional& StatsTemperatureType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    StatsTemperatureType::temperatureUnit_optional& StatsTemperatureType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void StatsTemperatureType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void StatsTemperatureType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void StatsTemperatureType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // StatsTimeType
    //

    const StatsTimeType::timeUnit_optional& StatsTimeType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    StatsTimeType::timeUnit_optional& StatsTimeType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void StatsTimeType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void StatsTimeType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void StatsTimeType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // StatsUserDefinedUnitType
    //

    const StatsUserDefinedUnitType::unitName_type& StatsUserDefinedUnitType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    StatsUserDefinedUnitType::unitName_type& StatsUserDefinedUnitType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void StatsUserDefinedUnitType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void StatsUserDefinedUnitType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // StatsPassFailType
    //

    const StatsPassFailType::PassFailStatsValue_sequence& StatsPassFailType::
    PassFailStatsValue () const
    {
      return this->PassFailStatsValue_;
    }

    StatsPassFailType::PassFailStatsValue_sequence& StatsPassFailType::
    PassFailStatsValue ()
    {
      return this->PassFailStatsValue_;
    }

    void StatsPassFailType::
    PassFailStatsValue (const PassFailStatsValue_sequence& s)
    {
      this->PassFailStatsValue_ = s;
    }


    // GeometricCharacteristicStatsEvalType
    //

    const GeometricCharacteristicStatsEvalType::ValueStats_optional& GeometricCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    GeometricCharacteristicStatsEvalType::ValueStats_optional& GeometricCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void GeometricCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void GeometricCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void GeometricCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const GeometricCharacteristicStatsEvalType::MaxValueStats_optional& GeometricCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    GeometricCharacteristicStatsEvalType::MaxValueStats_optional& GeometricCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void GeometricCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void GeometricCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void GeometricCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const GeometricCharacteristicStatsEvalType::MinValueStats_optional& GeometricCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    GeometricCharacteristicStatsEvalType::MinValueStats_optional& GeometricCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void GeometricCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void GeometricCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void GeometricCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }


    // CompositeSegmentStatsEvalBaseType
    //

    const CompositeSegmentStatsEvalBaseType::ValueStats_optional& CompositeSegmentStatsEvalBaseType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    CompositeSegmentStatsEvalBaseType::ValueStats_optional& CompositeSegmentStatsEvalBaseType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void CompositeSegmentStatsEvalBaseType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void CompositeSegmentStatsEvalBaseType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void CompositeSegmentStatsEvalBaseType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const CompositeSegmentStatsEvalBaseType::MaxValueStats_optional& CompositeSegmentStatsEvalBaseType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    CompositeSegmentStatsEvalBaseType::MaxValueStats_optional& CompositeSegmentStatsEvalBaseType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void CompositeSegmentStatsEvalBaseType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void CompositeSegmentStatsEvalBaseType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void CompositeSegmentStatsEvalBaseType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const CompositeSegmentStatsEvalBaseType::MinValueStats_optional& CompositeSegmentStatsEvalBaseType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    CompositeSegmentStatsEvalBaseType::MinValueStats_optional& CompositeSegmentStatsEvalBaseType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void CompositeSegmentStatsEvalBaseType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void CompositeSegmentStatsEvalBaseType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void CompositeSegmentStatsEvalBaseType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }


    // CompositeSegmentPositionStatsEvalType
    //


    // CompositeSegmentsPositionStatsEvalType
    //

    const CompositeSegmentsPositionStatsEvalType::SecondCompositeSegmentPositionStats_type& CompositeSegmentsPositionStatsEvalType::
    SecondCompositeSegmentPositionStats () const
    {
      return this->SecondCompositeSegmentPositionStats_.get ();
    }

    CompositeSegmentsPositionStatsEvalType::SecondCompositeSegmentPositionStats_type& CompositeSegmentsPositionStatsEvalType::
    SecondCompositeSegmentPositionStats ()
    {
      return this->SecondCompositeSegmentPositionStats_.get ();
    }

    void CompositeSegmentsPositionStatsEvalType::
    SecondCompositeSegmentPositionStats (const SecondCompositeSegmentPositionStats_type& x)
    {
      this->SecondCompositeSegmentPositionStats_.set (x);
    }

    void CompositeSegmentsPositionStatsEvalType::
    SecondCompositeSegmentPositionStats (::std::unique_ptr< SecondCompositeSegmentPositionStats_type > x)
    {
      this->SecondCompositeSegmentPositionStats_.set (std::move (x));
    }

    const CompositeSegmentsPositionStatsEvalType::ThirdCompositeSegmentPositionStats_optional& CompositeSegmentsPositionStatsEvalType::
    ThirdCompositeSegmentPositionStats () const
    {
      return this->ThirdCompositeSegmentPositionStats_;
    }

    CompositeSegmentsPositionStatsEvalType::ThirdCompositeSegmentPositionStats_optional& CompositeSegmentsPositionStatsEvalType::
    ThirdCompositeSegmentPositionStats ()
    {
      return this->ThirdCompositeSegmentPositionStats_;
    }

    void CompositeSegmentsPositionStatsEvalType::
    ThirdCompositeSegmentPositionStats (const ThirdCompositeSegmentPositionStats_type& x)
    {
      this->ThirdCompositeSegmentPositionStats_.set (x);
    }

    void CompositeSegmentsPositionStatsEvalType::
    ThirdCompositeSegmentPositionStats (const ThirdCompositeSegmentPositionStats_optional& x)
    {
      this->ThirdCompositeSegmentPositionStats_ = x;
    }

    void CompositeSegmentsPositionStatsEvalType::
    ThirdCompositeSegmentPositionStats (::std::unique_ptr< ThirdCompositeSegmentPositionStats_type > x)
    {
      this->ThirdCompositeSegmentPositionStats_.set (std::move (x));
    }

    const CompositeSegmentsPositionStatsEvalType::FourthCompositeSegmentPositionStats_optional& CompositeSegmentsPositionStatsEvalType::
    FourthCompositeSegmentPositionStats () const
    {
      return this->FourthCompositeSegmentPositionStats_;
    }

    CompositeSegmentsPositionStatsEvalType::FourthCompositeSegmentPositionStats_optional& CompositeSegmentsPositionStatsEvalType::
    FourthCompositeSegmentPositionStats ()
    {
      return this->FourthCompositeSegmentPositionStats_;
    }

    void CompositeSegmentsPositionStatsEvalType::
    FourthCompositeSegmentPositionStats (const FourthCompositeSegmentPositionStats_type& x)
    {
      this->FourthCompositeSegmentPositionStats_.set (x);
    }

    void CompositeSegmentsPositionStatsEvalType::
    FourthCompositeSegmentPositionStats (const FourthCompositeSegmentPositionStats_optional& x)
    {
      this->FourthCompositeSegmentPositionStats_ = x;
    }

    void CompositeSegmentsPositionStatsEvalType::
    FourthCompositeSegmentPositionStats (::std::unique_ptr< FourthCompositeSegmentPositionStats_type > x)
    {
      this->FourthCompositeSegmentPositionStats_.set (std::move (x));
    }


    // CompositeSegmentProfileStatsEvalType
    //


    // CompositeSegmentsProfileStatsEvalType
    //

    const CompositeSegmentsProfileStatsEvalType::SecondCompositeSegmentProfileStats_type& CompositeSegmentsProfileStatsEvalType::
    SecondCompositeSegmentProfileStats () const
    {
      return this->SecondCompositeSegmentProfileStats_.get ();
    }

    CompositeSegmentsProfileStatsEvalType::SecondCompositeSegmentProfileStats_type& CompositeSegmentsProfileStatsEvalType::
    SecondCompositeSegmentProfileStats ()
    {
      return this->SecondCompositeSegmentProfileStats_.get ();
    }

    void CompositeSegmentsProfileStatsEvalType::
    SecondCompositeSegmentProfileStats (const SecondCompositeSegmentProfileStats_type& x)
    {
      this->SecondCompositeSegmentProfileStats_.set (x);
    }

    void CompositeSegmentsProfileStatsEvalType::
    SecondCompositeSegmentProfileStats (::std::unique_ptr< SecondCompositeSegmentProfileStats_type > x)
    {
      this->SecondCompositeSegmentProfileStats_.set (std::move (x));
    }

    const CompositeSegmentsProfileStatsEvalType::ThirdCompositeSegmentProfileStats_optional& CompositeSegmentsProfileStatsEvalType::
    ThirdCompositeSegmentProfileStats () const
    {
      return this->ThirdCompositeSegmentProfileStats_;
    }

    CompositeSegmentsProfileStatsEvalType::ThirdCompositeSegmentProfileStats_optional& CompositeSegmentsProfileStatsEvalType::
    ThirdCompositeSegmentProfileStats ()
    {
      return this->ThirdCompositeSegmentProfileStats_;
    }

    void CompositeSegmentsProfileStatsEvalType::
    ThirdCompositeSegmentProfileStats (const ThirdCompositeSegmentProfileStats_type& x)
    {
      this->ThirdCompositeSegmentProfileStats_.set (x);
    }

    void CompositeSegmentsProfileStatsEvalType::
    ThirdCompositeSegmentProfileStats (const ThirdCompositeSegmentProfileStats_optional& x)
    {
      this->ThirdCompositeSegmentProfileStats_ = x;
    }

    void CompositeSegmentsProfileStatsEvalType::
    ThirdCompositeSegmentProfileStats (::std::unique_ptr< ThirdCompositeSegmentProfileStats_type > x)
    {
      this->ThirdCompositeSegmentProfileStats_.set (std::move (x));
    }

    const CompositeSegmentsProfileStatsEvalType::FourthCompositeSegmentProfileStats_optional& CompositeSegmentsProfileStatsEvalType::
    FourthCompositeSegmentProfileStats () const
    {
      return this->FourthCompositeSegmentProfileStats_;
    }

    CompositeSegmentsProfileStatsEvalType::FourthCompositeSegmentProfileStats_optional& CompositeSegmentsProfileStatsEvalType::
    FourthCompositeSegmentProfileStats ()
    {
      return this->FourthCompositeSegmentProfileStats_;
    }

    void CompositeSegmentsProfileStatsEvalType::
    FourthCompositeSegmentProfileStats (const FourthCompositeSegmentProfileStats_type& x)
    {
      this->FourthCompositeSegmentProfileStats_.set (x);
    }

    void CompositeSegmentsProfileStatsEvalType::
    FourthCompositeSegmentProfileStats (const FourthCompositeSegmentProfileStats_optional& x)
    {
      this->FourthCompositeSegmentProfileStats_ = x;
    }

    void CompositeSegmentsProfileStatsEvalType::
    FourthCompositeSegmentProfileStats (::std::unique_ptr< FourthCompositeSegmentProfileStats_type > x)
    {
      this->FourthCompositeSegmentProfileStats_.set (std::move (x));
    }


    // CompositeSegmentSymmetryStatsEvalType
    //


    // CompositeSegmentsSymmetryStatsEvalType
    //

    const CompositeSegmentsSymmetryStatsEvalType::SecondCompositeSegmentSymmetryStats_type& CompositeSegmentsSymmetryStatsEvalType::
    SecondCompositeSegmentSymmetryStats () const
    {
      return this->SecondCompositeSegmentSymmetryStats_.get ();
    }

    CompositeSegmentsSymmetryStatsEvalType::SecondCompositeSegmentSymmetryStats_type& CompositeSegmentsSymmetryStatsEvalType::
    SecondCompositeSegmentSymmetryStats ()
    {
      return this->SecondCompositeSegmentSymmetryStats_.get ();
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    SecondCompositeSegmentSymmetryStats (const SecondCompositeSegmentSymmetryStats_type& x)
    {
      this->SecondCompositeSegmentSymmetryStats_.set (x);
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    SecondCompositeSegmentSymmetryStats (::std::unique_ptr< SecondCompositeSegmentSymmetryStats_type > x)
    {
      this->SecondCompositeSegmentSymmetryStats_.set (std::move (x));
    }

    const CompositeSegmentsSymmetryStatsEvalType::ThirdCompositeSegmentSymmetryStats_optional& CompositeSegmentsSymmetryStatsEvalType::
    ThirdCompositeSegmentSymmetryStats () const
    {
      return this->ThirdCompositeSegmentSymmetryStats_;
    }

    CompositeSegmentsSymmetryStatsEvalType::ThirdCompositeSegmentSymmetryStats_optional& CompositeSegmentsSymmetryStatsEvalType::
    ThirdCompositeSegmentSymmetryStats ()
    {
      return this->ThirdCompositeSegmentSymmetryStats_;
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    ThirdCompositeSegmentSymmetryStats (const ThirdCompositeSegmentSymmetryStats_type& x)
    {
      this->ThirdCompositeSegmentSymmetryStats_.set (x);
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    ThirdCompositeSegmentSymmetryStats (const ThirdCompositeSegmentSymmetryStats_optional& x)
    {
      this->ThirdCompositeSegmentSymmetryStats_ = x;
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    ThirdCompositeSegmentSymmetryStats (::std::unique_ptr< ThirdCompositeSegmentSymmetryStats_type > x)
    {
      this->ThirdCompositeSegmentSymmetryStats_.set (std::move (x));
    }


    // LinearCharacteristicStatsEvalType
    //

    const LinearCharacteristicStatsEvalType::ValueStats_optional& LinearCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    LinearCharacteristicStatsEvalType::ValueStats_optional& LinearCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void LinearCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const LinearCharacteristicStatsEvalType::MaxValueStats_optional& LinearCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    LinearCharacteristicStatsEvalType::MaxValueStats_optional& LinearCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void LinearCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const LinearCharacteristicStatsEvalType::MinValueStats_optional& LinearCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    LinearCharacteristicStatsEvalType::MinValueStats_optional& LinearCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void LinearCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const LinearCharacteristicStatsEvalType::DeviationStats_optional& LinearCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    LinearCharacteristicStatsEvalType::DeviationStats_optional& LinearCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void LinearCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const LinearCharacteristicStatsEvalType::MaxDeviationStats_optional& LinearCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    LinearCharacteristicStatsEvalType::MaxDeviationStats_optional& LinearCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void LinearCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const LinearCharacteristicStatsEvalType::MinDeviationStats_optional& LinearCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    LinearCharacteristicStatsEvalType::MinDeviationStats_optional& LinearCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void LinearCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void LinearCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void LinearCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // AngularCharacteristicStatsEvalType
    //

    const AngularCharacteristicStatsEvalType::ValueStats_optional& AngularCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    AngularCharacteristicStatsEvalType::ValueStats_optional& AngularCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void AngularCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const AngularCharacteristicStatsEvalType::MaxValueStats_optional& AngularCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    AngularCharacteristicStatsEvalType::MaxValueStats_optional& AngularCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void AngularCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const AngularCharacteristicStatsEvalType::MinValueStats_optional& AngularCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    AngularCharacteristicStatsEvalType::MinValueStats_optional& AngularCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void AngularCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const AngularCharacteristicStatsEvalType::DeviationStats_optional& AngularCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    AngularCharacteristicStatsEvalType::DeviationStats_optional& AngularCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void AngularCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const AngularCharacteristicStatsEvalType::MaxDeviationStats_optional& AngularCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    AngularCharacteristicStatsEvalType::MaxDeviationStats_optional& AngularCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void AngularCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const AngularCharacteristicStatsEvalType::MinDeviationStats_optional& AngularCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    AngularCharacteristicStatsEvalType::MinDeviationStats_optional& AngularCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void AngularCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void AngularCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void AngularCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedAttributeCharacteristicStatsEvalType
    //

    const UserDefinedAttributeCharacteristicStatsEvalType::AttributeStats_optional& UserDefinedAttributeCharacteristicStatsEvalType::
    AttributeStats () const
    {
      return this->AttributeStats_;
    }

    UserDefinedAttributeCharacteristicStatsEvalType::AttributeStats_optional& UserDefinedAttributeCharacteristicStatsEvalType::
    AttributeStats ()
    {
      return this->AttributeStats_;
    }

    void UserDefinedAttributeCharacteristicStatsEvalType::
    AttributeStats (const AttributeStats_type& x)
    {
      this->AttributeStats_.set (x);
    }

    void UserDefinedAttributeCharacteristicStatsEvalType::
    AttributeStats (const AttributeStats_optional& x)
    {
      this->AttributeStats_ = x;
    }

    void UserDefinedAttributeCharacteristicStatsEvalType::
    AttributeStats (::std::unique_ptr< AttributeStats_type > x)
    {
      this->AttributeStats_.set (std::move (x));
    }


    // UserDefinedLinearCharacteristicStatsEvalType
    //

    const UserDefinedLinearCharacteristicStatsEvalType::ValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::ValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedLinearCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedLinearCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedLinearCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedLinearCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedLinearCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedLinearCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedLinearCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedAngularCharacteristicStatsEvalType
    //

    const UserDefinedAngularCharacteristicStatsEvalType::ValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::ValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedAngularCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedAngularCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedAngularCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedAngularCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedAngularCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedAngularCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedAngularCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedAreaCharacteristicStatsEvalType
    //

    const UserDefinedAreaCharacteristicStatsEvalType::ValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::ValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedAreaCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedAreaCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedAreaCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedAreaCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedAreaCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedAreaCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedAreaCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedForceCharacteristicStatsEvalType
    //

    const UserDefinedForceCharacteristicStatsEvalType::ValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::ValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedForceCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedForceCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedForceCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedForceCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedForceCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedForceCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedForceCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedMassCharacteristicStatsEvalType
    //

    const UserDefinedMassCharacteristicStatsEvalType::ValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::ValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedMassCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedMassCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedMassCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedMassCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedMassCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedMassCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedMassCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedPressureCharacteristicStatsEvalType
    //

    const UserDefinedPressureCharacteristicStatsEvalType::ValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::ValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedPressureCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedPressureCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedPressureCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedPressureCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedPressureCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedPressureCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedPressureCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedSpeedCharacteristicStatsEvalType
    //

    const UserDefinedSpeedCharacteristicStatsEvalType::ValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::ValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedSpeedCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedSpeedCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedSpeedCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedSpeedCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedSpeedCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedSpeedCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedTemperatureCharacteristicStatsEvalType
    //

    const UserDefinedTemperatureCharacteristicStatsEvalType::ValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::ValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedTemperatureCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedTemperatureCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedTemperatureCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedTemperatureCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedTemperatureCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedTemperatureCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedTimeCharacteristicStatsEvalType
    //

    const UserDefinedTimeCharacteristicStatsEvalType::ValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::ValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedTimeCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedTimeCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedTimeCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedTimeCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedTimeCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedTimeCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedTimeCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // UserDefinedUnitCharacteristicStatsEvalType
    //

    const UserDefinedUnitCharacteristicStatsEvalType::ValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    ValueStats () const
    {
      return this->ValueStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::ValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    ValueStats ()
    {
      return this->ValueStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    ValueStats (const ValueStats_type& x)
    {
      this->ValueStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    ValueStats (const ValueStats_optional& x)
    {
      this->ValueStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    ValueStats (::std::unique_ptr< ValueStats_type > x)
    {
      this->ValueStats_.set (std::move (x));
    }

    const UserDefinedUnitCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MaxValueStats () const
    {
      return this->MaxValueStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::MaxValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MaxValueStats ()
    {
      return this->MaxValueStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_type& x)
    {
      this->MaxValueStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxValueStats (const MaxValueStats_optional& x)
    {
      this->MaxValueStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxValueStats (::std::unique_ptr< MaxValueStats_type > x)
    {
      this->MaxValueStats_.set (std::move (x));
    }

    const UserDefinedUnitCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MinValueStats () const
    {
      return this->MinValueStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::MinValueStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MinValueStats ()
    {
      return this->MinValueStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_type& x)
    {
      this->MinValueStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinValueStats (const MinValueStats_optional& x)
    {
      this->MinValueStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinValueStats (::std::unique_ptr< MinValueStats_type > x)
    {
      this->MinValueStats_.set (std::move (x));
    }

    const UserDefinedUnitCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::DeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    DeviationStats (const DeviationStats_optional& x)
    {
      this->DeviationStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }

    const UserDefinedUnitCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MaxDeviationStats () const
    {
      return this->MaxDeviationStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::MaxDeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MaxDeviationStats ()
    {
      return this->MaxDeviationStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_type& x)
    {
      this->MaxDeviationStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxDeviationStats (const MaxDeviationStats_optional& x)
    {
      this->MaxDeviationStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > x)
    {
      this->MaxDeviationStats_.set (std::move (x));
    }

    const UserDefinedUnitCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MinDeviationStats () const
    {
      return this->MinDeviationStats_;
    }

    UserDefinedUnitCharacteristicStatsEvalType::MinDeviationStats_optional& UserDefinedUnitCharacteristicStatsEvalType::
    MinDeviationStats ()
    {
      return this->MinDeviationStats_;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_type& x)
    {
      this->MinDeviationStats_.set (x);
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinDeviationStats (const MinDeviationStats_optional& x)
    {
      this->MinDeviationStats_ = x;
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > x)
    {
      this->MinDeviationStats_.set (std::move (x));
    }


    // SurfaceTextureCharacteristicStatsEvalType
    //

    const SurfaceTextureCharacteristicStatsEvalType::RoughnessAverageValueStats_optional& SurfaceTextureCharacteristicStatsEvalType::
    RoughnessAverageValueStats () const
    {
      return this->RoughnessAverageValueStats_;
    }

    SurfaceTextureCharacteristicStatsEvalType::RoughnessAverageValueStats_optional& SurfaceTextureCharacteristicStatsEvalType::
    RoughnessAverageValueStats ()
    {
      return this->RoughnessAverageValueStats_;
    }

    void SurfaceTextureCharacteristicStatsEvalType::
    RoughnessAverageValueStats (const RoughnessAverageValueStats_type& x)
    {
      this->RoughnessAverageValueStats_.set (x);
    }

    void SurfaceTextureCharacteristicStatsEvalType::
    RoughnessAverageValueStats (const RoughnessAverageValueStats_optional& x)
    {
      this->RoughnessAverageValueStats_ = x;
    }

    void SurfaceTextureCharacteristicStatsEvalType::
    RoughnessAverageValueStats (::std::unique_ptr< RoughnessAverageValueStats_type > x)
    {
      this->RoughnessAverageValueStats_.set (std::move (x));
    }


    // OrientationCharacteristicStatsEvalType
    //

    const OrientationCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& OrientationCharacteristicStatsEvalType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    OrientationCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& OrientationCharacteristicStatsEvalType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void OrientationCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void OrientationCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void OrientationCharacteristicStatsEvalType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }

    const OrientationCharacteristicStatsEvalType::DatumsOkStats_optional& OrientationCharacteristicStatsEvalType::
    DatumsOkStats () const
    {
      return this->DatumsOkStats_;
    }

    OrientationCharacteristicStatsEvalType::DatumsOkStats_optional& OrientationCharacteristicStatsEvalType::
    DatumsOkStats ()
    {
      return this->DatumsOkStats_;
    }

    void OrientationCharacteristicStatsEvalType::
    DatumsOkStats (const DatumsOkStats_type& x)
    {
      this->DatumsOkStats_.set (x);
    }

    void OrientationCharacteristicStatsEvalType::
    DatumsOkStats (const DatumsOkStats_optional& x)
    {
      this->DatumsOkStats_ = x;
    }

    void OrientationCharacteristicStatsEvalType::
    DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > x)
    {
      this->DatumsOkStats_.set (std::move (x));
    }

    const OrientationCharacteristicStatsEvalType::BonusStats_optional& OrientationCharacteristicStatsEvalType::
    BonusStats () const
    {
      return this->BonusStats_;
    }

    OrientationCharacteristicStatsEvalType::BonusStats_optional& OrientationCharacteristicStatsEvalType::
    BonusStats ()
    {
      return this->BonusStats_;
    }

    void OrientationCharacteristicStatsEvalType::
    BonusStats (const BonusStats_type& x)
    {
      this->BonusStats_.set (x);
    }

    void OrientationCharacteristicStatsEvalType::
    BonusStats (const BonusStats_optional& x)
    {
      this->BonusStats_ = x;
    }

    void OrientationCharacteristicStatsEvalType::
    BonusStats (::std::unique_ptr< BonusStats_type > x)
    {
      this->BonusStats_.set (std::move (x));
    }

    const OrientationCharacteristicStatsEvalType::ReferenceLengthStats_optional& OrientationCharacteristicStatsEvalType::
    ReferenceLengthStats () const
    {
      return this->ReferenceLengthStats_;
    }

    OrientationCharacteristicStatsEvalType::ReferenceLengthStats_optional& OrientationCharacteristicStatsEvalType::
    ReferenceLengthStats ()
    {
      return this->ReferenceLengthStats_;
    }

    void OrientationCharacteristicStatsEvalType::
    ReferenceLengthStats (const ReferenceLengthStats_type& x)
    {
      this->ReferenceLengthStats_.set (x);
    }

    void OrientationCharacteristicStatsEvalType::
    ReferenceLengthStats (const ReferenceLengthStats_optional& x)
    {
      this->ReferenceLengthStats_ = x;
    }

    void OrientationCharacteristicStatsEvalType::
    ReferenceLengthStats (::std::unique_ptr< ReferenceLengthStats_type > x)
    {
      this->ReferenceLengthStats_.set (std::move (x));
    }


    // AngularityCharacteristicStatsEvalType
    //


    // PerpendicularityCharacteristicStatsEvalType
    //


    // ParallelismCharacteristicStatsEvalType
    //


    // FormCharacteristicStatsEvalBaseType
    //

    const FormCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& FormCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    FormCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& FormCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void FormCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void FormCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void FormCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }


    // CircularityCharacteristicStatsEvalType
    //

    const CircularityCharacteristicStatsEvalType::MaxCircularityStats_optional& CircularityCharacteristicStatsEvalType::
    MaxCircularityStats () const
    {
      return this->MaxCircularityStats_;
    }

    CircularityCharacteristicStatsEvalType::MaxCircularityStats_optional& CircularityCharacteristicStatsEvalType::
    MaxCircularityStats ()
    {
      return this->MaxCircularityStats_;
    }

    void CircularityCharacteristicStatsEvalType::
    MaxCircularityStats (const MaxCircularityStats_type& x)
    {
      this->MaxCircularityStats_.set (x);
    }

    void CircularityCharacteristicStatsEvalType::
    MaxCircularityStats (const MaxCircularityStats_optional& x)
    {
      this->MaxCircularityStats_ = x;
    }

    void CircularityCharacteristicStatsEvalType::
    MaxCircularityStats (::std::unique_ptr< MaxCircularityStats_type > x)
    {
      this->MaxCircularityStats_.set (std::move (x));
    }


    // ConicityCharacteristicStatsEvalType
    //


    // CylindricityCharacteristicStatsEvalType
    //

    const CylindricityCharacteristicStatsEvalType::MaxCylindricityStats_optional& CylindricityCharacteristicStatsEvalType::
    MaxCylindricityStats () const
    {
      return this->MaxCylindricityStats_;
    }

    CylindricityCharacteristicStatsEvalType::MaxCylindricityStats_optional& CylindricityCharacteristicStatsEvalType::
    MaxCylindricityStats ()
    {
      return this->MaxCylindricityStats_;
    }

    void CylindricityCharacteristicStatsEvalType::
    MaxCylindricityStats (const MaxCylindricityStats_type& x)
    {
      this->MaxCylindricityStats_.set (x);
    }

    void CylindricityCharacteristicStatsEvalType::
    MaxCylindricityStats (const MaxCylindricityStats_optional& x)
    {
      this->MaxCylindricityStats_ = x;
    }

    void CylindricityCharacteristicStatsEvalType::
    MaxCylindricityStats (::std::unique_ptr< MaxCylindricityStats_type > x)
    {
      this->MaxCylindricityStats_.set (std::move (x));
    }


    // EllipticityCharacteristicStatsEvalType
    //


    // FlatnessCharacteristicStatsEvalType
    //

    const FlatnessCharacteristicStatsEvalType::BonusStats_optional& FlatnessCharacteristicStatsEvalType::
    BonusStats () const
    {
      return this->BonusStats_;
    }

    FlatnessCharacteristicStatsEvalType::BonusStats_optional& FlatnessCharacteristicStatsEvalType::
    BonusStats ()
    {
      return this->BonusStats_;
    }

    void FlatnessCharacteristicStatsEvalType::
    BonusStats (const BonusStats_type& x)
    {
      this->BonusStats_.set (x);
    }

    void FlatnessCharacteristicStatsEvalType::
    BonusStats (const BonusStats_optional& x)
    {
      this->BonusStats_ = x;
    }

    void FlatnessCharacteristicStatsEvalType::
    BonusStats (::std::unique_ptr< BonusStats_type > x)
    {
      this->BonusStats_.set (std::move (x));
    }

    const FlatnessCharacteristicStatsEvalType::MaxFlatnessStats_optional& FlatnessCharacteristicStatsEvalType::
    MaxFlatnessStats () const
    {
      return this->MaxFlatnessStats_;
    }

    FlatnessCharacteristicStatsEvalType::MaxFlatnessStats_optional& FlatnessCharacteristicStatsEvalType::
    MaxFlatnessStats ()
    {
      return this->MaxFlatnessStats_;
    }

    void FlatnessCharacteristicStatsEvalType::
    MaxFlatnessStats (const MaxFlatnessStats_type& x)
    {
      this->MaxFlatnessStats_.set (x);
    }

    void FlatnessCharacteristicStatsEvalType::
    MaxFlatnessStats (const MaxFlatnessStats_optional& x)
    {
      this->MaxFlatnessStats_ = x;
    }

    void FlatnessCharacteristicStatsEvalType::
    MaxFlatnessStats (::std::unique_ptr< MaxFlatnessStats_type > x)
    {
      this->MaxFlatnessStats_.set (std::move (x));
    }


    // SphericityCharacteristicStatsEvalType
    //


    // StraightnessCharacteristicStatsEvalType
    //

    const StraightnessCharacteristicStatsEvalType::BonusStats_optional& StraightnessCharacteristicStatsEvalType::
    BonusStats () const
    {
      return this->BonusStats_;
    }

    StraightnessCharacteristicStatsEvalType::BonusStats_optional& StraightnessCharacteristicStatsEvalType::
    BonusStats ()
    {
      return this->BonusStats_;
    }

    void StraightnessCharacteristicStatsEvalType::
    BonusStats (const BonusStats_type& x)
    {
      this->BonusStats_.set (x);
    }

    void StraightnessCharacteristicStatsEvalType::
    BonusStats (const BonusStats_optional& x)
    {
      this->BonusStats_ = x;
    }

    void StraightnessCharacteristicStatsEvalType::
    BonusStats (::std::unique_ptr< BonusStats_type > x)
    {
      this->BonusStats_.set (std::move (x));
    }

    const StraightnessCharacteristicStatsEvalType::MaxStraightnessStats_optional& StraightnessCharacteristicStatsEvalType::
    MaxStraightnessStats () const
    {
      return this->MaxStraightnessStats_;
    }

    StraightnessCharacteristicStatsEvalType::MaxStraightnessStats_optional& StraightnessCharacteristicStatsEvalType::
    MaxStraightnessStats ()
    {
      return this->MaxStraightnessStats_;
    }

    void StraightnessCharacteristicStatsEvalType::
    MaxStraightnessStats (const MaxStraightnessStats_type& x)
    {
      this->MaxStraightnessStats_.set (x);
    }

    void StraightnessCharacteristicStatsEvalType::
    MaxStraightnessStats (const MaxStraightnessStats_optional& x)
    {
      this->MaxStraightnessStats_ = x;
    }

    void StraightnessCharacteristicStatsEvalType::
    MaxStraightnessStats (::std::unique_ptr< MaxStraightnessStats_type > x)
    {
      this->MaxStraightnessStats_.set (std::move (x));
    }


    // ToroidicityCharacteristicStatsEvalType
    //


    // OtherFormCharacteristicStatsEvalType
    //


    // LocationCharacteristicStatsEvalType
    //

    const LocationCharacteristicStatsEvalType::DatumsOkStats_optional& LocationCharacteristicStatsEvalType::
    DatumsOkStats () const
    {
      return this->DatumsOkStats_;
    }

    LocationCharacteristicStatsEvalType::DatumsOkStats_optional& LocationCharacteristicStatsEvalType::
    DatumsOkStats ()
    {
      return this->DatumsOkStats_;
    }

    void LocationCharacteristicStatsEvalType::
    DatumsOkStats (const DatumsOkStats_type& x)
    {
      this->DatumsOkStats_.set (x);
    }

    void LocationCharacteristicStatsEvalType::
    DatumsOkStats (const DatumsOkStats_optional& x)
    {
      this->DatumsOkStats_ = x;
    }

    void LocationCharacteristicStatsEvalType::
    DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > x)
    {
      this->DatumsOkStats_.set (std::move (x));
    }


    // PositionCharacteristicStatsEvalType
    //

    const PositionCharacteristicStatsEvalType::BonusStats_optional& PositionCharacteristicStatsEvalType::
    BonusStats () const
    {
      return this->BonusStats_;
    }

    PositionCharacteristicStatsEvalType::BonusStats_optional& PositionCharacteristicStatsEvalType::
    BonusStats ()
    {
      return this->BonusStats_;
    }

    void PositionCharacteristicStatsEvalType::
    BonusStats (const BonusStats_type& x)
    {
      this->BonusStats_.set (x);
    }

    void PositionCharacteristicStatsEvalType::
    BonusStats (const BonusStats_optional& x)
    {
      this->BonusStats_ = x;
    }

    void PositionCharacteristicStatsEvalType::
    BonusStats (::std::unique_ptr< BonusStats_type > x)
    {
      this->BonusStats_.set (std::move (x));
    }

    const PositionCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& PositionCharacteristicStatsEvalType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    PositionCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& PositionCharacteristicStatsEvalType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void PositionCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void PositionCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void PositionCharacteristicStatsEvalType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }

    const PositionCharacteristicStatsEvalType::CompositeSegmentsStats_optional& PositionCharacteristicStatsEvalType::
    CompositeSegmentsStats () const
    {
      return this->CompositeSegmentsStats_;
    }

    PositionCharacteristicStatsEvalType::CompositeSegmentsStats_optional& PositionCharacteristicStatsEvalType::
    CompositeSegmentsStats ()
    {
      return this->CompositeSegmentsStats_;
    }

    void PositionCharacteristicStatsEvalType::
    CompositeSegmentsStats (const CompositeSegmentsStats_type& x)
    {
      this->CompositeSegmentsStats_.set (x);
    }

    void PositionCharacteristicStatsEvalType::
    CompositeSegmentsStats (const CompositeSegmentsStats_optional& x)
    {
      this->CompositeSegmentsStats_ = x;
    }

    void PositionCharacteristicStatsEvalType::
    CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > x)
    {
      this->CompositeSegmentsStats_.set (std::move (x));
    }


    // AngularCoordinateCharacteristicStatsEvalType
    //


    // AngleCharacteristicStatsEvalType
    //


    // AngleFromCharacteristicStatsEvalType
    //


    // AngleBetweenCharacteristicStatsEvalType
    //


    // LinearCoordinateCharacteristicStatsEvalType
    //


    // CurveLengthCharacteristicStatsEvalType
    //


    // DiameterCharacteristicStatsEvalType
    //


    // SphericalDiameterCharacteristicStatsEvalType
    //


    // LengthCharacteristicStatsEvalType
    //


    // WidthCharacteristicStatsEvalType
    //


    // HeightCharacteristicStatsEvalType
    //


    // DepthCharacteristicStatsEvalType
    //


    // ThicknessCharacteristicStatsEvalType
    //


    // SquareCharacteristicStatsEvalType
    //


    // DistanceFromCharacteristicStatsEvalType
    //


    // DistanceBetweenCharacteristicStatsEvalType
    //


    // RadiusCharacteristicStatsEvalType
    //


    // SphericalRadiusCharacteristicStatsEvalType
    //


    // ChordCharacteristicStatsEvalType
    //


    // ConicalTaperCharacteristicStatsEvalType
    //


    // FlatTaperCharacteristicStatsEvalType
    //


    // RunoutCharacteristicStatsEvalBaseType
    //

    const RunoutCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& RunoutCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    RunoutCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& RunoutCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void RunoutCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void RunoutCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void RunoutCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }

    const RunoutCharacteristicStatsEvalBaseType::DatumsOkStats_optional& RunoutCharacteristicStatsEvalBaseType::
    DatumsOkStats () const
    {
      return this->DatumsOkStats_;
    }

    RunoutCharacteristicStatsEvalBaseType::DatumsOkStats_optional& RunoutCharacteristicStatsEvalBaseType::
    DatumsOkStats ()
    {
      return this->DatumsOkStats_;
    }

    void RunoutCharacteristicStatsEvalBaseType::
    DatumsOkStats (const DatumsOkStats_type& x)
    {
      this->DatumsOkStats_.set (x);
    }

    void RunoutCharacteristicStatsEvalBaseType::
    DatumsOkStats (const DatumsOkStats_optional& x)
    {
      this->DatumsOkStats_ = x;
    }

    void RunoutCharacteristicStatsEvalBaseType::
    DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > x)
    {
      this->DatumsOkStats_.set (std::move (x));
    }


    // CircularRunoutCharacteristicStatsEvalType
    //


    // TotalRunoutCharacteristicStatsEvalType
    //


    // CoaxialityCharacteristicStatsEvalType
    //

    const CoaxialityCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& CoaxialityCharacteristicStatsEvalType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    CoaxialityCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& CoaxialityCharacteristicStatsEvalType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void CoaxialityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void CoaxialityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void CoaxialityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }


    // ConcentricityCharacteristicStatsEvalType
    //

    const ConcentricityCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& ConcentricityCharacteristicStatsEvalType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    ConcentricityCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& ConcentricityCharacteristicStatsEvalType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void ConcentricityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void ConcentricityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void ConcentricityCharacteristicStatsEvalType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }


    // SymmetryCharacteristicStatsEvalType
    //

    const SymmetryCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& SymmetryCharacteristicStatsEvalType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    SymmetryCharacteristicStatsEvalType::CapabilityCalculationMethod_optional& SymmetryCharacteristicStatsEvalType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void SymmetryCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void SymmetryCharacteristicStatsEvalType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void SymmetryCharacteristicStatsEvalType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }

    const SymmetryCharacteristicStatsEvalType::CompositeSegmentsStats_optional& SymmetryCharacteristicStatsEvalType::
    CompositeSegmentsStats () const
    {
      return this->CompositeSegmentsStats_;
    }

    SymmetryCharacteristicStatsEvalType::CompositeSegmentsStats_optional& SymmetryCharacteristicStatsEvalType::
    CompositeSegmentsStats ()
    {
      return this->CompositeSegmentsStats_;
    }

    void SymmetryCharacteristicStatsEvalType::
    CompositeSegmentsStats (const CompositeSegmentsStats_type& x)
    {
      this->CompositeSegmentsStats_.set (x);
    }

    void SymmetryCharacteristicStatsEvalType::
    CompositeSegmentsStats (const CompositeSegmentsStats_optional& x)
    {
      this->CompositeSegmentsStats_ = x;
    }

    void SymmetryCharacteristicStatsEvalType::
    CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > x)
    {
      this->CompositeSegmentsStats_.set (std::move (x));
    }


    // PointDeviationStatsEvalType
    //

    const PointDeviationStatsEvalType::MeasuredPointIds_type& PointDeviationStatsEvalType::
    MeasuredPointIds () const
    {
      return this->MeasuredPointIds_.get ();
    }

    PointDeviationStatsEvalType::MeasuredPointIds_type& PointDeviationStatsEvalType::
    MeasuredPointIds ()
    {
      return this->MeasuredPointIds_.get ();
    }

    void PointDeviationStatsEvalType::
    MeasuredPointIds (const MeasuredPointIds_type& x)
    {
      this->MeasuredPointIds_.set (x);
    }

    void PointDeviationStatsEvalType::
    MeasuredPointIds (::std::unique_ptr< MeasuredPointIds_type > x)
    {
      this->MeasuredPointIds_.set (std::move (x));
    }

    const PointDeviationStatsEvalType::DeviationStats_type& PointDeviationStatsEvalType::
    DeviationStats () const
    {
      return this->DeviationStats_.get ();
    }

    PointDeviationStatsEvalType::DeviationStats_type& PointDeviationStatsEvalType::
    DeviationStats ()
    {
      return this->DeviationStats_.get ();
    }

    void PointDeviationStatsEvalType::
    DeviationStats (const DeviationStats_type& x)
    {
      this->DeviationStats_.set (x);
    }

    void PointDeviationStatsEvalType::
    DeviationStats (::std::unique_ptr< DeviationStats_type > x)
    {
      this->DeviationStats_.set (std::move (x));
    }


    // PointDeviationsStatsEvalType
    //

    const PointDeviationsStatsEvalType::PointDeviationStats_sequence& PointDeviationsStatsEvalType::
    PointDeviationStats () const
    {
      return this->PointDeviationStats_;
    }

    PointDeviationsStatsEvalType::PointDeviationStats_sequence& PointDeviationsStatsEvalType::
    PointDeviationStats ()
    {
      return this->PointDeviationStats_;
    }

    void PointDeviationsStatsEvalType::
    PointDeviationStats (const PointDeviationStats_sequence& s)
    {
      this->PointDeviationStats_ = s;
    }

    const PointDeviationsStatsEvalType::n_type& PointDeviationsStatsEvalType::
    n () const
    {
      return this->n_.get ();
    }

    PointDeviationsStatsEvalType::n_type& PointDeviationsStatsEvalType::
    n ()
    {
      return this->n_.get ();
    }

    void PointDeviationsStatsEvalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointDeviationsStatsEvalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ProfileCharacteristicStatsEvalBaseType
    //

    const ProfileCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& ProfileCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod () const
    {
      return this->CapabilityCalculationMethod_;
    }

    ProfileCharacteristicStatsEvalBaseType::CapabilityCalculationMethod_optional& ProfileCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod ()
    {
      return this->CapabilityCalculationMethod_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x)
    {
      this->CapabilityCalculationMethod_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x)
    {
      this->CapabilityCalculationMethod_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > x)
    {
      this->CapabilityCalculationMethod_.set (std::move (x));
    }

    const ProfileCharacteristicStatsEvalBaseType::WorstPositiveDeviationStats_optional& ProfileCharacteristicStatsEvalBaseType::
    WorstPositiveDeviationStats () const
    {
      return this->WorstPositiveDeviationStats_;
    }

    ProfileCharacteristicStatsEvalBaseType::WorstPositiveDeviationStats_optional& ProfileCharacteristicStatsEvalBaseType::
    WorstPositiveDeviationStats ()
    {
      return this->WorstPositiveDeviationStats_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstPositiveDeviationStats (const WorstPositiveDeviationStats_type& x)
    {
      this->WorstPositiveDeviationStats_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstPositiveDeviationStats (const WorstPositiveDeviationStats_optional& x)
    {
      this->WorstPositiveDeviationStats_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstPositiveDeviationStats (::std::unique_ptr< WorstPositiveDeviationStats_type > x)
    {
      this->WorstPositiveDeviationStats_.set (std::move (x));
    }

    const ProfileCharacteristicStatsEvalBaseType::WorstNegativeDeviationStats_optional& ProfileCharacteristicStatsEvalBaseType::
    WorstNegativeDeviationStats () const
    {
      return this->WorstNegativeDeviationStats_;
    }

    ProfileCharacteristicStatsEvalBaseType::WorstNegativeDeviationStats_optional& ProfileCharacteristicStatsEvalBaseType::
    WorstNegativeDeviationStats ()
    {
      return this->WorstNegativeDeviationStats_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstNegativeDeviationStats (const WorstNegativeDeviationStats_type& x)
    {
      this->WorstNegativeDeviationStats_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstNegativeDeviationStats (const WorstNegativeDeviationStats_optional& x)
    {
      this->WorstNegativeDeviationStats_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    WorstNegativeDeviationStats (::std::unique_ptr< WorstNegativeDeviationStats_type > x)
    {
      this->WorstNegativeDeviationStats_.set (std::move (x));
    }

    const ProfileCharacteristicStatsEvalBaseType::PointDeviationsStats_optional& ProfileCharacteristicStatsEvalBaseType::
    PointDeviationsStats () const
    {
      return this->PointDeviationsStats_;
    }

    ProfileCharacteristicStatsEvalBaseType::PointDeviationsStats_optional& ProfileCharacteristicStatsEvalBaseType::
    PointDeviationsStats ()
    {
      return this->PointDeviationsStats_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    PointDeviationsStats (const PointDeviationsStats_type& x)
    {
      this->PointDeviationsStats_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    PointDeviationsStats (const PointDeviationsStats_optional& x)
    {
      this->PointDeviationsStats_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    PointDeviationsStats (::std::unique_ptr< PointDeviationsStats_type > x)
    {
      this->PointDeviationsStats_.set (std::move (x));
    }

    const ProfileCharacteristicStatsEvalBaseType::DatumsOkStats_optional& ProfileCharacteristicStatsEvalBaseType::
    DatumsOkStats () const
    {
      return this->DatumsOkStats_;
    }

    ProfileCharacteristicStatsEvalBaseType::DatumsOkStats_optional& ProfileCharacteristicStatsEvalBaseType::
    DatumsOkStats ()
    {
      return this->DatumsOkStats_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    DatumsOkStats (const DatumsOkStats_type& x)
    {
      this->DatumsOkStats_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    DatumsOkStats (const DatumsOkStats_optional& x)
    {
      this->DatumsOkStats_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > x)
    {
      this->DatumsOkStats_.set (std::move (x));
    }

    const ProfileCharacteristicStatsEvalBaseType::CompositeSegmentsStats_optional& ProfileCharacteristicStatsEvalBaseType::
    CompositeSegmentsStats () const
    {
      return this->CompositeSegmentsStats_;
    }

    ProfileCharacteristicStatsEvalBaseType::CompositeSegmentsStats_optional& ProfileCharacteristicStatsEvalBaseType::
    CompositeSegmentsStats ()
    {
      return this->CompositeSegmentsStats_;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CompositeSegmentsStats (const CompositeSegmentsStats_type& x)
    {
      this->CompositeSegmentsStats_.set (x);
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CompositeSegmentsStats (const CompositeSegmentsStats_optional& x)
    {
      this->CompositeSegmentsStats_ = x;
    }

    void ProfileCharacteristicStatsEvalBaseType::
    CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > x)
    {
      this->CompositeSegmentsStats_.set (std::move (x));
    }


    // LineProfileCharacteristicStatsEvalType
    //


    // PointProfileCharacteristicStatsEvalType
    //


    // SurfaceProfileCharacteristicStatsEvalType
    //


    // SurfaceProfileNonUniformCharacteristicStatsEvalType
    //


    // ThreadCharacteristicStatsEvalType
    //

    const ThreadCharacteristicStatsEvalType::ThreadStats_optional& ThreadCharacteristicStatsEvalType::
    ThreadStats () const
    {
      return this->ThreadStats_;
    }

    ThreadCharacteristicStatsEvalType::ThreadStats_optional& ThreadCharacteristicStatsEvalType::
    ThreadStats ()
    {
      return this->ThreadStats_;
    }

    void ThreadCharacteristicStatsEvalType::
    ThreadStats (const ThreadStats_type& x)
    {
      this->ThreadStats_.set (x);
    }

    void ThreadCharacteristicStatsEvalType::
    ThreadStats (const ThreadStats_optional& x)
    {
      this->ThreadStats_ = x;
    }

    void ThreadCharacteristicStatsEvalType::
    ThreadStats (::std::unique_ptr< ThreadStats_type > x)
    {
      this->ThreadStats_.set (std::move (x));
    }

    const ThreadCharacteristicStatsEvalType::PitchDiameterStats_optional& ThreadCharacteristicStatsEvalType::
    PitchDiameterStats () const
    {
      return this->PitchDiameterStats_;
    }

    ThreadCharacteristicStatsEvalType::PitchDiameterStats_optional& ThreadCharacteristicStatsEvalType::
    PitchDiameterStats ()
    {
      return this->PitchDiameterStats_;
    }

    void ThreadCharacteristicStatsEvalType::
    PitchDiameterStats (const PitchDiameterStats_type& x)
    {
      this->PitchDiameterStats_.set (x);
    }

    void ThreadCharacteristicStatsEvalType::
    PitchDiameterStats (const PitchDiameterStats_optional& x)
    {
      this->PitchDiameterStats_ = x;
    }

    void ThreadCharacteristicStatsEvalType::
    PitchDiameterStats (::std::unique_ptr< PitchDiameterStats_type > x)
    {
      this->PitchDiameterStats_.set (std::move (x));
    }

    const ThreadCharacteristicStatsEvalType::FunctionalSizeStats_optional& ThreadCharacteristicStatsEvalType::
    FunctionalSizeStats () const
    {
      return this->FunctionalSizeStats_;
    }

    ThreadCharacteristicStatsEvalType::FunctionalSizeStats_optional& ThreadCharacteristicStatsEvalType::
    FunctionalSizeStats ()
    {
      return this->FunctionalSizeStats_;
    }

    void ThreadCharacteristicStatsEvalType::
    FunctionalSizeStats (const FunctionalSizeStats_type& x)
    {
      this->FunctionalSizeStats_.set (x);
    }

    void ThreadCharacteristicStatsEvalType::
    FunctionalSizeStats (const FunctionalSizeStats_optional& x)
    {
      this->FunctionalSizeStats_ = x;
    }

    void ThreadCharacteristicStatsEvalType::
    FunctionalSizeStats (::std::unique_ptr< FunctionalSizeStats_type > x)
    {
      this->FunctionalSizeStats_.set (std::move (x));
    }


    // WeldCharacteristicStatsEvalBaseType
    //

    const WeldCharacteristicStatsEvalBaseType::WeldStats_optional& WeldCharacteristicStatsEvalBaseType::
    WeldStats () const
    {
      return this->WeldStats_;
    }

    WeldCharacteristicStatsEvalBaseType::WeldStats_optional& WeldCharacteristicStatsEvalBaseType::
    WeldStats ()
    {
      return this->WeldStats_;
    }

    void WeldCharacteristicStatsEvalBaseType::
    WeldStats (const WeldStats_type& x)
    {
      this->WeldStats_.set (x);
    }

    void WeldCharacteristicStatsEvalBaseType::
    WeldStats (const WeldStats_optional& x)
    {
      this->WeldStats_ = x;
    }

    void WeldCharacteristicStatsEvalBaseType::
    WeldStats (::std::unique_ptr< WeldStats_type > x)
    {
      this->WeldStats_.set (std::move (x));
    }


    // WeldFilletCharacteristicStatsEvalType
    //


    // WeldPlugCharacteristicStatsEvalType
    //


    // WeldSlotCharacteristicStatsEvalType
    //


    // WeldSpotCharacteristicStatsEvalType
    //


    // WeldStudCharacteristicStatsEvalType
    //


    // WeldSeamCharacteristicStatsEvalType
    //


    // WeldSurfacingCharacteristicStatsEvalType
    //


    // WeldEdgeCharacteristicStatsEvalType
    //


    // WeldSquareCharacteristicStatsEvalType
    //


    // WeldBevelCharacteristicStatsEvalType
    //


    // WeldVCharacteristicStatsEvalType
    //


    // WeldUCharacteristicStatsEvalType
    //


    // WeldJCharacteristicStatsEvalType
    //


    // WeldFlareVCharacteristicStatsEvalType
    //


    // WeldFlareBevelCharacteristicStatsEvalType
    //


    // WeldScarfCharacteristicStatsEvalType
    //


    // WeldCompoundCharacteristicStatsEvalType
    //


    // CharacteristicsStatsType
    //

    const CharacteristicsStatsType::CharacteristicStats_sequence& CharacteristicsStatsType::
    CharacteristicStats () const
    {
      return this->CharacteristicStats_;
    }

    CharacteristicsStatsType::CharacteristicStats_sequence& CharacteristicsStatsType::
    CharacteristicStats ()
    {
      return this->CharacteristicStats_;
    }

    void CharacteristicsStatsType::
    CharacteristicStats (const CharacteristicStats_sequence& s)
    {
      this->CharacteristicStats_ = s;
    }

    const CharacteristicsStatsType::n_type& CharacteristicsStatsType::
    n () const
    {
      return this->n_.get ();
    }

    CharacteristicsStatsType::n_type& CharacteristicsStatsType::
    n ()
    {
      return this->n_.get ();
    }

    void CharacteristicsStatsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CharacteristicsStatsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AverageFeatureType
    //

    const AverageFeatureType::FeatureMeasurement_type& AverageFeatureType::
    FeatureMeasurement () const
    {
      return this->FeatureMeasurement_.get ();
    }

    AverageFeatureType::FeatureMeasurement_type& AverageFeatureType::
    FeatureMeasurement ()
    {
      return this->FeatureMeasurement_.get ();
    }

    void AverageFeatureType::
    FeatureMeasurement (const FeatureMeasurement_type& x)
    {
      this->FeatureMeasurement_.set (x);
    }

    void AverageFeatureType::
    FeatureMeasurement (::std::unique_ptr< FeatureMeasurement_type > x)
    {
      this->FeatureMeasurement_.set (std::move (x));
    }

    const AverageFeatureType::MeasuredIds_type& AverageFeatureType::
    MeasuredIds () const
    {
      return this->MeasuredIds_.get ();
    }

    AverageFeatureType::MeasuredIds_type& AverageFeatureType::
    MeasuredIds ()
    {
      return this->MeasuredIds_.get ();
    }

    void AverageFeatureType::
    MeasuredIds (const MeasuredIds_type& x)
    {
      this->MeasuredIds_.set (x);
    }

    void AverageFeatureType::
    MeasuredIds (::std::unique_ptr< MeasuredIds_type > x)
    {
      this->MeasuredIds_.set (std::move (x));
    }


    // AverageFeaturesType
    //

    const AverageFeaturesType::AverageFeature_sequence& AverageFeaturesType::
    AverageFeature () const
    {
      return this->AverageFeature_;
    }

    AverageFeaturesType::AverageFeature_sequence& AverageFeaturesType::
    AverageFeature ()
    {
      return this->AverageFeature_;
    }

    void AverageFeaturesType::
    AverageFeature (const AverageFeature_sequence& s)
    {
      this->AverageFeature_ = s;
    }

    const AverageFeaturesType::n_type& AverageFeaturesType::
    n () const
    {
      return this->n_.get ();
    }

    AverageFeaturesType::n_type& AverageFeaturesType::
    n ()
    {
      return this->n_.get ();
    }

    void AverageFeaturesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AverageFeaturesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsType
    //

    const SummaryStatisticsType::Attributes_optional& SummaryStatisticsType::
    Attributes () const
    {
      return this->Attributes_;
    }

    SummaryStatisticsType::Attributes_optional& SummaryStatisticsType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void SummaryStatisticsType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void SummaryStatisticsType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void SummaryStatisticsType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const SummaryStatisticsType::TypeOfSummary_type& SummaryStatisticsType::
    TypeOfSummary () const
    {
      return this->TypeOfSummary_.get ();
    }

    SummaryStatisticsType::TypeOfSummary_type& SummaryStatisticsType::
    TypeOfSummary ()
    {
      return this->TypeOfSummary_.get ();
    }

    void SummaryStatisticsType::
    TypeOfSummary (const TypeOfSummary_type& x)
    {
      this->TypeOfSummary_.set (x);
    }

    void SummaryStatisticsType::
    TypeOfSummary (::std::unique_ptr< TypeOfSummary_type > x)
    {
      this->TypeOfSummary_.set (std::move (x));
    }

    const SummaryStatisticsType::SummaryStatsValue_sequence& SummaryStatisticsType::
    SummaryStatsValue () const
    {
      return this->SummaryStatsValue_;
    }

    SummaryStatisticsType::SummaryStatsValue_sequence& SummaryStatisticsType::
    SummaryStatsValue ()
    {
      return this->SummaryStatsValue_;
    }

    void SummaryStatisticsType::
    SummaryStatsValue (const SummaryStatsValue_sequence& s)
    {
      this->SummaryStatsValue_ = s;
    }


    // SummariesStatisticsType
    //

    const SummariesStatisticsType::StatsSummary_sequence& SummariesStatisticsType::
    StatsSummary () const
    {
      return this->StatsSummary_;
    }

    SummariesStatisticsType::StatsSummary_sequence& SummariesStatisticsType::
    StatsSummary ()
    {
      return this->StatsSummary_;
    }

    void SummariesStatisticsType::
    StatsSummary (const StatsSummary_sequence& s)
    {
      this->StatsSummary_ = s;
    }

    const SummariesStatisticsType::n_type& SummariesStatisticsType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsType::n_type& SummariesStatisticsType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsLinearType
    //

    const SummaryStatisticsLinearType::linearUnit_optional& SummaryStatisticsLinearType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    SummaryStatisticsLinearType::linearUnit_optional& SummaryStatisticsLinearType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void SummaryStatisticsLinearType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void SummaryStatisticsLinearType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void SummaryStatisticsLinearType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // SummariesStatisticsLinearType
    //

    const SummariesStatisticsLinearType::LinearStatsSummary_sequence& SummariesStatisticsLinearType::
    LinearStatsSummary () const
    {
      return this->LinearStatsSummary_;
    }

    SummariesStatisticsLinearType::LinearStatsSummary_sequence& SummariesStatisticsLinearType::
    LinearStatsSummary ()
    {
      return this->LinearStatsSummary_;
    }

    void SummariesStatisticsLinearType::
    LinearStatsSummary (const LinearStatsSummary_sequence& s)
    {
      this->LinearStatsSummary_ = s;
    }

    const SummariesStatisticsLinearType::n_type& SummariesStatisticsLinearType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsLinearType::n_type& SummariesStatisticsLinearType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsLinearType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsLinearType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsAngularType
    //

    const SummaryStatisticsAngularType::angularUnit_optional& SummaryStatisticsAngularType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    SummaryStatisticsAngularType::angularUnit_optional& SummaryStatisticsAngularType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void SummaryStatisticsAngularType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void SummaryStatisticsAngularType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void SummaryStatisticsAngularType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // SummariesStatisticsAngularType
    //

    const SummariesStatisticsAngularType::AngularStatsSummary_sequence& SummariesStatisticsAngularType::
    AngularStatsSummary () const
    {
      return this->AngularStatsSummary_;
    }

    SummariesStatisticsAngularType::AngularStatsSummary_sequence& SummariesStatisticsAngularType::
    AngularStatsSummary ()
    {
      return this->AngularStatsSummary_;
    }

    void SummariesStatisticsAngularType::
    AngularStatsSummary (const AngularStatsSummary_sequence& s)
    {
      this->AngularStatsSummary_ = s;
    }

    const SummariesStatisticsAngularType::n_type& SummariesStatisticsAngularType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsAngularType::n_type& SummariesStatisticsAngularType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsAngularType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsAngularType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsAreaType
    //

    const SummaryStatisticsAreaType::areaUnit_optional& SummaryStatisticsAreaType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    SummaryStatisticsAreaType::areaUnit_optional& SummaryStatisticsAreaType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void SummaryStatisticsAreaType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void SummaryStatisticsAreaType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void SummaryStatisticsAreaType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // SummariesStatisticsAreaType
    //

    const SummariesStatisticsAreaType::AreaStatsSummary_sequence& SummariesStatisticsAreaType::
    AreaStatsSummary () const
    {
      return this->AreaStatsSummary_;
    }

    SummariesStatisticsAreaType::AreaStatsSummary_sequence& SummariesStatisticsAreaType::
    AreaStatsSummary ()
    {
      return this->AreaStatsSummary_;
    }

    void SummariesStatisticsAreaType::
    AreaStatsSummary (const AreaStatsSummary_sequence& s)
    {
      this->AreaStatsSummary_ = s;
    }

    const SummariesStatisticsAreaType::n_type& SummariesStatisticsAreaType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsAreaType::n_type& SummariesStatisticsAreaType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsAreaType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsAreaType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsForceType
    //

    const SummaryStatisticsForceType::forceUnit_optional& SummaryStatisticsForceType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    SummaryStatisticsForceType::forceUnit_optional& SummaryStatisticsForceType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void SummaryStatisticsForceType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void SummaryStatisticsForceType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void SummaryStatisticsForceType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // SummariesStatisticsForceType
    //

    const SummariesStatisticsForceType::ForceStatsSummary_sequence& SummariesStatisticsForceType::
    ForceStatsSummary () const
    {
      return this->ForceStatsSummary_;
    }

    SummariesStatisticsForceType::ForceStatsSummary_sequence& SummariesStatisticsForceType::
    ForceStatsSummary ()
    {
      return this->ForceStatsSummary_;
    }

    void SummariesStatisticsForceType::
    ForceStatsSummary (const ForceStatsSummary_sequence& s)
    {
      this->ForceStatsSummary_ = s;
    }

    const SummariesStatisticsForceType::n_type& SummariesStatisticsForceType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsForceType::n_type& SummariesStatisticsForceType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsForceType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsForceType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsMassType
    //

    const SummaryStatisticsMassType::massUnit_optional& SummaryStatisticsMassType::
    massUnit () const
    {
      return this->massUnit_;
    }

    SummaryStatisticsMassType::massUnit_optional& SummaryStatisticsMassType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void SummaryStatisticsMassType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void SummaryStatisticsMassType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void SummaryStatisticsMassType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // SummariesStatisticsMassType
    //

    const SummariesStatisticsMassType::MassStatsSummary_sequence& SummariesStatisticsMassType::
    MassStatsSummary () const
    {
      return this->MassStatsSummary_;
    }

    SummariesStatisticsMassType::MassStatsSummary_sequence& SummariesStatisticsMassType::
    MassStatsSummary ()
    {
      return this->MassStatsSummary_;
    }

    void SummariesStatisticsMassType::
    MassStatsSummary (const MassStatsSummary_sequence& s)
    {
      this->MassStatsSummary_ = s;
    }

    const SummariesStatisticsMassType::n_type& SummariesStatisticsMassType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsMassType::n_type& SummariesStatisticsMassType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsMassType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsMassType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsPressureType
    //

    const SummaryStatisticsPressureType::pressureUnit_optional& SummaryStatisticsPressureType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    SummaryStatisticsPressureType::pressureUnit_optional& SummaryStatisticsPressureType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void SummaryStatisticsPressureType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void SummaryStatisticsPressureType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void SummaryStatisticsPressureType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // SummariesStatisticsPressureType
    //

    const SummariesStatisticsPressureType::PressureStatsSummary_sequence& SummariesStatisticsPressureType::
    PressureStatsSummary () const
    {
      return this->PressureStatsSummary_;
    }

    SummariesStatisticsPressureType::PressureStatsSummary_sequence& SummariesStatisticsPressureType::
    PressureStatsSummary ()
    {
      return this->PressureStatsSummary_;
    }

    void SummariesStatisticsPressureType::
    PressureStatsSummary (const PressureStatsSummary_sequence& s)
    {
      this->PressureStatsSummary_ = s;
    }

    const SummariesStatisticsPressureType::n_type& SummariesStatisticsPressureType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsPressureType::n_type& SummariesStatisticsPressureType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsPressureType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsPressureType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsSpeedType
    //

    const SummaryStatisticsSpeedType::speedUnit_optional& SummaryStatisticsSpeedType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    SummaryStatisticsSpeedType::speedUnit_optional& SummaryStatisticsSpeedType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void SummaryStatisticsSpeedType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void SummaryStatisticsSpeedType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void SummaryStatisticsSpeedType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // SummariesStatisticsSpeedType
    //

    const SummariesStatisticsSpeedType::SpeedStatsSummary_sequence& SummariesStatisticsSpeedType::
    SpeedStatsSummary () const
    {
      return this->SpeedStatsSummary_;
    }

    SummariesStatisticsSpeedType::SpeedStatsSummary_sequence& SummariesStatisticsSpeedType::
    SpeedStatsSummary ()
    {
      return this->SpeedStatsSummary_;
    }

    void SummariesStatisticsSpeedType::
    SpeedStatsSummary (const SpeedStatsSummary_sequence& s)
    {
      this->SpeedStatsSummary_ = s;
    }

    const SummariesStatisticsSpeedType::n_type& SummariesStatisticsSpeedType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsSpeedType::n_type& SummariesStatisticsSpeedType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsSpeedType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsSpeedType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsTemperatureType
    //

    const SummaryStatisticsTemperatureType::temperatureUnit_optional& SummaryStatisticsTemperatureType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    SummaryStatisticsTemperatureType::temperatureUnit_optional& SummaryStatisticsTemperatureType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void SummaryStatisticsTemperatureType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void SummaryStatisticsTemperatureType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void SummaryStatisticsTemperatureType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // SummariesStatisticsTemperatureType
    //

    const SummariesStatisticsTemperatureType::TemperatureStatsSummary_sequence& SummariesStatisticsTemperatureType::
    TemperatureStatsSummary () const
    {
      return this->TemperatureStatsSummary_;
    }

    SummariesStatisticsTemperatureType::TemperatureStatsSummary_sequence& SummariesStatisticsTemperatureType::
    TemperatureStatsSummary ()
    {
      return this->TemperatureStatsSummary_;
    }

    void SummariesStatisticsTemperatureType::
    TemperatureStatsSummary (const TemperatureStatsSummary_sequence& s)
    {
      this->TemperatureStatsSummary_ = s;
    }

    const SummariesStatisticsTemperatureType::n_type& SummariesStatisticsTemperatureType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsTemperatureType::n_type& SummariesStatisticsTemperatureType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsTemperatureType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsTemperatureType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsTimeType
    //

    const SummaryStatisticsTimeType::timeUnit_optional& SummaryStatisticsTimeType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    SummaryStatisticsTimeType::timeUnit_optional& SummaryStatisticsTimeType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void SummaryStatisticsTimeType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void SummaryStatisticsTimeType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void SummaryStatisticsTimeType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // SummariesStatisticsTimeType
    //

    const SummariesStatisticsTimeType::TimeStatsSummary_sequence& SummariesStatisticsTimeType::
    TimeStatsSummary () const
    {
      return this->TimeStatsSummary_;
    }

    SummariesStatisticsTimeType::TimeStatsSummary_sequence& SummariesStatisticsTimeType::
    TimeStatsSummary ()
    {
      return this->TimeStatsSummary_;
    }

    void SummariesStatisticsTimeType::
    TimeStatsSummary (const TimeStatsSummary_sequence& s)
    {
      this->TimeStatsSummary_ = s;
    }

    const SummariesStatisticsTimeType::n_type& SummariesStatisticsTimeType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsTimeType::n_type& SummariesStatisticsTimeType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsTimeType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsTimeType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SummaryStatisticsUserDefinedUnitType
    //

    const SummaryStatisticsUserDefinedUnitType::unitName_type& SummaryStatisticsUserDefinedUnitType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    SummaryStatisticsUserDefinedUnitType::unitName_type& SummaryStatisticsUserDefinedUnitType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void SummaryStatisticsUserDefinedUnitType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void SummaryStatisticsUserDefinedUnitType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // SummariesStatisticsUserDefinedUnitType
    //

    const SummariesStatisticsUserDefinedUnitType::UserDefinedUnitStatsSummary_sequence& SummariesStatisticsUserDefinedUnitType::
    UserDefinedUnitStatsSummary () const
    {
      return this->UserDefinedUnitStatsSummary_;
    }

    SummariesStatisticsUserDefinedUnitType::UserDefinedUnitStatsSummary_sequence& SummariesStatisticsUserDefinedUnitType::
    UserDefinedUnitStatsSummary ()
    {
      return this->UserDefinedUnitStatsSummary_;
    }

    void SummariesStatisticsUserDefinedUnitType::
    UserDefinedUnitStatsSummary (const UserDefinedUnitStatsSummary_sequence& s)
    {
      this->UserDefinedUnitStatsSummary_ = s;
    }

    const SummariesStatisticsUserDefinedUnitType::n_type& SummariesStatisticsUserDefinedUnitType::
    n () const
    {
      return this->n_.get ();
    }

    SummariesStatisticsUserDefinedUnitType::n_type& SummariesStatisticsUserDefinedUnitType::
    n ()
    {
      return this->n_.get ();
    }

    void SummariesStatisticsUserDefinedUnitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummariesStatisticsUserDefinedUnitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AssignableCauseEnumType
    //

    AssignableCauseEnumType::
    AssignableCauseEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AssignableCauseEnumType_literals_[v])
    {
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const AssignableCauseEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AssignableCauseEnumType& AssignableCauseEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AssignableCauseEnumType_literals_[v]);

      return *this;
    }


    // AssignableCauseType
    //

    const AssignableCauseType::Attributes_optional& AssignableCauseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AssignableCauseType::Attributes_optional& AssignableCauseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AssignableCauseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AssignableCauseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AssignableCauseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const AssignableCauseType::Description_optional& AssignableCauseType::
    Description () const
    {
      return this->Description_;
    }

    AssignableCauseType::Description_optional& AssignableCauseType::
    Description ()
    {
      return this->Description_;
    }

    void AssignableCauseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void AssignableCauseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void AssignableCauseType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const AssignableCauseType::AssignableCauseEnum_optional& AssignableCauseType::
    AssignableCauseEnum () const
    {
      return this->AssignableCauseEnum_;
    }

    AssignableCauseType::AssignableCauseEnum_optional& AssignableCauseType::
    AssignableCauseEnum ()
    {
      return this->AssignableCauseEnum_;
    }

    void AssignableCauseType::
    AssignableCauseEnum (const AssignableCauseEnum_type& x)
    {
      this->AssignableCauseEnum_.set (x);
    }

    void AssignableCauseType::
    AssignableCauseEnum (const AssignableCauseEnum_optional& x)
    {
      this->AssignableCauseEnum_ = x;
    }

    void AssignableCauseType::
    AssignableCauseEnum (::std::unique_ptr< AssignableCauseEnum_type > x)
    {
      this->AssignableCauseEnum_.set (std::move (x));
    }

    const AssignableCauseType::CorrectiveActionIds_optional& AssignableCauseType::
    CorrectiveActionIds () const
    {
      return this->CorrectiveActionIds_;
    }

    AssignableCauseType::CorrectiveActionIds_optional& AssignableCauseType::
    CorrectiveActionIds ()
    {
      return this->CorrectiveActionIds_;
    }

    void AssignableCauseType::
    CorrectiveActionIds (const CorrectiveActionIds_type& x)
    {
      this->CorrectiveActionIds_.set (x);
    }

    void AssignableCauseType::
    CorrectiveActionIds (const CorrectiveActionIds_optional& x)
    {
      this->CorrectiveActionIds_ = x;
    }

    void AssignableCauseType::
    CorrectiveActionIds (::std::unique_ptr< CorrectiveActionIds_type > x)
    {
      this->CorrectiveActionIds_.set (std::move (x));
    }

    const AssignableCauseType::id_type& AssignableCauseType::
    id () const
    {
      return this->id_.get ();
    }

    AssignableCauseType::id_type& AssignableCauseType::
    id ()
    {
      return this->id_.get ();
    }

    void AssignableCauseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AssignableCauseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // AssignableCausesType
    //

    const AssignableCausesType::AssignableCause_sequence& AssignableCausesType::
    AssignableCause () const
    {
      return this->AssignableCause_;
    }

    AssignableCausesType::AssignableCause_sequence& AssignableCausesType::
    AssignableCause ()
    {
      return this->AssignableCause_;
    }

    void AssignableCausesType::
    AssignableCause (const AssignableCause_sequence& s)
    {
      this->AssignableCause_ = s;
    }

    const AssignableCausesType::n_type& AssignableCausesType::
    n () const
    {
      return this->n_.get ();
    }

    AssignableCausesType::n_type& AssignableCausesType::
    n ()
    {
      return this->n_.get ();
    }

    void AssignableCausesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AssignableCausesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ActionToTakeEnumType
    //

    ActionToTakeEnumType::
    ActionToTakeEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ActionToTakeEnumType_literals_[v])
    {
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const ActionToTakeEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ActionToTakeEnumType& ActionToTakeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ActionToTakeEnumType_literals_[v]);

      return *this;
    }


    // CorrectiveActionType
    //

    const CorrectiveActionType::Attributes_optional& CorrectiveActionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    CorrectiveActionType::Attributes_optional& CorrectiveActionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void CorrectiveActionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void CorrectiveActionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void CorrectiveActionType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const CorrectiveActionType::ActionToTake_optional& CorrectiveActionType::
    ActionToTake () const
    {
      return this->ActionToTake_;
    }

    CorrectiveActionType::ActionToTake_optional& CorrectiveActionType::
    ActionToTake ()
    {
      return this->ActionToTake_;
    }

    void CorrectiveActionType::
    ActionToTake (const ActionToTake_type& x)
    {
      this->ActionToTake_.set (x);
    }

    void CorrectiveActionType::
    ActionToTake (const ActionToTake_optional& x)
    {
      this->ActionToTake_ = x;
    }

    void CorrectiveActionType::
    ActionToTake (::std::unique_ptr< ActionToTake_type > x)
    {
      this->ActionToTake_.set (std::move (x));
    }

    const CorrectiveActionType::ActionToTakeEnum_optional& CorrectiveActionType::
    ActionToTakeEnum () const
    {
      return this->ActionToTakeEnum_;
    }

    CorrectiveActionType::ActionToTakeEnum_optional& CorrectiveActionType::
    ActionToTakeEnum ()
    {
      return this->ActionToTakeEnum_;
    }

    void CorrectiveActionType::
    ActionToTakeEnum (const ActionToTakeEnum_type& x)
    {
      this->ActionToTakeEnum_.set (x);
    }

    void CorrectiveActionType::
    ActionToTakeEnum (const ActionToTakeEnum_optional& x)
    {
      this->ActionToTakeEnum_ = x;
    }

    void CorrectiveActionType::
    ActionToTakeEnum (::std::unique_ptr< ActionToTakeEnum_type > x)
    {
      this->ActionToTakeEnum_.set (std::move (x));
    }

    const CorrectiveActionType::id_type& CorrectiveActionType::
    id () const
    {
      return this->id_.get ();
    }

    CorrectiveActionType::id_type& CorrectiveActionType::
    id ()
    {
      return this->id_.get ();
    }

    void CorrectiveActionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void CorrectiveActionType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CorrectiveActionsType
    //

    const CorrectiveActionsType::CorrectiveAction_sequence& CorrectiveActionsType::
    CorrectiveAction () const
    {
      return this->CorrectiveAction_;
    }

    CorrectiveActionsType::CorrectiveAction_sequence& CorrectiveActionsType::
    CorrectiveAction ()
    {
      return this->CorrectiveAction_;
    }

    void CorrectiveActionsType::
    CorrectiveAction (const CorrectiveAction_sequence& s)
    {
      this->CorrectiveAction_ = s;
    }

    const CorrectiveActionsType::n_type& CorrectiveActionsType::
    n () const
    {
      return this->n_.get ();
    }

    CorrectiveActionsType::n_type& CorrectiveActionsType::
    n ()
    {
      return this->n_.get ();
    }

    void CorrectiveActionsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CorrectiveActionsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // StudyIssueType
    //

    const StudyIssueType::Traceability_optional& StudyIssueType::
    Traceability () const
    {
      return this->Traceability_;
    }

    StudyIssueType::Traceability_optional& StudyIssueType::
    Traceability ()
    {
      return this->Traceability_;
    }

    void StudyIssueType::
    Traceability (const Traceability_type& x)
    {
      this->Traceability_.set (x);
    }

    void StudyIssueType::
    Traceability (const Traceability_optional& x)
    {
      this->Traceability_ = x;
    }

    void StudyIssueType::
    Traceability (::std::unique_ptr< Traceability_type > x)
    {
      this->Traceability_.set (std::move (x));
    }

    const StudyIssueType::AssignableCauseIds_optional& StudyIssueType::
    AssignableCauseIds () const
    {
      return this->AssignableCauseIds_;
    }

    StudyIssueType::AssignableCauseIds_optional& StudyIssueType::
    AssignableCauseIds ()
    {
      return this->AssignableCauseIds_;
    }

    void StudyIssueType::
    AssignableCauseIds (const AssignableCauseIds_type& x)
    {
      this->AssignableCauseIds_.set (x);
    }

    void StudyIssueType::
    AssignableCauseIds (const AssignableCauseIds_optional& x)
    {
      this->AssignableCauseIds_ = x;
    }

    void StudyIssueType::
    AssignableCauseIds (::std::unique_ptr< AssignableCauseIds_type > x)
    {
      this->AssignableCauseIds_.set (std::move (x));
    }

    const StudyIssueType::CorrectiveActionIds_optional& StudyIssueType::
    CorrectiveActionIds () const
    {
      return this->CorrectiveActionIds_;
    }

    StudyIssueType::CorrectiveActionIds_optional& StudyIssueType::
    CorrectiveActionIds ()
    {
      return this->CorrectiveActionIds_;
    }

    void StudyIssueType::
    CorrectiveActionIds (const CorrectiveActionIds_type& x)
    {
      this->CorrectiveActionIds_.set (x);
    }

    void StudyIssueType::
    CorrectiveActionIds (const CorrectiveActionIds_optional& x)
    {
      this->CorrectiveActionIds_ = x;
    }

    void StudyIssueType::
    CorrectiveActionIds (::std::unique_ptr< CorrectiveActionIds_type > x)
    {
      this->CorrectiveActionIds_.set (std::move (x));
    }

    const StudyIssueType::Resolution_optional& StudyIssueType::
    Resolution () const
    {
      return this->Resolution_;
    }

    StudyIssueType::Resolution_optional& StudyIssueType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void StudyIssueType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void StudyIssueType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void StudyIssueType::
    Resolution (::std::unique_ptr< Resolution_type > x)
    {
      this->Resolution_.set (std::move (x));
    }

    const StudyIssueType::CharacteristicMeasurementIds_optional& StudyIssueType::
    CharacteristicMeasurementIds () const
    {
      return this->CharacteristicMeasurementIds_;
    }

    StudyIssueType::CharacteristicMeasurementIds_optional& StudyIssueType::
    CharacteristicMeasurementIds ()
    {
      return this->CharacteristicMeasurementIds_;
    }

    void StudyIssueType::
    CharacteristicMeasurementIds (const CharacteristicMeasurementIds_type& x)
    {
      this->CharacteristicMeasurementIds_.set (x);
    }

    void StudyIssueType::
    CharacteristicMeasurementIds (const CharacteristicMeasurementIds_optional& x)
    {
      this->CharacteristicMeasurementIds_ = x;
    }

    void StudyIssueType::
    CharacteristicMeasurementIds (::std::unique_ptr< CharacteristicMeasurementIds_type > x)
    {
      this->CharacteristicMeasurementIds_.set (std::move (x));
    }

    const StudyIssueType::SubgroupIds_optional& StudyIssueType::
    SubgroupIds () const
    {
      return this->SubgroupIds_;
    }

    StudyIssueType::SubgroupIds_optional& StudyIssueType::
    SubgroupIds ()
    {
      return this->SubgroupIds_;
    }

    void StudyIssueType::
    SubgroupIds (const SubgroupIds_type& x)
    {
      this->SubgroupIds_.set (x);
    }

    void StudyIssueType::
    SubgroupIds (const SubgroupIds_optional& x)
    {
      this->SubgroupIds_ = x;
    }

    void StudyIssueType::
    SubgroupIds (::std::unique_ptr< SubgroupIds_type > x)
    {
      this->SubgroupIds_.set (std::move (x));
    }

    const StudyIssueType::id_type& StudyIssueType::
    id () const
    {
      return this->id_.get ();
    }

    StudyIssueType::id_type& StudyIssueType::
    id ()
    {
      return this->id_.get ();
    }

    void StudyIssueType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void StudyIssueType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ControlIssueEnumType
    //

    ControlIssueEnumType::
    ControlIssueEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ControlIssueEnumType::
    ControlIssueEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ControlIssueEnumType_literals_[v])
    {
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const ControlIssueEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ControlIssueEnumType& ControlIssueEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ControlIssueEnumType_literals_[v]);

      return *this;
    }


    // ControlIssueType
    //

    const ControlIssueType::ControlIssueEnum_optional& ControlIssueType::
    ControlIssueEnum () const
    {
      return this->ControlIssueEnum_;
    }

    ControlIssueType::ControlIssueEnum_optional& ControlIssueType::
    ControlIssueEnum ()
    {
      return this->ControlIssueEnum_;
    }

    void ControlIssueType::
    ControlIssueEnum (const ControlIssueEnum_type& x)
    {
      this->ControlIssueEnum_.set (x);
    }

    void ControlIssueType::
    ControlIssueEnum (const ControlIssueEnum_optional& x)
    {
      this->ControlIssueEnum_ = x;
    }

    void ControlIssueType::
    ControlIssueEnum (::std::unique_ptr< ControlIssueEnum_type > x)
    {
      this->ControlIssueEnum_.set (std::move (x));
    }

    const ControlIssueType::OtherControlIssue_optional& ControlIssueType::
    OtherControlIssue () const
    {
      return this->OtherControlIssue_;
    }

    ControlIssueType::OtherControlIssue_optional& ControlIssueType::
    OtherControlIssue ()
    {
      return this->OtherControlIssue_;
    }

    void ControlIssueType::
    OtherControlIssue (const OtherControlIssue_type& x)
    {
      this->OtherControlIssue_.set (x);
    }

    void ControlIssueType::
    OtherControlIssue (const OtherControlIssue_optional& x)
    {
      this->OtherControlIssue_ = x;
    }

    void ControlIssueType::
    OtherControlIssue (::std::unique_ptr< OtherControlIssue_type > x)
    {
      this->OtherControlIssue_.set (std::move (x));
    }


    // ControlIssueDetailsType
    //

    const ControlIssueDetailsType::ControlIssue_type& ControlIssueDetailsType::
    ControlIssue () const
    {
      return this->ControlIssue_.get ();
    }

    ControlIssueDetailsType::ControlIssue_type& ControlIssueDetailsType::
    ControlIssue ()
    {
      return this->ControlIssue_.get ();
    }

    void ControlIssueDetailsType::
    ControlIssue (const ControlIssue_type& x)
    {
      this->ControlIssue_.set (x);
    }

    void ControlIssueDetailsType::
    ControlIssue (::std::unique_ptr< ControlIssue_type > x)
    {
      this->ControlIssue_.set (std::move (x));
    }

    const ControlIssueDetailsType::ControlMethodId_optional& ControlIssueDetailsType::
    ControlMethodId () const
    {
      return this->ControlMethodId_;
    }

    ControlIssueDetailsType::ControlMethodId_optional& ControlIssueDetailsType::
    ControlMethodId ()
    {
      return this->ControlMethodId_;
    }

    void ControlIssueDetailsType::
    ControlMethodId (const ControlMethodId_type& x)
    {
      this->ControlMethodId_.set (x);
    }

    void ControlIssueDetailsType::
    ControlMethodId (const ControlMethodId_optional& x)
    {
      this->ControlMethodId_ = x;
    }

    void ControlIssueDetailsType::
    ControlMethodId (::std::unique_ptr< ControlMethodId_type > x)
    {
      this->ControlMethodId_.set (std::move (x));
    }

    const ControlIssueDetailsType::StudyIssueId_optional& ControlIssueDetailsType::
    StudyIssueId () const
    {
      return this->StudyIssueId_;
    }

    ControlIssueDetailsType::StudyIssueId_optional& ControlIssueDetailsType::
    StudyIssueId ()
    {
      return this->StudyIssueId_;
    }

    void ControlIssueDetailsType::
    StudyIssueId (const StudyIssueId_type& x)
    {
      this->StudyIssueId_.set (x);
    }

    void ControlIssueDetailsType::
    StudyIssueId (const StudyIssueId_optional& x)
    {
      this->StudyIssueId_ = x;
    }

    void ControlIssueDetailsType::
    StudyIssueId (::std::unique_ptr< StudyIssueId_type > x)
    {
      this->StudyIssueId_.set (std::move (x));
    }


    // ControlIssueDetailsListType
    //

    const ControlIssueDetailsListType::ControlIssueDetails_sequence& ControlIssueDetailsListType::
    ControlIssueDetails () const
    {
      return this->ControlIssueDetails_;
    }

    ControlIssueDetailsListType::ControlIssueDetails_sequence& ControlIssueDetailsListType::
    ControlIssueDetails ()
    {
      return this->ControlIssueDetails_;
    }

    void ControlIssueDetailsListType::
    ControlIssueDetails (const ControlIssueDetails_sequence& s)
    {
      this->ControlIssueDetails_ = s;
    }

    const ControlIssueDetailsListType::n_type& ControlIssueDetailsListType::
    n () const
    {
      return this->n_.get ();
    }

    ControlIssueDetailsListType::n_type& ControlIssueDetailsListType::
    n ()
    {
      return this->n_.get ();
    }

    void ControlIssueDetailsListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ControlIssueDetailsListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // LimitingNumberType
    //

    LimitingNumberType::
    LimitingNumberType ()
    : ::xml_schema::type (),
      Count_ (this),
      Fraction_ (this)
    {
    }

    LimitingNumberType::
    LimitingNumberType (const LimitingNumberType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Count_ (x.Count_, f, this),
      Fraction_ (x.Fraction_, f, this)
    {
    }

    LimitingNumberType::
    LimitingNumberType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Count_ (this),
      Fraction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LimitingNumberType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Count
        //
        if (n.name () == L"Count" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Count_)
          {
            this->Count_.set (Count_traits::create (i, f, this));
            continue;
          }
        }

        // Fraction
        //
        if (n.name () == L"Fraction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Fraction_)
          {
            this->Fraction_.set (Fraction_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    LimitingNumberType* LimitingNumberType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LimitingNumberType (*this, f, c);
    }

    LimitingNumberType& LimitingNumberType::
    operator= (const LimitingNumberType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Count_ = x.Count_;
        this->Fraction_ = x.Fraction_;
      }

      return *this;
    }

    LimitingNumberType::
    ~LimitingNumberType ()
    {
    }

    // CriterionDecimalType
    //

    CriterionDecimalType::
    CriterionDecimalType ()
    : ::xml_schema::type (),
      Limit_ (this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
    }

    CriterionDecimalType::
    CriterionDecimalType (const Limit_type& Limit)
    : ::xml_schema::type (),
      Limit_ (Limit, this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
    }

    CriterionDecimalType::
    CriterionDecimalType (const CriterionDecimalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Limit_ (x.Limit_, f, this),
      NumberAllowedExceptions_ (x.NumberAllowedExceptions_, f, this),
      ExtremeLimit_ (x.ExtremeLimit_, f, this)
    {
    }

    CriterionDecimalType::
    CriterionDecimalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Limit_ (this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CriterionDecimalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Limit
        //
        if (n.name () == L"Limit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Limit_.present ())
          {
            this->Limit_.set (Limit_traits::create (i, f, this));
            continue;
          }
        }

        // NumberAllowedExceptions
        //
        if (n.name () == L"NumberAllowedExceptions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberAllowedExceptions_type > r (
            NumberAllowedExceptions_traits::create (i, f, this));

          if (!this->NumberAllowedExceptions_)
          {
            this->NumberAllowedExceptions_.set (::std::move (r));
            continue;
          }
        }

        // ExtremeLimit
        //
        if (n.name () == L"ExtremeLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ExtremeLimit_)
          {
            this->ExtremeLimit_.set (ExtremeLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Limit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Limit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CriterionDecimalType* CriterionDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionDecimalType (*this, f, c);
    }

    CriterionDecimalType& CriterionDecimalType::
    operator= (const CriterionDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Limit_ = x.Limit_;
        this->NumberAllowedExceptions_ = x.NumberAllowedExceptions_;
        this->ExtremeLimit_ = x.ExtremeLimit_;
      }

      return *this;
    }

    CriterionDecimalType::
    ~CriterionDecimalType ()
    {
    }

    // CriterionLinearType
    //

    CriterionLinearType::
    CriterionLinearType ()
    : ::xsd::qif30::CriterionDecimalType (),
      linearUnit_ (this)
    {
    }

    CriterionLinearType::
    CriterionLinearType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      linearUnit_ (this)
    {
    }

    CriterionLinearType::
    CriterionLinearType (const CriterionLinearType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    CriterionLinearType::
    CriterionLinearType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionLinearType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionLinearType* CriterionLinearType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionLinearType (*this, f, c);
    }

    CriterionLinearType& CriterionLinearType::
    operator= (const CriterionLinearType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    CriterionLinearType::
    ~CriterionLinearType ()
    {
    }

    // CriterionAngularType
    //

    CriterionAngularType::
    CriterionAngularType ()
    : ::xsd::qif30::CriterionDecimalType (),
      angularUnit_ (this)
    {
    }

    CriterionAngularType::
    CriterionAngularType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      angularUnit_ (this)
    {
    }

    CriterionAngularType::
    CriterionAngularType (const CriterionAngularType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    CriterionAngularType::
    CriterionAngularType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionAngularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionAngularType* CriterionAngularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionAngularType (*this, f, c);
    }

    CriterionAngularType& CriterionAngularType::
    operator= (const CriterionAngularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    CriterionAngularType::
    ~CriterionAngularType ()
    {
    }

    // CriterionAreaType
    //

    CriterionAreaType::
    CriterionAreaType ()
    : ::xsd::qif30::CriterionDecimalType (),
      areaUnit_ (this)
    {
    }

    CriterionAreaType::
    CriterionAreaType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      areaUnit_ (this)
    {
    }

    CriterionAreaType::
    CriterionAreaType (const CriterionAreaType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    CriterionAreaType::
    CriterionAreaType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionAreaType* CriterionAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionAreaType (*this, f, c);
    }

    CriterionAreaType& CriterionAreaType::
    operator= (const CriterionAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    CriterionAreaType::
    ~CriterionAreaType ()
    {
    }

    // CriterionForceType
    //

    CriterionForceType::
    CriterionForceType ()
    : ::xsd::qif30::CriterionDecimalType (),
      forceUnit_ (this)
    {
    }

    CriterionForceType::
    CriterionForceType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      forceUnit_ (this)
    {
    }

    CriterionForceType::
    CriterionForceType (const CriterionForceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    CriterionForceType::
    CriterionForceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionForceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionForceType* CriterionForceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionForceType (*this, f, c);
    }

    CriterionForceType& CriterionForceType::
    operator= (const CriterionForceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    CriterionForceType::
    ~CriterionForceType ()
    {
    }

    // CriterionMassType
    //

    CriterionMassType::
    CriterionMassType ()
    : ::xsd::qif30::CriterionDecimalType (),
      massUnit_ (this)
    {
    }

    CriterionMassType::
    CriterionMassType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      massUnit_ (this)
    {
    }

    CriterionMassType::
    CriterionMassType (const CriterionMassType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    CriterionMassType::
    CriterionMassType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionMassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionMassType* CriterionMassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionMassType (*this, f, c);
    }

    CriterionMassType& CriterionMassType::
    operator= (const CriterionMassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    CriterionMassType::
    ~CriterionMassType ()
    {
    }

    // CriterionPressureType
    //

    CriterionPressureType::
    CriterionPressureType ()
    : ::xsd::qif30::CriterionDecimalType (),
      pressureUnit_ (this)
    {
    }

    CriterionPressureType::
    CriterionPressureType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      pressureUnit_ (this)
    {
    }

    CriterionPressureType::
    CriterionPressureType (const CriterionPressureType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    CriterionPressureType::
    CriterionPressureType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionPressureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionPressureType* CriterionPressureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionPressureType (*this, f, c);
    }

    CriterionPressureType& CriterionPressureType::
    operator= (const CriterionPressureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    CriterionPressureType::
    ~CriterionPressureType ()
    {
    }

    // CriterionSpeedType
    //

    CriterionSpeedType::
    CriterionSpeedType ()
    : ::xsd::qif30::CriterionDecimalType (),
      speedUnit_ (this)
    {
    }

    CriterionSpeedType::
    CriterionSpeedType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      speedUnit_ (this)
    {
    }

    CriterionSpeedType::
    CriterionSpeedType (const CriterionSpeedType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    CriterionSpeedType::
    CriterionSpeedType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionSpeedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionSpeedType* CriterionSpeedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionSpeedType (*this, f, c);
    }

    CriterionSpeedType& CriterionSpeedType::
    operator= (const CriterionSpeedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    CriterionSpeedType::
    ~CriterionSpeedType ()
    {
    }

    // CriterionTemperatureType
    //

    CriterionTemperatureType::
    CriterionTemperatureType ()
    : ::xsd::qif30::CriterionDecimalType (),
      temperatureUnit_ (this)
    {
    }

    CriterionTemperatureType::
    CriterionTemperatureType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      temperatureUnit_ (this)
    {
    }

    CriterionTemperatureType::
    CriterionTemperatureType (const CriterionTemperatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    CriterionTemperatureType::
    CriterionTemperatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionTemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionTemperatureType* CriterionTemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionTemperatureType (*this, f, c);
    }

    CriterionTemperatureType& CriterionTemperatureType::
    operator= (const CriterionTemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    CriterionTemperatureType::
    ~CriterionTemperatureType ()
    {
    }

    // CriterionTimeType
    //

    CriterionTimeType::
    CriterionTimeType ()
    : ::xsd::qif30::CriterionDecimalType (),
      timeUnit_ (this)
    {
    }

    CriterionTimeType::
    CriterionTimeType (const Limit_type& Limit)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      timeUnit_ (this)
    {
    }

    CriterionTimeType::
    CriterionTimeType (const CriterionTimeType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    CriterionTimeType::
    CriterionTimeType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    CriterionTimeType* CriterionTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionTimeType (*this, f, c);
    }

    CriterionTimeType& CriterionTimeType::
    operator= (const CriterionTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    CriterionTimeType::
    ~CriterionTimeType ()
    {
    }

    // CriterionUserDefinedUnitType
    //

    CriterionUserDefinedUnitType::
    CriterionUserDefinedUnitType ()
    : ::xsd::qif30::CriterionDecimalType (),
      unitName_ (this)
    {
    }

    CriterionUserDefinedUnitType::
    CriterionUserDefinedUnitType (const Limit_type& Limit,
                                  const unitName_type& unitName)
    : ::xsd::qif30::CriterionDecimalType (Limit),
      unitName_ (unitName, this)
    {
    }

    CriterionUserDefinedUnitType::
    CriterionUserDefinedUnitType (const CriterionUserDefinedUnitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    CriterionUserDefinedUnitType::
    CriterionUserDefinedUnitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CriterionDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriterionUserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CriterionDecimalType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    CriterionUserDefinedUnitType* CriterionUserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionUserDefinedUnitType (*this, f, c);
    }

    CriterionUserDefinedUnitType& CriterionUserDefinedUnitType::
    operator= (const CriterionUserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CriterionDecimalType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    CriterionUserDefinedUnitType::
    ~CriterionUserDefinedUnitType ()
    {
    }

    // CriterionIntegerType
    //

    CriterionIntegerType::
    CriterionIntegerType ()
    : ::xml_schema::type (),
      Limit_ (this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
    }

    CriterionIntegerType::
    CriterionIntegerType (const Limit_type& Limit)
    : ::xml_schema::type (),
      Limit_ (Limit, this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
    }

    CriterionIntegerType::
    CriterionIntegerType (const CriterionIntegerType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Limit_ (x.Limit_, f, this),
      NumberAllowedExceptions_ (x.NumberAllowedExceptions_, f, this),
      ExtremeLimit_ (x.ExtremeLimit_, f, this)
    {
    }

    CriterionIntegerType::
    CriterionIntegerType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Limit_ (this),
      NumberAllowedExceptions_ (this),
      ExtremeLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CriterionIntegerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Limit
        //
        if (n.name () == L"Limit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Limit_.present ())
          {
            this->Limit_.set (Limit_traits::create (i, f, this));
            continue;
          }
        }

        // NumberAllowedExceptions
        //
        if (n.name () == L"NumberAllowedExceptions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberAllowedExceptions_type > r (
            NumberAllowedExceptions_traits::create (i, f, this));

          if (!this->NumberAllowedExceptions_)
          {
            this->NumberAllowedExceptions_.set (::std::move (r));
            continue;
          }
        }

        // ExtremeLimit
        //
        if (n.name () == L"ExtremeLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ExtremeLimit_)
          {
            this->ExtremeLimit_.set (ExtremeLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Limit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Limit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CriterionIntegerType* CriterionIntegerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionIntegerType (*this, f, c);
    }

    CriterionIntegerType& CriterionIntegerType::
    operator= (const CriterionIntegerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Limit_ = x.Limit_;
        this->NumberAllowedExceptions_ = x.NumberAllowedExceptions_;
        this->ExtremeLimit_ = x.ExtremeLimit_;
      }

      return *this;
    }

    CriterionIntegerType::
    ~CriterionIntegerType ()
    {
    }

    // CriterionOutOfType
    //

    CriterionOutOfType::
    CriterionOutOfType ()
    : ::xml_schema::type (),
      Numerator_ (this),
      Denominator_ (this),
      NumberAllowedExceptions_ (this)
    {
    }

    CriterionOutOfType::
    CriterionOutOfType (const Numerator_type& Numerator,
                        const Denominator_type& Denominator)
    : ::xml_schema::type (),
      Numerator_ (Numerator, this),
      Denominator_ (Denominator, this),
      NumberAllowedExceptions_ (this)
    {
    }

    CriterionOutOfType::
    CriterionOutOfType (const CriterionOutOfType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Numerator_ (x.Numerator_, f, this),
      Denominator_ (x.Denominator_, f, this),
      NumberAllowedExceptions_ (x.NumberAllowedExceptions_, f, this)
    {
    }

    CriterionOutOfType::
    CriterionOutOfType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Numerator_ (this),
      Denominator_ (this),
      NumberAllowedExceptions_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CriterionOutOfType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Numerator
        //
        if (n.name () == L"Numerator" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Numerator_.present ())
          {
            this->Numerator_.set (Numerator_traits::create (i, f, this));
            continue;
          }
        }

        // Denominator
        //
        if (n.name () == L"Denominator" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Denominator_.present ())
          {
            this->Denominator_.set (Denominator_traits::create (i, f, this));
            continue;
          }
        }

        // NumberAllowedExceptions
        //
        if (n.name () == L"NumberAllowedExceptions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberAllowedExceptions_type > r (
            NumberAllowedExceptions_traits::create (i, f, this));

          if (!this->NumberAllowedExceptions_)
          {
            this->NumberAllowedExceptions_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Numerator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Numerator",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Denominator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Denominator",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CriterionOutOfType* CriterionOutOfType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriterionOutOfType (*this, f, c);
    }

    CriterionOutOfType& CriterionOutOfType::
    operator= (const CriterionOutOfType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Numerator_ = x.Numerator_;
        this->Denominator_ = x.Denominator_;
        this->NumberAllowedExceptions_ = x.NumberAllowedExceptions_;
      }

      return *this;
    }

    CriterionOutOfType::
    ~CriterionOutOfType ()
    {
    }

    // SamplingMethodType
    //

    SamplingMethodType::
    SamplingMethodType ()
    : ::xml_schema::type (),
      SampleSize_ (this),
      SamplingPeriod_ (this),
      SamplingFrequency_ (this),
      SamplingInterval_ (this)
    {
    }

    SamplingMethodType::
    SamplingMethodType (const SampleSize_type& SampleSize)
    : ::xml_schema::type (),
      SampleSize_ (SampleSize, this),
      SamplingPeriod_ (this),
      SamplingFrequency_ (this),
      SamplingInterval_ (this)
    {
    }

    SamplingMethodType::
    SamplingMethodType (const SamplingMethodType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SampleSize_ (x.SampleSize_, f, this),
      SamplingPeriod_ (x.SamplingPeriod_, f, this),
      SamplingFrequency_ (x.SamplingFrequency_, f, this),
      SamplingInterval_ (x.SamplingInterval_, f, this)
    {
    }

    SamplingMethodType::
    SamplingMethodType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SampleSize_ (this),
      SamplingPeriod_ (this),
      SamplingFrequency_ (this),
      SamplingInterval_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SamplingMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SampleSize
        //
        if (n.name () == L"SampleSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleSize_.present ())
          {
            this->SampleSize_.set (SampleSize_traits::create (i, f, this));
            continue;
          }
        }

        // SamplingPeriod
        //
        if (n.name () == L"SamplingPeriod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SamplingPeriod_)
          {
            this->SamplingPeriod_.set (SamplingPeriod_traits::create (i, f, this));
            continue;
          }
        }

        // SamplingFrequency
        //
        if (n.name () == L"SamplingFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SamplingFrequency_)
          {
            this->SamplingFrequency_.set (SamplingFrequency_traits::create (i, f, this));
            continue;
          }
        }

        // SamplingInterval
        //
        if (n.name () == L"SamplingInterval" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingInterval_type > r (
            SamplingInterval_traits::create (i, f, this));

          if (!this->SamplingInterval_)
          {
            this->SamplingInterval_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SampleSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SamplingMethodType* SamplingMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SamplingMethodType (*this, f, c);
    }

    SamplingMethodType& SamplingMethodType::
    operator= (const SamplingMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SampleSize_ = x.SampleSize_;
        this->SamplingPeriod_ = x.SamplingPeriod_;
        this->SamplingFrequency_ = x.SamplingFrequency_;
        this->SamplingInterval_ = x.SamplingInterval_;
      }

      return *this;
    }

    SamplingMethodType::
    ~SamplingMethodType ()
    {
    }

    // SamplingIntervalEnumType
    //

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SamplingIntervalEnumType_convert ();
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SamplingIntervalEnumType_convert ();
    }

    SamplingIntervalEnumType::
    SamplingIntervalEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SamplingIntervalEnumType_convert ();
    }

    SamplingIntervalEnumType* SamplingIntervalEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SamplingIntervalEnumType (*this, f, c);
    }

    SamplingIntervalEnumType::value SamplingIntervalEnumType::
    _xsd_SamplingIntervalEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SamplingIntervalEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SamplingIntervalEnumType_indexes_,
                        _xsd_SamplingIntervalEnumType_indexes_ + 7,
                        *this,
                        c));

      if (i == _xsd_SamplingIntervalEnumType_indexes_ + 7 || _xsd_SamplingIntervalEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SamplingIntervalEnumType::
    _xsd_SamplingIntervalEnumType_literals_[7] =
    {
      L"SHIFT",
      L"DAY",
      L"HOUR",
      L"WEEK",
      L"MONTH",
      L"BATCH",
      L"LOT"
    };

    const SamplingIntervalEnumType::value SamplingIntervalEnumType::
    _xsd_SamplingIntervalEnumType_indexes_[7] =
    {
      ::xsd::qif30::SamplingIntervalEnumType::BATCH,
      ::xsd::qif30::SamplingIntervalEnumType::DAY,
      ::xsd::qif30::SamplingIntervalEnumType::HOUR,
      ::xsd::qif30::SamplingIntervalEnumType::LOT,
      ::xsd::qif30::SamplingIntervalEnumType::MONTH,
      ::xsd::qif30::SamplingIntervalEnumType::SHIFT,
      ::xsd::qif30::SamplingIntervalEnumType::WEEK
    };

    // SamplingIntervalType
    //

    SamplingIntervalType::
    SamplingIntervalType ()
    : ::xml_schema::type (),
      SamplingIntervalEnum_ (this),
      OtherSamplingInterval_ (this)
    {
    }

    SamplingIntervalType::
    SamplingIntervalType (const SamplingIntervalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SamplingIntervalEnum_ (x.SamplingIntervalEnum_, f, this),
      OtherSamplingInterval_ (x.OtherSamplingInterval_, f, this)
    {
    }

    SamplingIntervalType::
    SamplingIntervalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SamplingIntervalEnum_ (this),
      OtherSamplingInterval_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SamplingIntervalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SamplingIntervalEnum
        //
        if (n.name () == L"SamplingIntervalEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingIntervalEnum_type > r (
            SamplingIntervalEnum_traits::create (i, f, this));

          if (!this->SamplingIntervalEnum_)
          {
            this->SamplingIntervalEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherSamplingInterval
        //
        if (n.name () == L"OtherSamplingInterval" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherSamplingInterval_type > r (
            OtherSamplingInterval_traits::create (i, f, this));

          if (!this->OtherSamplingInterval_)
          {
            this->OtherSamplingInterval_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SamplingIntervalType* SamplingIntervalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SamplingIntervalType (*this, f, c);
    }

    SamplingIntervalType& SamplingIntervalType::
    operator= (const SamplingIntervalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SamplingIntervalEnum_ = x.SamplingIntervalEnum_;
        this->OtherSamplingInterval_ = x.OtherSamplingInterval_;
      }

      return *this;
    }

    SamplingIntervalType::
    ~SamplingIntervalType ()
    {
    }

    // ExclusionEnumType
    //

    ExclusionEnumType::
    ExclusionEnumType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ExclusionEnumType_convert ();
    }

    ExclusionEnumType::
    ExclusionEnumType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ExclusionEnumType_convert ();
    }

    ExclusionEnumType::
    ExclusionEnumType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ExclusionEnumType_convert ();
    }

    ExclusionEnumType* ExclusionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionEnumType (*this, f, c);
    }

    ExclusionEnumType::value ExclusionEnumType::
    _xsd_ExclusionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ExclusionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ExclusionEnumType_indexes_,
                        _xsd_ExclusionEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_ExclusionEnumType_indexes_ + 4 || _xsd_ExclusionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ExclusionEnumType::
    _xsd_ExclusionEnumType_literals_[4] =
    {
      L"FLIER",
      L"EQUIPERROR",
      L"REWORK",
      L"KNOWNCAUSE"
    };

    const ExclusionEnumType::value ExclusionEnumType::
    _xsd_ExclusionEnumType_indexes_[4] =
    {
      ::xsd::qif30::ExclusionEnumType::EQUIPERROR,
      ::xsd::qif30::ExclusionEnumType::FLIER,
      ::xsd::qif30::ExclusionEnumType::KNOWNCAUSE,
      ::xsd::qif30::ExclusionEnumType::REWORK
    };

    // ExclusionReasonType
    //

    ExclusionReasonType::
    ExclusionReasonType ()
    : ::xml_schema::type (),
      ExclusionReasonEnum_ (this),
      OtherExclusionReason_ (this)
    {
    }

    ExclusionReasonType::
    ExclusionReasonType (const ExclusionReasonType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ExclusionReasonEnum_ (x.ExclusionReasonEnum_, f, this),
      OtherExclusionReason_ (x.OtherExclusionReason_, f, this)
    {
    }

    ExclusionReasonType::
    ExclusionReasonType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ExclusionReasonEnum_ (this),
      OtherExclusionReason_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExclusionReasonType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExclusionReasonEnum
        //
        if (n.name () == L"ExclusionReasonEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExclusionReasonEnum_type > r (
            ExclusionReasonEnum_traits::create (i, f, this));

          if (!this->ExclusionReasonEnum_)
          {
            this->ExclusionReasonEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherExclusionReason
        //
        if (n.name () == L"OtherExclusionReason" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherExclusionReason_type > r (
            OtherExclusionReason_traits::create (i, f, this));

          if (!this->OtherExclusionReason_)
          {
            this->OtherExclusionReason_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExclusionReasonType* ExclusionReasonType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionReasonType (*this, f, c);
    }

    ExclusionReasonType& ExclusionReasonType::
    operator= (const ExclusionReasonType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ExclusionReasonEnum_ = x.ExclusionReasonEnum_;
        this->OtherExclusionReason_ = x.OtherExclusionReason_;
      }

      return *this;
    }

    ExclusionReasonType::
    ~ExclusionReasonType ()
    {
    }

    // ExclusionIdType
    //

    ExclusionIdType::
    ExclusionIdType ()
    : ::xml_schema::type (),
      Id_ (this),
      Reason_ (this)
    {
    }

    ExclusionIdType::
    ExclusionIdType (const Id_type& Id,
                     const Reason_type& Reason)
    : ::xml_schema::type (),
      Id_ (Id, this),
      Reason_ (Reason, this)
    {
    }

    ExclusionIdType::
    ExclusionIdType (::std::unique_ptr< Id_type > Id,
                     ::std::unique_ptr< Reason_type > Reason)
    : ::xml_schema::type (),
      Id_ (std::move (Id), this),
      Reason_ (std::move (Reason), this)
    {
    }

    ExclusionIdType::
    ExclusionIdType (const ExclusionIdType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      Reason_ (x.Reason_, f, this)
    {
    }

    ExclusionIdType::
    ExclusionIdType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this),
      Reason_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExclusionIdType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!Id_.present ())
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        // Reason
        //
        if (n.name () == L"Reason" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Reason_type > r (
            Reason_traits::create (i, f, this));

          if (!Reason_.present ())
          {
            this->Reason_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Id",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Reason",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExclusionIdType* ExclusionIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionIdType (*this, f, c);
    }

    ExclusionIdType& ExclusionIdType::
    operator= (const ExclusionIdType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
        this->Reason_ = x.Reason_;
      }

      return *this;
    }

    ExclusionIdType::
    ~ExclusionIdType ()
    {
    }

    // ExclusionIndexType
    //

    ExclusionIndexType::
    ExclusionIndexType ()
    : ::xml_schema::type (),
      Index_ (this),
      Reason_ (this)
    {
    }

    ExclusionIndexType::
    ExclusionIndexType (const Index_type& Index,
                        const Reason_type& Reason)
    : ::xml_schema::type (),
      Index_ (Index, this),
      Reason_ (Reason, this)
    {
    }

    ExclusionIndexType::
    ExclusionIndexType (const Index_type& Index,
                        ::std::unique_ptr< Reason_type > Reason)
    : ::xml_schema::type (),
      Index_ (Index, this),
      Reason_ (std::move (Reason), this)
    {
    }

    ExclusionIndexType::
    ExclusionIndexType (const ExclusionIndexType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Index_ (x.Index_, f, this),
      Reason_ (x.Reason_, f, this)
    {
    }

    ExclusionIndexType::
    ExclusionIndexType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Index_ (this),
      Reason_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExclusionIndexType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Index
        //
        if (n.name () == L"Index" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Index_.present ())
          {
            this->Index_.set (Index_traits::create (i, f, this));
            continue;
          }
        }

        // Reason
        //
        if (n.name () == L"Reason" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Reason_type > r (
            Reason_traits::create (i, f, this));

          if (!Reason_.present ())
          {
            this->Reason_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Index_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Index",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Reason",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExclusionIndexType* ExclusionIndexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionIndexType (*this, f, c);
    }

    ExclusionIndexType& ExclusionIndexType::
    operator= (const ExclusionIndexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Index_ = x.Index_;
        this->Reason_ = x.Reason_;
      }

      return *this;
    }

    ExclusionIndexType::
    ~ExclusionIndexType ()
    {
    }

    // ExclusionsIdType
    //

    ExclusionsIdType::
    ExclusionsIdType ()
    : ::xml_schema::type (),
      Exclusion_ (this),
      n_ (this)
    {
    }

    ExclusionsIdType::
    ExclusionsIdType (const n_type& n)
    : ::xml_schema::type (),
      Exclusion_ (this),
      n_ (n, this)
    {
    }

    ExclusionsIdType::
    ExclusionsIdType (const ExclusionsIdType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Exclusion_ (x.Exclusion_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExclusionsIdType::
    ExclusionsIdType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Exclusion_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExclusionsIdType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Exclusion
        //
        if (n.name () == L"Exclusion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Exclusion_type > r (
            Exclusion_traits::create (i, f, this));

          this->Exclusion_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExclusionsIdType* ExclusionsIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionsIdType (*this, f, c);
    }

    ExclusionsIdType& ExclusionsIdType::
    operator= (const ExclusionsIdType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Exclusion_ = x.Exclusion_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExclusionsIdType::
    ~ExclusionsIdType ()
    {
    }

    // ExclusionsIndexType
    //

    ExclusionsIndexType::
    ExclusionsIndexType ()
    : ::xml_schema::type (),
      Exclusion_ (this),
      n_ (this)
    {
    }

    ExclusionsIndexType::
    ExclusionsIndexType (const n_type& n)
    : ::xml_schema::type (),
      Exclusion_ (this),
      n_ (n, this)
    {
    }

    ExclusionsIndexType::
    ExclusionsIndexType (const ExclusionsIndexType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Exclusion_ (x.Exclusion_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExclusionsIndexType::
    ExclusionsIndexType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Exclusion_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExclusionsIndexType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Exclusion
        //
        if (n.name () == L"Exclusion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Exclusion_type > r (
            Exclusion_traits::create (i, f, this));

          this->Exclusion_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExclusionsIndexType* ExclusionsIndexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExclusionsIndexType (*this, f, c);
    }

    ExclusionsIndexType& ExclusionsIndexType::
    operator= (const ExclusionsIndexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Exclusion_ = x.Exclusion_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExclusionsIndexType::
    ~ExclusionsIndexType ()
    {
    }

    // StatsArrayIdType
    //

    StatsArrayIdType::
    StatsArrayIdType ()
    : ::xml_schema::type (),
      Ids_ (this),
      Exclusions_ (this)
    {
    }

    StatsArrayIdType::
    StatsArrayIdType (const Ids_type& Ids)
    : ::xml_schema::type (),
      Ids_ (Ids, this),
      Exclusions_ (this)
    {
    }

    StatsArrayIdType::
    StatsArrayIdType (::std::unique_ptr< Ids_type > Ids)
    : ::xml_schema::type (),
      Ids_ (std::move (Ids), this),
      Exclusions_ (this)
    {
    }

    StatsArrayIdType::
    StatsArrayIdType (const StatsArrayIdType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Ids_ (x.Ids_, f, this),
      Exclusions_ (x.Exclusions_, f, this)
    {
    }

    StatsArrayIdType::
    StatsArrayIdType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Ids_ (this),
      Exclusions_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsArrayIdType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Ids
        //
        if (n.name () == L"Ids" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Ids_type > r (
            Ids_traits::create (i, f, this));

          if (!Ids_.present ())
          {
            this->Ids_.set (::std::move (r));
            continue;
          }
        }

        // Exclusions
        //
        if (n.name () == L"Exclusions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Exclusions_type > r (
            Exclusions_traits::create (i, f, this));

          if (!this->Exclusions_)
          {
            this->Exclusions_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Ids_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Ids",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StatsArrayIdType* StatsArrayIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsArrayIdType (*this, f, c);
    }

    StatsArrayIdType& StatsArrayIdType::
    operator= (const StatsArrayIdType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Ids_ = x.Ids_;
        this->Exclusions_ = x.Exclusions_;
      }

      return *this;
    }

    StatsArrayIdType::
    ~StatsArrayIdType ()
    {
    }

    // StatsValuesType
    //

    StatsValuesType::
    StatsValuesType ()
    : ::xml_schema::type (),
      Values_ (this),
      Exclusions_ (this)
    {
    }

    StatsValuesType::
    StatsValuesType (const Values_type& Values)
    : ::xml_schema::type (),
      Values_ (Values, this),
      Exclusions_ (this)
    {
    }

    StatsValuesType::
    StatsValuesType (const StatsValuesType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Values_ (x.Values_, f, this),
      Exclusions_ (x.Exclusions_, f, this)
    {
    }

    StatsValuesType::
    StatsValuesType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Values_ (this),
      Exclusions_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Values
        //
        if (n.name () == L"Values" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Values_type > r (
            Values_traits::create (i, f, this));

          if (!Values_.present ())
          {
            this->Values_.set (::std::move (r));
            continue;
          }
        }

        // Exclusions
        //
        if (n.name () == L"Exclusions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Exclusions_type > r (
            Exclusions_traits::create (i, f, this));

          if (!this->Exclusions_)
          {
            this->Exclusions_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Values_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Values",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StatsValuesType* StatsValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsValuesType (*this, f, c);
    }

    StatsValuesType& StatsValuesType::
    operator= (const StatsValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Values_ = x.Values_;
        this->Exclusions_ = x.Exclusions_;
      }

      return *this;
    }

    StatsValuesType::
    ~StatsValuesType ()
    {
    }

    // StatsEvalStatusEnumType
    //

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_StatsEvalStatusEnumType_convert ();
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_StatsEvalStatusEnumType_convert ();
    }

    StatsEvalStatusEnumType::
    StatsEvalStatusEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_StatsEvalStatusEnumType_convert ();
    }

    StatsEvalStatusEnumType* StatsEvalStatusEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsEvalStatusEnumType (*this, f, c);
    }

    StatsEvalStatusEnumType::value StatsEvalStatusEnumType::
    _xsd_StatsEvalStatusEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_StatsEvalStatusEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_StatsEvalStatusEnumType_indexes_,
                        _xsd_StatsEvalStatusEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_StatsEvalStatusEnumType_indexes_ + 4 || _xsd_StatsEvalStatusEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const StatsEvalStatusEnumType::
    _xsd_StatsEvalStatusEnumType_literals_[4] =
    {
      L"PASS",
      L"FAIL",
      L"INFORMATIONAL",
      L"UNDEFINED"
    };

    const StatsEvalStatusEnumType::value StatsEvalStatusEnumType::
    _xsd_StatsEvalStatusEnumType_indexes_[4] =
    {
      ::xsd::qif30::StatsEvalStatusEnumType::FAIL,
      ::xsd::qif30::StatsEvalStatusEnumType::INFORMATIONAL,
      ::xsd::qif30::StatsEvalStatusEnumType::PASS,
      ::xsd::qif30::StatsEvalStatusEnumType::UNDEFINED
    };

    // StatsEvalStatusType
    //

    StatsEvalStatusType::
    StatsEvalStatusType ()
    : ::xml_schema::type (),
      StatsEvalStatusEnum_ (this),
      OtherStatsEvalStatus_ (this)
    {
    }

    StatsEvalStatusType::
    StatsEvalStatusType (const StatsEvalStatusType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StatsEvalStatusEnum_ (x.StatsEvalStatusEnum_, f, this),
      OtherStatsEvalStatus_ (x.OtherStatsEvalStatus_, f, this)
    {
    }

    StatsEvalStatusType::
    StatsEvalStatusType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatsEvalStatusEnum_ (this),
      OtherStatsEvalStatus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsEvalStatusType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatsEvalStatusEnum
        //
        if (n.name () == L"StatsEvalStatusEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatsEvalStatusEnum_type > r (
            StatsEvalStatusEnum_traits::create (i, f, this));

          if (!this->StatsEvalStatusEnum_)
          {
            this->StatsEvalStatusEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherStatsEvalStatus
        //
        if (n.name () == L"OtherStatsEvalStatus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherStatsEvalStatus_type > r (
            OtherStatsEvalStatus_traits::create (i, f, this));

          if (!this->OtherStatsEvalStatus_)
          {
            this->OtherStatsEvalStatus_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsEvalStatusType* StatsEvalStatusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsEvalStatusType (*this, f, c);
    }

    StatsEvalStatusType& StatsEvalStatusType::
    operator= (const StatsEvalStatusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StatsEvalStatusEnum_ = x.StatsEvalStatusEnum_;
        this->OtherStatsEvalStatus_ = x.OtherStatsEvalStatus_;
      }

      return *this;
    }

    StatsEvalStatusType::
    ~StatsEvalStatusType ()
    {
    }

    // StudyIssuesType
    //

    StudyIssuesType::
    StudyIssuesType ()
    : ::xml_schema::type (),
      StudyIssue_ (this),
      n_ (this)
    {
    }

    StudyIssuesType::
    StudyIssuesType (const n_type& n)
    : ::xml_schema::type (),
      StudyIssue_ (this),
      n_ (n, this)
    {
    }

    StudyIssuesType::
    StudyIssuesType (const StudyIssuesType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StudyIssue_ (x.StudyIssue_, f, this),
      n_ (x.n_, f, this)
    {
    }

    StudyIssuesType::
    StudyIssuesType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StudyIssue_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StudyIssuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StudyIssue
        //
        if (n.name () == L"StudyIssue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StudyIssue_type > r (
            StudyIssue_traits::create (i, f, this));

          this->StudyIssue_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    StudyIssuesType* StudyIssuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StudyIssuesType (*this, f, c);
    }

    StudyIssuesType& StudyIssuesType::
    operator= (const StudyIssuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StudyIssue_ = x.StudyIssue_;
        this->n_ = x.n_;
      }

      return *this;
    }

    StudyIssuesType::
    ~StudyIssuesType ()
    {
    }

    // OneSidedCapabilityCalculationEnumType
    //

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_OneSidedCapabilityCalculationEnumType_convert ();
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_OneSidedCapabilityCalculationEnumType_convert ();
    }

    OneSidedCapabilityCalculationEnumType::
    OneSidedCapabilityCalculationEnumType (const ::std::wstring& s,
                                           const xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_OneSidedCapabilityCalculationEnumType_convert ();
    }

    OneSidedCapabilityCalculationEnumType* OneSidedCapabilityCalculationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OneSidedCapabilityCalculationEnumType (*this, f, c);
    }

    OneSidedCapabilityCalculationEnumType::value OneSidedCapabilityCalculationEnumType::
    _xsd_OneSidedCapabilityCalculationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_OneSidedCapabilityCalculationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_OneSidedCapabilityCalculationEnumType_indexes_,
                        _xsd_OneSidedCapabilityCalculationEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_OneSidedCapabilityCalculationEnumType_indexes_ + 2 || _xsd_OneSidedCapabilityCalculationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const OneSidedCapabilityCalculationEnumType::
    _xsd_OneSidedCapabilityCalculationEnumType_literals_[2] =
    {
      L"THREE_SIGMA",
      L"SIX_SIGMA"
    };

    const OneSidedCapabilityCalculationEnumType::value OneSidedCapabilityCalculationEnumType::
    _xsd_OneSidedCapabilityCalculationEnumType_indexes_[2] =
    {
      ::xsd::qif30::OneSidedCapabilityCalculationEnumType::SIX_SIGMA,
      ::xsd::qif30::OneSidedCapabilityCalculationEnumType::THREE_SIGMA
    };

    // PositionCapabilityCalculationEnumType
    //

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_PositionCapabilityCalculationEnumType_convert ();
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_PositionCapabilityCalculationEnumType_convert ();
    }

    PositionCapabilityCalculationEnumType::
    PositionCapabilityCalculationEnumType (const ::std::wstring& s,
                                           const xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_PositionCapabilityCalculationEnumType_convert ();
    }

    PositionCapabilityCalculationEnumType* PositionCapabilityCalculationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PositionCapabilityCalculationEnumType (*this, f, c);
    }

    PositionCapabilityCalculationEnumType::value PositionCapabilityCalculationEnumType::
    _xsd_PositionCapabilityCalculationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PositionCapabilityCalculationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PositionCapabilityCalculationEnumType_indexes_,
                        _xsd_PositionCapabilityCalculationEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_PositionCapabilityCalculationEnumType_indexes_ + 4 || _xsd_PositionCapabilityCalculationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const PositionCapabilityCalculationEnumType::
    _xsd_PositionCapabilityCalculationEnumType_literals_[4] =
    {
      L"THREE_SIGMA",
      L"SIX_SIGMA",
      L"BIVARIATE",
      L"TRIVARIATE"
    };

    const PositionCapabilityCalculationEnumType::value PositionCapabilityCalculationEnumType::
    _xsd_PositionCapabilityCalculationEnumType_indexes_[4] =
    {
      ::xsd::qif30::PositionCapabilityCalculationEnumType::BIVARIATE,
      ::xsd::qif30::PositionCapabilityCalculationEnumType::SIX_SIGMA,
      ::xsd::qif30::PositionCapabilityCalculationEnumType::THREE_SIGMA,
      ::xsd::qif30::PositionCapabilityCalculationEnumType::TRIVARIATE
    };

    // DistributionTransformationEnumType
    //

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DistributionTransformationEnumType_convert ();
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DistributionTransformationEnumType_convert ();
    }

    DistributionTransformationEnumType::
    DistributionTransformationEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DistributionTransformationEnumType_convert ();
    }

    DistributionTransformationEnumType* DistributionTransformationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistributionTransformationEnumType (*this, f, c);
    }

    DistributionTransformationEnumType::value DistributionTransformationEnumType::
    _xsd_DistributionTransformationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DistributionTransformationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DistributionTransformationEnumType_indexes_,
                        _xsd_DistributionTransformationEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DistributionTransformationEnumType_indexes_ + 3 || _xsd_DistributionTransformationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DistributionTransformationEnumType::
    _xsd_DistributionTransformationEnumType_literals_[3] =
    {
      L"LOGNORMAL",
      L"BOUNDED",
      L"UNBOUNDED"
    };

    const DistributionTransformationEnumType::value DistributionTransformationEnumType::
    _xsd_DistributionTransformationEnumType_indexes_[3] =
    {
      ::xsd::qif30::DistributionTransformationEnumType::BOUNDED,
      ::xsd::qif30::DistributionTransformationEnumType::LOGNORMAL,
      ::xsd::qif30::DistributionTransformationEnumType::UNBOUNDED
    };

    // DistributionTransformationType
    //

    DistributionTransformationType::
    DistributionTransformationType ()
    : ::xml_schema::type (),
      DistributionTransformationEnum_ (this),
      BoxCoxTransformation_ (this),
      OtherDistributionTransformation_ (this)
    {
    }

    DistributionTransformationType::
    DistributionTransformationType (const DistributionTransformationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DistributionTransformationEnum_ (x.DistributionTransformationEnum_, f, this),
      BoxCoxTransformation_ (x.BoxCoxTransformation_, f, this),
      OtherDistributionTransformation_ (x.OtherDistributionTransformation_, f, this)
    {
    }

    DistributionTransformationType::
    DistributionTransformationType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DistributionTransformationEnum_ (this),
      BoxCoxTransformation_ (this),
      OtherDistributionTransformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DistributionTransformationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DistributionTransformationEnum
        //
        if (n.name () == L"DistributionTransformationEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DistributionTransformationEnum_type > r (
            DistributionTransformationEnum_traits::create (i, f, this));

          if (!this->DistributionTransformationEnum_)
          {
            this->DistributionTransformationEnum_.set (::std::move (r));
            continue;
          }
        }

        // BoxCoxTransformation
        //
        if (n.name () == L"BoxCoxTransformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->BoxCoxTransformation_)
          {
            this->BoxCoxTransformation_.set (BoxCoxTransformation_traits::create (i, f, this));
            continue;
          }
        }

        // OtherDistributionTransformation
        //
        if (n.name () == L"OtherDistributionTransformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherDistributionTransformation_type > r (
            OtherDistributionTransformation_traits::create (i, f, this));

          if (!this->OtherDistributionTransformation_)
          {
            this->OtherDistributionTransformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DistributionTransformationType* DistributionTransformationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistributionTransformationType (*this, f, c);
    }

    DistributionTransformationType& DistributionTransformationType::
    operator= (const DistributionTransformationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DistributionTransformationEnum_ = x.DistributionTransformationEnum_;
        this->BoxCoxTransformation_ = x.BoxCoxTransformation_;
        this->OtherDistributionTransformation_ = x.OtherDistributionTransformation_;
      }

      return *this;
    }

    DistributionTransformationType::
    ~DistributionTransformationType ()
    {
    }

    // SubgroupType
    //

    SubgroupType::
    SubgroupType ()
    : ::xml_schema::type (),
      MeasuredIds_ (this),
      id_ (this)
    {
    }

    SubgroupType::
    SubgroupType (const MeasuredIds_type& MeasuredIds,
                  const id_type& id)
    : ::xml_schema::type (),
      MeasuredIds_ (MeasuredIds, this),
      id_ (id, this)
    {
    }

    SubgroupType::
    SubgroupType (::std::unique_ptr< MeasuredIds_type > MeasuredIds,
                  const id_type& id)
    : ::xml_schema::type (),
      MeasuredIds_ (std::move (MeasuredIds), this),
      id_ (id, this)
    {
    }

    SubgroupType::
    SubgroupType (const SubgroupType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasuredIds_ (x.MeasuredIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    SubgroupType::
    SubgroupType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasuredIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasuredIds
        //
        if (n.name () == L"MeasuredIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredIds_type > r (
            MeasuredIds_traits::create (i, f, this));

          if (!MeasuredIds_.present ())
          {
            this->MeasuredIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MeasuredIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeasuredIds",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    SubgroupType* SubgroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupType (*this, f, c);
    }

    SubgroupType& SubgroupType::
    operator= (const SubgroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasuredIds_ = x.MeasuredIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    SubgroupType::
    ~SubgroupType ()
    {
    }

    // SubgroupsType
    //

    SubgroupsType::
    SubgroupsType ()
    : ::xml_schema::type (),
      Subgroup_ (this),
      n_ (this)
    {
    }

    SubgroupsType::
    SubgroupsType (const n_type& n)
    : ::xml_schema::type (),
      Subgroup_ (this),
      n_ (n, this)
    {
    }

    SubgroupsType::
    SubgroupsType (const SubgroupsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Subgroup_ (x.Subgroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SubgroupsType::
    SubgroupsType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Subgroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Subgroup
        //
        if (n.name () == L"Subgroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Subgroup_type > r (
            Subgroup_traits::create (i, f, this));

          this->Subgroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SubgroupsType* SubgroupsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupsType (*this, f, c);
    }

    SubgroupsType& SubgroupsType::
    operator= (const SubgroupsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Subgroup_ = x.Subgroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SubgroupsType::
    ~SubgroupsType ()
    {
    }

    // SubgroupValuesType
    //

    SubgroupValuesType::
    SubgroupValuesType ()
    : ::xml_schema::type (),
      Subgroup_ (this),
      n_ (this)
    {
    }

    SubgroupValuesType::
    SubgroupValuesType (const n_type& n)
    : ::xml_schema::type (),
      Subgroup_ (this),
      n_ (n, this)
    {
    }

    SubgroupValuesType::
    SubgroupValuesType (const SubgroupValuesType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Subgroup_ (x.Subgroup_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SubgroupValuesType::
    SubgroupValuesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Subgroup_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Subgroup
        //
        if (n.name () == L"Subgroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Subgroup_type > r (
            Subgroup_traits::create (i, f, this));

          this->Subgroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SubgroupValuesType* SubgroupValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupValuesType (*this, f, c);
    }

    SubgroupValuesType& SubgroupValuesType::
    operator= (const SubgroupValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Subgroup_ = x.Subgroup_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SubgroupValuesType::
    ~SubgroupValuesType ()
    {
    }

    // CharacteristicStatsEvalBaseType
    //

    CharacteristicStatsEvalBaseType::
    CharacteristicStatsEvalBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this),
      MeasuredIds_ (this),
      Subgroups_ (this),
      MeasuredValues_ (this),
      SubgroupValues_ (this),
      Status_ (this),
      StudyIssues_ (this),
      DistributionTransformation_ (this)
    {
    }

    CharacteristicStatsEvalBaseType::
    CharacteristicStatsEvalBaseType (const Status_type& Status)
    : ::xml_schema::type (),
      Attributes_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this),
      MeasuredIds_ (this),
      Subgroups_ (this),
      MeasuredValues_ (this),
      SubgroupValues_ (this),
      Status_ (Status, this),
      StudyIssues_ (this),
      DistributionTransformation_ (this)
    {
    }

    CharacteristicStatsEvalBaseType::
    CharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type > Status)
    : ::xml_schema::type (),
      Attributes_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this),
      MeasuredIds_ (this),
      Subgroups_ (this),
      MeasuredValues_ (this),
      SubgroupValues_ (this),
      Status_ (std::move (Status), this),
      StudyIssues_ (this),
      DistributionTransformation_ (this)
    {
    }

    CharacteristicStatsEvalBaseType::
    CharacteristicStatsEvalBaseType (const CharacteristicStatsEvalBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      SoftwareId_ (x.SoftwareId_, f, this),
      StandardId_ (x.StandardId_, f, this),
      AlgorithmId_ (x.AlgorithmId_, f, this),
      MeasuredIds_ (x.MeasuredIds_, f, this),
      Subgroups_ (x.Subgroups_, f, this),
      MeasuredValues_ (x.MeasuredValues_, f, this),
      SubgroupValues_ (x.SubgroupValues_, f, this),
      Status_ (x.Status_, f, this),
      StudyIssues_ (x.StudyIssues_, f, this),
      DistributionTransformation_ (x.DistributionTransformation_, f, this)
    {
    }

    CharacteristicStatsEvalBaseType::
    CharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this),
      MeasuredIds_ (this),
      Subgroups_ (this),
      MeasuredValues_ (this),
      SubgroupValues_ (this),
      Status_ (this),
      StudyIssues_ (this),
      DistributionTransformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CharacteristicStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // SoftwareId
        //
        if (n.name () == L"SoftwareId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SoftwareId_type > r (
            SoftwareId_traits::create (i, f, this));

          if (!this->SoftwareId_)
          {
            this->SoftwareId_.set (::std::move (r));
            continue;
          }
        }

        // StandardId
        //
        if (n.name () == L"StandardId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardId_type > r (
            StandardId_traits::create (i, f, this));

          if (!this->StandardId_)
          {
            this->StandardId_.set (::std::move (r));
            continue;
          }
        }

        // AlgorithmId
        //
        if (n.name () == L"AlgorithmId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AlgorithmId_type > r (
            AlgorithmId_traits::create (i, f, this));

          if (!this->AlgorithmId_)
          {
            this->AlgorithmId_.set (::std::move (r));
            continue;
          }
        }

        // MeasuredIds
        //
        if (n.name () == L"MeasuredIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredIds_type > r (
            MeasuredIds_traits::create (i, f, this));

          if (!this->MeasuredIds_)
          {
            this->MeasuredIds_.set (::std::move (r));
            continue;
          }
        }

        // Subgroups
        //
        if (n.name () == L"Subgroups" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Subgroups_type > r (
            Subgroups_traits::create (i, f, this));

          if (!this->Subgroups_)
          {
            this->Subgroups_.set (::std::move (r));
            continue;
          }
        }

        // MeasuredValues
        //
        if (n.name () == L"MeasuredValues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredValues_type > r (
            MeasuredValues_traits::create (i, f, this));

          if (!this->MeasuredValues_)
          {
            this->MeasuredValues_.set (::std::move (r));
            continue;
          }
        }

        // SubgroupValues
        //
        if (n.name () == L"SubgroupValues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubgroupValues_type > r (
            SubgroupValues_traits::create (i, f, this));

          if (!this->SubgroupValues_)
          {
            this->SubgroupValues_.set (::std::move (r));
            continue;
          }
        }

        // Status
        //
        if (n.name () == L"Status" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Status_type > r (
            Status_traits::create (i, f, this));

          if (!Status_.present ())
          {
            this->Status_.set (::std::move (r));
            continue;
          }
        }

        // StudyIssues
        //
        if (n.name () == L"StudyIssues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StudyIssues_type > r (
            StudyIssues_traits::create (i, f, this));

          if (!this->StudyIssues_)
          {
            this->StudyIssues_.set (::std::move (r));
            continue;
          }
        }

        // DistributionTransformation
        //
        if (n.name () == L"DistributionTransformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DistributionTransformation_type > r (
            DistributionTransformation_traits::create (i, f, this));

          if (!this->DistributionTransformation_)
          {
            this->DistributionTransformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Status_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Status",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CharacteristicStatsEvalBaseType& CharacteristicStatsEvalBaseType::
    operator= (const CharacteristicStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->SoftwareId_ = x.SoftwareId_;
        this->StandardId_ = x.StandardId_;
        this->AlgorithmId_ = x.AlgorithmId_;
        this->MeasuredIds_ = x.MeasuredIds_;
        this->Subgroups_ = x.Subgroups_;
        this->MeasuredValues_ = x.MeasuredValues_;
        this->SubgroupValues_ = x.SubgroupValues_;
        this->Status_ = x.Status_;
        this->StudyIssues_ = x.StudyIssues_;
        this->DistributionTransformation_ = x.DistributionTransformation_;
      }

      return *this;
    }

    CharacteristicStatsEvalBaseType::
    ~CharacteristicStatsEvalBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CommonStatsValue_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TotalNumber_element_factory_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalNumber",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupTotalNumbers_element_factory_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupTotalNumbers",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveNumber_element_factory_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveNumber",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupEffectiveNumbers_element_factory_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupEffectiveNumbers",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberSubgroups_element_factory_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberSubgroups",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumericCharacteristicStatsValue_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Average_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Average",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupAverages_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupAverages",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Difference_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Difference",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupDifferences_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupDifferences",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RootMeanSquare_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RootMeanSquare",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Maximum_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Maximum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupMaxima_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupMaxima",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Minimum_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Minimum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupMinima_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupMinima",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Range_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Range",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupRanges_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupRanges",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AverageRange_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"AverageRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_StandardDeviation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"StandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Skew_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Skew",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Kurtosis_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Kurtosis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Normality_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Normality",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProcessVariation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EstimatedStandardDeviation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EstimatedStandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UpperControlLimit_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperControlLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LowerControlLimit_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerControlLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UpperControlLimitRange_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperControlLimitRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LowerControlLimitRange_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerControlLimitRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberOutOfControl_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOutOfControl",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AppraiserVariation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"AppraiserVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EquipmentVariation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EquipmentVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Interaction_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Interaction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GageRandR_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandR",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PartVariation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"PartVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TotalVariation_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Linearity_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Linearity",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Bias_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Bias",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeLinearity_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeLinearity",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeBias_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeBias",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GoodnessOfFit_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"GoodnessOfFit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RegressionSlope_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RegressionSlope",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RegressionIntercept_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RegressionIntercept",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UpperConfidenceLimit_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperConfidenceLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LowerConfidenceLimit_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerConfidenceLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TDistribution_element_factory_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TDistribution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberOutOfTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOutOfTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupNumbersOutOfTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersOutOfTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberOverUpperTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOverUpperTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupNumbersOverUpperTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersOverUpperTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberUnderLowerTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberUnderLowerTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SubgroupNumbersUnderLowerTolerance_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersUnderLowerTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cp_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cp",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cpk_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cpk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Pp_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Pp",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Ppk_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Ppk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cm_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cmk_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cmk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cpm_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cpm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeAppraiserVariation_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeAppraiserVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeEquipmentVariation_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeEquipmentVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeInteraction_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeInteraction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeGageRandR_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeGageRandR",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativePartVariation_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativePartVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RelativeTotalVariation_element_factory_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeTotalVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    // StatsBaseType
    //

    StatsBaseType::
    StatsBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      CommonStatsValue_ (this)
    {
    }

    StatsBaseType::
    StatsBaseType (const StatsBaseType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      CommonStatsValue_ (x.CommonStatsValue_, f, this)
    {
    }

    StatsBaseType::
    StatsBaseType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      CommonStatsValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // CommonStatsValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CommonStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< CommonStatsValue_type > r (
              dynamic_cast< CommonStatsValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->CommonStatsValue_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsBaseType& StatsBaseType::
    operator= (const StatsBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->CommonStatsValue_ = x.CommonStatsValue_;
      }

      return *this;
    }

    StatsBaseType::
    ~StatsBaseType ()
    {
    }

    // StatsNumericalBaseType
    //

    StatsNumericalBaseType::
    StatsNumericalBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      NumericCharacteristicStatsValue_ (this)
    {
    }

    StatsNumericalBaseType::
    StatsNumericalBaseType (const StatsNumericalBaseType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      NumericCharacteristicStatsValue_ (x.NumericCharacteristicStatsValue_, f, this)
    {
    }

    StatsNumericalBaseType::
    StatsNumericalBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      NumericCharacteristicStatsValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsNumericalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // NumericCharacteristicStatsValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"NumericCharacteristicStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< NumericCharacteristicStatsValue_type > r (
              dynamic_cast< NumericCharacteristicStatsValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NumericCharacteristicStatsValue_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsNumericalBaseType& StatsNumericalBaseType::
    operator= (const StatsNumericalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->NumericCharacteristicStatsValue_ = x.NumericCharacteristicStatsValue_;
      }

      return *this;
    }

    StatsNumericalBaseType::
    ~StatsNumericalBaseType ()
    {
    }

    // StatsWithTolNumericalBaseType
    //

    StatsWithTolNumericalBaseType::
    StatsWithTolNumericalBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      NumericCharacteristicWithTolStatsValue_ (this)
    {
    }

    StatsWithTolNumericalBaseType::
    StatsWithTolNumericalBaseType (const StatsWithTolNumericalBaseType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      NumericCharacteristicWithTolStatsValue_ (x.NumericCharacteristicWithTolStatsValue_, f, this)
    {
    }

    StatsWithTolNumericalBaseType::
    StatsWithTolNumericalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      NumericCharacteristicWithTolStatsValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsWithTolNumericalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // NumericCharacteristicWithTolStatsValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"NumericCharacteristicWithTolStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< NumericCharacteristicWithTolStatsValue_type > r (
              dynamic_cast< NumericCharacteristicWithTolStatsValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NumericCharacteristicWithTolStatsValue_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsWithTolNumericalBaseType& StatsWithTolNumericalBaseType::
    operator= (const StatsWithTolNumericalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->NumericCharacteristicWithTolStatsValue_ = x.NumericCharacteristicWithTolStatsValue_;
      }

      return *this;
    }

    StatsWithTolNumericalBaseType::
    ~StatsWithTolNumericalBaseType ()
    {
    }

    // StatsWithTolLinearType
    //

    StatsWithTolLinearType::
    StatsWithTolLinearType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      linearUnit_ (this)
    {
    }

    StatsWithTolLinearType::
    StatsWithTolLinearType (const StatsWithTolLinearType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    StatsWithTolLinearType::
    StatsWithTolLinearType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolLinearType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolLinearType* StatsWithTolLinearType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolLinearType (*this, f, c);
    }

    StatsWithTolLinearType& StatsWithTolLinearType::
    operator= (const StatsWithTolLinearType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    StatsWithTolLinearType::
    ~StatsWithTolLinearType ()
    {
    }

    // StatsWithTolAngularType
    //

    StatsWithTolAngularType::
    StatsWithTolAngularType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      angularUnit_ (this)
    {
    }

    StatsWithTolAngularType::
    StatsWithTolAngularType (const StatsWithTolAngularType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    StatsWithTolAngularType::
    StatsWithTolAngularType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolAngularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolAngularType* StatsWithTolAngularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolAngularType (*this, f, c);
    }

    StatsWithTolAngularType& StatsWithTolAngularType::
    operator= (const StatsWithTolAngularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    StatsWithTolAngularType::
    ~StatsWithTolAngularType ()
    {
    }

    // StatsWithTolAreaType
    //

    StatsWithTolAreaType::
    StatsWithTolAreaType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      areaUnit_ (this)
    {
    }

    StatsWithTolAreaType::
    StatsWithTolAreaType (const StatsWithTolAreaType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    StatsWithTolAreaType::
    StatsWithTolAreaType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolAreaType* StatsWithTolAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolAreaType (*this, f, c);
    }

    StatsWithTolAreaType& StatsWithTolAreaType::
    operator= (const StatsWithTolAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    StatsWithTolAreaType::
    ~StatsWithTolAreaType ()
    {
    }

    // StatsWithTolForceType
    //

    StatsWithTolForceType::
    StatsWithTolForceType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      forceUnit_ (this)
    {
    }

    StatsWithTolForceType::
    StatsWithTolForceType (const StatsWithTolForceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    StatsWithTolForceType::
    StatsWithTolForceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolForceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolForceType* StatsWithTolForceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolForceType (*this, f, c);
    }

    StatsWithTolForceType& StatsWithTolForceType::
    operator= (const StatsWithTolForceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    StatsWithTolForceType::
    ~StatsWithTolForceType ()
    {
    }

    // StatsWithTolMassType
    //

    StatsWithTolMassType::
    StatsWithTolMassType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      massUnit_ (this)
    {
    }

    StatsWithTolMassType::
    StatsWithTolMassType (const StatsWithTolMassType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    StatsWithTolMassType::
    StatsWithTolMassType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolMassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolMassType* StatsWithTolMassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolMassType (*this, f, c);
    }

    StatsWithTolMassType& StatsWithTolMassType::
    operator= (const StatsWithTolMassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    StatsWithTolMassType::
    ~StatsWithTolMassType ()
    {
    }

    // StatsWithTolPressureType
    //

    StatsWithTolPressureType::
    StatsWithTolPressureType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      pressureUnit_ (this)
    {
    }

    StatsWithTolPressureType::
    StatsWithTolPressureType (const StatsWithTolPressureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    StatsWithTolPressureType::
    StatsWithTolPressureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolPressureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolPressureType* StatsWithTolPressureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolPressureType (*this, f, c);
    }

    StatsWithTolPressureType& StatsWithTolPressureType::
    operator= (const StatsWithTolPressureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    StatsWithTolPressureType::
    ~StatsWithTolPressureType ()
    {
    }

    // StatsWithTolSpeedType
    //

    StatsWithTolSpeedType::
    StatsWithTolSpeedType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      speedUnit_ (this)
    {
    }

    StatsWithTolSpeedType::
    StatsWithTolSpeedType (const StatsWithTolSpeedType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    StatsWithTolSpeedType::
    StatsWithTolSpeedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolSpeedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolSpeedType* StatsWithTolSpeedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolSpeedType (*this, f, c);
    }

    StatsWithTolSpeedType& StatsWithTolSpeedType::
    operator= (const StatsWithTolSpeedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    StatsWithTolSpeedType::
    ~StatsWithTolSpeedType ()
    {
    }

    // StatsWithTolTemperatureType
    //

    StatsWithTolTemperatureType::
    StatsWithTolTemperatureType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      temperatureUnit_ (this)
    {
    }

    StatsWithTolTemperatureType::
    StatsWithTolTemperatureType (const StatsWithTolTemperatureType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    StatsWithTolTemperatureType::
    StatsWithTolTemperatureType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolTemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolTemperatureType* StatsWithTolTemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolTemperatureType (*this, f, c);
    }

    StatsWithTolTemperatureType& StatsWithTolTemperatureType::
    operator= (const StatsWithTolTemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    StatsWithTolTemperatureType::
    ~StatsWithTolTemperatureType ()
    {
    }

    // StatsWithTolTimeType
    //

    StatsWithTolTimeType::
    StatsWithTolTimeType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      timeUnit_ (this)
    {
    }

    StatsWithTolTimeType::
    StatsWithTolTimeType (const StatsWithTolTimeType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    StatsWithTolTimeType::
    StatsWithTolTimeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsWithTolTimeType* StatsWithTolTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolTimeType (*this, f, c);
    }

    StatsWithTolTimeType& StatsWithTolTimeType::
    operator= (const StatsWithTolTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    StatsWithTolTimeType::
    ~StatsWithTolTimeType ()
    {
    }

    // StatsWithTolUserDefinedUnitType
    //

    StatsWithTolUserDefinedUnitType::
    StatsWithTolUserDefinedUnitType ()
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      unitName_ (this)
    {
    }

    StatsWithTolUserDefinedUnitType::
    StatsWithTolUserDefinedUnitType (const unitName_type& unitName)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (),
      unitName_ (unitName, this)
    {
    }

    StatsWithTolUserDefinedUnitType::
    StatsWithTolUserDefinedUnitType (const StatsWithTolUserDefinedUnitType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    StatsWithTolUserDefinedUnitType::
    StatsWithTolUserDefinedUnitType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithTolNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsWithTolUserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithTolNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    StatsWithTolUserDefinedUnitType* StatsWithTolUserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsWithTolUserDefinedUnitType (*this, f, c);
    }

    StatsWithTolUserDefinedUnitType& StatsWithTolUserDefinedUnitType::
    operator= (const StatsWithTolUserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithTolNumericalBaseType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    StatsWithTolUserDefinedUnitType::
    ~StatsWithTolUserDefinedUnitType ()
    {
    }

    // StatsLinearType
    //

    StatsLinearType::
    StatsLinearType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      linearUnit_ (this)
    {
    }

    StatsLinearType::
    StatsLinearType (const StatsLinearType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    StatsLinearType::
    StatsLinearType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsLinearType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsLinearType* StatsLinearType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsLinearType (*this, f, c);
    }

    StatsLinearType& StatsLinearType::
    operator= (const StatsLinearType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    StatsLinearType::
    ~StatsLinearType ()
    {
    }

    // StatsAngularType
    //

    StatsAngularType::
    StatsAngularType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      angularUnit_ (this)
    {
    }

    StatsAngularType::
    StatsAngularType (const StatsAngularType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    StatsAngularType::
    StatsAngularType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsAngularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsAngularType* StatsAngularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsAngularType (*this, f, c);
    }

    StatsAngularType& StatsAngularType::
    operator= (const StatsAngularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    StatsAngularType::
    ~StatsAngularType ()
    {
    }

    // StatsAreaType
    //

    StatsAreaType::
    StatsAreaType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      areaUnit_ (this)
    {
    }

    StatsAreaType::
    StatsAreaType (const StatsAreaType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    StatsAreaType::
    StatsAreaType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsAreaType* StatsAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsAreaType (*this, f, c);
    }

    StatsAreaType& StatsAreaType::
    operator= (const StatsAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    StatsAreaType::
    ~StatsAreaType ()
    {
    }

    // StatsForceType
    //

    StatsForceType::
    StatsForceType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      forceUnit_ (this)
    {
    }

    StatsForceType::
    StatsForceType (const StatsForceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    StatsForceType::
    StatsForceType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsForceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsForceType* StatsForceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsForceType (*this, f, c);
    }

    StatsForceType& StatsForceType::
    operator= (const StatsForceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    StatsForceType::
    ~StatsForceType ()
    {
    }

    // StatsMassType
    //

    StatsMassType::
    StatsMassType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      massUnit_ (this)
    {
    }

    StatsMassType::
    StatsMassType (const StatsMassType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    StatsMassType::
    StatsMassType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsMassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsMassType* StatsMassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsMassType (*this, f, c);
    }

    StatsMassType& StatsMassType::
    operator= (const StatsMassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    StatsMassType::
    ~StatsMassType ()
    {
    }

    // StatsPressureType
    //

    StatsPressureType::
    StatsPressureType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      pressureUnit_ (this)
    {
    }

    StatsPressureType::
    StatsPressureType (const StatsPressureType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    StatsPressureType::
    StatsPressureType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsPressureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsPressureType* StatsPressureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsPressureType (*this, f, c);
    }

    StatsPressureType& StatsPressureType::
    operator= (const StatsPressureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    StatsPressureType::
    ~StatsPressureType ()
    {
    }

    // StatsSpeedType
    //

    StatsSpeedType::
    StatsSpeedType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      speedUnit_ (this)
    {
    }

    StatsSpeedType::
    StatsSpeedType (const StatsSpeedType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    StatsSpeedType::
    StatsSpeedType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsSpeedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsSpeedType* StatsSpeedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsSpeedType (*this, f, c);
    }

    StatsSpeedType& StatsSpeedType::
    operator= (const StatsSpeedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    StatsSpeedType::
    ~StatsSpeedType ()
    {
    }

    // StatsTemperatureType
    //

    StatsTemperatureType::
    StatsTemperatureType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      temperatureUnit_ (this)
    {
    }

    StatsTemperatureType::
    StatsTemperatureType (const StatsTemperatureType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    StatsTemperatureType::
    StatsTemperatureType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsTemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsTemperatureType* StatsTemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsTemperatureType (*this, f, c);
    }

    StatsTemperatureType& StatsTemperatureType::
    operator= (const StatsTemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    StatsTemperatureType::
    ~StatsTemperatureType ()
    {
    }

    // StatsTimeType
    //

    StatsTimeType::
    StatsTimeType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      timeUnit_ (this)
    {
    }

    StatsTimeType::
    StatsTimeType (const StatsTimeType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    StatsTimeType::
    StatsTimeType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    StatsTimeType* StatsTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsTimeType (*this, f, c);
    }

    StatsTimeType& StatsTimeType::
    operator= (const StatsTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    StatsTimeType::
    ~StatsTimeType ()
    {
    }

    // StatsUserDefinedUnitType
    //

    StatsUserDefinedUnitType::
    StatsUserDefinedUnitType ()
    : ::xsd::qif30::StatsNumericalBaseType (),
      unitName_ (this)
    {
    }

    StatsUserDefinedUnitType::
    StatsUserDefinedUnitType (const unitName_type& unitName)
    : ::xsd::qif30::StatsNumericalBaseType (),
      unitName_ (unitName, this)
    {
    }

    StatsUserDefinedUnitType::
    StatsUserDefinedUnitType (const StatsUserDefinedUnitType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    StatsUserDefinedUnitType::
    StatsUserDefinedUnitType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsNumericalBaseType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatsUserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNumericalBaseType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    StatsUserDefinedUnitType* StatsUserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsUserDefinedUnitType (*this, f, c);
    }

    StatsUserDefinedUnitType& StatsUserDefinedUnitType::
    operator= (const StatsUserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNumericalBaseType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    StatsUserDefinedUnitType::
    ~StatsUserDefinedUnitType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FailurePercentage_element_factory_init (
      L"PassFailStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"FailurePercentage",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_NumberFailures_element_factory_init (
      L"PassFailStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberFailures",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    // StatsPassFailType
    //

    StatsPassFailType::
    StatsPassFailType ()
    : ::xsd::qif30::StatsBaseType (),
      PassFailStatsValue_ (this)
    {
    }

    StatsPassFailType::
    StatsPassFailType (const StatsPassFailType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::StatsBaseType (x, f, c),
      PassFailStatsValue_ (x.PassFailStatsValue_, f, this)
    {
    }

    StatsPassFailType::
    StatsPassFailType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::StatsBaseType (e, f | ::xml_schema::flags::base, c),
      PassFailStatsValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsPassFailType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PassFailStatsValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PassFailStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PassFailStatsValue_type > r (
              dynamic_cast< PassFailStatsValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->PassFailStatsValue_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsPassFailType* StatsPassFailType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsPassFailType (*this, f, c);
    }

    StatsPassFailType& StatsPassFailType::
    operator= (const StatsPassFailType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsBaseType& > (*this) = x;
        this->PassFailStatsValue_ = x.PassFailStatsValue_;
      }

      return *this;
    }

    StatsPassFailType::
    ~StatsPassFailType ()
    {
    }

    // GeometricCharacteristicStatsEvalType
    //

    GeometricCharacteristicStatsEvalType::
    GeometricCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
    }

    GeometricCharacteristicStatsEvalType::
    GeometricCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
    }

    GeometricCharacteristicStatsEvalType::
    GeometricCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
    }

    GeometricCharacteristicStatsEvalType::
    GeometricCharacteristicStatsEvalType (const GeometricCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this)
    {
    }

    GeometricCharacteristicStatsEvalType::
    GeometricCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void GeometricCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    GeometricCharacteristicStatsEvalType* GeometricCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GeometricCharacteristicStatsEvalType (*this, f, c);
    }

    GeometricCharacteristicStatsEvalType& GeometricCharacteristicStatsEvalType::
    operator= (const GeometricCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
      }

      return *this;
    }

    GeometricCharacteristicStatsEvalType::
    ~GeometricCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GeometricCharacteristicStatsEvalType >
    _xsd_GeometricCharacteristicStatsEvalType_type_factory_init (
      L"GeometricCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // CompositeSegmentStatsEvalBaseType
    //

    CompositeSegmentStatsEvalBaseType::
    CompositeSegmentStatsEvalBaseType ()
    : ::xml_schema::type (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
    }

    CompositeSegmentStatsEvalBaseType::
    CompositeSegmentStatsEvalBaseType (const CompositeSegmentStatsEvalBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this)
    {
    }

    CompositeSegmentStatsEvalBaseType::
    CompositeSegmentStatsEvalBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CompositeSegmentStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CompositeSegmentStatsEvalBaseType& CompositeSegmentStatsEvalBaseType::
    operator= (const CompositeSegmentStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
      }

      return *this;
    }

    CompositeSegmentStatsEvalBaseType::
    ~CompositeSegmentStatsEvalBaseType ()
    {
    }

    // CompositeSegmentPositionStatsEvalType
    //

    CompositeSegmentPositionStatsEvalType::
    CompositeSegmentPositionStatsEvalType ()
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType ()
    {
    }

    CompositeSegmentPositionStatsEvalType::
    CompositeSegmentPositionStatsEvalType (const CompositeSegmentPositionStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (x, f, c)
    {
    }

    CompositeSegmentPositionStatsEvalType::
    CompositeSegmentPositionStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (e, f, c)
    {
    }

    CompositeSegmentPositionStatsEvalType* CompositeSegmentPositionStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentPositionStatsEvalType (*this, f, c);
    }

    CompositeSegmentPositionStatsEvalType::
    ~CompositeSegmentPositionStatsEvalType ()
    {
    }

    // CompositeSegmentsPositionStatsEvalType
    //

    CompositeSegmentsPositionStatsEvalType::
    CompositeSegmentsPositionStatsEvalType ()
    : ::xml_schema::type (),
      SecondCompositeSegmentPositionStats_ (this),
      ThirdCompositeSegmentPositionStats_ (this),
      FourthCompositeSegmentPositionStats_ (this)
    {
    }

    CompositeSegmentsPositionStatsEvalType::
    CompositeSegmentsPositionStatsEvalType (const SecondCompositeSegmentPositionStats_type& SecondCompositeSegmentPositionStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentPositionStats_ (SecondCompositeSegmentPositionStats, this),
      ThirdCompositeSegmentPositionStats_ (this),
      FourthCompositeSegmentPositionStats_ (this)
    {
    }

    CompositeSegmentsPositionStatsEvalType::
    CompositeSegmentsPositionStatsEvalType (::std::unique_ptr< SecondCompositeSegmentPositionStats_type > SecondCompositeSegmentPositionStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentPositionStats_ (std::move (SecondCompositeSegmentPositionStats), this),
      ThirdCompositeSegmentPositionStats_ (this),
      FourthCompositeSegmentPositionStats_ (this)
    {
    }

    CompositeSegmentsPositionStatsEvalType::
    CompositeSegmentsPositionStatsEvalType (const CompositeSegmentsPositionStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SecondCompositeSegmentPositionStats_ (x.SecondCompositeSegmentPositionStats_, f, this),
      ThirdCompositeSegmentPositionStats_ (x.ThirdCompositeSegmentPositionStats_, f, this),
      FourthCompositeSegmentPositionStats_ (x.FourthCompositeSegmentPositionStats_, f, this)
    {
    }

    CompositeSegmentsPositionStatsEvalType::
    CompositeSegmentsPositionStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SecondCompositeSegmentPositionStats_ (this),
      ThirdCompositeSegmentPositionStats_ (this),
      FourthCompositeSegmentPositionStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CompositeSegmentsPositionStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SecondCompositeSegmentPositionStats
        //
        if (n.name () == L"SecondCompositeSegmentPositionStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondCompositeSegmentPositionStats_type > r (
            SecondCompositeSegmentPositionStats_traits::create (i, f, this));

          if (!SecondCompositeSegmentPositionStats_.present ())
          {
            this->SecondCompositeSegmentPositionStats_.set (::std::move (r));
            continue;
          }
        }

        // ThirdCompositeSegmentPositionStats
        //
        if (n.name () == L"ThirdCompositeSegmentPositionStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThirdCompositeSegmentPositionStats_type > r (
            ThirdCompositeSegmentPositionStats_traits::create (i, f, this));

          if (!this->ThirdCompositeSegmentPositionStats_)
          {
            this->ThirdCompositeSegmentPositionStats_.set (::std::move (r));
            continue;
          }
        }

        // FourthCompositeSegmentPositionStats
        //
        if (n.name () == L"FourthCompositeSegmentPositionStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FourthCompositeSegmentPositionStats_type > r (
            FourthCompositeSegmentPositionStats_traits::create (i, f, this));

          if (!this->FourthCompositeSegmentPositionStats_)
          {
            this->FourthCompositeSegmentPositionStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SecondCompositeSegmentPositionStats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondCompositeSegmentPositionStats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CompositeSegmentsPositionStatsEvalType* CompositeSegmentsPositionStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentsPositionStatsEvalType (*this, f, c);
    }

    CompositeSegmentsPositionStatsEvalType& CompositeSegmentsPositionStatsEvalType::
    operator= (const CompositeSegmentsPositionStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SecondCompositeSegmentPositionStats_ = x.SecondCompositeSegmentPositionStats_;
        this->ThirdCompositeSegmentPositionStats_ = x.ThirdCompositeSegmentPositionStats_;
        this->FourthCompositeSegmentPositionStats_ = x.FourthCompositeSegmentPositionStats_;
      }

      return *this;
    }

    CompositeSegmentsPositionStatsEvalType::
    ~CompositeSegmentsPositionStatsEvalType ()
    {
    }

    // CompositeSegmentProfileStatsEvalType
    //

    CompositeSegmentProfileStatsEvalType::
    CompositeSegmentProfileStatsEvalType ()
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType ()
    {
    }

    CompositeSegmentProfileStatsEvalType::
    CompositeSegmentProfileStatsEvalType (const CompositeSegmentProfileStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (x, f, c)
    {
    }

    CompositeSegmentProfileStatsEvalType::
    CompositeSegmentProfileStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (e, f, c)
    {
    }

    CompositeSegmentProfileStatsEvalType* CompositeSegmentProfileStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentProfileStatsEvalType (*this, f, c);
    }

    CompositeSegmentProfileStatsEvalType::
    ~CompositeSegmentProfileStatsEvalType ()
    {
    }

    // CompositeSegmentsProfileStatsEvalType
    //

    CompositeSegmentsProfileStatsEvalType::
    CompositeSegmentsProfileStatsEvalType ()
    : ::xml_schema::type (),
      SecondCompositeSegmentProfileStats_ (this),
      ThirdCompositeSegmentProfileStats_ (this),
      FourthCompositeSegmentProfileStats_ (this)
    {
    }

    CompositeSegmentsProfileStatsEvalType::
    CompositeSegmentsProfileStatsEvalType (const SecondCompositeSegmentProfileStats_type& SecondCompositeSegmentProfileStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentProfileStats_ (SecondCompositeSegmentProfileStats, this),
      ThirdCompositeSegmentProfileStats_ (this),
      FourthCompositeSegmentProfileStats_ (this)
    {
    }

    CompositeSegmentsProfileStatsEvalType::
    CompositeSegmentsProfileStatsEvalType (::std::unique_ptr< SecondCompositeSegmentProfileStats_type > SecondCompositeSegmentProfileStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentProfileStats_ (std::move (SecondCompositeSegmentProfileStats), this),
      ThirdCompositeSegmentProfileStats_ (this),
      FourthCompositeSegmentProfileStats_ (this)
    {
    }

    CompositeSegmentsProfileStatsEvalType::
    CompositeSegmentsProfileStatsEvalType (const CompositeSegmentsProfileStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SecondCompositeSegmentProfileStats_ (x.SecondCompositeSegmentProfileStats_, f, this),
      ThirdCompositeSegmentProfileStats_ (x.ThirdCompositeSegmentProfileStats_, f, this),
      FourthCompositeSegmentProfileStats_ (x.FourthCompositeSegmentProfileStats_, f, this)
    {
    }

    CompositeSegmentsProfileStatsEvalType::
    CompositeSegmentsProfileStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SecondCompositeSegmentProfileStats_ (this),
      ThirdCompositeSegmentProfileStats_ (this),
      FourthCompositeSegmentProfileStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CompositeSegmentsProfileStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SecondCompositeSegmentProfileStats
        //
        if (n.name () == L"SecondCompositeSegmentProfileStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondCompositeSegmentProfileStats_type > r (
            SecondCompositeSegmentProfileStats_traits::create (i, f, this));

          if (!SecondCompositeSegmentProfileStats_.present ())
          {
            this->SecondCompositeSegmentProfileStats_.set (::std::move (r));
            continue;
          }
        }

        // ThirdCompositeSegmentProfileStats
        //
        if (n.name () == L"ThirdCompositeSegmentProfileStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThirdCompositeSegmentProfileStats_type > r (
            ThirdCompositeSegmentProfileStats_traits::create (i, f, this));

          if (!this->ThirdCompositeSegmentProfileStats_)
          {
            this->ThirdCompositeSegmentProfileStats_.set (::std::move (r));
            continue;
          }
        }

        // FourthCompositeSegmentProfileStats
        //
        if (n.name () == L"FourthCompositeSegmentProfileStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FourthCompositeSegmentProfileStats_type > r (
            FourthCompositeSegmentProfileStats_traits::create (i, f, this));

          if (!this->FourthCompositeSegmentProfileStats_)
          {
            this->FourthCompositeSegmentProfileStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SecondCompositeSegmentProfileStats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondCompositeSegmentProfileStats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CompositeSegmentsProfileStatsEvalType* CompositeSegmentsProfileStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentsProfileStatsEvalType (*this, f, c);
    }

    CompositeSegmentsProfileStatsEvalType& CompositeSegmentsProfileStatsEvalType::
    operator= (const CompositeSegmentsProfileStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SecondCompositeSegmentProfileStats_ = x.SecondCompositeSegmentProfileStats_;
        this->ThirdCompositeSegmentProfileStats_ = x.ThirdCompositeSegmentProfileStats_;
        this->FourthCompositeSegmentProfileStats_ = x.FourthCompositeSegmentProfileStats_;
      }

      return *this;
    }

    CompositeSegmentsProfileStatsEvalType::
    ~CompositeSegmentsProfileStatsEvalType ()
    {
    }

    // CompositeSegmentSymmetryStatsEvalType
    //

    CompositeSegmentSymmetryStatsEvalType::
    CompositeSegmentSymmetryStatsEvalType ()
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType ()
    {
    }

    CompositeSegmentSymmetryStatsEvalType::
    CompositeSegmentSymmetryStatsEvalType (const CompositeSegmentSymmetryStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (x, f, c)
    {
    }

    CompositeSegmentSymmetryStatsEvalType::
    CompositeSegmentSymmetryStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CompositeSegmentStatsEvalBaseType (e, f, c)
    {
    }

    CompositeSegmentSymmetryStatsEvalType* CompositeSegmentSymmetryStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentSymmetryStatsEvalType (*this, f, c);
    }

    CompositeSegmentSymmetryStatsEvalType::
    ~CompositeSegmentSymmetryStatsEvalType ()
    {
    }

    // CompositeSegmentsSymmetryStatsEvalType
    //

    CompositeSegmentsSymmetryStatsEvalType::
    CompositeSegmentsSymmetryStatsEvalType ()
    : ::xml_schema::type (),
      SecondCompositeSegmentSymmetryStats_ (this),
      ThirdCompositeSegmentSymmetryStats_ (this)
    {
    }

    CompositeSegmentsSymmetryStatsEvalType::
    CompositeSegmentsSymmetryStatsEvalType (const SecondCompositeSegmentSymmetryStats_type& SecondCompositeSegmentSymmetryStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentSymmetryStats_ (SecondCompositeSegmentSymmetryStats, this),
      ThirdCompositeSegmentSymmetryStats_ (this)
    {
    }

    CompositeSegmentsSymmetryStatsEvalType::
    CompositeSegmentsSymmetryStatsEvalType (::std::unique_ptr< SecondCompositeSegmentSymmetryStats_type > SecondCompositeSegmentSymmetryStats)
    : ::xml_schema::type (),
      SecondCompositeSegmentSymmetryStats_ (std::move (SecondCompositeSegmentSymmetryStats), this),
      ThirdCompositeSegmentSymmetryStats_ (this)
    {
    }

    CompositeSegmentsSymmetryStatsEvalType::
    CompositeSegmentsSymmetryStatsEvalType (const CompositeSegmentsSymmetryStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SecondCompositeSegmentSymmetryStats_ (x.SecondCompositeSegmentSymmetryStats_, f, this),
      ThirdCompositeSegmentSymmetryStats_ (x.ThirdCompositeSegmentSymmetryStats_, f, this)
    {
    }

    CompositeSegmentsSymmetryStatsEvalType::
    CompositeSegmentsSymmetryStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SecondCompositeSegmentSymmetryStats_ (this),
      ThirdCompositeSegmentSymmetryStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CompositeSegmentsSymmetryStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SecondCompositeSegmentSymmetryStats
        //
        if (n.name () == L"SecondCompositeSegmentSymmetryStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondCompositeSegmentSymmetryStats_type > r (
            SecondCompositeSegmentSymmetryStats_traits::create (i, f, this));

          if (!SecondCompositeSegmentSymmetryStats_.present ())
          {
            this->SecondCompositeSegmentSymmetryStats_.set (::std::move (r));
            continue;
          }
        }

        // ThirdCompositeSegmentSymmetryStats
        //
        if (n.name () == L"ThirdCompositeSegmentSymmetryStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThirdCompositeSegmentSymmetryStats_type > r (
            ThirdCompositeSegmentSymmetryStats_traits::create (i, f, this));

          if (!this->ThirdCompositeSegmentSymmetryStats_)
          {
            this->ThirdCompositeSegmentSymmetryStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SecondCompositeSegmentSymmetryStats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondCompositeSegmentSymmetryStats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CompositeSegmentsSymmetryStatsEvalType* CompositeSegmentsSymmetryStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeSegmentsSymmetryStatsEvalType (*this, f, c);
    }

    CompositeSegmentsSymmetryStatsEvalType& CompositeSegmentsSymmetryStatsEvalType::
    operator= (const CompositeSegmentsSymmetryStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SecondCompositeSegmentSymmetryStats_ = x.SecondCompositeSegmentSymmetryStats_;
        this->ThirdCompositeSegmentSymmetryStats_ = x.ThirdCompositeSegmentSymmetryStats_;
      }

      return *this;
    }

    CompositeSegmentsSymmetryStatsEvalType::
    ~CompositeSegmentsSymmetryStatsEvalType ()
    {
    }

    // LinearCharacteristicStatsEvalType
    //

    LinearCharacteristicStatsEvalType::
    LinearCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    LinearCharacteristicStatsEvalType::
    LinearCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    LinearCharacteristicStatsEvalType::
    LinearCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    LinearCharacteristicStatsEvalType::
    LinearCharacteristicStatsEvalType (const LinearCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    LinearCharacteristicStatsEvalType::
    LinearCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LinearCharacteristicStatsEvalType* LinearCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearCharacteristicStatsEvalType (*this, f, c);
    }

    LinearCharacteristicStatsEvalType& LinearCharacteristicStatsEvalType::
    operator= (const LinearCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    LinearCharacteristicStatsEvalType::
    ~LinearCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearCharacteristicStatsEvalType >
    _xsd_LinearCharacteristicStatsEvalType_type_factory_init (
      L"LinearCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngularCharacteristicStatsEvalType
    //

    AngularCharacteristicStatsEvalType::
    AngularCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    AngularCharacteristicStatsEvalType::
    AngularCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    AngularCharacteristicStatsEvalType::
    AngularCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    AngularCharacteristicStatsEvalType::
    AngularCharacteristicStatsEvalType (const AngularCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    AngularCharacteristicStatsEvalType::
    AngularCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AngularCharacteristicStatsEvalType* AngularCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularCharacteristicStatsEvalType (*this, f, c);
    }

    AngularCharacteristicStatsEvalType& AngularCharacteristicStatsEvalType::
    operator= (const AngularCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    AngularCharacteristicStatsEvalType::
    ~AngularCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngularCharacteristicStatsEvalType >
    _xsd_AngularCharacteristicStatsEvalType_type_factory_init (
      L"AngularCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedAttributeCharacteristicStatsEvalType
    //

    UserDefinedAttributeCharacteristicStatsEvalType::
    UserDefinedAttributeCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      AttributeStats_ (this)
    {
    }

    UserDefinedAttributeCharacteristicStatsEvalType::
    UserDefinedAttributeCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      AttributeStats_ (this)
    {
    }

    UserDefinedAttributeCharacteristicStatsEvalType::
    UserDefinedAttributeCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      AttributeStats_ (this)
    {
    }

    UserDefinedAttributeCharacteristicStatsEvalType::
    UserDefinedAttributeCharacteristicStatsEvalType (const UserDefinedAttributeCharacteristicStatsEvalType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      AttributeStats_ (x.AttributeStats_, f, this)
    {
    }

    UserDefinedAttributeCharacteristicStatsEvalType::
    UserDefinedAttributeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      AttributeStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedAttributeCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AttributeStats
        //
        if (n.name () == L"AttributeStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AttributeStats_type > r (
            AttributeStats_traits::create (i, f, this));

          if (!this->AttributeStats_)
          {
            this->AttributeStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedAttributeCharacteristicStatsEvalType* UserDefinedAttributeCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedAttributeCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedAttributeCharacteristicStatsEvalType& UserDefinedAttributeCharacteristicStatsEvalType::
    operator= (const UserDefinedAttributeCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->AttributeStats_ = x.AttributeStats_;
      }

      return *this;
    }

    UserDefinedAttributeCharacteristicStatsEvalType::
    ~UserDefinedAttributeCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedAttributeCharacteristicStatsEvalType >
    _xsd_UserDefinedAttributeCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedAttributeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedLinearCharacteristicStatsEvalType
    //

    UserDefinedLinearCharacteristicStatsEvalType::
    UserDefinedLinearCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedLinearCharacteristicStatsEvalType::
    UserDefinedLinearCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedLinearCharacteristicStatsEvalType::
    UserDefinedLinearCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedLinearCharacteristicStatsEvalType::
    UserDefinedLinearCharacteristicStatsEvalType (const UserDefinedLinearCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedLinearCharacteristicStatsEvalType::
    UserDefinedLinearCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedLinearCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedLinearCharacteristicStatsEvalType* UserDefinedLinearCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedLinearCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedLinearCharacteristicStatsEvalType& UserDefinedLinearCharacteristicStatsEvalType::
    operator= (const UserDefinedLinearCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedLinearCharacteristicStatsEvalType::
    ~UserDefinedLinearCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedLinearCharacteristicStatsEvalType >
    _xsd_UserDefinedLinearCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedLinearCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedAngularCharacteristicStatsEvalType
    //

    UserDefinedAngularCharacteristicStatsEvalType::
    UserDefinedAngularCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAngularCharacteristicStatsEvalType::
    UserDefinedAngularCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAngularCharacteristicStatsEvalType::
    UserDefinedAngularCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAngularCharacteristicStatsEvalType::
    UserDefinedAngularCharacteristicStatsEvalType (const UserDefinedAngularCharacteristicStatsEvalType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedAngularCharacteristicStatsEvalType::
    UserDefinedAngularCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedAngularCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedAngularCharacteristicStatsEvalType* UserDefinedAngularCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedAngularCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedAngularCharacteristicStatsEvalType& UserDefinedAngularCharacteristicStatsEvalType::
    operator= (const UserDefinedAngularCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedAngularCharacteristicStatsEvalType::
    ~UserDefinedAngularCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedAngularCharacteristicStatsEvalType >
    _xsd_UserDefinedAngularCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedAngularCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedAreaCharacteristicStatsEvalType
    //

    UserDefinedAreaCharacteristicStatsEvalType::
    UserDefinedAreaCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAreaCharacteristicStatsEvalType::
    UserDefinedAreaCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAreaCharacteristicStatsEvalType::
    UserDefinedAreaCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedAreaCharacteristicStatsEvalType::
    UserDefinedAreaCharacteristicStatsEvalType (const UserDefinedAreaCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedAreaCharacteristicStatsEvalType::
    UserDefinedAreaCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedAreaCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedAreaCharacteristicStatsEvalType* UserDefinedAreaCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedAreaCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedAreaCharacteristicStatsEvalType& UserDefinedAreaCharacteristicStatsEvalType::
    operator= (const UserDefinedAreaCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedAreaCharacteristicStatsEvalType::
    ~UserDefinedAreaCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedAreaCharacteristicStatsEvalType >
    _xsd_UserDefinedAreaCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedAreaCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedForceCharacteristicStatsEvalType
    //

    UserDefinedForceCharacteristicStatsEvalType::
    UserDefinedForceCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedForceCharacteristicStatsEvalType::
    UserDefinedForceCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedForceCharacteristicStatsEvalType::
    UserDefinedForceCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedForceCharacteristicStatsEvalType::
    UserDefinedForceCharacteristicStatsEvalType (const UserDefinedForceCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedForceCharacteristicStatsEvalType::
    UserDefinedForceCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedForceCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedForceCharacteristicStatsEvalType* UserDefinedForceCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedForceCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedForceCharacteristicStatsEvalType& UserDefinedForceCharacteristicStatsEvalType::
    operator= (const UserDefinedForceCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedForceCharacteristicStatsEvalType::
    ~UserDefinedForceCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedForceCharacteristicStatsEvalType >
    _xsd_UserDefinedForceCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedForceCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedMassCharacteristicStatsEvalType
    //

    UserDefinedMassCharacteristicStatsEvalType::
    UserDefinedMassCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedMassCharacteristicStatsEvalType::
    UserDefinedMassCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedMassCharacteristicStatsEvalType::
    UserDefinedMassCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedMassCharacteristicStatsEvalType::
    UserDefinedMassCharacteristicStatsEvalType (const UserDefinedMassCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedMassCharacteristicStatsEvalType::
    UserDefinedMassCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedMassCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedMassCharacteristicStatsEvalType* UserDefinedMassCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedMassCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedMassCharacteristicStatsEvalType& UserDefinedMassCharacteristicStatsEvalType::
    operator= (const UserDefinedMassCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedMassCharacteristicStatsEvalType::
    ~UserDefinedMassCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedMassCharacteristicStatsEvalType >
    _xsd_UserDefinedMassCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedMassCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedPressureCharacteristicStatsEvalType
    //

    UserDefinedPressureCharacteristicStatsEvalType::
    UserDefinedPressureCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedPressureCharacteristicStatsEvalType::
    UserDefinedPressureCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedPressureCharacteristicStatsEvalType::
    UserDefinedPressureCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedPressureCharacteristicStatsEvalType::
    UserDefinedPressureCharacteristicStatsEvalType (const UserDefinedPressureCharacteristicStatsEvalType& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedPressureCharacteristicStatsEvalType::
    UserDefinedPressureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedPressureCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedPressureCharacteristicStatsEvalType* UserDefinedPressureCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedPressureCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedPressureCharacteristicStatsEvalType& UserDefinedPressureCharacteristicStatsEvalType::
    operator= (const UserDefinedPressureCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedPressureCharacteristicStatsEvalType::
    ~UserDefinedPressureCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedPressureCharacteristicStatsEvalType >
    _xsd_UserDefinedPressureCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedPressureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedSpeedCharacteristicStatsEvalType
    //

    UserDefinedSpeedCharacteristicStatsEvalType::
    UserDefinedSpeedCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedSpeedCharacteristicStatsEvalType::
    UserDefinedSpeedCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedSpeedCharacteristicStatsEvalType::
    UserDefinedSpeedCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedSpeedCharacteristicStatsEvalType::
    UserDefinedSpeedCharacteristicStatsEvalType (const UserDefinedSpeedCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedSpeedCharacteristicStatsEvalType::
    UserDefinedSpeedCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedSpeedCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedSpeedCharacteristicStatsEvalType* UserDefinedSpeedCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedSpeedCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedSpeedCharacteristicStatsEvalType& UserDefinedSpeedCharacteristicStatsEvalType::
    operator= (const UserDefinedSpeedCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedSpeedCharacteristicStatsEvalType::
    ~UserDefinedSpeedCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedSpeedCharacteristicStatsEvalType >
    _xsd_UserDefinedSpeedCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedSpeedCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedTemperatureCharacteristicStatsEvalType
    //

    UserDefinedTemperatureCharacteristicStatsEvalType::
    UserDefinedTemperatureCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::
    UserDefinedTemperatureCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::
    UserDefinedTemperatureCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::
    UserDefinedTemperatureCharacteristicStatsEvalType (const UserDefinedTemperatureCharacteristicStatsEvalType& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::
    UserDefinedTemperatureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedTemperatureCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedTemperatureCharacteristicStatsEvalType* UserDefinedTemperatureCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedTemperatureCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedTemperatureCharacteristicStatsEvalType& UserDefinedTemperatureCharacteristicStatsEvalType::
    operator= (const UserDefinedTemperatureCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedTemperatureCharacteristicStatsEvalType::
    ~UserDefinedTemperatureCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedTemperatureCharacteristicStatsEvalType >
    _xsd_UserDefinedTemperatureCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedTemperatureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedTimeCharacteristicStatsEvalType
    //

    UserDefinedTimeCharacteristicStatsEvalType::
    UserDefinedTimeCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTimeCharacteristicStatsEvalType::
    UserDefinedTimeCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTimeCharacteristicStatsEvalType::
    UserDefinedTimeCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedTimeCharacteristicStatsEvalType::
    UserDefinedTimeCharacteristicStatsEvalType (const UserDefinedTimeCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedTimeCharacteristicStatsEvalType::
    UserDefinedTimeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedTimeCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedTimeCharacteristicStatsEvalType* UserDefinedTimeCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedTimeCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedTimeCharacteristicStatsEvalType& UserDefinedTimeCharacteristicStatsEvalType::
    operator= (const UserDefinedTimeCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedTimeCharacteristicStatsEvalType::
    ~UserDefinedTimeCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedTimeCharacteristicStatsEvalType >
    _xsd_UserDefinedTimeCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedTimeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedUnitCharacteristicStatsEvalType
    //

    UserDefinedUnitCharacteristicStatsEvalType::
    UserDefinedUnitCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedUnitCharacteristicStatsEvalType::
    UserDefinedUnitCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedUnitCharacteristicStatsEvalType::
    UserDefinedUnitCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
    }

    UserDefinedUnitCharacteristicStatsEvalType::
    UserDefinedUnitCharacteristicStatsEvalType (const UserDefinedUnitCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ValueStats_ (x.ValueStats_, f, this),
      MaxValueStats_ (x.MaxValueStats_, f, this),
      MinValueStats_ (x.MinValueStats_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this),
      MaxDeviationStats_ (x.MaxDeviationStats_, f, this),
      MinDeviationStats_ (x.MinDeviationStats_, f, this)
    {
    }

    UserDefinedUnitCharacteristicStatsEvalType::
    UserDefinedUnitCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ValueStats_ (this),
      MaxValueStats_ (this),
      MinValueStats_ (this),
      DeviationStats_ (this),
      MaxDeviationStats_ (this),
      MinDeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ValueStats
        //
        if (n.name () == L"ValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ValueStats_type > r (
            ValueStats_traits::create (i, f, this));

          if (!this->ValueStats_)
          {
            this->ValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxValueStats
        //
        if (n.name () == L"MaxValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxValueStats_type > r (
            MaxValueStats_traits::create (i, f, this));

          if (!this->MaxValueStats_)
          {
            this->MaxValueStats_.set (::std::move (r));
            continue;
          }
        }

        // MinValueStats
        //
        if (n.name () == L"MinValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinValueStats_type > r (
            MinValueStats_traits::create (i, f, this));

          if (!this->MinValueStats_)
          {
            this->MinValueStats_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!this->DeviationStats_)
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationStats
        //
        if (n.name () == L"MaxDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationStats_type > r (
            MaxDeviationStats_traits::create (i, f, this));

          if (!this->MaxDeviationStats_)
          {
            this->MaxDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // MinDeviationStats
        //
        if (n.name () == L"MinDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinDeviationStats_type > r (
            MinDeviationStats_traits::create (i, f, this));

          if (!this->MinDeviationStats_)
          {
            this->MinDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UserDefinedUnitCharacteristicStatsEvalType* UserDefinedUnitCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitCharacteristicStatsEvalType (*this, f, c);
    }

    UserDefinedUnitCharacteristicStatsEvalType& UserDefinedUnitCharacteristicStatsEvalType::
    operator= (const UserDefinedUnitCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ValueStats_ = x.ValueStats_;
        this->MaxValueStats_ = x.MaxValueStats_;
        this->MinValueStats_ = x.MinValueStats_;
        this->DeviationStats_ = x.DeviationStats_;
        this->MaxDeviationStats_ = x.MaxDeviationStats_;
        this->MinDeviationStats_ = x.MinDeviationStats_;
      }

      return *this;
    }

    UserDefinedUnitCharacteristicStatsEvalType::
    ~UserDefinedUnitCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedUnitCharacteristicStatsEvalType >
    _xsd_UserDefinedUnitCharacteristicStatsEvalType_type_factory_init (
      L"UserDefinedUnitCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceTextureCharacteristicStatsEvalType
    //

    SurfaceTextureCharacteristicStatsEvalType::
    SurfaceTextureCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      RoughnessAverageValueStats_ (this)
    {
    }

    SurfaceTextureCharacteristicStatsEvalType::
    SurfaceTextureCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      RoughnessAverageValueStats_ (this)
    {
    }

    SurfaceTextureCharacteristicStatsEvalType::
    SurfaceTextureCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      RoughnessAverageValueStats_ (this)
    {
    }

    SurfaceTextureCharacteristicStatsEvalType::
    SurfaceTextureCharacteristicStatsEvalType (const SurfaceTextureCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      RoughnessAverageValueStats_ (x.RoughnessAverageValueStats_, f, this)
    {
    }

    SurfaceTextureCharacteristicStatsEvalType::
    SurfaceTextureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      RoughnessAverageValueStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceTextureCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RoughnessAverageValueStats
        //
        if (n.name () == L"RoughnessAverageValueStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RoughnessAverageValueStats_type > r (
            RoughnessAverageValueStats_traits::create (i, f, this));

          if (!this->RoughnessAverageValueStats_)
          {
            this->RoughnessAverageValueStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceTextureCharacteristicStatsEvalType* SurfaceTextureCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceTextureCharacteristicStatsEvalType (*this, f, c);
    }

    SurfaceTextureCharacteristicStatsEvalType& SurfaceTextureCharacteristicStatsEvalType::
    operator= (const SurfaceTextureCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->RoughnessAverageValueStats_ = x.RoughnessAverageValueStats_;
      }

      return *this;
    }

    SurfaceTextureCharacteristicStatsEvalType::
    ~SurfaceTextureCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceTextureCharacteristicStatsEvalType >
    _xsd_SurfaceTextureCharacteristicStatsEvalType_type_factory_init (
      L"SurfaceTextureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // OrientationCharacteristicStatsEvalType
    //

    OrientationCharacteristicStatsEvalType::
    OrientationCharacteristicStatsEvalType ()
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this),
      BonusStats_ (this),
      ReferenceLengthStats_ (this)
    {
    }

    OrientationCharacteristicStatsEvalType::
    OrientationCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this),
      BonusStats_ (this),
      ReferenceLengthStats_ (this)
    {
    }

    OrientationCharacteristicStatsEvalType::
    OrientationCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this),
      BonusStats_ (this),
      ReferenceLengthStats_ (this)
    {
    }

    OrientationCharacteristicStatsEvalType::
    OrientationCharacteristicStatsEvalType (const OrientationCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this),
      DatumsOkStats_ (x.DatumsOkStats_, f, this),
      BonusStats_ (x.BonusStats_, f, this),
      ReferenceLengthStats_ (x.ReferenceLengthStats_, f, this)
    {
    }

    OrientationCharacteristicStatsEvalType::
    OrientationCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this),
      BonusStats_ (this),
      ReferenceLengthStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrientationCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometricCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        // DatumsOkStats
        //
        if (n.name () == L"DatumsOkStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumsOkStats_type > r (
            DatumsOkStats_traits::create (i, f, this));

          if (!this->DatumsOkStats_)
          {
            this->DatumsOkStats_.set (::std::move (r));
            continue;
          }
        }

        // BonusStats
        //
        if (n.name () == L"BonusStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BonusStats_type > r (
            BonusStats_traits::create (i, f, this));

          if (!this->BonusStats_)
          {
            this->BonusStats_.set (::std::move (r));
            continue;
          }
        }

        // ReferenceLengthStats
        //
        if (n.name () == L"ReferenceLengthStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceLengthStats_type > r (
            ReferenceLengthStats_traits::create (i, f, this));

          if (!this->ReferenceLengthStats_)
          {
            this->ReferenceLengthStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OrientationCharacteristicStatsEvalType* OrientationCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrientationCharacteristicStatsEvalType (*this, f, c);
    }

    OrientationCharacteristicStatsEvalType& OrientationCharacteristicStatsEvalType::
    operator= (const OrientationCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
        this->DatumsOkStats_ = x.DatumsOkStats_;
        this->BonusStats_ = x.BonusStats_;
        this->ReferenceLengthStats_ = x.ReferenceLengthStats_;
      }

      return *this;
    }

    OrientationCharacteristicStatsEvalType::
    ~OrientationCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OrientationCharacteristicStatsEvalType >
    _xsd_OrientationCharacteristicStatsEvalType_type_factory_init (
      L"OrientationCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngularityCharacteristicStatsEvalType
    //

    AngularityCharacteristicStatsEvalType::
    AngularityCharacteristicStatsEvalType ()
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType ()
    {
    }

    AngularityCharacteristicStatsEvalType::
    AngularityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (Status)
    {
    }

    AngularityCharacteristicStatsEvalType::
    AngularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (std::move (Status))
    {
    }

    AngularityCharacteristicStatsEvalType::
    AngularityCharacteristicStatsEvalType (const AngularityCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (x, f, c)
    {
    }

    AngularityCharacteristicStatsEvalType::
    AngularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (e, f, c)
    {
    }

    AngularityCharacteristicStatsEvalType* AngularityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularityCharacteristicStatsEvalType (*this, f, c);
    }

    AngularityCharacteristicStatsEvalType::
    ~AngularityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngularityCharacteristicStatsEvalType >
    _xsd_AngularityCharacteristicStatsEvalType_type_factory_init (
      L"AngularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // PerpendicularityCharacteristicStatsEvalType
    //

    PerpendicularityCharacteristicStatsEvalType::
    PerpendicularityCharacteristicStatsEvalType ()
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType ()
    {
    }

    PerpendicularityCharacteristicStatsEvalType::
    PerpendicularityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (Status)
    {
    }

    PerpendicularityCharacteristicStatsEvalType::
    PerpendicularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (std::move (Status))
    {
    }

    PerpendicularityCharacteristicStatsEvalType::
    PerpendicularityCharacteristicStatsEvalType (const PerpendicularityCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (x, f, c)
    {
    }

    PerpendicularityCharacteristicStatsEvalType::
    PerpendicularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (e, f, c)
    {
    }

    PerpendicularityCharacteristicStatsEvalType* PerpendicularityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PerpendicularityCharacteristicStatsEvalType (*this, f, c);
    }

    PerpendicularityCharacteristicStatsEvalType::
    ~PerpendicularityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PerpendicularityCharacteristicStatsEvalType >
    _xsd_PerpendicularityCharacteristicStatsEvalType_type_factory_init (
      L"PerpendicularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ParallelismCharacteristicStatsEvalType
    //

    ParallelismCharacteristicStatsEvalType::
    ParallelismCharacteristicStatsEvalType ()
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType ()
    {
    }

    ParallelismCharacteristicStatsEvalType::
    ParallelismCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (Status)
    {
    }

    ParallelismCharacteristicStatsEvalType::
    ParallelismCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (std::move (Status))
    {
    }

    ParallelismCharacteristicStatsEvalType::
    ParallelismCharacteristicStatsEvalType (const ParallelismCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (x, f, c)
    {
    }

    ParallelismCharacteristicStatsEvalType::
    ParallelismCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::OrientationCharacteristicStatsEvalType (e, f, c)
    {
    }

    ParallelismCharacteristicStatsEvalType* ParallelismCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParallelismCharacteristicStatsEvalType (*this, f, c);
    }

    ParallelismCharacteristicStatsEvalType::
    ~ParallelismCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ParallelismCharacteristicStatsEvalType >
    _xsd_ParallelismCharacteristicStatsEvalType_type_factory_init (
      L"ParallelismCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // FormCharacteristicStatsEvalBaseType
    //

    FormCharacteristicStatsEvalBaseType::
    FormCharacteristicStatsEvalBaseType ()
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this)
    {
    }

    FormCharacteristicStatsEvalBaseType::
    FormCharacteristicStatsEvalBaseType (const Status_type& Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this)
    {
    }

    FormCharacteristicStatsEvalBaseType::
    FormCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this)
    {
    }

    FormCharacteristicStatsEvalBaseType::
    FormCharacteristicStatsEvalBaseType (const FormCharacteristicStatsEvalBaseType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this)
    {
    }

    FormCharacteristicStatsEvalBaseType::
    FormCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FormCharacteristicStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometricCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FormCharacteristicStatsEvalBaseType& FormCharacteristicStatsEvalBaseType::
    operator= (const FormCharacteristicStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
      }

      return *this;
    }

    FormCharacteristicStatsEvalBaseType::
    ~FormCharacteristicStatsEvalBaseType ()
    {
    }

    // CircularityCharacteristicStatsEvalType
    //

    CircularityCharacteristicStatsEvalType::
    CircularityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (),
      MaxCircularityStats_ (this)
    {
    }

    CircularityCharacteristicStatsEvalType::
    CircularityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status),
      MaxCircularityStats_ (this)
    {
    }

    CircularityCharacteristicStatsEvalType::
    CircularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status)),
      MaxCircularityStats_ (this)
    {
    }

    CircularityCharacteristicStatsEvalType::
    CircularityCharacteristicStatsEvalType (const CircularityCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c),
      MaxCircularityStats_ (x.MaxCircularityStats_, f, this)
    {
    }

    CircularityCharacteristicStatsEvalType::
    CircularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      MaxCircularityStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularityCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FormCharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxCircularityStats
        //
        if (n.name () == L"MaxCircularityStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxCircularityStats_type > r (
            MaxCircularityStats_traits::create (i, f, this));

          if (!this->MaxCircularityStats_)
          {
            this->MaxCircularityStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularityCharacteristicStatsEvalType* CircularityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularityCharacteristicStatsEvalType (*this, f, c);
    }

    CircularityCharacteristicStatsEvalType& CircularityCharacteristicStatsEvalType::
    operator= (const CircularityCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (*this) = x;
        this->MaxCircularityStats_ = x.MaxCircularityStats_;
      }

      return *this;
    }

    CircularityCharacteristicStatsEvalType::
    ~CircularityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularityCharacteristicStatsEvalType >
    _xsd_CircularityCharacteristicStatsEvalType_type_factory_init (
      L"CircularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicityCharacteristicStatsEvalType
    //

    ConicityCharacteristicStatsEvalType::
    ConicityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType ()
    {
    }

    ConicityCharacteristicStatsEvalType::
    ConicityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status)
    {
    }

    ConicityCharacteristicStatsEvalType::
    ConicityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    ConicityCharacteristicStatsEvalType::
    ConicityCharacteristicStatsEvalType (const ConicityCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    ConicityCharacteristicStatsEvalType::
    ConicityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    ConicityCharacteristicStatsEvalType* ConicityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicityCharacteristicStatsEvalType (*this, f, c);
    }

    ConicityCharacteristicStatsEvalType::
    ~ConicityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicityCharacteristicStatsEvalType >
    _xsd_ConicityCharacteristicStatsEvalType_type_factory_init (
      L"ConicityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricityCharacteristicStatsEvalType
    //

    CylindricityCharacteristicStatsEvalType::
    CylindricityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (),
      MaxCylindricityStats_ (this)
    {
    }

    CylindricityCharacteristicStatsEvalType::
    CylindricityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status),
      MaxCylindricityStats_ (this)
    {
    }

    CylindricityCharacteristicStatsEvalType::
    CylindricityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status)),
      MaxCylindricityStats_ (this)
    {
    }

    CylindricityCharacteristicStatsEvalType::
    CylindricityCharacteristicStatsEvalType (const CylindricityCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c),
      MaxCylindricityStats_ (x.MaxCylindricityStats_, f, this)
    {
    }

    CylindricityCharacteristicStatsEvalType::
    CylindricityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      MaxCylindricityStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricityCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FormCharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxCylindricityStats
        //
        if (n.name () == L"MaxCylindricityStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxCylindricityStats_type > r (
            MaxCylindricityStats_traits::create (i, f, this));

          if (!this->MaxCylindricityStats_)
          {
            this->MaxCylindricityStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricityCharacteristicStatsEvalType* CylindricityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricityCharacteristicStatsEvalType (*this, f, c);
    }

    CylindricityCharacteristicStatsEvalType& CylindricityCharacteristicStatsEvalType::
    operator= (const CylindricityCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (*this) = x;
        this->MaxCylindricityStats_ = x.MaxCylindricityStats_;
      }

      return *this;
    }

    CylindricityCharacteristicStatsEvalType::
    ~CylindricityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricityCharacteristicStatsEvalType >
    _xsd_CylindricityCharacteristicStatsEvalType_type_factory_init (
      L"CylindricityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticityCharacteristicStatsEvalType
    //

    EllipticityCharacteristicStatsEvalType::
    EllipticityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType ()
    {
    }

    EllipticityCharacteristicStatsEvalType::
    EllipticityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status)
    {
    }

    EllipticityCharacteristicStatsEvalType::
    EllipticityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    EllipticityCharacteristicStatsEvalType::
    EllipticityCharacteristicStatsEvalType (const EllipticityCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    EllipticityCharacteristicStatsEvalType::
    EllipticityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    EllipticityCharacteristicStatsEvalType* EllipticityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticityCharacteristicStatsEvalType (*this, f, c);
    }

    EllipticityCharacteristicStatsEvalType::
    ~EllipticityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipticityCharacteristicStatsEvalType >
    _xsd_EllipticityCharacteristicStatsEvalType_type_factory_init (
      L"EllipticityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // FlatnessCharacteristicStatsEvalType
    //

    FlatnessCharacteristicStatsEvalType::
    FlatnessCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (),
      BonusStats_ (this),
      MaxFlatnessStats_ (this)
    {
    }

    FlatnessCharacteristicStatsEvalType::
    FlatnessCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status),
      BonusStats_ (this),
      MaxFlatnessStats_ (this)
    {
    }

    FlatnessCharacteristicStatsEvalType::
    FlatnessCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status)),
      BonusStats_ (this),
      MaxFlatnessStats_ (this)
    {
    }

    FlatnessCharacteristicStatsEvalType::
    FlatnessCharacteristicStatsEvalType (const FlatnessCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c),
      BonusStats_ (x.BonusStats_, f, this),
      MaxFlatnessStats_ (x.MaxFlatnessStats_, f, this)
    {
    }

    FlatnessCharacteristicStatsEvalType::
    FlatnessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      BonusStats_ (this),
      MaxFlatnessStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FlatnessCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FormCharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BonusStats
        //
        if (n.name () == L"BonusStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BonusStats_type > r (
            BonusStats_traits::create (i, f, this));

          if (!this->BonusStats_)
          {
            this->BonusStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxFlatnessStats
        //
        if (n.name () == L"MaxFlatnessStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFlatnessStats_type > r (
            MaxFlatnessStats_traits::create (i, f, this));

          if (!this->MaxFlatnessStats_)
          {
            this->MaxFlatnessStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FlatnessCharacteristicStatsEvalType* FlatnessCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FlatnessCharacteristicStatsEvalType (*this, f, c);
    }

    FlatnessCharacteristicStatsEvalType& FlatnessCharacteristicStatsEvalType::
    operator= (const FlatnessCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (*this) = x;
        this->BonusStats_ = x.BonusStats_;
        this->MaxFlatnessStats_ = x.MaxFlatnessStats_;
      }

      return *this;
    }

    FlatnessCharacteristicStatsEvalType::
    ~FlatnessCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FlatnessCharacteristicStatsEvalType >
    _xsd_FlatnessCharacteristicStatsEvalType_type_factory_init (
      L"FlatnessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericityCharacteristicStatsEvalType
    //

    SphericityCharacteristicStatsEvalType::
    SphericityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType ()
    {
    }

    SphericityCharacteristicStatsEvalType::
    SphericityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status)
    {
    }

    SphericityCharacteristicStatsEvalType::
    SphericityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    SphericityCharacteristicStatsEvalType::
    SphericityCharacteristicStatsEvalType (const SphericityCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    SphericityCharacteristicStatsEvalType::
    SphericityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    SphericityCharacteristicStatsEvalType* SphericityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericityCharacteristicStatsEvalType (*this, f, c);
    }

    SphericityCharacteristicStatsEvalType::
    ~SphericityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericityCharacteristicStatsEvalType >
    _xsd_SphericityCharacteristicStatsEvalType_type_factory_init (
      L"SphericityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // StraightnessCharacteristicStatsEvalType
    //

    StraightnessCharacteristicStatsEvalType::
    StraightnessCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (),
      BonusStats_ (this),
      MaxStraightnessStats_ (this)
    {
    }

    StraightnessCharacteristicStatsEvalType::
    StraightnessCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status),
      BonusStats_ (this),
      MaxStraightnessStats_ (this)
    {
    }

    StraightnessCharacteristicStatsEvalType::
    StraightnessCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status)),
      BonusStats_ (this),
      MaxStraightnessStats_ (this)
    {
    }

    StraightnessCharacteristicStatsEvalType::
    StraightnessCharacteristicStatsEvalType (const StraightnessCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c),
      BonusStats_ (x.BonusStats_, f, this),
      MaxStraightnessStats_ (x.MaxStraightnessStats_, f, this)
    {
    }

    StraightnessCharacteristicStatsEvalType::
    StraightnessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      BonusStats_ (this),
      MaxStraightnessStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StraightnessCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FormCharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BonusStats
        //
        if (n.name () == L"BonusStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BonusStats_type > r (
            BonusStats_traits::create (i, f, this));

          if (!this->BonusStats_)
          {
            this->BonusStats_.set (::std::move (r));
            continue;
          }
        }

        // MaxStraightnessStats
        //
        if (n.name () == L"MaxStraightnessStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxStraightnessStats_type > r (
            MaxStraightnessStats_traits::create (i, f, this));

          if (!this->MaxStraightnessStats_)
          {
            this->MaxStraightnessStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StraightnessCharacteristicStatsEvalType* StraightnessCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StraightnessCharacteristicStatsEvalType (*this, f, c);
    }

    StraightnessCharacteristicStatsEvalType& StraightnessCharacteristicStatsEvalType::
    operator= (const StraightnessCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (*this) = x;
        this->BonusStats_ = x.BonusStats_;
        this->MaxStraightnessStats_ = x.MaxStraightnessStats_;
      }

      return *this;
    }

    StraightnessCharacteristicStatsEvalType::
    ~StraightnessCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StraightnessCharacteristicStatsEvalType >
    _xsd_StraightnessCharacteristicStatsEvalType_type_factory_init (
      L"StraightnessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidicityCharacteristicStatsEvalType
    //

    ToroidicityCharacteristicStatsEvalType::
    ToroidicityCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType ()
    {
    }

    ToroidicityCharacteristicStatsEvalType::
    ToroidicityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status)
    {
    }

    ToroidicityCharacteristicStatsEvalType::
    ToroidicityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    ToroidicityCharacteristicStatsEvalType::
    ToroidicityCharacteristicStatsEvalType (const ToroidicityCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    ToroidicityCharacteristicStatsEvalType::
    ToroidicityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    ToroidicityCharacteristicStatsEvalType* ToroidicityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidicityCharacteristicStatsEvalType (*this, f, c);
    }

    ToroidicityCharacteristicStatsEvalType::
    ~ToroidicityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToroidicityCharacteristicStatsEvalType >
    _xsd_ToroidicityCharacteristicStatsEvalType_type_factory_init (
      L"ToroidicityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherFormCharacteristicStatsEvalType
    //

    OtherFormCharacteristicStatsEvalType::
    OtherFormCharacteristicStatsEvalType ()
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType ()
    {
    }

    OtherFormCharacteristicStatsEvalType::
    OtherFormCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (Status)
    {
    }

    OtherFormCharacteristicStatsEvalType::
    OtherFormCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    OtherFormCharacteristicStatsEvalType::
    OtherFormCharacteristicStatsEvalType (const OtherFormCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    OtherFormCharacteristicStatsEvalType::
    OtherFormCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::FormCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    OtherFormCharacteristicStatsEvalType* OtherFormCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherFormCharacteristicStatsEvalType (*this, f, c);
    }

    OtherFormCharacteristicStatsEvalType::
    ~OtherFormCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherFormCharacteristicStatsEvalType >
    _xsd_OtherFormCharacteristicStatsEvalType_type_factory_init (
      L"OtherFormCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // LocationCharacteristicStatsEvalType
    //

    LocationCharacteristicStatsEvalType::
    LocationCharacteristicStatsEvalType ()
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (),
      DatumsOkStats_ (this)
    {
    }

    LocationCharacteristicStatsEvalType::
    LocationCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (Status),
      DatumsOkStats_ (this)
    {
    }

    LocationCharacteristicStatsEvalType::
    LocationCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (std::move (Status)),
      DatumsOkStats_ (this)
    {
    }

    LocationCharacteristicStatsEvalType::
    LocationCharacteristicStatsEvalType (const LocationCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (x, f, c),
      DatumsOkStats_ (x.DatumsOkStats_, f, this)
    {
    }

    LocationCharacteristicStatsEvalType::
    LocationCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      DatumsOkStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LocationCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometricCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumsOkStats
        //
        if (n.name () == L"DatumsOkStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumsOkStats_type > r (
            DatumsOkStats_traits::create (i, f, this));

          if (!this->DatumsOkStats_)
          {
            this->DatumsOkStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LocationCharacteristicStatsEvalType* LocationCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocationCharacteristicStatsEvalType (*this, f, c);
    }

    LocationCharacteristicStatsEvalType& LocationCharacteristicStatsEvalType::
    operator= (const LocationCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (*this) = x;
        this->DatumsOkStats_ = x.DatumsOkStats_;
      }

      return *this;
    }

    LocationCharacteristicStatsEvalType::
    ~LocationCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LocationCharacteristicStatsEvalType >
    _xsd_LocationCharacteristicStatsEvalType_type_factory_init (
      L"LocationCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // PositionCharacteristicStatsEvalType
    //

    PositionCharacteristicStatsEvalType::
    PositionCharacteristicStatsEvalType ()
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (),
      BonusStats_ (this),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    PositionCharacteristicStatsEvalType::
    PositionCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (Status),
      BonusStats_ (this),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    PositionCharacteristicStatsEvalType::
    PositionCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (std::move (Status)),
      BonusStats_ (this),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    PositionCharacteristicStatsEvalType::
    PositionCharacteristicStatsEvalType (const PositionCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (x, f, c),
      BonusStats_ (x.BonusStats_, f, this),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this),
      CompositeSegmentsStats_ (x.CompositeSegmentsStats_, f, this)
    {
    }

    PositionCharacteristicStatsEvalType::
    PositionCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      BonusStats_ (this),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PositionCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LocationCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BonusStats
        //
        if (n.name () == L"BonusStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BonusStats_type > r (
            BonusStats_traits::create (i, f, this));

          if (!this->BonusStats_)
          {
            this->BonusStats_.set (::std::move (r));
            continue;
          }
        }

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        // CompositeSegmentsStats
        //
        if (n.name () == L"CompositeSegmentsStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CompositeSegmentsStats_type > r (
            CompositeSegmentsStats_traits::create (i, f, this));

          if (!this->CompositeSegmentsStats_)
          {
            this->CompositeSegmentsStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PositionCharacteristicStatsEvalType* PositionCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PositionCharacteristicStatsEvalType (*this, f, c);
    }

    PositionCharacteristicStatsEvalType& PositionCharacteristicStatsEvalType::
    operator= (const PositionCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LocationCharacteristicStatsEvalType& > (*this) = x;
        this->BonusStats_ = x.BonusStats_;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
        this->CompositeSegmentsStats_ = x.CompositeSegmentsStats_;
      }

      return *this;
    }

    PositionCharacteristicStatsEvalType::
    ~PositionCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PositionCharacteristicStatsEvalType >
    _xsd_PositionCharacteristicStatsEvalType_type_factory_init (
      L"PositionCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngularCoordinateCharacteristicStatsEvalType
    //

    AngularCoordinateCharacteristicStatsEvalType::
    AngularCoordinateCharacteristicStatsEvalType ()
    : ::xsd::qif30::AngularCharacteristicStatsEvalType ()
    {
    }

    AngularCoordinateCharacteristicStatsEvalType::
    AngularCoordinateCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (Status)
    {
    }

    AngularCoordinateCharacteristicStatsEvalType::
    AngularCoordinateCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (std::move (Status))
    {
    }

    AngularCoordinateCharacteristicStatsEvalType::
    AngularCoordinateCharacteristicStatsEvalType (const AngularCoordinateCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (x, f, c)
    {
    }

    AngularCoordinateCharacteristicStatsEvalType::
    AngularCoordinateCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (e, f, c)
    {
    }

    AngularCoordinateCharacteristicStatsEvalType* AngularCoordinateCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularCoordinateCharacteristicStatsEvalType (*this, f, c);
    }

    AngularCoordinateCharacteristicStatsEvalType::
    ~AngularCoordinateCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngularCoordinateCharacteristicStatsEvalType >
    _xsd_AngularCoordinateCharacteristicStatsEvalType_type_factory_init (
      L"AngularCoordinateCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngleCharacteristicStatsEvalType
    //

    AngleCharacteristicStatsEvalType::
    AngleCharacteristicStatsEvalType ()
    : ::xsd::qif30::AngularCharacteristicStatsEvalType ()
    {
    }

    AngleCharacteristicStatsEvalType::
    AngleCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (Status)
    {
    }

    AngleCharacteristicStatsEvalType::
    AngleCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (std::move (Status))
    {
    }

    AngleCharacteristicStatsEvalType::
    AngleCharacteristicStatsEvalType (const AngleCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (x, f, c)
    {
    }

    AngleCharacteristicStatsEvalType::
    AngleCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (e, f, c)
    {
    }

    AngleCharacteristicStatsEvalType* AngleCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleCharacteristicStatsEvalType (*this, f, c);
    }

    AngleCharacteristicStatsEvalType::
    ~AngleCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngleCharacteristicStatsEvalType >
    _xsd_AngleCharacteristicStatsEvalType_type_factory_init (
      L"AngleCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngleFromCharacteristicStatsEvalType
    //

    AngleFromCharacteristicStatsEvalType::
    AngleFromCharacteristicStatsEvalType ()
    : ::xsd::qif30::AngularCharacteristicStatsEvalType ()
    {
    }

    AngleFromCharacteristicStatsEvalType::
    AngleFromCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (Status)
    {
    }

    AngleFromCharacteristicStatsEvalType::
    AngleFromCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (std::move (Status))
    {
    }

    AngleFromCharacteristicStatsEvalType::
    AngleFromCharacteristicStatsEvalType (const AngleFromCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (x, f, c)
    {
    }

    AngleFromCharacteristicStatsEvalType::
    AngleFromCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (e, f, c)
    {
    }

    AngleFromCharacteristicStatsEvalType* AngleFromCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleFromCharacteristicStatsEvalType (*this, f, c);
    }

    AngleFromCharacteristicStatsEvalType::
    ~AngleFromCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngleFromCharacteristicStatsEvalType >
    _xsd_AngleFromCharacteristicStatsEvalType_type_factory_init (
      L"AngleFromCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // AngleBetweenCharacteristicStatsEvalType
    //

    AngleBetweenCharacteristicStatsEvalType::
    AngleBetweenCharacteristicStatsEvalType ()
    : ::xsd::qif30::AngularCharacteristicStatsEvalType ()
    {
    }

    AngleBetweenCharacteristicStatsEvalType::
    AngleBetweenCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (Status)
    {
    }

    AngleBetweenCharacteristicStatsEvalType::
    AngleBetweenCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (std::move (Status))
    {
    }

    AngleBetweenCharacteristicStatsEvalType::
    AngleBetweenCharacteristicStatsEvalType (const AngleBetweenCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (x, f, c)
    {
    }

    AngleBetweenCharacteristicStatsEvalType::
    AngleBetweenCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::AngularCharacteristicStatsEvalType (e, f, c)
    {
    }

    AngleBetweenCharacteristicStatsEvalType* AngleBetweenCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleBetweenCharacteristicStatsEvalType (*this, f, c);
    }

    AngleBetweenCharacteristicStatsEvalType::
    ~AngleBetweenCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AngleBetweenCharacteristicStatsEvalType >
    _xsd_AngleBetweenCharacteristicStatsEvalType_type_factory_init (
      L"AngleBetweenCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // LinearCoordinateCharacteristicStatsEvalType
    //

    LinearCoordinateCharacteristicStatsEvalType::
    LinearCoordinateCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    LinearCoordinateCharacteristicStatsEvalType::
    LinearCoordinateCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    LinearCoordinateCharacteristicStatsEvalType::
    LinearCoordinateCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    LinearCoordinateCharacteristicStatsEvalType::
    LinearCoordinateCharacteristicStatsEvalType (const LinearCoordinateCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    LinearCoordinateCharacteristicStatsEvalType::
    LinearCoordinateCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    LinearCoordinateCharacteristicStatsEvalType* LinearCoordinateCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearCoordinateCharacteristicStatsEvalType (*this, f, c);
    }

    LinearCoordinateCharacteristicStatsEvalType::
    ~LinearCoordinateCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearCoordinateCharacteristicStatsEvalType >
    _xsd_LinearCoordinateCharacteristicStatsEvalType_type_factory_init (
      L"LinearCoordinateCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // CurveLengthCharacteristicStatsEvalType
    //

    CurveLengthCharacteristicStatsEvalType::
    CurveLengthCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    CurveLengthCharacteristicStatsEvalType::
    CurveLengthCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    CurveLengthCharacteristicStatsEvalType::
    CurveLengthCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    CurveLengthCharacteristicStatsEvalType::
    CurveLengthCharacteristicStatsEvalType (const CurveLengthCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    CurveLengthCharacteristicStatsEvalType::
    CurveLengthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    CurveLengthCharacteristicStatsEvalType* CurveLengthCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CurveLengthCharacteristicStatsEvalType (*this, f, c);
    }

    CurveLengthCharacteristicStatsEvalType::
    ~CurveLengthCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CurveLengthCharacteristicStatsEvalType >
    _xsd_CurveLengthCharacteristicStatsEvalType_type_factory_init (
      L"CurveLengthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // DiameterCharacteristicStatsEvalType
    //

    DiameterCharacteristicStatsEvalType::
    DiameterCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    DiameterCharacteristicStatsEvalType::
    DiameterCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    DiameterCharacteristicStatsEvalType::
    DiameterCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    DiameterCharacteristicStatsEvalType::
    DiameterCharacteristicStatsEvalType (const DiameterCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    DiameterCharacteristicStatsEvalType::
    DiameterCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    DiameterCharacteristicStatsEvalType* DiameterCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DiameterCharacteristicStatsEvalType (*this, f, c);
    }

    DiameterCharacteristicStatsEvalType::
    ~DiameterCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DiameterCharacteristicStatsEvalType >
    _xsd_DiameterCharacteristicStatsEvalType_type_factory_init (
      L"DiameterCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalDiameterCharacteristicStatsEvalType
    //

    SphericalDiameterCharacteristicStatsEvalType::
    SphericalDiameterCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    SphericalDiameterCharacteristicStatsEvalType::
    SphericalDiameterCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    SphericalDiameterCharacteristicStatsEvalType::
    SphericalDiameterCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    SphericalDiameterCharacteristicStatsEvalType::
    SphericalDiameterCharacteristicStatsEvalType (const SphericalDiameterCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    SphericalDiameterCharacteristicStatsEvalType::
    SphericalDiameterCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    SphericalDiameterCharacteristicStatsEvalType* SphericalDiameterCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalDiameterCharacteristicStatsEvalType (*this, f, c);
    }

    SphericalDiameterCharacteristicStatsEvalType::
    ~SphericalDiameterCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalDiameterCharacteristicStatsEvalType >
    _xsd_SphericalDiameterCharacteristicStatsEvalType_type_factory_init (
      L"SphericalDiameterCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // LengthCharacteristicStatsEvalType
    //

    LengthCharacteristicStatsEvalType::
    LengthCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    LengthCharacteristicStatsEvalType::
    LengthCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    LengthCharacteristicStatsEvalType::
    LengthCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    LengthCharacteristicStatsEvalType::
    LengthCharacteristicStatsEvalType (const LengthCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    LengthCharacteristicStatsEvalType::
    LengthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    LengthCharacteristicStatsEvalType* LengthCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LengthCharacteristicStatsEvalType (*this, f, c);
    }

    LengthCharacteristicStatsEvalType::
    ~LengthCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LengthCharacteristicStatsEvalType >
    _xsd_LengthCharacteristicStatsEvalType_type_factory_init (
      L"LengthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WidthCharacteristicStatsEvalType
    //

    WidthCharacteristicStatsEvalType::
    WidthCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    WidthCharacteristicStatsEvalType::
    WidthCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    WidthCharacteristicStatsEvalType::
    WidthCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    WidthCharacteristicStatsEvalType::
    WidthCharacteristicStatsEvalType (const WidthCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    WidthCharacteristicStatsEvalType::
    WidthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    WidthCharacteristicStatsEvalType* WidthCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WidthCharacteristicStatsEvalType (*this, f, c);
    }

    WidthCharacteristicStatsEvalType::
    ~WidthCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WidthCharacteristicStatsEvalType >
    _xsd_WidthCharacteristicStatsEvalType_type_factory_init (
      L"WidthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // HeightCharacteristicStatsEvalType
    //

    HeightCharacteristicStatsEvalType::
    HeightCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    HeightCharacteristicStatsEvalType::
    HeightCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    HeightCharacteristicStatsEvalType::
    HeightCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    HeightCharacteristicStatsEvalType::
    HeightCharacteristicStatsEvalType (const HeightCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    HeightCharacteristicStatsEvalType::
    HeightCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    HeightCharacteristicStatsEvalType* HeightCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HeightCharacteristicStatsEvalType (*this, f, c);
    }

    HeightCharacteristicStatsEvalType::
    ~HeightCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, HeightCharacteristicStatsEvalType >
    _xsd_HeightCharacteristicStatsEvalType_type_factory_init (
      L"HeightCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // DepthCharacteristicStatsEvalType
    //

    DepthCharacteristicStatsEvalType::
    DepthCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    DepthCharacteristicStatsEvalType::
    DepthCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    DepthCharacteristicStatsEvalType::
    DepthCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    DepthCharacteristicStatsEvalType::
    DepthCharacteristicStatsEvalType (const DepthCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    DepthCharacteristicStatsEvalType::
    DepthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    DepthCharacteristicStatsEvalType* DepthCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DepthCharacteristicStatsEvalType (*this, f, c);
    }

    DepthCharacteristicStatsEvalType::
    ~DepthCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DepthCharacteristicStatsEvalType >
    _xsd_DepthCharacteristicStatsEvalType_type_factory_init (
      L"DepthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ThicknessCharacteristicStatsEvalType
    //

    ThicknessCharacteristicStatsEvalType::
    ThicknessCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    ThicknessCharacteristicStatsEvalType::
    ThicknessCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    ThicknessCharacteristicStatsEvalType::
    ThicknessCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    ThicknessCharacteristicStatsEvalType::
    ThicknessCharacteristicStatsEvalType (const ThicknessCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    ThicknessCharacteristicStatsEvalType::
    ThicknessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    ThicknessCharacteristicStatsEvalType* ThicknessCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThicknessCharacteristicStatsEvalType (*this, f, c);
    }

    ThicknessCharacteristicStatsEvalType::
    ~ThicknessCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThicknessCharacteristicStatsEvalType >
    _xsd_ThicknessCharacteristicStatsEvalType_type_factory_init (
      L"ThicknessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SquareCharacteristicStatsEvalType
    //

    SquareCharacteristicStatsEvalType::
    SquareCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    SquareCharacteristicStatsEvalType::
    SquareCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    SquareCharacteristicStatsEvalType::
    SquareCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    SquareCharacteristicStatsEvalType::
    SquareCharacteristicStatsEvalType (const SquareCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    SquareCharacteristicStatsEvalType::
    SquareCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    SquareCharacteristicStatsEvalType* SquareCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SquareCharacteristicStatsEvalType (*this, f, c);
    }

    SquareCharacteristicStatsEvalType::
    ~SquareCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SquareCharacteristicStatsEvalType >
    _xsd_SquareCharacteristicStatsEvalType_type_factory_init (
      L"SquareCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // DistanceFromCharacteristicStatsEvalType
    //

    DistanceFromCharacteristicStatsEvalType::
    DistanceFromCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    DistanceFromCharacteristicStatsEvalType::
    DistanceFromCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    DistanceFromCharacteristicStatsEvalType::
    DistanceFromCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    DistanceFromCharacteristicStatsEvalType::
    DistanceFromCharacteristicStatsEvalType (const DistanceFromCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    DistanceFromCharacteristicStatsEvalType::
    DistanceFromCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    DistanceFromCharacteristicStatsEvalType* DistanceFromCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistanceFromCharacteristicStatsEvalType (*this, f, c);
    }

    DistanceFromCharacteristicStatsEvalType::
    ~DistanceFromCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DistanceFromCharacteristicStatsEvalType >
    _xsd_DistanceFromCharacteristicStatsEvalType_type_factory_init (
      L"DistanceFromCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // DistanceBetweenCharacteristicStatsEvalType
    //

    DistanceBetweenCharacteristicStatsEvalType::
    DistanceBetweenCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    DistanceBetweenCharacteristicStatsEvalType::
    DistanceBetweenCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    DistanceBetweenCharacteristicStatsEvalType::
    DistanceBetweenCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    DistanceBetweenCharacteristicStatsEvalType::
    DistanceBetweenCharacteristicStatsEvalType (const DistanceBetweenCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    DistanceBetweenCharacteristicStatsEvalType::
    DistanceBetweenCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    DistanceBetweenCharacteristicStatsEvalType* DistanceBetweenCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistanceBetweenCharacteristicStatsEvalType (*this, f, c);
    }

    DistanceBetweenCharacteristicStatsEvalType::
    ~DistanceBetweenCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DistanceBetweenCharacteristicStatsEvalType >
    _xsd_DistanceBetweenCharacteristicStatsEvalType_type_factory_init (
      L"DistanceBetweenCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // RadiusCharacteristicStatsEvalType
    //

    RadiusCharacteristicStatsEvalType::
    RadiusCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    RadiusCharacteristicStatsEvalType::
    RadiusCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    RadiusCharacteristicStatsEvalType::
    RadiusCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    RadiusCharacteristicStatsEvalType::
    RadiusCharacteristicStatsEvalType (const RadiusCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    RadiusCharacteristicStatsEvalType::
    RadiusCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    RadiusCharacteristicStatsEvalType* RadiusCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RadiusCharacteristicStatsEvalType (*this, f, c);
    }

    RadiusCharacteristicStatsEvalType::
    ~RadiusCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RadiusCharacteristicStatsEvalType >
    _xsd_RadiusCharacteristicStatsEvalType_type_factory_init (
      L"RadiusCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalRadiusCharacteristicStatsEvalType
    //

    SphericalRadiusCharacteristicStatsEvalType::
    SphericalRadiusCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    SphericalRadiusCharacteristicStatsEvalType::
    SphericalRadiusCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    SphericalRadiusCharacteristicStatsEvalType::
    SphericalRadiusCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    SphericalRadiusCharacteristicStatsEvalType::
    SphericalRadiusCharacteristicStatsEvalType (const SphericalRadiusCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    SphericalRadiusCharacteristicStatsEvalType::
    SphericalRadiusCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    SphericalRadiusCharacteristicStatsEvalType* SphericalRadiusCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalRadiusCharacteristicStatsEvalType (*this, f, c);
    }

    SphericalRadiusCharacteristicStatsEvalType::
    ~SphericalRadiusCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalRadiusCharacteristicStatsEvalType >
    _xsd_SphericalRadiusCharacteristicStatsEvalType_type_factory_init (
      L"SphericalRadiusCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ChordCharacteristicStatsEvalType
    //

    ChordCharacteristicStatsEvalType::
    ChordCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    ChordCharacteristicStatsEvalType::
    ChordCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    ChordCharacteristicStatsEvalType::
    ChordCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    ChordCharacteristicStatsEvalType::
    ChordCharacteristicStatsEvalType (const ChordCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    ChordCharacteristicStatsEvalType::
    ChordCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    ChordCharacteristicStatsEvalType* ChordCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChordCharacteristicStatsEvalType (*this, f, c);
    }

    ChordCharacteristicStatsEvalType::
    ~ChordCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ChordCharacteristicStatsEvalType >
    _xsd_ChordCharacteristicStatsEvalType_type_factory_init (
      L"ChordCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalTaperCharacteristicStatsEvalType
    //

    ConicalTaperCharacteristicStatsEvalType::
    ConicalTaperCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    ConicalTaperCharacteristicStatsEvalType::
    ConicalTaperCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    ConicalTaperCharacteristicStatsEvalType::
    ConicalTaperCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    ConicalTaperCharacteristicStatsEvalType::
    ConicalTaperCharacteristicStatsEvalType (const ConicalTaperCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    ConicalTaperCharacteristicStatsEvalType::
    ConicalTaperCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    ConicalTaperCharacteristicStatsEvalType* ConicalTaperCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalTaperCharacteristicStatsEvalType (*this, f, c);
    }

    ConicalTaperCharacteristicStatsEvalType::
    ~ConicalTaperCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicalTaperCharacteristicStatsEvalType >
    _xsd_ConicalTaperCharacteristicStatsEvalType_type_factory_init (
      L"ConicalTaperCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // FlatTaperCharacteristicStatsEvalType
    //

    FlatTaperCharacteristicStatsEvalType::
    FlatTaperCharacteristicStatsEvalType ()
    : ::xsd::qif30::LinearCharacteristicStatsEvalType ()
    {
    }

    FlatTaperCharacteristicStatsEvalType::
    FlatTaperCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (Status)
    {
    }

    FlatTaperCharacteristicStatsEvalType::
    FlatTaperCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (std::move (Status))
    {
    }

    FlatTaperCharacteristicStatsEvalType::
    FlatTaperCharacteristicStatsEvalType (const FlatTaperCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (x, f, c)
    {
    }

    FlatTaperCharacteristicStatsEvalType::
    FlatTaperCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::LinearCharacteristicStatsEvalType (e, f, c)
    {
    }

    FlatTaperCharacteristicStatsEvalType* FlatTaperCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FlatTaperCharacteristicStatsEvalType (*this, f, c);
    }

    FlatTaperCharacteristicStatsEvalType::
    ~FlatTaperCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FlatTaperCharacteristicStatsEvalType >
    _xsd_FlatTaperCharacteristicStatsEvalType_type_factory_init (
      L"FlatTaperCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // RunoutCharacteristicStatsEvalBaseType
    //

    RunoutCharacteristicStatsEvalBaseType::
    RunoutCharacteristicStatsEvalBaseType ()
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this)
    {
    }

    RunoutCharacteristicStatsEvalBaseType::
    RunoutCharacteristicStatsEvalBaseType (const Status_type& Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this)
    {
    }

    RunoutCharacteristicStatsEvalBaseType::
    RunoutCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this)
    {
    }

    RunoutCharacteristicStatsEvalBaseType::
    RunoutCharacteristicStatsEvalBaseType (const RunoutCharacteristicStatsEvalBaseType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this),
      DatumsOkStats_ (x.DatumsOkStats_, f, this)
    {
    }

    RunoutCharacteristicStatsEvalBaseType::
    RunoutCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this),
      DatumsOkStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RunoutCharacteristicStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometricCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        // DatumsOkStats
        //
        if (n.name () == L"DatumsOkStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumsOkStats_type > r (
            DatumsOkStats_traits::create (i, f, this));

          if (!this->DatumsOkStats_)
          {
            this->DatumsOkStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    RunoutCharacteristicStatsEvalBaseType& RunoutCharacteristicStatsEvalBaseType::
    operator= (const RunoutCharacteristicStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
        this->DatumsOkStats_ = x.DatumsOkStats_;
      }

      return *this;
    }

    RunoutCharacteristicStatsEvalBaseType::
    ~RunoutCharacteristicStatsEvalBaseType ()
    {
    }

    // CircularRunoutCharacteristicStatsEvalType
    //

    CircularRunoutCharacteristicStatsEvalType::
    CircularRunoutCharacteristicStatsEvalType ()
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType ()
    {
    }

    CircularRunoutCharacteristicStatsEvalType::
    CircularRunoutCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (Status)
    {
    }

    CircularRunoutCharacteristicStatsEvalType::
    CircularRunoutCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    CircularRunoutCharacteristicStatsEvalType::
    CircularRunoutCharacteristicStatsEvalType (const CircularRunoutCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    CircularRunoutCharacteristicStatsEvalType::
    CircularRunoutCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    CircularRunoutCharacteristicStatsEvalType* CircularRunoutCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularRunoutCharacteristicStatsEvalType (*this, f, c);
    }

    CircularRunoutCharacteristicStatsEvalType::
    ~CircularRunoutCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularRunoutCharacteristicStatsEvalType >
    _xsd_CircularRunoutCharacteristicStatsEvalType_type_factory_init (
      L"CircularRunoutCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // TotalRunoutCharacteristicStatsEvalType
    //

    TotalRunoutCharacteristicStatsEvalType::
    TotalRunoutCharacteristicStatsEvalType ()
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType ()
    {
    }

    TotalRunoutCharacteristicStatsEvalType::
    TotalRunoutCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (Status)
    {
    }

    TotalRunoutCharacteristicStatsEvalType::
    TotalRunoutCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    TotalRunoutCharacteristicStatsEvalType::
    TotalRunoutCharacteristicStatsEvalType (const TotalRunoutCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    TotalRunoutCharacteristicStatsEvalType::
    TotalRunoutCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    TotalRunoutCharacteristicStatsEvalType* TotalRunoutCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TotalRunoutCharacteristicStatsEvalType (*this, f, c);
    }

    TotalRunoutCharacteristicStatsEvalType::
    ~TotalRunoutCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TotalRunoutCharacteristicStatsEvalType >
    _xsd_TotalRunoutCharacteristicStatsEvalType_type_factory_init (
      L"TotalRunoutCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // CoaxialityCharacteristicStatsEvalType
    //

    CoaxialityCharacteristicStatsEvalType::
    CoaxialityCharacteristicStatsEvalType ()
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this)
    {
    }

    CoaxialityCharacteristicStatsEvalType::
    CoaxialityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this)
    {
    }

    CoaxialityCharacteristicStatsEvalType::
    CoaxialityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this)
    {
    }

    CoaxialityCharacteristicStatsEvalType::
    CoaxialityCharacteristicStatsEvalType (const CoaxialityCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this)
    {
    }

    CoaxialityCharacteristicStatsEvalType::
    CoaxialityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoaxialityCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LocationCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CoaxialityCharacteristicStatsEvalType* CoaxialityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoaxialityCharacteristicStatsEvalType (*this, f, c);
    }

    CoaxialityCharacteristicStatsEvalType& CoaxialityCharacteristicStatsEvalType::
    operator= (const CoaxialityCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LocationCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
      }

      return *this;
    }

    CoaxialityCharacteristicStatsEvalType::
    ~CoaxialityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CoaxialityCharacteristicStatsEvalType >
    _xsd_CoaxialityCharacteristicStatsEvalType_type_factory_init (
      L"CoaxialityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ConcentricityCharacteristicStatsEvalType
    //

    ConcentricityCharacteristicStatsEvalType::
    ConcentricityCharacteristicStatsEvalType ()
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this)
    {
    }

    ConcentricityCharacteristicStatsEvalType::
    ConcentricityCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this)
    {
    }

    ConcentricityCharacteristicStatsEvalType::
    ConcentricityCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this)
    {
    }

    ConcentricityCharacteristicStatsEvalType::
    ConcentricityCharacteristicStatsEvalType (const ConcentricityCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this)
    {
    }

    ConcentricityCharacteristicStatsEvalType::
    ConcentricityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConcentricityCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LocationCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConcentricityCharacteristicStatsEvalType* ConcentricityCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConcentricityCharacteristicStatsEvalType (*this, f, c);
    }

    ConcentricityCharacteristicStatsEvalType& ConcentricityCharacteristicStatsEvalType::
    operator= (const ConcentricityCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LocationCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
      }

      return *this;
    }

    ConcentricityCharacteristicStatsEvalType::
    ~ConcentricityCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConcentricityCharacteristicStatsEvalType >
    _xsd_ConcentricityCharacteristicStatsEvalType_type_factory_init (
      L"ConcentricityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SymmetryCharacteristicStatsEvalType
    //

    SymmetryCharacteristicStatsEvalType::
    SymmetryCharacteristicStatsEvalType ()
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    SymmetryCharacteristicStatsEvalType::
    SymmetryCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    SymmetryCharacteristicStatsEvalType::
    SymmetryCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    SymmetryCharacteristicStatsEvalType::
    SymmetryCharacteristicStatsEvalType (const SymmetryCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this),
      CompositeSegmentsStats_ (x.CompositeSegmentsStats_, f, this)
    {
    }

    SymmetryCharacteristicStatsEvalType::
    SymmetryCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::LocationCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this),
      CompositeSegmentsStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SymmetryCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LocationCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        // CompositeSegmentsStats
        //
        if (n.name () == L"CompositeSegmentsStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CompositeSegmentsStats_type > r (
            CompositeSegmentsStats_traits::create (i, f, this));

          if (!this->CompositeSegmentsStats_)
          {
            this->CompositeSegmentsStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SymmetryCharacteristicStatsEvalType* SymmetryCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SymmetryCharacteristicStatsEvalType (*this, f, c);
    }

    SymmetryCharacteristicStatsEvalType& SymmetryCharacteristicStatsEvalType::
    operator= (const SymmetryCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LocationCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
        this->CompositeSegmentsStats_ = x.CompositeSegmentsStats_;
      }

      return *this;
    }

    SymmetryCharacteristicStatsEvalType::
    ~SymmetryCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SymmetryCharacteristicStatsEvalType >
    _xsd_SymmetryCharacteristicStatsEvalType_type_factory_init (
      L"SymmetryCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDeviationStatsEvalType
    //

    PointDeviationStatsEvalType::
    PointDeviationStatsEvalType ()
    : ::xml_schema::type (),
      MeasuredPointIds_ (this),
      DeviationStats_ (this)
    {
    }

    PointDeviationStatsEvalType::
    PointDeviationStatsEvalType (const MeasuredPointIds_type& MeasuredPointIds,
                                 const DeviationStats_type& DeviationStats)
    : ::xml_schema::type (),
      MeasuredPointIds_ (MeasuredPointIds, this),
      DeviationStats_ (DeviationStats, this)
    {
    }

    PointDeviationStatsEvalType::
    PointDeviationStatsEvalType (::std::unique_ptr< MeasuredPointIds_type > MeasuredPointIds,
                                 ::std::unique_ptr< DeviationStats_type > DeviationStats)
    : ::xml_schema::type (),
      MeasuredPointIds_ (std::move (MeasuredPointIds), this),
      DeviationStats_ (std::move (DeviationStats), this)
    {
    }

    PointDeviationStatsEvalType::
    PointDeviationStatsEvalType (const PointDeviationStatsEvalType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasuredPointIds_ (x.MeasuredPointIds_, f, this),
      DeviationStats_ (x.DeviationStats_, f, this)
    {
    }

    PointDeviationStatsEvalType::
    PointDeviationStatsEvalType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasuredPointIds_ (this),
      DeviationStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDeviationStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasuredPointIds
        //
        if (n.name () == L"MeasuredPointIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredPointIds_type > r (
            MeasuredPointIds_traits::create (i, f, this));

          if (!MeasuredPointIds_.present ())
          {
            this->MeasuredPointIds_.set (::std::move (r));
            continue;
          }
        }

        // DeviationStats
        //
        if (n.name () == L"DeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationStats_type > r (
            DeviationStats_traits::create (i, f, this));

          if (!DeviationStats_.present ())
          {
            this->DeviationStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MeasuredPointIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeasuredPointIds",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DeviationStats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeviationStats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDeviationStatsEvalType* PointDeviationStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDeviationStatsEvalType (*this, f, c);
    }

    PointDeviationStatsEvalType& PointDeviationStatsEvalType::
    operator= (const PointDeviationStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasuredPointIds_ = x.MeasuredPointIds_;
        this->DeviationStats_ = x.DeviationStats_;
      }

      return *this;
    }

    PointDeviationStatsEvalType::
    ~PointDeviationStatsEvalType ()
    {
    }

    // PointDeviationsStatsEvalType
    //

    PointDeviationsStatsEvalType::
    PointDeviationsStatsEvalType ()
    : ::xml_schema::type (),
      PointDeviationStats_ (this),
      n_ (this)
    {
    }

    PointDeviationsStatsEvalType::
    PointDeviationsStatsEvalType (const n_type& n)
    : ::xml_schema::type (),
      PointDeviationStats_ (this),
      n_ (n, this)
    {
    }

    PointDeviationsStatsEvalType::
    PointDeviationsStatsEvalType (const PointDeviationsStatsEvalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointDeviationStats_ (x.PointDeviationStats_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointDeviationsStatsEvalType::
    PointDeviationsStatsEvalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointDeviationStats_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDeviationsStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointDeviationStats
        //
        if (n.name () == L"PointDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointDeviationStats_type > r (
            PointDeviationStats_traits::create (i, f, this));

          this->PointDeviationStats_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointDeviationsStatsEvalType* PointDeviationsStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDeviationsStatsEvalType (*this, f, c);
    }

    PointDeviationsStatsEvalType& PointDeviationsStatsEvalType::
    operator= (const PointDeviationsStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointDeviationStats_ = x.PointDeviationStats_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointDeviationsStatsEvalType::
    ~PointDeviationsStatsEvalType ()
    {
    }

    // ProfileCharacteristicStatsEvalBaseType
    //

    ProfileCharacteristicStatsEvalBaseType::
    ProfileCharacteristicStatsEvalBaseType ()
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (),
      CapabilityCalculationMethod_ (this),
      WorstPositiveDeviationStats_ (this),
      WorstNegativeDeviationStats_ (this),
      PointDeviationsStats_ (this),
      DatumsOkStats_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    ProfileCharacteristicStatsEvalBaseType::
    ProfileCharacteristicStatsEvalBaseType (const Status_type& Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (Status),
      CapabilityCalculationMethod_ (this),
      WorstPositiveDeviationStats_ (this),
      WorstNegativeDeviationStats_ (this),
      PointDeviationsStats_ (this),
      DatumsOkStats_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    ProfileCharacteristicStatsEvalBaseType::
    ProfileCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (std::move (Status)),
      CapabilityCalculationMethod_ (this),
      WorstPositiveDeviationStats_ (this),
      WorstNegativeDeviationStats_ (this),
      PointDeviationsStats_ (this),
      DatumsOkStats_ (this),
      CompositeSegmentsStats_ (this)
    {
    }

    ProfileCharacteristicStatsEvalBaseType::
    ProfileCharacteristicStatsEvalBaseType (const ProfileCharacteristicStatsEvalBaseType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (x, f, c),
      CapabilityCalculationMethod_ (x.CapabilityCalculationMethod_, f, this),
      WorstPositiveDeviationStats_ (x.WorstPositiveDeviationStats_, f, this),
      WorstNegativeDeviationStats_ (x.WorstNegativeDeviationStats_, f, this),
      PointDeviationsStats_ (x.PointDeviationsStats_, f, this),
      DatumsOkStats_ (x.DatumsOkStats_, f, this),
      CompositeSegmentsStats_ (x.CompositeSegmentsStats_, f, this)
    {
    }

    ProfileCharacteristicStatsEvalBaseType::
    ProfileCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::GeometricCharacteristicStatsEvalType (e, f | ::xml_schema::flags::base, c),
      CapabilityCalculationMethod_ (this),
      WorstPositiveDeviationStats_ (this),
      WorstNegativeDeviationStats_ (this),
      PointDeviationsStats_ (this),
      DatumsOkStats_ (this),
      CompositeSegmentsStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProfileCharacteristicStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometricCharacteristicStatsEvalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapabilityCalculationMethod
        //
        if (n.name () == L"CapabilityCalculationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CapabilityCalculationMethod_type > r (
            CapabilityCalculationMethod_traits::create (i, f, this));

          if (!this->CapabilityCalculationMethod_)
          {
            this->CapabilityCalculationMethod_.set (::std::move (r));
            continue;
          }
        }

        // WorstPositiveDeviationStats
        //
        if (n.name () == L"WorstPositiveDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorstPositiveDeviationStats_type > r (
            WorstPositiveDeviationStats_traits::create (i, f, this));

          if (!this->WorstPositiveDeviationStats_)
          {
            this->WorstPositiveDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // WorstNegativeDeviationStats
        //
        if (n.name () == L"WorstNegativeDeviationStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorstNegativeDeviationStats_type > r (
            WorstNegativeDeviationStats_traits::create (i, f, this));

          if (!this->WorstNegativeDeviationStats_)
          {
            this->WorstNegativeDeviationStats_.set (::std::move (r));
            continue;
          }
        }

        // PointDeviationsStats
        //
        if (n.name () == L"PointDeviationsStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointDeviationsStats_type > r (
            PointDeviationsStats_traits::create (i, f, this));

          if (!this->PointDeviationsStats_)
          {
            this->PointDeviationsStats_.set (::std::move (r));
            continue;
          }
        }

        // DatumsOkStats
        //
        if (n.name () == L"DatumsOkStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumsOkStats_type > r (
            DatumsOkStats_traits::create (i, f, this));

          if (!this->DatumsOkStats_)
          {
            this->DatumsOkStats_.set (::std::move (r));
            continue;
          }
        }

        // CompositeSegmentsStats
        //
        if (n.name () == L"CompositeSegmentsStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CompositeSegmentsStats_type > r (
            CompositeSegmentsStats_traits::create (i, f, this));

          if (!this->CompositeSegmentsStats_)
          {
            this->CompositeSegmentsStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProfileCharacteristicStatsEvalBaseType& ProfileCharacteristicStatsEvalBaseType::
    operator= (const ProfileCharacteristicStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (*this) = x;
        this->CapabilityCalculationMethod_ = x.CapabilityCalculationMethod_;
        this->WorstPositiveDeviationStats_ = x.WorstPositiveDeviationStats_;
        this->WorstNegativeDeviationStats_ = x.WorstNegativeDeviationStats_;
        this->PointDeviationsStats_ = x.PointDeviationsStats_;
        this->DatumsOkStats_ = x.DatumsOkStats_;
        this->CompositeSegmentsStats_ = x.CompositeSegmentsStats_;
      }

      return *this;
    }

    ProfileCharacteristicStatsEvalBaseType::
    ~ProfileCharacteristicStatsEvalBaseType ()
    {
    }

    // LineProfileCharacteristicStatsEvalType
    //

    LineProfileCharacteristicStatsEvalType::
    LineProfileCharacteristicStatsEvalType ()
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType ()
    {
    }

    LineProfileCharacteristicStatsEvalType::
    LineProfileCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (Status)
    {
    }

    LineProfileCharacteristicStatsEvalType::
    LineProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    LineProfileCharacteristicStatsEvalType::
    LineProfileCharacteristicStatsEvalType (const LineProfileCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    LineProfileCharacteristicStatsEvalType::
    LineProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    LineProfileCharacteristicStatsEvalType* LineProfileCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineProfileCharacteristicStatsEvalType (*this, f, c);
    }

    LineProfileCharacteristicStatsEvalType::
    ~LineProfileCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LineProfileCharacteristicStatsEvalType >
    _xsd_LineProfileCharacteristicStatsEvalType_type_factory_init (
      L"LineProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // PointProfileCharacteristicStatsEvalType
    //

    PointProfileCharacteristicStatsEvalType::
    PointProfileCharacteristicStatsEvalType ()
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType ()
    {
    }

    PointProfileCharacteristicStatsEvalType::
    PointProfileCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (Status)
    {
    }

    PointProfileCharacteristicStatsEvalType::
    PointProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    PointProfileCharacteristicStatsEvalType::
    PointProfileCharacteristicStatsEvalType (const PointProfileCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    PointProfileCharacteristicStatsEvalType::
    PointProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    PointProfileCharacteristicStatsEvalType* PointProfileCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointProfileCharacteristicStatsEvalType (*this, f, c);
    }

    PointProfileCharacteristicStatsEvalType::
    ~PointProfileCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointProfileCharacteristicStatsEvalType >
    _xsd_PointProfileCharacteristicStatsEvalType_type_factory_init (
      L"PointProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceProfileCharacteristicStatsEvalType
    //

    SurfaceProfileCharacteristicStatsEvalType::
    SurfaceProfileCharacteristicStatsEvalType ()
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType ()
    {
    }

    SurfaceProfileCharacteristicStatsEvalType::
    SurfaceProfileCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (Status)
    {
    }

    SurfaceProfileCharacteristicStatsEvalType::
    SurfaceProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    SurfaceProfileCharacteristicStatsEvalType::
    SurfaceProfileCharacteristicStatsEvalType (const SurfaceProfileCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    SurfaceProfileCharacteristicStatsEvalType::
    SurfaceProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    SurfaceProfileCharacteristicStatsEvalType* SurfaceProfileCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceProfileCharacteristicStatsEvalType (*this, f, c);
    }

    SurfaceProfileCharacteristicStatsEvalType::
    ~SurfaceProfileCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceProfileCharacteristicStatsEvalType >
    _xsd_SurfaceProfileCharacteristicStatsEvalType_type_factory_init (
      L"SurfaceProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceProfileNonUniformCharacteristicStatsEvalType
    //

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    SurfaceProfileNonUniformCharacteristicStatsEvalType ()
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType ()
    {
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    SurfaceProfileNonUniformCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (Status)
    {
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    SurfaceProfileNonUniformCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    SurfaceProfileNonUniformCharacteristicStatsEvalType (const SurfaceProfileNonUniformCharacteristicStatsEvalType& x,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    SurfaceProfileNonUniformCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f,
                                                         ::xml_schema::container* c)
    : ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType* SurfaceProfileNonUniformCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceProfileNonUniformCharacteristicStatsEvalType (*this, f, c);
    }

    SurfaceProfileNonUniformCharacteristicStatsEvalType::
    ~SurfaceProfileNonUniformCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceProfileNonUniformCharacteristicStatsEvalType >
    _xsd_SurfaceProfileNonUniformCharacteristicStatsEvalType_type_factory_init (
      L"SurfaceProfileNonUniformCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // ThreadCharacteristicStatsEvalType
    //

    ThreadCharacteristicStatsEvalType::
    ThreadCharacteristicStatsEvalType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      ThreadStats_ (this),
      PitchDiameterStats_ (this),
      FunctionalSizeStats_ (this)
    {
    }

    ThreadCharacteristicStatsEvalType::
    ThreadCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      ThreadStats_ (this),
      PitchDiameterStats_ (this),
      FunctionalSizeStats_ (this)
    {
    }

    ThreadCharacteristicStatsEvalType::
    ThreadCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      ThreadStats_ (this),
      PitchDiameterStats_ (this),
      FunctionalSizeStats_ (this)
    {
    }

    ThreadCharacteristicStatsEvalType::
    ThreadCharacteristicStatsEvalType (const ThreadCharacteristicStatsEvalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      ThreadStats_ (x.ThreadStats_, f, this),
      PitchDiameterStats_ (x.PitchDiameterStats_, f, this),
      FunctionalSizeStats_ (x.FunctionalSizeStats_, f, this)
    {
    }

    ThreadCharacteristicStatsEvalType::
    ThreadCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      ThreadStats_ (this),
      PitchDiameterStats_ (this),
      FunctionalSizeStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadCharacteristicStatsEvalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadStats
        //
        if (n.name () == L"ThreadStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadStats_type > r (
            ThreadStats_traits::create (i, f, this));

          if (!this->ThreadStats_)
          {
            this->ThreadStats_.set (::std::move (r));
            continue;
          }
        }

        // PitchDiameterStats
        //
        if (n.name () == L"PitchDiameterStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PitchDiameterStats_type > r (
            PitchDiameterStats_traits::create (i, f, this));

          if (!this->PitchDiameterStats_)
          {
            this->PitchDiameterStats_.set (::std::move (r));
            continue;
          }
        }

        // FunctionalSizeStats
        //
        if (n.name () == L"FunctionalSizeStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FunctionalSizeStats_type > r (
            FunctionalSizeStats_traits::create (i, f, this));

          if (!this->FunctionalSizeStats_)
          {
            this->FunctionalSizeStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadCharacteristicStatsEvalType* ThreadCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadCharacteristicStatsEvalType (*this, f, c);
    }

    ThreadCharacteristicStatsEvalType& ThreadCharacteristicStatsEvalType::
    operator= (const ThreadCharacteristicStatsEvalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->ThreadStats_ = x.ThreadStats_;
        this->PitchDiameterStats_ = x.PitchDiameterStats_;
        this->FunctionalSizeStats_ = x.FunctionalSizeStats_;
      }

      return *this;
    }

    ThreadCharacteristicStatsEvalType::
    ~ThreadCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThreadCharacteristicStatsEvalType >
    _xsd_ThreadCharacteristicStatsEvalType_type_factory_init (
      L"ThreadCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldCharacteristicStatsEvalBaseType
    //

    WeldCharacteristicStatsEvalBaseType::
    WeldCharacteristicStatsEvalBaseType ()
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (),
      WeldStats_ (this)
    {
    }

    WeldCharacteristicStatsEvalBaseType::
    WeldCharacteristicStatsEvalBaseType (const Status_type& Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (Status),
      WeldStats_ (this)
    {
    }

    WeldCharacteristicStatsEvalBaseType::
    WeldCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (std::move (Status)),
      WeldStats_ (this)
    {
    }

    WeldCharacteristicStatsEvalBaseType::
    WeldCharacteristicStatsEvalBaseType (const WeldCharacteristicStatsEvalBaseType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (x, f, c),
      WeldStats_ (x.WeldStats_, f, this)
    {
    }

    WeldCharacteristicStatsEvalBaseType::
    WeldCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CharacteristicStatsEvalBaseType (e, f | ::xml_schema::flags::base, c),
      WeldStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WeldCharacteristicStatsEvalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CharacteristicStatsEvalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WeldStats
        //
        if (n.name () == L"WeldStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WeldStats_type > r (
            WeldStats_traits::create (i, f, this));

          if (!this->WeldStats_)
          {
            this->WeldStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    WeldCharacteristicStatsEvalBaseType& WeldCharacteristicStatsEvalBaseType::
    operator= (const WeldCharacteristicStatsEvalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CharacteristicStatsEvalBaseType& > (*this) = x;
        this->WeldStats_ = x.WeldStats_;
      }

      return *this;
    }

    WeldCharacteristicStatsEvalBaseType::
    ~WeldCharacteristicStatsEvalBaseType ()
    {
    }

    // WeldFilletCharacteristicStatsEvalType
    //

    WeldFilletCharacteristicStatsEvalType::
    WeldFilletCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldFilletCharacteristicStatsEvalType::
    WeldFilletCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldFilletCharacteristicStatsEvalType::
    WeldFilletCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldFilletCharacteristicStatsEvalType::
    WeldFilletCharacteristicStatsEvalType (const WeldFilletCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldFilletCharacteristicStatsEvalType::
    WeldFilletCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldFilletCharacteristicStatsEvalType* WeldFilletCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldFilletCharacteristicStatsEvalType (*this, f, c);
    }

    WeldFilletCharacteristicStatsEvalType::
    ~WeldFilletCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldFilletCharacteristicStatsEvalType >
    _xsd_WeldFilletCharacteristicStatsEvalType_type_factory_init (
      L"WeldFilletCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldPlugCharacteristicStatsEvalType
    //

    WeldPlugCharacteristicStatsEvalType::
    WeldPlugCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldPlugCharacteristicStatsEvalType::
    WeldPlugCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldPlugCharacteristicStatsEvalType::
    WeldPlugCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldPlugCharacteristicStatsEvalType::
    WeldPlugCharacteristicStatsEvalType (const WeldPlugCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldPlugCharacteristicStatsEvalType::
    WeldPlugCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldPlugCharacteristicStatsEvalType* WeldPlugCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldPlugCharacteristicStatsEvalType (*this, f, c);
    }

    WeldPlugCharacteristicStatsEvalType::
    ~WeldPlugCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldPlugCharacteristicStatsEvalType >
    _xsd_WeldPlugCharacteristicStatsEvalType_type_factory_init (
      L"WeldPlugCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldSlotCharacteristicStatsEvalType
    //

    WeldSlotCharacteristicStatsEvalType::
    WeldSlotCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldSlotCharacteristicStatsEvalType::
    WeldSlotCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldSlotCharacteristicStatsEvalType::
    WeldSlotCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldSlotCharacteristicStatsEvalType::
    WeldSlotCharacteristicStatsEvalType (const WeldSlotCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldSlotCharacteristicStatsEvalType::
    WeldSlotCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldSlotCharacteristicStatsEvalType* WeldSlotCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSlotCharacteristicStatsEvalType (*this, f, c);
    }

    WeldSlotCharacteristicStatsEvalType::
    ~WeldSlotCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldSlotCharacteristicStatsEvalType >
    _xsd_WeldSlotCharacteristicStatsEvalType_type_factory_init (
      L"WeldSlotCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldSpotCharacteristicStatsEvalType
    //

    WeldSpotCharacteristicStatsEvalType::
    WeldSpotCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldSpotCharacteristicStatsEvalType::
    WeldSpotCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldSpotCharacteristicStatsEvalType::
    WeldSpotCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldSpotCharacteristicStatsEvalType::
    WeldSpotCharacteristicStatsEvalType (const WeldSpotCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldSpotCharacteristicStatsEvalType::
    WeldSpotCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldSpotCharacteristicStatsEvalType* WeldSpotCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSpotCharacteristicStatsEvalType (*this, f, c);
    }

    WeldSpotCharacteristicStatsEvalType::
    ~WeldSpotCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldSpotCharacteristicStatsEvalType >
    _xsd_WeldSpotCharacteristicStatsEvalType_type_factory_init (
      L"WeldSpotCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldStudCharacteristicStatsEvalType
    //

    WeldStudCharacteristicStatsEvalType::
    WeldStudCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldStudCharacteristicStatsEvalType::
    WeldStudCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldStudCharacteristicStatsEvalType::
    WeldStudCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldStudCharacteristicStatsEvalType::
    WeldStudCharacteristicStatsEvalType (const WeldStudCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldStudCharacteristicStatsEvalType::
    WeldStudCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldStudCharacteristicStatsEvalType* WeldStudCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldStudCharacteristicStatsEvalType (*this, f, c);
    }

    WeldStudCharacteristicStatsEvalType::
    ~WeldStudCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldStudCharacteristicStatsEvalType >
    _xsd_WeldStudCharacteristicStatsEvalType_type_factory_init (
      L"WeldStudCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldSeamCharacteristicStatsEvalType
    //

    WeldSeamCharacteristicStatsEvalType::
    WeldSeamCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldSeamCharacteristicStatsEvalType::
    WeldSeamCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldSeamCharacteristicStatsEvalType::
    WeldSeamCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldSeamCharacteristicStatsEvalType::
    WeldSeamCharacteristicStatsEvalType (const WeldSeamCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldSeamCharacteristicStatsEvalType::
    WeldSeamCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldSeamCharacteristicStatsEvalType* WeldSeamCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSeamCharacteristicStatsEvalType (*this, f, c);
    }

    WeldSeamCharacteristicStatsEvalType::
    ~WeldSeamCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldSeamCharacteristicStatsEvalType >
    _xsd_WeldSeamCharacteristicStatsEvalType_type_factory_init (
      L"WeldSeamCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldSurfacingCharacteristicStatsEvalType
    //

    WeldSurfacingCharacteristicStatsEvalType::
    WeldSurfacingCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldSurfacingCharacteristicStatsEvalType::
    WeldSurfacingCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldSurfacingCharacteristicStatsEvalType::
    WeldSurfacingCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldSurfacingCharacteristicStatsEvalType::
    WeldSurfacingCharacteristicStatsEvalType (const WeldSurfacingCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldSurfacingCharacteristicStatsEvalType::
    WeldSurfacingCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldSurfacingCharacteristicStatsEvalType* WeldSurfacingCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSurfacingCharacteristicStatsEvalType (*this, f, c);
    }

    WeldSurfacingCharacteristicStatsEvalType::
    ~WeldSurfacingCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldSurfacingCharacteristicStatsEvalType >
    _xsd_WeldSurfacingCharacteristicStatsEvalType_type_factory_init (
      L"WeldSurfacingCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldEdgeCharacteristicStatsEvalType
    //

    WeldEdgeCharacteristicStatsEvalType::
    WeldEdgeCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldEdgeCharacteristicStatsEvalType::
    WeldEdgeCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldEdgeCharacteristicStatsEvalType::
    WeldEdgeCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldEdgeCharacteristicStatsEvalType::
    WeldEdgeCharacteristicStatsEvalType (const WeldEdgeCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldEdgeCharacteristicStatsEvalType::
    WeldEdgeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldEdgeCharacteristicStatsEvalType* WeldEdgeCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldEdgeCharacteristicStatsEvalType (*this, f, c);
    }

    WeldEdgeCharacteristicStatsEvalType::
    ~WeldEdgeCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldEdgeCharacteristicStatsEvalType >
    _xsd_WeldEdgeCharacteristicStatsEvalType_type_factory_init (
      L"WeldEdgeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldSquareCharacteristicStatsEvalType
    //

    WeldSquareCharacteristicStatsEvalType::
    WeldSquareCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldSquareCharacteristicStatsEvalType::
    WeldSquareCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldSquareCharacteristicStatsEvalType::
    WeldSquareCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldSquareCharacteristicStatsEvalType::
    WeldSquareCharacteristicStatsEvalType (const WeldSquareCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldSquareCharacteristicStatsEvalType::
    WeldSquareCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldSquareCharacteristicStatsEvalType* WeldSquareCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldSquareCharacteristicStatsEvalType (*this, f, c);
    }

    WeldSquareCharacteristicStatsEvalType::
    ~WeldSquareCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldSquareCharacteristicStatsEvalType >
    _xsd_WeldSquareCharacteristicStatsEvalType_type_factory_init (
      L"WeldSquareCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldBevelCharacteristicStatsEvalType
    //

    WeldBevelCharacteristicStatsEvalType::
    WeldBevelCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldBevelCharacteristicStatsEvalType::
    WeldBevelCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldBevelCharacteristicStatsEvalType::
    WeldBevelCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldBevelCharacteristicStatsEvalType::
    WeldBevelCharacteristicStatsEvalType (const WeldBevelCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldBevelCharacteristicStatsEvalType::
    WeldBevelCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldBevelCharacteristicStatsEvalType* WeldBevelCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldBevelCharacteristicStatsEvalType (*this, f, c);
    }

    WeldBevelCharacteristicStatsEvalType::
    ~WeldBevelCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldBevelCharacteristicStatsEvalType >
    _xsd_WeldBevelCharacteristicStatsEvalType_type_factory_init (
      L"WeldBevelCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldVCharacteristicStatsEvalType
    //

    WeldVCharacteristicStatsEvalType::
    WeldVCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldVCharacteristicStatsEvalType::
    WeldVCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldVCharacteristicStatsEvalType::
    WeldVCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldVCharacteristicStatsEvalType::
    WeldVCharacteristicStatsEvalType (const WeldVCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldVCharacteristicStatsEvalType::
    WeldVCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldVCharacteristicStatsEvalType* WeldVCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldVCharacteristicStatsEvalType (*this, f, c);
    }

    WeldVCharacteristicStatsEvalType::
    ~WeldVCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldVCharacteristicStatsEvalType >
    _xsd_WeldVCharacteristicStatsEvalType_type_factory_init (
      L"WeldVCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldUCharacteristicStatsEvalType
    //

    WeldUCharacteristicStatsEvalType::
    WeldUCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldUCharacteristicStatsEvalType::
    WeldUCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldUCharacteristicStatsEvalType::
    WeldUCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldUCharacteristicStatsEvalType::
    WeldUCharacteristicStatsEvalType (const WeldUCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldUCharacteristicStatsEvalType::
    WeldUCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldUCharacteristicStatsEvalType* WeldUCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldUCharacteristicStatsEvalType (*this, f, c);
    }

    WeldUCharacteristicStatsEvalType::
    ~WeldUCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldUCharacteristicStatsEvalType >
    _xsd_WeldUCharacteristicStatsEvalType_type_factory_init (
      L"WeldUCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldJCharacteristicStatsEvalType
    //

    WeldJCharacteristicStatsEvalType::
    WeldJCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldJCharacteristicStatsEvalType::
    WeldJCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldJCharacteristicStatsEvalType::
    WeldJCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldJCharacteristicStatsEvalType::
    WeldJCharacteristicStatsEvalType (const WeldJCharacteristicStatsEvalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldJCharacteristicStatsEvalType::
    WeldJCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldJCharacteristicStatsEvalType* WeldJCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldJCharacteristicStatsEvalType (*this, f, c);
    }

    WeldJCharacteristicStatsEvalType::
    ~WeldJCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldJCharacteristicStatsEvalType >
    _xsd_WeldJCharacteristicStatsEvalType_type_factory_init (
      L"WeldJCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldFlareVCharacteristicStatsEvalType
    //

    WeldFlareVCharacteristicStatsEvalType::
    WeldFlareVCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldFlareVCharacteristicStatsEvalType::
    WeldFlareVCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldFlareVCharacteristicStatsEvalType::
    WeldFlareVCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldFlareVCharacteristicStatsEvalType::
    WeldFlareVCharacteristicStatsEvalType (const WeldFlareVCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldFlareVCharacteristicStatsEvalType::
    WeldFlareVCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldFlareVCharacteristicStatsEvalType* WeldFlareVCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldFlareVCharacteristicStatsEvalType (*this, f, c);
    }

    WeldFlareVCharacteristicStatsEvalType::
    ~WeldFlareVCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldFlareVCharacteristicStatsEvalType >
    _xsd_WeldFlareVCharacteristicStatsEvalType_type_factory_init (
      L"WeldFlareVCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldFlareBevelCharacteristicStatsEvalType
    //

    WeldFlareBevelCharacteristicStatsEvalType::
    WeldFlareBevelCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldFlareBevelCharacteristicStatsEvalType::
    WeldFlareBevelCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldFlareBevelCharacteristicStatsEvalType::
    WeldFlareBevelCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldFlareBevelCharacteristicStatsEvalType::
    WeldFlareBevelCharacteristicStatsEvalType (const WeldFlareBevelCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldFlareBevelCharacteristicStatsEvalType::
    WeldFlareBevelCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldFlareBevelCharacteristicStatsEvalType* WeldFlareBevelCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldFlareBevelCharacteristicStatsEvalType (*this, f, c);
    }

    WeldFlareBevelCharacteristicStatsEvalType::
    ~WeldFlareBevelCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldFlareBevelCharacteristicStatsEvalType >
    _xsd_WeldFlareBevelCharacteristicStatsEvalType_type_factory_init (
      L"WeldFlareBevelCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldScarfCharacteristicStatsEvalType
    //

    WeldScarfCharacteristicStatsEvalType::
    WeldScarfCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldScarfCharacteristicStatsEvalType::
    WeldScarfCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldScarfCharacteristicStatsEvalType::
    WeldScarfCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldScarfCharacteristicStatsEvalType::
    WeldScarfCharacteristicStatsEvalType (const WeldScarfCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldScarfCharacteristicStatsEvalType::
    WeldScarfCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldScarfCharacteristicStatsEvalType* WeldScarfCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldScarfCharacteristicStatsEvalType (*this, f, c);
    }

    WeldScarfCharacteristicStatsEvalType::
    ~WeldScarfCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldScarfCharacteristicStatsEvalType >
    _xsd_WeldScarfCharacteristicStatsEvalType_type_factory_init (
      L"WeldScarfCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    // WeldCompoundCharacteristicStatsEvalType
    //

    WeldCompoundCharacteristicStatsEvalType::
    WeldCompoundCharacteristicStatsEvalType ()
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType ()
    {
    }

    WeldCompoundCharacteristicStatsEvalType::
    WeldCompoundCharacteristicStatsEvalType (const Status_type& Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (Status)
    {
    }

    WeldCompoundCharacteristicStatsEvalType::
    WeldCompoundCharacteristicStatsEvalType (::std::unique_ptr< Status_type > Status)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (std::move (Status))
    {
    }

    WeldCompoundCharacteristicStatsEvalType::
    WeldCompoundCharacteristicStatsEvalType (const WeldCompoundCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (x, f, c)
    {
    }

    WeldCompoundCharacteristicStatsEvalType::
    WeldCompoundCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::WeldCharacteristicStatsEvalBaseType (e, f, c)
    {
    }

    WeldCompoundCharacteristicStatsEvalType* WeldCompoundCharacteristicStatsEvalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WeldCompoundCharacteristicStatsEvalType (*this, f, c);
    }

    WeldCompoundCharacteristicStatsEvalType::
    ~WeldCompoundCharacteristicStatsEvalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WeldCompoundCharacteristicStatsEvalType >
    _xsd_WeldCompoundCharacteristicStatsEvalType_type_factory_init (
      L"WeldCompoundCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngleBetweenCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleBetweenCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngleBetweenCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngleCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngleCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngularCoordinateCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularCoordinateCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngularCoordinateCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngleFromCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleFromCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngleFromCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngularCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngularCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AngularityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AngularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ChordCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ChordCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ChordCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularRunoutCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularRunoutCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularRunoutCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CoaxialityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CoaxialityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CoaxialityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConcentricityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConcentricityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConcentricityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicalTaperCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalTaperCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicalTaperCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CurveLengthCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CurveLengthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CurveLengthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DepthCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DepthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DepthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DiameterCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DiameterCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DiameterCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DistanceBetweenCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DistanceBetweenCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DistanceBetweenCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DistanceFromCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DistanceFromCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DistanceFromCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipticityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipticityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FlatnessCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"FlatnessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FlatnessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FlatTaperCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"FlatTaperCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FlatTaperCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GeometricCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"GeometricCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GeometricCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_HeightCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"HeightCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::HeightCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LengthCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LengthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LengthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearCoordinateCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearCoordinateCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearCoordinateCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LocationCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LocationCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LocationCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LineProfileCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LineProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LineProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherFormCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherFormCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherFormCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OrientationCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"OrientationCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OrientationCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ParallelismCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelismCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ParallelismCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PerpendicularityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PerpendicularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PerpendicularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointProfileCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PointProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PositionCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PositionCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PositionCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RadiusCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"RadiusCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::RadiusCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalDiameterCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalDiameterCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalDiameterCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalRadiusCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalRadiusCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalRadiusCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SquareCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SquareCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SquareCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_StraightnessCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"StraightnessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StraightnessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceProfileCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceProfileNonUniformCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceProfileNonUniformCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceProfileNonUniformCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceTextureCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceTextureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceTextureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SymmetryCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SymmetryCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SymmetryCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThicknessCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ThicknessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThicknessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThreadCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThreadCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToroidicityCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidicityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToroidicityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TotalRunoutCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalRunoutCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TotalRunoutCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedAttributeCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAttributeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedAttributeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedLinearCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedLinearCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedLinearCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedAngularCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAngularCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedAngularCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedAreaCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAreaCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedAreaCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedForceCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedForceCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedForceCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedMassCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedMassCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedMassCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedPressureCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedPressureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedPressureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedSpeedCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedSpeedCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedSpeedCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedTemperatureCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedTemperatureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedTemperatureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedTimeCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedTimeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedTimeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedUnitCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedUnitCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedUnitCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WidthCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WidthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WidthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldFilletCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFilletCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldFilletCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldPlugCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldPlugCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldPlugCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldSlotCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSlotCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldSlotCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldSpotCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSpotCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldSpotCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldStudCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldStudCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldStudCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldSeamCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSeamCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldSeamCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldSurfacingCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSurfacingCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldSurfacingCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldEdgeCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldEdgeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldEdgeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldSquareCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSquareCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldSquareCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldBevelCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldBevelCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldBevelCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldVCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldVCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldVCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldUCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldUCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldUCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldJCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldJCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldJCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldFlareVCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFlareVCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldFlareVCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldFlareBevelCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFlareBevelCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldFlareBevelCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldScarfCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldScarfCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldScarfCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WeldCompoundCharacteristicStats_element_factory_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldCompoundCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WeldCompoundCharacteristicStatsEvalType >);


    // CharacteristicsStatsType
    //

    CharacteristicsStatsType::
    CharacteristicsStatsType ()
    : ::xml_schema::type (),
      CharacteristicStats_ (this),
      n_ (this)
    {
    }

    CharacteristicsStatsType::
    CharacteristicsStatsType (const n_type& n)
    : ::xml_schema::type (),
      CharacteristicStats_ (this),
      n_ (n, this)
    {
    }

    CharacteristicsStatsType::
    CharacteristicsStatsType (const CharacteristicsStatsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CharacteristicStats_ (x.CharacteristicStats_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CharacteristicsStatsType::
    CharacteristicsStatsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CharacteristicStats_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CharacteristicsStatsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CharacteristicStats
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CharacteristicStats",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< CharacteristicStats_type > r (
              dynamic_cast< CharacteristicStats_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->CharacteristicStats_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CharacteristicsStatsType* CharacteristicsStatsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CharacteristicsStatsType (*this, f, c);
    }

    CharacteristicsStatsType& CharacteristicsStatsType::
    operator= (const CharacteristicsStatsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CharacteristicStats_ = x.CharacteristicStats_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CharacteristicsStatsType::
    ~CharacteristicsStatsType ()
    {
    }

    // AverageFeatureType
    //

    AverageFeatureType::
    AverageFeatureType ()
    : ::xml_schema::type (),
      FeatureMeasurement_ (this),
      MeasuredIds_ (this)
    {
    }

    AverageFeatureType::
    AverageFeatureType (const FeatureMeasurement_type& FeatureMeasurement,
                        const MeasuredIds_type& MeasuredIds)
    : ::xml_schema::type (),
      FeatureMeasurement_ (FeatureMeasurement, this),
      MeasuredIds_ (MeasuredIds, this)
    {
    }

    AverageFeatureType::
    AverageFeatureType (::std::unique_ptr< FeatureMeasurement_type > FeatureMeasurement,
                        ::std::unique_ptr< MeasuredIds_type > MeasuredIds)
    : ::xml_schema::type (),
      FeatureMeasurement_ (std::move (FeatureMeasurement), this),
      MeasuredIds_ (std::move (MeasuredIds), this)
    {
    }

    AverageFeatureType::
    AverageFeatureType (const AverageFeatureType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureMeasurement_ (x.FeatureMeasurement_, f, this),
      MeasuredIds_ (x.MeasuredIds_, f, this)
    {
    }

    AverageFeatureType::
    AverageFeatureType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureMeasurement_ (this),
      MeasuredIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AverageFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureMeasurement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureMeasurement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!FeatureMeasurement_.present ())
            {
              ::std::unique_ptr< FeatureMeasurement_type > r (
                dynamic_cast< FeatureMeasurement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->FeatureMeasurement_.set (::std::move (r));
              continue;
            }
          }
        }

        // MeasuredIds
        //
        if (n.name () == L"MeasuredIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredIds_type > r (
            MeasuredIds_traits::create (i, f, this));

          if (!MeasuredIds_.present ())
          {
            this->MeasuredIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureMeasurement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureMeasurement",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MeasuredIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeasuredIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AverageFeatureType* AverageFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AverageFeatureType (*this, f, c);
    }

    AverageFeatureType& AverageFeatureType::
    operator= (const AverageFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureMeasurement_ = x.FeatureMeasurement_;
        this->MeasuredIds_ = x.MeasuredIds_;
      }

      return *this;
    }

    AverageFeatureType::
    ~AverageFeatureType ()
    {
    }

    // AverageFeaturesType
    //

    AverageFeaturesType::
    AverageFeaturesType ()
    : ::xml_schema::type (),
      AverageFeature_ (this),
      n_ (this)
    {
    }

    AverageFeaturesType::
    AverageFeaturesType (const n_type& n)
    : ::xml_schema::type (),
      AverageFeature_ (this),
      n_ (n, this)
    {
    }

    AverageFeaturesType::
    AverageFeaturesType (const AverageFeaturesType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AverageFeature_ (x.AverageFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AverageFeaturesType::
    AverageFeaturesType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AverageFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AverageFeaturesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AverageFeature
        //
        if (n.name () == L"AverageFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AverageFeature_type > r (
            AverageFeature_traits::create (i, f, this));

          this->AverageFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AverageFeaturesType* AverageFeaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AverageFeaturesType (*this, f, c);
    }

    AverageFeaturesType& AverageFeaturesType::
    operator= (const AverageFeaturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AverageFeature_ = x.AverageFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AverageFeaturesType::
    ~AverageFeaturesType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SummaryAverage_element_factory_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryAverage",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SummaryMaximum_element_factory_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryMaximum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SummaryMinimum_element_factory_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryMinimum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SummaryRange_element_factory_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SummaryStandardDeviation_element_factory_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryStandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    // SummaryStatisticsType
    //

    SummaryStatisticsType::
    SummaryStatisticsType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      TypeOfSummary_ (this),
      SummaryStatsValue_ (this)
    {
    }

    SummaryStatisticsType::
    SummaryStatisticsType (const TypeOfSummary_type& TypeOfSummary)
    : ::xml_schema::type (),
      Attributes_ (this),
      TypeOfSummary_ (TypeOfSummary, this),
      SummaryStatsValue_ (this)
    {
    }

    SummaryStatisticsType::
    SummaryStatisticsType (const SummaryStatisticsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      TypeOfSummary_ (x.TypeOfSummary_, f, this),
      SummaryStatsValue_ (x.SummaryStatsValue_, f, this)
    {
    }

    SummaryStatisticsType::
    SummaryStatisticsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      TypeOfSummary_ (this),
      SummaryStatsValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // TypeOfSummary
        //
        if (n.name () == L"TypeOfSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TypeOfSummary_type > r (
            TypeOfSummary_traits::create (i, f, this));

          if (!TypeOfSummary_.present ())
          {
            this->TypeOfSummary_.set (::std::move (r));
            continue;
          }
        }

        // SummaryStatsValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"SummaryStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< SummaryStatsValue_type > r (
              dynamic_cast< SummaryStatsValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SummaryStatsValue_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TypeOfSummary_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TypeOfSummary",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SummaryStatisticsType* SummaryStatisticsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsType (*this, f, c);
    }

    SummaryStatisticsType& SummaryStatisticsType::
    operator= (const SummaryStatisticsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->TypeOfSummary_ = x.TypeOfSummary_;
        this->SummaryStatsValue_ = x.SummaryStatsValue_;
      }

      return *this;
    }

    SummaryStatisticsType::
    ~SummaryStatisticsType ()
    {
    }

    // SummariesStatisticsType
    //

    SummariesStatisticsType::
    SummariesStatisticsType ()
    : ::xml_schema::type (),
      StatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsType::
    SummariesStatisticsType (const n_type& n)
    : ::xml_schema::type (),
      StatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsType::
    SummariesStatisticsType (const SummariesStatisticsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StatsSummary_ (x.StatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsType::
    SummariesStatisticsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatsSummary
        //
        if (n.name () == L"StatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatsSummary_type > r (
            StatsSummary_traits::create (i, f, this));

          this->StatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsType* SummariesStatisticsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsType (*this, f, c);
    }

    SummariesStatisticsType& SummariesStatisticsType::
    operator= (const SummariesStatisticsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StatsSummary_ = x.StatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsType::
    ~SummariesStatisticsType ()
    {
    }

    // SummaryStatisticsLinearType
    //

    SummaryStatisticsLinearType::
    SummaryStatisticsLinearType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      linearUnit_ (this)
    {
    }

    SummaryStatisticsLinearType::
    SummaryStatisticsLinearType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      linearUnit_ (this)
    {
    }

    SummaryStatisticsLinearType::
    SummaryStatisticsLinearType (const SummaryStatisticsLinearType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    SummaryStatisticsLinearType::
    SummaryStatisticsLinearType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsLinearType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsLinearType* SummaryStatisticsLinearType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsLinearType (*this, f, c);
    }

    SummaryStatisticsLinearType& SummaryStatisticsLinearType::
    operator= (const SummaryStatisticsLinearType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    SummaryStatisticsLinearType::
    ~SummaryStatisticsLinearType ()
    {
    }

    // SummariesStatisticsLinearType
    //

    SummariesStatisticsLinearType::
    SummariesStatisticsLinearType ()
    : ::xml_schema::type (),
      LinearStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsLinearType::
    SummariesStatisticsLinearType (const n_type& n)
    : ::xml_schema::type (),
      LinearStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsLinearType::
    SummariesStatisticsLinearType (const SummariesStatisticsLinearType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearStatsSummary_ (x.LinearStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsLinearType::
    SummariesStatisticsLinearType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsLinearType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearStatsSummary
        //
        if (n.name () == L"LinearStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearStatsSummary_type > r (
            LinearStatsSummary_traits::create (i, f, this));

          this->LinearStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsLinearType* SummariesStatisticsLinearType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsLinearType (*this, f, c);
    }

    SummariesStatisticsLinearType& SummariesStatisticsLinearType::
    operator= (const SummariesStatisticsLinearType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearStatsSummary_ = x.LinearStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsLinearType::
    ~SummariesStatisticsLinearType ()
    {
    }

    // SummaryStatisticsAngularType
    //

    SummaryStatisticsAngularType::
    SummaryStatisticsAngularType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      angularUnit_ (this)
    {
    }

    SummaryStatisticsAngularType::
    SummaryStatisticsAngularType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      angularUnit_ (this)
    {
    }

    SummaryStatisticsAngularType::
    SummaryStatisticsAngularType (const SummaryStatisticsAngularType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    SummaryStatisticsAngularType::
    SummaryStatisticsAngularType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsAngularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsAngularType* SummaryStatisticsAngularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsAngularType (*this, f, c);
    }

    SummaryStatisticsAngularType& SummaryStatisticsAngularType::
    operator= (const SummaryStatisticsAngularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    SummaryStatisticsAngularType::
    ~SummaryStatisticsAngularType ()
    {
    }

    // SummariesStatisticsAngularType
    //

    SummariesStatisticsAngularType::
    SummariesStatisticsAngularType ()
    : ::xml_schema::type (),
      AngularStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsAngularType::
    SummariesStatisticsAngularType (const n_type& n)
    : ::xml_schema::type (),
      AngularStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsAngularType::
    SummariesStatisticsAngularType (const SummariesStatisticsAngularType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AngularStatsSummary_ (x.AngularStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsAngularType::
    SummariesStatisticsAngularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AngularStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsAngularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AngularStatsSummary
        //
        if (n.name () == L"AngularStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularStatsSummary_type > r (
            AngularStatsSummary_traits::create (i, f, this));

          this->AngularStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsAngularType* SummariesStatisticsAngularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsAngularType (*this, f, c);
    }

    SummariesStatisticsAngularType& SummariesStatisticsAngularType::
    operator= (const SummariesStatisticsAngularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AngularStatsSummary_ = x.AngularStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsAngularType::
    ~SummariesStatisticsAngularType ()
    {
    }

    // SummaryStatisticsAreaType
    //

    SummaryStatisticsAreaType::
    SummaryStatisticsAreaType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      areaUnit_ (this)
    {
    }

    SummaryStatisticsAreaType::
    SummaryStatisticsAreaType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      areaUnit_ (this)
    {
    }

    SummaryStatisticsAreaType::
    SummaryStatisticsAreaType (const SummaryStatisticsAreaType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    SummaryStatisticsAreaType::
    SummaryStatisticsAreaType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsAreaType* SummaryStatisticsAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsAreaType (*this, f, c);
    }

    SummaryStatisticsAreaType& SummaryStatisticsAreaType::
    operator= (const SummaryStatisticsAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    SummaryStatisticsAreaType::
    ~SummaryStatisticsAreaType ()
    {
    }

    // SummariesStatisticsAreaType
    //

    SummariesStatisticsAreaType::
    SummariesStatisticsAreaType ()
    : ::xml_schema::type (),
      AreaStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsAreaType::
    SummariesStatisticsAreaType (const n_type& n)
    : ::xml_schema::type (),
      AreaStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsAreaType::
    SummariesStatisticsAreaType (const SummariesStatisticsAreaType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaStatsSummary_ (x.AreaStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsAreaType::
    SummariesStatisticsAreaType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AreaStatsSummary
        //
        if (n.name () == L"AreaStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaStatsSummary_type > r (
            AreaStatsSummary_traits::create (i, f, this));

          this->AreaStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsAreaType* SummariesStatisticsAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsAreaType (*this, f, c);
    }

    SummariesStatisticsAreaType& SummariesStatisticsAreaType::
    operator= (const SummariesStatisticsAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaStatsSummary_ = x.AreaStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsAreaType::
    ~SummariesStatisticsAreaType ()
    {
    }

    // SummaryStatisticsForceType
    //

    SummaryStatisticsForceType::
    SummaryStatisticsForceType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      forceUnit_ (this)
    {
    }

    SummaryStatisticsForceType::
    SummaryStatisticsForceType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      forceUnit_ (this)
    {
    }

    SummaryStatisticsForceType::
    SummaryStatisticsForceType (const SummaryStatisticsForceType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    SummaryStatisticsForceType::
    SummaryStatisticsForceType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsForceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsForceType* SummaryStatisticsForceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsForceType (*this, f, c);
    }

    SummaryStatisticsForceType& SummaryStatisticsForceType::
    operator= (const SummaryStatisticsForceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    SummaryStatisticsForceType::
    ~SummaryStatisticsForceType ()
    {
    }

    // SummariesStatisticsForceType
    //

    SummariesStatisticsForceType::
    SummariesStatisticsForceType ()
    : ::xml_schema::type (),
      ForceStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsForceType::
    SummariesStatisticsForceType (const n_type& n)
    : ::xml_schema::type (),
      ForceStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsForceType::
    SummariesStatisticsForceType (const SummariesStatisticsForceType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ForceStatsSummary_ (x.ForceStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsForceType::
    SummariesStatisticsForceType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ForceStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsForceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ForceStatsSummary
        //
        if (n.name () == L"ForceStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceStatsSummary_type > r (
            ForceStatsSummary_traits::create (i, f, this));

          this->ForceStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsForceType* SummariesStatisticsForceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsForceType (*this, f, c);
    }

    SummariesStatisticsForceType& SummariesStatisticsForceType::
    operator= (const SummariesStatisticsForceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ForceStatsSummary_ = x.ForceStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsForceType::
    ~SummariesStatisticsForceType ()
    {
    }

    // SummaryStatisticsMassType
    //

    SummaryStatisticsMassType::
    SummaryStatisticsMassType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      massUnit_ (this)
    {
    }

    SummaryStatisticsMassType::
    SummaryStatisticsMassType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      massUnit_ (this)
    {
    }

    SummaryStatisticsMassType::
    SummaryStatisticsMassType (const SummaryStatisticsMassType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    SummaryStatisticsMassType::
    SummaryStatisticsMassType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsMassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsMassType* SummaryStatisticsMassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsMassType (*this, f, c);
    }

    SummaryStatisticsMassType& SummaryStatisticsMassType::
    operator= (const SummaryStatisticsMassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    SummaryStatisticsMassType::
    ~SummaryStatisticsMassType ()
    {
    }

    // SummariesStatisticsMassType
    //

    SummariesStatisticsMassType::
    SummariesStatisticsMassType ()
    : ::xml_schema::type (),
      MassStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsMassType::
    SummariesStatisticsMassType (const n_type& n)
    : ::xml_schema::type (),
      MassStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsMassType::
    SummariesStatisticsMassType (const SummariesStatisticsMassType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MassStatsSummary_ (x.MassStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsMassType::
    SummariesStatisticsMassType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MassStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsMassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MassStatsSummary
        //
        if (n.name () == L"MassStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassStatsSummary_type > r (
            MassStatsSummary_traits::create (i, f, this));

          this->MassStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsMassType* SummariesStatisticsMassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsMassType (*this, f, c);
    }

    SummariesStatisticsMassType& SummariesStatisticsMassType::
    operator= (const SummariesStatisticsMassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MassStatsSummary_ = x.MassStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsMassType::
    ~SummariesStatisticsMassType ()
    {
    }

    // SummaryStatisticsPressureType
    //

    SummaryStatisticsPressureType::
    SummaryStatisticsPressureType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      pressureUnit_ (this)
    {
    }

    SummaryStatisticsPressureType::
    SummaryStatisticsPressureType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      pressureUnit_ (this)
    {
    }

    SummaryStatisticsPressureType::
    SummaryStatisticsPressureType (const SummaryStatisticsPressureType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    SummaryStatisticsPressureType::
    SummaryStatisticsPressureType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsPressureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsPressureType* SummaryStatisticsPressureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsPressureType (*this, f, c);
    }

    SummaryStatisticsPressureType& SummaryStatisticsPressureType::
    operator= (const SummaryStatisticsPressureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    SummaryStatisticsPressureType::
    ~SummaryStatisticsPressureType ()
    {
    }

    // SummariesStatisticsPressureType
    //

    SummariesStatisticsPressureType::
    SummariesStatisticsPressureType ()
    : ::xml_schema::type (),
      PressureStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsPressureType::
    SummariesStatisticsPressureType (const n_type& n)
    : ::xml_schema::type (),
      PressureStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsPressureType::
    SummariesStatisticsPressureType (const SummariesStatisticsPressureType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PressureStatsSummary_ (x.PressureStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsPressureType::
    SummariesStatisticsPressureType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PressureStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsPressureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PressureStatsSummary
        //
        if (n.name () == L"PressureStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureStatsSummary_type > r (
            PressureStatsSummary_traits::create (i, f, this));

          this->PressureStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsPressureType* SummariesStatisticsPressureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsPressureType (*this, f, c);
    }

    SummariesStatisticsPressureType& SummariesStatisticsPressureType::
    operator= (const SummariesStatisticsPressureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PressureStatsSummary_ = x.PressureStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsPressureType::
    ~SummariesStatisticsPressureType ()
    {
    }

    // SummaryStatisticsSpeedType
    //

    SummaryStatisticsSpeedType::
    SummaryStatisticsSpeedType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      speedUnit_ (this)
    {
    }

    SummaryStatisticsSpeedType::
    SummaryStatisticsSpeedType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      speedUnit_ (this)
    {
    }

    SummaryStatisticsSpeedType::
    SummaryStatisticsSpeedType (const SummaryStatisticsSpeedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    SummaryStatisticsSpeedType::
    SummaryStatisticsSpeedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsSpeedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsSpeedType* SummaryStatisticsSpeedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsSpeedType (*this, f, c);
    }

    SummaryStatisticsSpeedType& SummaryStatisticsSpeedType::
    operator= (const SummaryStatisticsSpeedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    SummaryStatisticsSpeedType::
    ~SummaryStatisticsSpeedType ()
    {
    }

    // SummariesStatisticsSpeedType
    //

    SummariesStatisticsSpeedType::
    SummariesStatisticsSpeedType ()
    : ::xml_schema::type (),
      SpeedStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsSpeedType::
    SummariesStatisticsSpeedType (const n_type& n)
    : ::xml_schema::type (),
      SpeedStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsSpeedType::
    SummariesStatisticsSpeedType (const SummariesStatisticsSpeedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SpeedStatsSummary_ (x.SpeedStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsSpeedType::
    SummariesStatisticsSpeedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SpeedStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsSpeedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SpeedStatsSummary
        //
        if (n.name () == L"SpeedStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedStatsSummary_type > r (
            SpeedStatsSummary_traits::create (i, f, this));

          this->SpeedStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsSpeedType* SummariesStatisticsSpeedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsSpeedType (*this, f, c);
    }

    SummariesStatisticsSpeedType& SummariesStatisticsSpeedType::
    operator= (const SummariesStatisticsSpeedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SpeedStatsSummary_ = x.SpeedStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsSpeedType::
    ~SummariesStatisticsSpeedType ()
    {
    }

    // SummaryStatisticsTemperatureType
    //

    SummaryStatisticsTemperatureType::
    SummaryStatisticsTemperatureType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      temperatureUnit_ (this)
    {
    }

    SummaryStatisticsTemperatureType::
    SummaryStatisticsTemperatureType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      temperatureUnit_ (this)
    {
    }

    SummaryStatisticsTemperatureType::
    SummaryStatisticsTemperatureType (const SummaryStatisticsTemperatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    SummaryStatisticsTemperatureType::
    SummaryStatisticsTemperatureType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsTemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsTemperatureType* SummaryStatisticsTemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsTemperatureType (*this, f, c);
    }

    SummaryStatisticsTemperatureType& SummaryStatisticsTemperatureType::
    operator= (const SummaryStatisticsTemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    SummaryStatisticsTemperatureType::
    ~SummaryStatisticsTemperatureType ()
    {
    }

    // SummariesStatisticsTemperatureType
    //

    SummariesStatisticsTemperatureType::
    SummariesStatisticsTemperatureType ()
    : ::xml_schema::type (),
      TemperatureStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsTemperatureType::
    SummariesStatisticsTemperatureType (const n_type& n)
    : ::xml_schema::type (),
      TemperatureStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsTemperatureType::
    SummariesStatisticsTemperatureType (const SummariesStatisticsTemperatureType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TemperatureStatsSummary_ (x.TemperatureStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsTemperatureType::
    SummariesStatisticsTemperatureType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TemperatureStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsTemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TemperatureStatsSummary
        //
        if (n.name () == L"TemperatureStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStatsSummary_type > r (
            TemperatureStatsSummary_traits::create (i, f, this));

          this->TemperatureStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsTemperatureType* SummariesStatisticsTemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsTemperatureType (*this, f, c);
    }

    SummariesStatisticsTemperatureType& SummariesStatisticsTemperatureType::
    operator= (const SummariesStatisticsTemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TemperatureStatsSummary_ = x.TemperatureStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsTemperatureType::
    ~SummariesStatisticsTemperatureType ()
    {
    }

    // SummaryStatisticsTimeType
    //

    SummaryStatisticsTimeType::
    SummaryStatisticsTimeType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      timeUnit_ (this)
    {
    }

    SummaryStatisticsTimeType::
    SummaryStatisticsTimeType (const TypeOfSummary_type& TypeOfSummary)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      timeUnit_ (this)
    {
    }

    SummaryStatisticsTimeType::
    SummaryStatisticsTimeType (const SummaryStatisticsTimeType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    SummaryStatisticsTimeType::
    SummaryStatisticsTimeType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SummaryStatisticsTimeType* SummaryStatisticsTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsTimeType (*this, f, c);
    }

    SummaryStatisticsTimeType& SummaryStatisticsTimeType::
    operator= (const SummaryStatisticsTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    SummaryStatisticsTimeType::
    ~SummaryStatisticsTimeType ()
    {
    }

    // SummariesStatisticsTimeType
    //

    SummariesStatisticsTimeType::
    SummariesStatisticsTimeType ()
    : ::xml_schema::type (),
      TimeStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsTimeType::
    SummariesStatisticsTimeType (const n_type& n)
    : ::xml_schema::type (),
      TimeStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsTimeType::
    SummariesStatisticsTimeType (const SummariesStatisticsTimeType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TimeStatsSummary_ (x.TimeStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsTimeType::
    SummariesStatisticsTimeType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TimeStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TimeStatsSummary
        //
        if (n.name () == L"TimeStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStatsSummary_type > r (
            TimeStatsSummary_traits::create (i, f, this));

          this->TimeStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsTimeType* SummariesStatisticsTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsTimeType (*this, f, c);
    }

    SummariesStatisticsTimeType& SummariesStatisticsTimeType::
    operator= (const SummariesStatisticsTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TimeStatsSummary_ = x.TimeStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsTimeType::
    ~SummariesStatisticsTimeType ()
    {
    }

    // SummaryStatisticsUserDefinedUnitType
    //

    SummaryStatisticsUserDefinedUnitType::
    SummaryStatisticsUserDefinedUnitType ()
    : ::xsd::qif30::SummaryStatisticsType (),
      unitName_ (this)
    {
    }

    SummaryStatisticsUserDefinedUnitType::
    SummaryStatisticsUserDefinedUnitType (const TypeOfSummary_type& TypeOfSummary,
                                          const unitName_type& unitName)
    : ::xsd::qif30::SummaryStatisticsType (TypeOfSummary),
      unitName_ (unitName, this)
    {
    }

    SummaryStatisticsUserDefinedUnitType::
    SummaryStatisticsUserDefinedUnitType (const SummaryStatisticsUserDefinedUnitType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    SummaryStatisticsUserDefinedUnitType::
    SummaryStatisticsUserDefinedUnitType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SummaryStatisticsType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatisticsUserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SummaryStatisticsType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    SummaryStatisticsUserDefinedUnitType* SummaryStatisticsUserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatisticsUserDefinedUnitType (*this, f, c);
    }

    SummaryStatisticsUserDefinedUnitType& SummaryStatisticsUserDefinedUnitType::
    operator= (const SummaryStatisticsUserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SummaryStatisticsType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    SummaryStatisticsUserDefinedUnitType::
    ~SummaryStatisticsUserDefinedUnitType ()
    {
    }

    // SummariesStatisticsUserDefinedUnitType
    //

    SummariesStatisticsUserDefinedUnitType::
    SummariesStatisticsUserDefinedUnitType ()
    : ::xml_schema::type (),
      UserDefinedUnitStatsSummary_ (this),
      n_ (this)
    {
    }

    SummariesStatisticsUserDefinedUnitType::
    SummariesStatisticsUserDefinedUnitType (const n_type& n)
    : ::xml_schema::type (),
      UserDefinedUnitStatsSummary_ (this),
      n_ (n, this)
    {
    }

    SummariesStatisticsUserDefinedUnitType::
    SummariesStatisticsUserDefinedUnitType (const SummariesStatisticsUserDefinedUnitType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UserDefinedUnitStatsSummary_ (x.UserDefinedUnitStatsSummary_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummariesStatisticsUserDefinedUnitType::
    SummariesStatisticsUserDefinedUnitType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UserDefinedUnitStatsSummary_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummariesStatisticsUserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UserDefinedUnitStatsSummary
        //
        if (n.name () == L"UserDefinedUnitStatsSummary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitStatsSummary_type > r (
            UserDefinedUnitStatsSummary_traits::create (i, f, this));

          this->UserDefinedUnitStatsSummary_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummariesStatisticsUserDefinedUnitType* SummariesStatisticsUserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummariesStatisticsUserDefinedUnitType (*this, f, c);
    }

    SummariesStatisticsUserDefinedUnitType& SummariesStatisticsUserDefinedUnitType::
    operator= (const SummariesStatisticsUserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->UserDefinedUnitStatsSummary_ = x.UserDefinedUnitStatsSummary_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummariesStatisticsUserDefinedUnitType::
    ~SummariesStatisticsUserDefinedUnitType ()
    {
    }

    // AssignableCauseEnumType
    //

    AssignableCauseEnumType::
    AssignableCauseEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AssignableCauseEnumType_convert ();
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AssignableCauseEnumType_convert ();
    }

    AssignableCauseEnumType::
    AssignableCauseEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AssignableCauseEnumType_convert ();
    }

    AssignableCauseEnumType* AssignableCauseEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssignableCauseEnumType (*this, f, c);
    }

    AssignableCauseEnumType::value AssignableCauseEnumType::
    _xsd_AssignableCauseEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AssignableCauseEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AssignableCauseEnumType_indexes_,
                        _xsd_AssignableCauseEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_AssignableCauseEnumType_indexes_ + 5 || _xsd_AssignableCauseEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AssignableCauseEnumType::
    _xsd_AssignableCauseEnumType_literals_[5] =
    {
      L"POWER_FAILURE",
      L"BROKEN_TOOL",
      L"COMPUTER_CRASH",
      L"WEATHER_EVENT",
      L"OTHER"
    };

    const AssignableCauseEnumType::value AssignableCauseEnumType::
    _xsd_AssignableCauseEnumType_indexes_[5] =
    {
      ::xsd::qif30::AssignableCauseEnumType::BROKEN_TOOL,
      ::xsd::qif30::AssignableCauseEnumType::COMPUTER_CRASH,
      ::xsd::qif30::AssignableCauseEnumType::OTHER,
      ::xsd::qif30::AssignableCauseEnumType::POWER_FAILURE,
      ::xsd::qif30::AssignableCauseEnumType::WEATHER_EVENT
    };

    // AssignableCauseType
    //

    AssignableCauseType::
    AssignableCauseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Description_ (this),
      AssignableCauseEnum_ (this),
      CorrectiveActionIds_ (this),
      id_ (this)
    {
    }

    AssignableCauseType::
    AssignableCauseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Description_ (this),
      AssignableCauseEnum_ (this),
      CorrectiveActionIds_ (this),
      id_ (id, this)
    {
    }

    AssignableCauseType::
    AssignableCauseType (const AssignableCauseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Description_ (x.Description_, f, this),
      AssignableCauseEnum_ (x.AssignableCauseEnum_, f, this),
      CorrectiveActionIds_ (x.CorrectiveActionIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AssignableCauseType::
    AssignableCauseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Description_ (this),
      AssignableCauseEnum_ (this),
      CorrectiveActionIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AssignableCauseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // AssignableCauseEnum
        //
        if (n.name () == L"AssignableCauseEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssignableCauseEnum_type > r (
            AssignableCauseEnum_traits::create (i, f, this));

          if (!this->AssignableCauseEnum_)
          {
            this->AssignableCauseEnum_.set (::std::move (r));
            continue;
          }
        }

        // CorrectiveActionIds
        //
        if (n.name () == L"CorrectiveActionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActionIds_type > r (
            CorrectiveActionIds_traits::create (i, f, this));

          if (!this->CorrectiveActionIds_)
          {
            this->CorrectiveActionIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    AssignableCauseType* AssignableCauseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssignableCauseType (*this, f, c);
    }

    AssignableCauseType& AssignableCauseType::
    operator= (const AssignableCauseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Description_ = x.Description_;
        this->AssignableCauseEnum_ = x.AssignableCauseEnum_;
        this->CorrectiveActionIds_ = x.CorrectiveActionIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AssignableCauseType::
    ~AssignableCauseType ()
    {
    }

    // AssignableCausesType
    //

    AssignableCausesType::
    AssignableCausesType ()
    : ::xml_schema::type (),
      AssignableCause_ (this),
      n_ (this)
    {
    }

    AssignableCausesType::
    AssignableCausesType (const n_type& n)
    : ::xml_schema::type (),
      AssignableCause_ (this),
      n_ (n, this)
    {
    }

    AssignableCausesType::
    AssignableCausesType (const AssignableCausesType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AssignableCause_ (x.AssignableCause_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AssignableCausesType::
    AssignableCausesType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AssignableCause_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AssignableCausesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssignableCause
        //
        if (n.name () == L"AssignableCause" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssignableCause_type > r (
            AssignableCause_traits::create (i, f, this));

          this->AssignableCause_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AssignableCausesType* AssignableCausesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssignableCausesType (*this, f, c);
    }

    AssignableCausesType& AssignableCausesType::
    operator= (const AssignableCausesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AssignableCause_ = x.AssignableCause_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AssignableCausesType::
    ~AssignableCausesType ()
    {
    }

    // ActionToTakeEnumType
    //

    ActionToTakeEnumType::
    ActionToTakeEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ActionToTakeEnumType_convert ();
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ActionToTakeEnumType_convert ();
    }

    ActionToTakeEnumType::
    ActionToTakeEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ActionToTakeEnumType_convert ();
    }

    ActionToTakeEnumType* ActionToTakeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionToTakeEnumType (*this, f, c);
    }

    ActionToTakeEnumType::value ActionToTakeEnumType::
    _xsd_ActionToTakeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ActionToTakeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ActionToTakeEnumType_indexes_,
                        _xsd_ActionToTakeEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_ActionToTakeEnumType_indexes_ + 8 || _xsd_ActionToTakeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ActionToTakeEnumType::
    _xsd_ActionToTakeEnumType_literals_[8] =
    {
      L"HALT_PRODUCTION",
      L"CONTAINMENT",
      L"NEW_MATERIAL_BATCH",
      L"NEW_TOOLING",
      L"INSPECT_100PC",
      L"REBOOT",
      L"RECALIBRATE",
      L"OTHER"
    };

    const ActionToTakeEnumType::value ActionToTakeEnumType::
    _xsd_ActionToTakeEnumType_indexes_[8] =
    {
      ::xsd::qif30::ActionToTakeEnumType::CONTAINMENT,
      ::xsd::qif30::ActionToTakeEnumType::HALT_PRODUCTION,
      ::xsd::qif30::ActionToTakeEnumType::INSPECT_100PC,
      ::xsd::qif30::ActionToTakeEnumType::NEW_MATERIAL_BATCH,
      ::xsd::qif30::ActionToTakeEnumType::NEW_TOOLING,
      ::xsd::qif30::ActionToTakeEnumType::OTHER,
      ::xsd::qif30::ActionToTakeEnumType::REBOOT,
      ::xsd::qif30::ActionToTakeEnumType::RECALIBRATE
    };

    // CorrectiveActionType
    //

    CorrectiveActionType::
    CorrectiveActionType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      ActionToTake_ (this),
      ActionToTakeEnum_ (this),
      id_ (this)
    {
    }

    CorrectiveActionType::
    CorrectiveActionType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      ActionToTake_ (this),
      ActionToTakeEnum_ (this),
      id_ (id, this)
    {
    }

    CorrectiveActionType::
    CorrectiveActionType (const CorrectiveActionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      ActionToTake_ (x.ActionToTake_, f, this),
      ActionToTakeEnum_ (x.ActionToTakeEnum_, f, this),
      id_ (x.id_, f, this)
    {
    }

    CorrectiveActionType::
    CorrectiveActionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      ActionToTake_ (this),
      ActionToTakeEnum_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CorrectiveActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // ActionToTake
        //
        if (n.name () == L"ActionToTake" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActionToTake_type > r (
            ActionToTake_traits::create (i, f, this));

          if (!this->ActionToTake_)
          {
            this->ActionToTake_.set (::std::move (r));
            continue;
          }
        }

        // ActionToTakeEnum
        //
        if (n.name () == L"ActionToTakeEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActionToTakeEnum_type > r (
            ActionToTakeEnum_traits::create (i, f, this));

          if (!this->ActionToTakeEnum_)
          {
            this->ActionToTakeEnum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    CorrectiveActionType* CorrectiveActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CorrectiveActionType (*this, f, c);
    }

    CorrectiveActionType& CorrectiveActionType::
    operator= (const CorrectiveActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->ActionToTake_ = x.ActionToTake_;
        this->ActionToTakeEnum_ = x.ActionToTakeEnum_;
        this->id_ = x.id_;
      }

      return *this;
    }

    CorrectiveActionType::
    ~CorrectiveActionType ()
    {
    }

    // CorrectiveActionsType
    //

    CorrectiveActionsType::
    CorrectiveActionsType ()
    : ::xml_schema::type (),
      CorrectiveAction_ (this),
      n_ (this)
    {
    }

    CorrectiveActionsType::
    CorrectiveActionsType (const n_type& n)
    : ::xml_schema::type (),
      CorrectiveAction_ (this),
      n_ (n, this)
    {
    }

    CorrectiveActionsType::
    CorrectiveActionsType (const CorrectiveActionsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CorrectiveAction_ (x.CorrectiveAction_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CorrectiveActionsType::
    CorrectiveActionsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CorrectiveAction_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CorrectiveActionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CorrectiveAction
        //
        if (n.name () == L"CorrectiveAction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveAction_type > r (
            CorrectiveAction_traits::create (i, f, this));

          this->CorrectiveAction_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CorrectiveActionsType* CorrectiveActionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CorrectiveActionsType (*this, f, c);
    }

    CorrectiveActionsType& CorrectiveActionsType::
    operator= (const CorrectiveActionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CorrectiveAction_ = x.CorrectiveAction_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CorrectiveActionsType::
    ~CorrectiveActionsType ()
    {
    }

    // StudyIssueType
    //

    StudyIssueType::
    StudyIssueType ()
    : ::xml_schema::type (),
      Traceability_ (this),
      AssignableCauseIds_ (this),
      CorrectiveActionIds_ (this),
      Resolution_ (this),
      CharacteristicMeasurementIds_ (this),
      SubgroupIds_ (this),
      id_ (this)
    {
    }

    StudyIssueType::
    StudyIssueType (const id_type& id)
    : ::xml_schema::type (),
      Traceability_ (this),
      AssignableCauseIds_ (this),
      CorrectiveActionIds_ (this),
      Resolution_ (this),
      CharacteristicMeasurementIds_ (this),
      SubgroupIds_ (this),
      id_ (id, this)
    {
    }

    StudyIssueType::
    StudyIssueType (const StudyIssueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Traceability_ (x.Traceability_, f, this),
      AssignableCauseIds_ (x.AssignableCauseIds_, f, this),
      CorrectiveActionIds_ (x.CorrectiveActionIds_, f, this),
      Resolution_ (x.Resolution_, f, this),
      CharacteristicMeasurementIds_ (x.CharacteristicMeasurementIds_, f, this),
      SubgroupIds_ (x.SubgroupIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    StudyIssueType::
    StudyIssueType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Traceability_ (this),
      AssignableCauseIds_ (this),
      CorrectiveActionIds_ (this),
      Resolution_ (this),
      CharacteristicMeasurementIds_ (this),
      SubgroupIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StudyIssueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Traceability
        //
        if (n.name () == L"Traceability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Traceability_type > r (
            Traceability_traits::create (i, f, this));

          if (!this->Traceability_)
          {
            this->Traceability_.set (::std::move (r));
            continue;
          }
        }

        // AssignableCauseIds
        //
        if (n.name () == L"AssignableCauseIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssignableCauseIds_type > r (
            AssignableCauseIds_traits::create (i, f, this));

          if (!this->AssignableCauseIds_)
          {
            this->AssignableCauseIds_.set (::std::move (r));
            continue;
          }
        }

        // CorrectiveActionIds
        //
        if (n.name () == L"CorrectiveActionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActionIds_type > r (
            CorrectiveActionIds_traits::create (i, f, this));

          if (!this->CorrectiveActionIds_)
          {
            this->CorrectiveActionIds_.set (::std::move (r));
            continue;
          }
        }

        // Resolution
        //
        if (n.name () == L"Resolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (::std::move (r));
            continue;
          }
        }

        // CharacteristicMeasurementIds
        //
        if (n.name () == L"CharacteristicMeasurementIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicMeasurementIds_type > r (
            CharacteristicMeasurementIds_traits::create (i, f, this));

          if (!this->CharacteristicMeasurementIds_)
          {
            this->CharacteristicMeasurementIds_.set (::std::move (r));
            continue;
          }
        }

        // SubgroupIds
        //
        if (n.name () == L"SubgroupIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubgroupIds_type > r (
            SubgroupIds_traits::create (i, f, this));

          if (!this->SubgroupIds_)
          {
            this->SubgroupIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    StudyIssueType* StudyIssueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StudyIssueType (*this, f, c);
    }

    StudyIssueType& StudyIssueType::
    operator= (const StudyIssueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Traceability_ = x.Traceability_;
        this->AssignableCauseIds_ = x.AssignableCauseIds_;
        this->CorrectiveActionIds_ = x.CorrectiveActionIds_;
        this->Resolution_ = x.Resolution_;
        this->CharacteristicMeasurementIds_ = x.CharacteristicMeasurementIds_;
        this->SubgroupIds_ = x.SubgroupIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    StudyIssueType::
    ~StudyIssueType ()
    {
    }

    // ControlIssueEnumType
    //

    ControlIssueEnumType::
    ControlIssueEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ControlIssueEnumType_convert ();
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ControlIssueEnumType_convert ();
    }

    ControlIssueEnumType::
    ControlIssueEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ControlIssueEnumType_convert ();
    }

    ControlIssueEnumType* ControlIssueEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlIssueEnumType (*this, f, c);
    }

    ControlIssueEnumType::value ControlIssueEnumType::
    _xsd_ControlIssueEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ControlIssueEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ControlIssueEnumType_indexes_,
                        _xsd_ControlIssueEnumType_indexes_ + 14,
                        *this,
                        c));

      if (i == _xsd_ControlIssueEnumType_indexes_ + 14 || _xsd_ControlIssueEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ControlIssueEnumType::
    _xsd_ControlIssueEnumType_literals_[14] =
    {
      L"OOT",
      L"CP",
      L"CPK",
      L"PP",
      L"PPK",
      L"OOC",
      L"TRENDING",
      L"SKEWED",
      L"ONETHIRDGROUPED",
      L"TWOTHIRDGROUPED",
      L"OSCILLATING",
      L"STRATIFIED",
      L"OOCRNG",
      L"UNDEFINED"
    };

    const ControlIssueEnumType::value ControlIssueEnumType::
    _xsd_ControlIssueEnumType_indexes_[14] =
    {
      ::xsd::qif30::ControlIssueEnumType::CP,
      ::xsd::qif30::ControlIssueEnumType::CPK,
      ::xsd::qif30::ControlIssueEnumType::ONETHIRDGROUPED,
      ::xsd::qif30::ControlIssueEnumType::OOC,
      ::xsd::qif30::ControlIssueEnumType::OOCRNG,
      ::xsd::qif30::ControlIssueEnumType::OOT,
      ::xsd::qif30::ControlIssueEnumType::OSCILLATING,
      ::xsd::qif30::ControlIssueEnumType::PP,
      ::xsd::qif30::ControlIssueEnumType::PPK,
      ::xsd::qif30::ControlIssueEnumType::SKEWED,
      ::xsd::qif30::ControlIssueEnumType::STRATIFIED,
      ::xsd::qif30::ControlIssueEnumType::TRENDING,
      ::xsd::qif30::ControlIssueEnumType::TWOTHIRDGROUPED,
      ::xsd::qif30::ControlIssueEnumType::UNDEFINED
    };

    // ControlIssueType
    //

    ControlIssueType::
    ControlIssueType ()
    : ::xml_schema::type (),
      ControlIssueEnum_ (this),
      OtherControlIssue_ (this)
    {
    }

    ControlIssueType::
    ControlIssueType (const ControlIssueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ControlIssueEnum_ (x.ControlIssueEnum_, f, this),
      OtherControlIssue_ (x.OtherControlIssue_, f, this)
    {
    }

    ControlIssueType::
    ControlIssueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ControlIssueEnum_ (this),
      OtherControlIssue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ControlIssueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ControlIssueEnum
        //
        if (n.name () == L"ControlIssueEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlIssueEnum_type > r (
            ControlIssueEnum_traits::create (i, f, this));

          if (!this->ControlIssueEnum_)
          {
            this->ControlIssueEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherControlIssue
        //
        if (n.name () == L"OtherControlIssue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherControlIssue_type > r (
            OtherControlIssue_traits::create (i, f, this));

          if (!this->OtherControlIssue_)
          {
            this->OtherControlIssue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ControlIssueType* ControlIssueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlIssueType (*this, f, c);
    }

    ControlIssueType& ControlIssueType::
    operator= (const ControlIssueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ControlIssueEnum_ = x.ControlIssueEnum_;
        this->OtherControlIssue_ = x.OtherControlIssue_;
      }

      return *this;
    }

    ControlIssueType::
    ~ControlIssueType ()
    {
    }

    // ControlIssueDetailsType
    //

    ControlIssueDetailsType::
    ControlIssueDetailsType ()
    : ::xml_schema::type (),
      ControlIssue_ (this),
      ControlMethodId_ (this),
      StudyIssueId_ (this)
    {
    }

    ControlIssueDetailsType::
    ControlIssueDetailsType (const ControlIssue_type& ControlIssue)
    : ::xml_schema::type (),
      ControlIssue_ (ControlIssue, this),
      ControlMethodId_ (this),
      StudyIssueId_ (this)
    {
    }

    ControlIssueDetailsType::
    ControlIssueDetailsType (::std::unique_ptr< ControlIssue_type > ControlIssue)
    : ::xml_schema::type (),
      ControlIssue_ (std::move (ControlIssue), this),
      ControlMethodId_ (this),
      StudyIssueId_ (this)
    {
    }

    ControlIssueDetailsType::
    ControlIssueDetailsType (const ControlIssueDetailsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ControlIssue_ (x.ControlIssue_, f, this),
      ControlMethodId_ (x.ControlMethodId_, f, this),
      StudyIssueId_ (x.StudyIssueId_, f, this)
    {
    }

    ControlIssueDetailsType::
    ControlIssueDetailsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ControlIssue_ (this),
      ControlMethodId_ (this),
      StudyIssueId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ControlIssueDetailsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ControlIssue
        //
        if (n.name () == L"ControlIssue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlIssue_type > r (
            ControlIssue_traits::create (i, f, this));

          if (!ControlIssue_.present ())
          {
            this->ControlIssue_.set (::std::move (r));
            continue;
          }
        }

        // ControlMethodId
        //
        if (n.name () == L"ControlMethodId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlMethodId_type > r (
            ControlMethodId_traits::create (i, f, this));

          if (!this->ControlMethodId_)
          {
            this->ControlMethodId_.set (::std::move (r));
            continue;
          }
        }

        // StudyIssueId
        //
        if (n.name () == L"StudyIssueId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StudyIssueId_type > r (
            StudyIssueId_traits::create (i, f, this));

          if (!this->StudyIssueId_)
          {
            this->StudyIssueId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ControlIssue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ControlIssue",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ControlIssueDetailsType* ControlIssueDetailsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlIssueDetailsType (*this, f, c);
    }

    ControlIssueDetailsType& ControlIssueDetailsType::
    operator= (const ControlIssueDetailsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ControlIssue_ = x.ControlIssue_;
        this->ControlMethodId_ = x.ControlMethodId_;
        this->StudyIssueId_ = x.StudyIssueId_;
      }

      return *this;
    }

    ControlIssueDetailsType::
    ~ControlIssueDetailsType ()
    {
    }

    // ControlIssueDetailsListType
    //

    ControlIssueDetailsListType::
    ControlIssueDetailsListType ()
    : ::xml_schema::type (),
      ControlIssueDetails_ (this),
      n_ (this)
    {
    }

    ControlIssueDetailsListType::
    ControlIssueDetailsListType (const n_type& n)
    : ::xml_schema::type (),
      ControlIssueDetails_ (this),
      n_ (n, this)
    {
    }

    ControlIssueDetailsListType::
    ControlIssueDetailsListType (const ControlIssueDetailsListType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ControlIssueDetails_ (x.ControlIssueDetails_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ControlIssueDetailsListType::
    ControlIssueDetailsListType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ControlIssueDetails_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ControlIssueDetailsListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ControlIssueDetails
        //
        if (n.name () == L"ControlIssueDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlIssueDetails_type > r (
            ControlIssueDetails_traits::create (i, f, this));

          this->ControlIssueDetails_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ControlIssueDetailsListType* ControlIssueDetailsListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlIssueDetailsListType (*this, f, c);
    }

    ControlIssueDetailsListType& ControlIssueDetailsListType::
    operator= (const ControlIssueDetailsListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ControlIssueDetails_ = x.ControlIssueDetails_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ControlIssueDetailsListType::
    ~ControlIssueDetailsListType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const LimitingNumberType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Count
      //
      if (i.Count ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Count",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Count ();
      }

      // Fraction
      //
      if (i.Fraction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Fraction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Fraction ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionDecimalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Limit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Limit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.Limit ());
      }

      // NumberAllowedExceptions
      //
      if (i.NumberAllowedExceptions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberAllowedExceptions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberAllowedExceptions ();
      }

      // ExtremeLimit
      //
      if (i.ExtremeLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExtremeLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.ExtremeLimit ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionLinearType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionAngularType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionAreaType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionForceType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionMassType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionPressureType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionSpeedType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionTemperatureType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionTimeType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionUserDefinedUnitType& i)
    {
      e << static_cast< const ::xsd::qif30::CriterionDecimalType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionIntegerType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Limit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Limit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Limit ();
      }

      // NumberAllowedExceptions
      //
      if (i.NumberAllowedExceptions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberAllowedExceptions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberAllowedExceptions ();
      }

      // ExtremeLimit
      //
      if (i.ExtremeLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExtremeLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExtremeLimit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CriterionOutOfType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Numerator
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Numerator",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Numerator ();
      }

      // Denominator
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Denominator",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Denominator ();
      }

      // NumberAllowedExceptions
      //
      if (i.NumberAllowedExceptions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberAllowedExceptions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberAllowedExceptions ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SamplingMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SampleSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleSize ();
      }

      // SamplingPeriod
      //
      if (i.SamplingPeriod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingPeriod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingPeriod ();
      }

      // SamplingFrequency
      //
      if (i.SamplingFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingFrequency ();
      }

      // SamplingInterval
      //
      if (i.SamplingInterval ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingInterval",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingInterval ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SamplingIntervalEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SamplingIntervalEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SamplingIntervalEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SamplingIntervalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SamplingIntervalEnum
      //
      if (i.SamplingIntervalEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingIntervalEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingIntervalEnum ();
      }

      // OtherSamplingInterval
      //
      if (i.OtherSamplingInterval ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherSamplingInterval",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherSamplingInterval ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ExclusionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ExclusionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionReasonType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ExclusionReasonEnum
      //
      if (i.ExclusionReasonEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExclusionReasonEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExclusionReasonEnum ();
      }

      // OtherExclusionReason
      //
      if (i.OtherExclusionReason ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherExclusionReason",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherExclusionReason ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionIdType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Id ();
      }

      // Reason
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Reason",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Reason ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionIndexType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Index
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Index",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Index ();
      }

      // Reason
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Reason",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Reason ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionsIdType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Exclusion
      //
      for (ExclusionsIdType::Exclusion_const_iterator
           b (i.Exclusion ().begin ()), n (i.Exclusion ().end ());
           b != n; ++b)
      {
        const ExclusionsIdType::Exclusion_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Exclusion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExclusionsIndexType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Exclusion
      //
      for (ExclusionsIndexType::Exclusion_const_iterator
           b (i.Exclusion ().begin ()), n (i.Exclusion ().end ());
           b != n; ++b)
      {
        const ExclusionsIndexType::Exclusion_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Exclusion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsArrayIdType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Ids
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Ids",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Ids ();
      }

      // Exclusions
      //
      if (i.Exclusions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Exclusions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Exclusions ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsValuesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Values
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Values",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Values ();
      }

      // Exclusions
      //
      if (i.Exclusions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Exclusions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Exclusions ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsEvalStatusEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const StatsEvalStatusEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const StatsEvalStatusEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsEvalStatusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatsEvalStatusEnum
      //
      if (i.StatsEvalStatusEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatsEvalStatusEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StatsEvalStatusEnum ();
      }

      // OtherStatsEvalStatus
      //
      if (i.OtherStatsEvalStatus ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherStatsEvalStatus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherStatsEvalStatus ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StudyIssuesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StudyIssue
      //
      for (StudyIssuesType::StudyIssue_const_iterator
           b (i.StudyIssue ().begin ()), n (i.StudyIssue ().end ());
           b != n; ++b)
      {
        const StudyIssuesType::StudyIssue_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StudyIssue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OneSidedCapabilityCalculationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const OneSidedCapabilityCalculationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const OneSidedCapabilityCalculationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PositionCapabilityCalculationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PositionCapabilityCalculationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PositionCapabilityCalculationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DistributionTransformationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DistributionTransformationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DistributionTransformationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DistributionTransformationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DistributionTransformationEnum
      //
      if (i.DistributionTransformationEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DistributionTransformationEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DistributionTransformationEnum ();
      }

      // BoxCoxTransformation
      //
      if (i.BoxCoxTransformation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BoxCoxTransformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.BoxCoxTransformation ());
      }

      // OtherDistributionTransformation
      //
      if (i.OtherDistributionTransformation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherDistributionTransformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherDistributionTransformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasuredIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeasuredIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Subgroup
      //
      for (SubgroupsType::Subgroup_const_iterator
           b (i.Subgroup ().begin ()), n (i.Subgroup ().end ());
           b != n; ++b)
      {
        const SubgroupsType::Subgroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Subgroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupValuesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Subgroup
      //
      for (SubgroupValuesType::Subgroup_const_iterator
           b (i.Subgroup ().begin ()), n (i.Subgroup ().end ());
           b != n; ++b)
      {
        const SubgroupValuesType::Subgroup_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Subgroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CharacteristicStatsEvalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // SoftwareId
      //
      if (i.SoftwareId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SoftwareId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SoftwareId ();
      }

      // StandardId
      //
      if (i.StandardId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardId ();
      }

      // AlgorithmId
      //
      if (i.AlgorithmId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AlgorithmId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AlgorithmId ();
      }

      // MeasuredIds
      //
      if (i.MeasuredIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuredIds ();
      }

      // Subgroups
      //
      if (i.Subgroups ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Subgroups",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Subgroups ();
      }

      // MeasuredValues
      //
      if (i.MeasuredValues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredValues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuredValues ();
      }

      // SubgroupValues
      //
      if (i.SubgroupValues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupValues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubgroupValues ();
      }

      // Status
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Status",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Status ();
      }

      // StudyIssues
      //
      if (i.StudyIssues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StudyIssues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StudyIssues ();
      }

      // DistributionTransformation
      //
      if (i.DistributionTransformation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DistributionTransformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DistributionTransformation ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsWithReferenceBaseType >
    _xsd_CommonStatsValue_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerType >
    _xsd_TotalNumber_element_serializer_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalNumber",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupIntegersType >
    _xsd_SubgroupTotalNumbers_element_serializer_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupTotalNumbers",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerType >
    _xsd_EffectiveNumber_element_serializer_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveNumber",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupIntegersType >
    _xsd_SubgroupEffectiveNumbers_element_serializer_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupEffectiveNumbers",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerType >
    _xsd_NumberSubgroups_element_serializer_init (
      L"CommonStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberSubgroups",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsWithReferenceBaseType >
    _xsd_NumericCharacteristicStatsValue_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Average_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Average",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupDecimalsType >
    _xsd_SubgroupAverages_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupAverages",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Difference_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Difference",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupDecimalsType >
    _xsd_SubgroupDifferences_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupDifferences",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RootMeanSquare_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RootMeanSquare",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >
    _xsd_Maximum_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Maximum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupDecimalsType >
    _xsd_SubgroupMaxima_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupMaxima",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >
    _xsd_Minimum_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Minimum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalWithReferenceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupDecimalsType >
    _xsd_SubgroupMinima_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupMinima",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Range_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Range",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupDecimalsType >
    _xsd_SubgroupRanges_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupRanges",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupDecimalsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_AverageRange_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"AverageRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_StandardDeviation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"StandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Skew_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Skew",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Kurtosis_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Kurtosis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Normality_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Normality",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_ProcessVariation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_EstimatedStandardDeviation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EstimatedStandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_UpperControlLimit_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperControlLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_LowerControlLimit_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerControlLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_UpperControlLimitRange_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperControlLimitRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_LowerControlLimitRange_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerControlLimitRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >
    _xsd_NumberOutOfControl_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOutOfControl",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_AppraiserVariation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"AppraiserVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_EquipmentVariation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"EquipmentVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Interaction_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Interaction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_GageRandR_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandR",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_PartVariation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"PartVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_TotalVariation_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Linearity_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Linearity",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Bias_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Bias",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeLinearity_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeLinearity",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeBias_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeBias",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_GoodnessOfFit_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"GoodnessOfFit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RegressionSlope_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RegressionSlope",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RegressionIntercept_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RegressionIntercept",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_UpperConfidenceLimit_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"UpperConfidenceLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_LowerConfidenceLimit_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"LowerConfidenceLimit",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_TDistribution_element_serializer_init (
      L"NumericCharacteristicStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"TDistribution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >
    _xsd_NumberOutOfTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOutOfTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupIntegersType >
    _xsd_SubgroupNumbersOutOfTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersOutOfTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >
    _xsd_NumberOverUpperTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberOverUpperTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupIntegersType >
    _xsd_SubgroupNumbersOverUpperTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersOverUpperTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >
    _xsd_NumberUnderLowerTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberUnderLowerTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerWithReferencesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SubgroupIntegersType >
    _xsd_SubgroupNumbersUnderLowerTolerance_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SubgroupNumbersUnderLowerTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SubgroupIntegersType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Cp_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cp",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Cpk_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cpk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Pp_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Pp",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Ppk_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Ppk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Cm_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Cmk_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cmk",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_Cpm_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"Cpm",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeAppraiserVariation_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeAppraiserVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeEquipmentVariation_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeEquipmentVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeInteraction_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeInteraction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeGageRandR_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeGageRandR",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativePartVariation_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativePartVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_RelativeTotalVariation_element_serializer_init (
      L"NumericCharacteristicWithTolStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"RelativeTotalVariation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    void
    operator<< (xercesc::DOMElement& e, const StatsBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // CommonStatsValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatsBaseType::CommonStatsValue_const_iterator
             b (i.CommonStatsValue ().begin ()), n (i.CommonStatsValue ().end ());
             b != n; ++b)
        {
          const StatsBaseType::CommonStatsValue_type& x (*b);

          if (typeid (StatsBaseType::CommonStatsValue_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CommonStatsValue",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CommonStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsNumericalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // NumericCharacteristicStatsValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatsNumericalBaseType::NumericCharacteristicStatsValue_const_iterator
             b (i.NumericCharacteristicStatsValue ().begin ()), n (i.NumericCharacteristicStatsValue ().end ());
             b != n; ++b)
        {
          const StatsNumericalBaseType::NumericCharacteristicStatsValue_type& x (*b);

          if (typeid (StatsNumericalBaseType::NumericCharacteristicStatsValue_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NumericCharacteristicStatsValue",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NumericCharacteristicStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolNumericalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // NumericCharacteristicWithTolStatsValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatsWithTolNumericalBaseType::NumericCharacteristicWithTolStatsValue_const_iterator
             b (i.NumericCharacteristicWithTolStatsValue ().begin ()), n (i.NumericCharacteristicWithTolStatsValue ().end ());
             b != n; ++b)
        {
          const StatsWithTolNumericalBaseType::NumericCharacteristicWithTolStatsValue_type& x (*b);

          if (typeid (StatsWithTolNumericalBaseType::NumericCharacteristicWithTolStatsValue_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NumericCharacteristicWithTolStatsValue",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NumericCharacteristicWithTolStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolLinearType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolAngularType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolAreaType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolForceType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolMassType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolPressureType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolSpeedType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolTemperatureType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolTimeType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithTolUserDefinedUnitType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithTolNumericalBaseType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsLinearType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsAngularType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsAreaType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsForceType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsMassType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsPressureType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsSpeedType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsTemperatureType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsTimeType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsUserDefinedUnitType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNumericalBaseType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_FailurePercentage_element_serializer_init (
      L"PassFailStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"FailurePercentage",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsNonNegativeIntegerType >
    _xsd_NumberFailures_element_serializer_init (
      L"PassFailStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"NumberFailures",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsNonNegativeIntegerType >);


    void
    operator<< (xercesc::DOMElement& e, const StatsPassFailType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsBaseType& > (i);

      // PassFailStatsValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatsPassFailType::PassFailStatsValue_const_iterator
             b (i.PassFailStatsValue ().begin ()), n (i.PassFailStatsValue ().end ());
             b != n; ++b)
        {
          const StatsPassFailType::PassFailStatsValue_type& x (*b);

          if (typeid (StatsPassFailType::PassFailStatsValue_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"PassFailStatsValue",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"PassFailStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GeometricCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GeometricCharacteristicStatsEvalType >
    _xsd_GeometricCharacteristicStatsEvalType_type_serializer_init (
      L"GeometricCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentStatsEvalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentPositionStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CompositeSegmentStatsEvalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentsPositionStatsEvalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SecondCompositeSegmentPositionStats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondCompositeSegmentPositionStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondCompositeSegmentPositionStats ();
      }

      // ThirdCompositeSegmentPositionStats
      //
      if (i.ThirdCompositeSegmentPositionStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThirdCompositeSegmentPositionStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThirdCompositeSegmentPositionStats ();
      }

      // FourthCompositeSegmentPositionStats
      //
      if (i.FourthCompositeSegmentPositionStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FourthCompositeSegmentPositionStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FourthCompositeSegmentPositionStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentProfileStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CompositeSegmentStatsEvalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentsProfileStatsEvalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SecondCompositeSegmentProfileStats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondCompositeSegmentProfileStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondCompositeSegmentProfileStats ();
      }

      // ThirdCompositeSegmentProfileStats
      //
      if (i.ThirdCompositeSegmentProfileStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThirdCompositeSegmentProfileStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThirdCompositeSegmentProfileStats ();
      }

      // FourthCompositeSegmentProfileStats
      //
      if (i.FourthCompositeSegmentProfileStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FourthCompositeSegmentProfileStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FourthCompositeSegmentProfileStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentSymmetryStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CompositeSegmentStatsEvalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CompositeSegmentsSymmetryStatsEvalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SecondCompositeSegmentSymmetryStats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondCompositeSegmentSymmetryStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondCompositeSegmentSymmetryStats ();
      }

      // ThirdCompositeSegmentSymmetryStats
      //
      if (i.ThirdCompositeSegmentSymmetryStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThirdCompositeSegmentSymmetryStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThirdCompositeSegmentSymmetryStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearCharacteristicStatsEvalType >
    _xsd_LinearCharacteristicStatsEvalType_type_serializer_init (
      L"LinearCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngularCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngularCharacteristicStatsEvalType >
    _xsd_AngularCharacteristicStatsEvalType_type_serializer_init (
      L"AngularCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedAttributeCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // AttributeStats
      //
      if (i.AttributeStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AttributeStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AttributeStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedAttributeCharacteristicStatsEvalType >
    _xsd_UserDefinedAttributeCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedAttributeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedLinearCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedLinearCharacteristicStatsEvalType >
    _xsd_UserDefinedLinearCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedLinearCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedAngularCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedAngularCharacteristicStatsEvalType >
    _xsd_UserDefinedAngularCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedAngularCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedAreaCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedAreaCharacteristicStatsEvalType >
    _xsd_UserDefinedAreaCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedAreaCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedForceCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedForceCharacteristicStatsEvalType >
    _xsd_UserDefinedForceCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedForceCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedMassCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedMassCharacteristicStatsEvalType >
    _xsd_UserDefinedMassCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedMassCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedPressureCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedPressureCharacteristicStatsEvalType >
    _xsd_UserDefinedPressureCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedPressureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedSpeedCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedSpeedCharacteristicStatsEvalType >
    _xsd_UserDefinedSpeedCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedSpeedCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedTemperatureCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedTemperatureCharacteristicStatsEvalType >
    _xsd_UserDefinedTemperatureCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedTemperatureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedTimeCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedTimeCharacteristicStatsEvalType >
    _xsd_UserDefinedTimeCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedTimeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedUnitCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ValueStats
      //
      if (i.ValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ValueStats ();
      }

      // MaxValueStats
      //
      if (i.MaxValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxValueStats ();
      }

      // MinValueStats
      //
      if (i.MinValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinValueStats ();
      }

      // DeviationStats
      //
      if (i.DeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DeviationStats ();
      }

      // MaxDeviationStats
      //
      if (i.MaxDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxDeviationStats ();
      }

      // MinDeviationStats
      //
      if (i.MinDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinDeviationStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedUnitCharacteristicStatsEvalType >
    _xsd_UserDefinedUnitCharacteristicStatsEvalType_type_serializer_init (
      L"UserDefinedUnitCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceTextureCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // RoughnessAverageValueStats
      //
      if (i.RoughnessAverageValueStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RoughnessAverageValueStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RoughnessAverageValueStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceTextureCharacteristicStatsEvalType >
    _xsd_SurfaceTextureCharacteristicStatsEvalType_type_serializer_init (
      L"SurfaceTextureCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OrientationCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }

      // DatumsOkStats
      //
      if (i.DatumsOkStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumsOkStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumsOkStats ();
      }

      // BonusStats
      //
      if (i.BonusStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BonusStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BonusStats ();
      }

      // ReferenceLengthStats
      //
      if (i.ReferenceLengthStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceLengthStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReferenceLengthStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OrientationCharacteristicStatsEvalType >
    _xsd_OrientationCharacteristicStatsEvalType_type_serializer_init (
      L"OrientationCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngularityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::OrientationCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngularityCharacteristicStatsEvalType >
    _xsd_AngularityCharacteristicStatsEvalType_type_serializer_init (
      L"AngularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PerpendicularityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::OrientationCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PerpendicularityCharacteristicStatsEvalType >
    _xsd_PerpendicularityCharacteristicStatsEvalType_type_serializer_init (
      L"PerpendicularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ParallelismCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::OrientationCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ParallelismCharacteristicStatsEvalType >
    _xsd_ParallelismCharacteristicStatsEvalType_type_serializer_init (
      L"ParallelismCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FormCharacteristicStatsEvalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);

      // MaxCircularityStats
      //
      if (i.MaxCircularityStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxCircularityStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxCircularityStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularityCharacteristicStatsEvalType >
    _xsd_CircularityCharacteristicStatsEvalType_type_serializer_init (
      L"CircularityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicityCharacteristicStatsEvalType >
    _xsd_ConicityCharacteristicStatsEvalType_type_serializer_init (
      L"ConicityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);

      // MaxCylindricityStats
      //
      if (i.MaxCylindricityStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxCylindricityStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxCylindricityStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricityCharacteristicStatsEvalType >
    _xsd_CylindricityCharacteristicStatsEvalType_type_serializer_init (
      L"CylindricityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipticityCharacteristicStatsEvalType >
    _xsd_EllipticityCharacteristicStatsEvalType_type_serializer_init (
      L"EllipticityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FlatnessCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);

      // BonusStats
      //
      if (i.BonusStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BonusStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BonusStats ();
      }

      // MaxFlatnessStats
      //
      if (i.MaxFlatnessStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFlatnessStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxFlatnessStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FlatnessCharacteristicStatsEvalType >
    _xsd_FlatnessCharacteristicStatsEvalType_type_serializer_init (
      L"FlatnessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericityCharacteristicStatsEvalType >
    _xsd_SphericityCharacteristicStatsEvalType_type_serializer_init (
      L"SphericityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const StraightnessCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);

      // BonusStats
      //
      if (i.BonusStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BonusStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BonusStats ();
      }

      // MaxStraightnessStats
      //
      if (i.MaxStraightnessStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxStraightnessStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxStraightnessStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StraightnessCharacteristicStatsEvalType >
    _xsd_StraightnessCharacteristicStatsEvalType_type_serializer_init (
      L"StraightnessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidicityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToroidicityCharacteristicStatsEvalType >
    _xsd_ToroidicityCharacteristicStatsEvalType_type_serializer_init (
      L"ToroidicityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherFormCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::FormCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherFormCharacteristicStatsEvalType >
    _xsd_OtherFormCharacteristicStatsEvalType_type_serializer_init (
      L"OtherFormCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LocationCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (i);

      // DatumsOkStats
      //
      if (i.DatumsOkStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumsOkStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumsOkStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LocationCharacteristicStatsEvalType >
    _xsd_LocationCharacteristicStatsEvalType_type_serializer_init (
      L"LocationCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PositionCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LocationCharacteristicStatsEvalType& > (i);

      // BonusStats
      //
      if (i.BonusStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BonusStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BonusStats ();
      }

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }

      // CompositeSegmentsStats
      //
      if (i.CompositeSegmentsStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompositeSegmentsStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CompositeSegmentsStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PositionCharacteristicStatsEvalType >
    _xsd_PositionCharacteristicStatsEvalType_type_serializer_init (
      L"PositionCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngularCoordinateCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::AngularCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngularCoordinateCharacteristicStatsEvalType >
    _xsd_AngularCoordinateCharacteristicStatsEvalType_type_serializer_init (
      L"AngularCoordinateCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngleCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::AngularCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngleCharacteristicStatsEvalType >
    _xsd_AngleCharacteristicStatsEvalType_type_serializer_init (
      L"AngleCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngleFromCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::AngularCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngleFromCharacteristicStatsEvalType >
    _xsd_AngleFromCharacteristicStatsEvalType_type_serializer_init (
      L"AngleFromCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngleBetweenCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::AngularCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AngleBetweenCharacteristicStatsEvalType >
    _xsd_AngleBetweenCharacteristicStatsEvalType_type_serializer_init (
      L"AngleBetweenCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LinearCoordinateCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearCoordinateCharacteristicStatsEvalType >
    _xsd_LinearCoordinateCharacteristicStatsEvalType_type_serializer_init (
      L"LinearCoordinateCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CurveLengthCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CurveLengthCharacteristicStatsEvalType >
    _xsd_CurveLengthCharacteristicStatsEvalType_type_serializer_init (
      L"CurveLengthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DiameterCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DiameterCharacteristicStatsEvalType >
    _xsd_DiameterCharacteristicStatsEvalType_type_serializer_init (
      L"DiameterCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalDiameterCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalDiameterCharacteristicStatsEvalType >
    _xsd_SphericalDiameterCharacteristicStatsEvalType_type_serializer_init (
      L"SphericalDiameterCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LengthCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LengthCharacteristicStatsEvalType >
    _xsd_LengthCharacteristicStatsEvalType_type_serializer_init (
      L"LengthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WidthCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WidthCharacteristicStatsEvalType >
    _xsd_WidthCharacteristicStatsEvalType_type_serializer_init (
      L"WidthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const HeightCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, HeightCharacteristicStatsEvalType >
    _xsd_HeightCharacteristicStatsEvalType_type_serializer_init (
      L"HeightCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DepthCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DepthCharacteristicStatsEvalType >
    _xsd_DepthCharacteristicStatsEvalType_type_serializer_init (
      L"DepthCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThicknessCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThicknessCharacteristicStatsEvalType >
    _xsd_ThicknessCharacteristicStatsEvalType_type_serializer_init (
      L"ThicknessCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SquareCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SquareCharacteristicStatsEvalType >
    _xsd_SquareCharacteristicStatsEvalType_type_serializer_init (
      L"SquareCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DistanceFromCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DistanceFromCharacteristicStatsEvalType >
    _xsd_DistanceFromCharacteristicStatsEvalType_type_serializer_init (
      L"DistanceFromCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DistanceBetweenCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DistanceBetweenCharacteristicStatsEvalType >
    _xsd_DistanceBetweenCharacteristicStatsEvalType_type_serializer_init (
      L"DistanceBetweenCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const RadiusCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RadiusCharacteristicStatsEvalType >
    _xsd_RadiusCharacteristicStatsEvalType_type_serializer_init (
      L"RadiusCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalRadiusCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalRadiusCharacteristicStatsEvalType >
    _xsd_SphericalRadiusCharacteristicStatsEvalType_type_serializer_init (
      L"SphericalRadiusCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ChordCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ChordCharacteristicStatsEvalType >
    _xsd_ChordCharacteristicStatsEvalType_type_serializer_init (
      L"ChordCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalTaperCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicalTaperCharacteristicStatsEvalType >
    _xsd_ConicalTaperCharacteristicStatsEvalType_type_serializer_init (
      L"ConicalTaperCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FlatTaperCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearCharacteristicStatsEvalType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FlatTaperCharacteristicStatsEvalType >
    _xsd_FlatTaperCharacteristicStatsEvalType_type_serializer_init (
      L"FlatTaperCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const RunoutCharacteristicStatsEvalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }

      // DatumsOkStats
      //
      if (i.DatumsOkStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumsOkStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumsOkStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularRunoutCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularRunoutCharacteristicStatsEvalType >
    _xsd_CircularRunoutCharacteristicStatsEvalType_type_serializer_init (
      L"CircularRunoutCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TotalRunoutCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TotalRunoutCharacteristicStatsEvalType >
    _xsd_TotalRunoutCharacteristicStatsEvalType_type_serializer_init (
      L"TotalRunoutCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CoaxialityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LocationCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CoaxialityCharacteristicStatsEvalType >
    _xsd_CoaxialityCharacteristicStatsEvalType_type_serializer_init (
      L"CoaxialityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConcentricityCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LocationCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConcentricityCharacteristicStatsEvalType >
    _xsd_ConcentricityCharacteristicStatsEvalType_type_serializer_init (
      L"ConcentricityCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SymmetryCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::LocationCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }

      // CompositeSegmentsStats
      //
      if (i.CompositeSegmentsStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompositeSegmentsStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CompositeSegmentsStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SymmetryCharacteristicStatsEvalType >
    _xsd_SymmetryCharacteristicStatsEvalType_type_serializer_init (
      L"SymmetryCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDeviationStatsEvalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasuredPointIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredPointIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeasuredPointIds ();
      }

      // DeviationStats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeviationStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDeviationsStatsEvalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointDeviationStats
      //
      for (PointDeviationsStatsEvalType::PointDeviationStats_const_iterator
           b (i.PointDeviationStats ().begin ()), n (i.PointDeviationStats ().end ());
           b != n; ++b)
      {
        const PointDeviationsStatsEvalType::PointDeviationStats_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ProfileCharacteristicStatsEvalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometricCharacteristicStatsEvalType& > (i);

      // CapabilityCalculationMethod
      //
      if (i.CapabilityCalculationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CapabilityCalculationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CapabilityCalculationMethod ();
      }

      // WorstPositiveDeviationStats
      //
      if (i.WorstPositiveDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorstPositiveDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorstPositiveDeviationStats ();
      }

      // WorstNegativeDeviationStats
      //
      if (i.WorstNegativeDeviationStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorstNegativeDeviationStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorstNegativeDeviationStats ();
      }

      // PointDeviationsStats
      //
      if (i.PointDeviationsStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointDeviationsStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointDeviationsStats ();
      }

      // DatumsOkStats
      //
      if (i.DatumsOkStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumsOkStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumsOkStats ();
      }

      // CompositeSegmentsStats
      //
      if (i.CompositeSegmentsStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CompositeSegmentsStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CompositeSegmentsStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineProfileCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LineProfileCharacteristicStatsEvalType >
    _xsd_LineProfileCharacteristicStatsEvalType_type_serializer_init (
      L"LineProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointProfileCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointProfileCharacteristicStatsEvalType >
    _xsd_PointProfileCharacteristicStatsEvalType_type_serializer_init (
      L"PointProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceProfileCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceProfileCharacteristicStatsEvalType >
    _xsd_SurfaceProfileCharacteristicStatsEvalType_type_serializer_init (
      L"SurfaceProfileCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceProfileNonUniformCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceProfileNonUniformCharacteristicStatsEvalType >
    _xsd_SurfaceProfileNonUniformCharacteristicStatsEvalType_type_serializer_init (
      L"SurfaceProfileNonUniformCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThreadCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // ThreadStats
      //
      if (i.ThreadStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThreadStats ();
      }

      // PitchDiameterStats
      //
      if (i.PitchDiameterStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PitchDiameterStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PitchDiameterStats ();
      }

      // FunctionalSizeStats
      //
      if (i.FunctionalSizeStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FunctionalSizeStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FunctionalSizeStats ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThreadCharacteristicStatsEvalType >
    _xsd_ThreadCharacteristicStatsEvalType_type_serializer_init (
      L"ThreadCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldCharacteristicStatsEvalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::CharacteristicStatsEvalBaseType& > (i);

      // WeldStats
      //
      if (i.WeldStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WeldStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WeldStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WeldFilletCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldFilletCharacteristicStatsEvalType >
    _xsd_WeldFilletCharacteristicStatsEvalType_type_serializer_init (
      L"WeldFilletCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldPlugCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldPlugCharacteristicStatsEvalType >
    _xsd_WeldPlugCharacteristicStatsEvalType_type_serializer_init (
      L"WeldPlugCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldSlotCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldSlotCharacteristicStatsEvalType >
    _xsd_WeldSlotCharacteristicStatsEvalType_type_serializer_init (
      L"WeldSlotCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldSpotCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldSpotCharacteristicStatsEvalType >
    _xsd_WeldSpotCharacteristicStatsEvalType_type_serializer_init (
      L"WeldSpotCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldStudCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldStudCharacteristicStatsEvalType >
    _xsd_WeldStudCharacteristicStatsEvalType_type_serializer_init (
      L"WeldStudCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldSeamCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldSeamCharacteristicStatsEvalType >
    _xsd_WeldSeamCharacteristicStatsEvalType_type_serializer_init (
      L"WeldSeamCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldSurfacingCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldSurfacingCharacteristicStatsEvalType >
    _xsd_WeldSurfacingCharacteristicStatsEvalType_type_serializer_init (
      L"WeldSurfacingCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldEdgeCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldEdgeCharacteristicStatsEvalType >
    _xsd_WeldEdgeCharacteristicStatsEvalType_type_serializer_init (
      L"WeldEdgeCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldSquareCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldSquareCharacteristicStatsEvalType >
    _xsd_WeldSquareCharacteristicStatsEvalType_type_serializer_init (
      L"WeldSquareCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldBevelCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldBevelCharacteristicStatsEvalType >
    _xsd_WeldBevelCharacteristicStatsEvalType_type_serializer_init (
      L"WeldBevelCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldVCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldVCharacteristicStatsEvalType >
    _xsd_WeldVCharacteristicStatsEvalType_type_serializer_init (
      L"WeldVCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldUCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldUCharacteristicStatsEvalType >
    _xsd_WeldUCharacteristicStatsEvalType_type_serializer_init (
      L"WeldUCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldJCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldJCharacteristicStatsEvalType >
    _xsd_WeldJCharacteristicStatsEvalType_type_serializer_init (
      L"WeldJCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldFlareVCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldFlareVCharacteristicStatsEvalType >
    _xsd_WeldFlareVCharacteristicStatsEvalType_type_serializer_init (
      L"WeldFlareVCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldFlareBevelCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldFlareBevelCharacteristicStatsEvalType >
    _xsd_WeldFlareBevelCharacteristicStatsEvalType_type_serializer_init (
      L"WeldFlareBevelCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldScarfCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldScarfCharacteristicStatsEvalType >
    _xsd_WeldScarfCharacteristicStatsEvalType_type_serializer_init (
      L"WeldScarfCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WeldCompoundCharacteristicStatsEvalType& i)
    {
      e << static_cast< const ::xsd::qif30::WeldCharacteristicStatsEvalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WeldCompoundCharacteristicStatsEvalType >
    _xsd_WeldCompoundCharacteristicStatsEvalType_type_serializer_init (
      L"WeldCompoundCharacteristicStatsEvalType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngleBetweenCharacteristicStatsEvalType >
    _xsd_AngleBetweenCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleBetweenCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngleBetweenCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngleCharacteristicStatsEvalType >
    _xsd_AngleCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngleCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngularCoordinateCharacteristicStatsEvalType >
    _xsd_AngularCoordinateCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularCoordinateCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngularCoordinateCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngleFromCharacteristicStatsEvalType >
    _xsd_AngleFromCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngleFromCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngleFromCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngularCharacteristicStatsEvalType >
    _xsd_AngularCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngularCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AngularityCharacteristicStatsEvalType >
    _xsd_AngularityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"AngularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AngularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ChordCharacteristicStatsEvalType >
    _xsd_ChordCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ChordCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ChordCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularityCharacteristicStatsEvalType >
    _xsd_CircularityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularRunoutCharacteristicStatsEvalType >
    _xsd_CircularRunoutCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularRunoutCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularRunoutCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CoaxialityCharacteristicStatsEvalType >
    _xsd_CoaxialityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CoaxialityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CoaxialityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConcentricityCharacteristicStatsEvalType >
    _xsd_ConcentricityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConcentricityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConcentricityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicalTaperCharacteristicStatsEvalType >
    _xsd_ConicalTaperCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalTaperCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicalTaperCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicityCharacteristicStatsEvalType >
    _xsd_ConicityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CurveLengthCharacteristicStatsEvalType >
    _xsd_CurveLengthCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CurveLengthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CurveLengthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricityCharacteristicStatsEvalType >
    _xsd_CylindricityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DepthCharacteristicStatsEvalType >
    _xsd_DepthCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DepthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DepthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DiameterCharacteristicStatsEvalType >
    _xsd_DiameterCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DiameterCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DiameterCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DistanceBetweenCharacteristicStatsEvalType >
    _xsd_DistanceBetweenCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DistanceBetweenCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DistanceBetweenCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DistanceFromCharacteristicStatsEvalType >
    _xsd_DistanceFromCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"DistanceFromCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DistanceFromCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipticityCharacteristicStatsEvalType >
    _xsd_EllipticityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipticityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FlatnessCharacteristicStatsEvalType >
    _xsd_FlatnessCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"FlatnessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FlatnessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FlatTaperCharacteristicStatsEvalType >
    _xsd_FlatTaperCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"FlatTaperCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FlatTaperCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GeometricCharacteristicStatsEvalType >
    _xsd_GeometricCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"GeometricCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GeometricCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::HeightCharacteristicStatsEvalType >
    _xsd_HeightCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"HeightCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::HeightCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LengthCharacteristicStatsEvalType >
    _xsd_LengthCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LengthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LengthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearCharacteristicStatsEvalType >
    _xsd_LinearCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearCoordinateCharacteristicStatsEvalType >
    _xsd_LinearCoordinateCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearCoordinateCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearCoordinateCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LocationCharacteristicStatsEvalType >
    _xsd_LocationCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LocationCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LocationCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LineProfileCharacteristicStatsEvalType >
    _xsd_LineProfileCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"LineProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LineProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherFormCharacteristicStatsEvalType >
    _xsd_OtherFormCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherFormCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherFormCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OrientationCharacteristicStatsEvalType >
    _xsd_OrientationCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"OrientationCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OrientationCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ParallelismCharacteristicStatsEvalType >
    _xsd_ParallelismCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelismCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ParallelismCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PerpendicularityCharacteristicStatsEvalType >
    _xsd_PerpendicularityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PerpendicularityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PerpendicularityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointProfileCharacteristicStatsEvalType >
    _xsd_PointProfileCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PointProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PositionCharacteristicStatsEvalType >
    _xsd_PositionCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"PositionCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PositionCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::RadiusCharacteristicStatsEvalType >
    _xsd_RadiusCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"RadiusCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::RadiusCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalDiameterCharacteristicStatsEvalType >
    _xsd_SphericalDiameterCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalDiameterCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalDiameterCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalRadiusCharacteristicStatsEvalType >
    _xsd_SphericalRadiusCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalRadiusCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalRadiusCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericityCharacteristicStatsEvalType >
    _xsd_SphericityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SquareCharacteristicStatsEvalType >
    _xsd_SquareCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SquareCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SquareCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StraightnessCharacteristicStatsEvalType >
    _xsd_StraightnessCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"StraightnessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StraightnessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceProfileCharacteristicStatsEvalType >
    _xsd_SurfaceProfileCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceProfileCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceProfileCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceProfileNonUniformCharacteristicStatsEvalType >
    _xsd_SurfaceProfileNonUniformCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceProfileNonUniformCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceProfileNonUniformCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceTextureCharacteristicStatsEvalType >
    _xsd_SurfaceTextureCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceTextureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceTextureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SymmetryCharacteristicStatsEvalType >
    _xsd_SymmetryCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"SymmetryCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SymmetryCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThicknessCharacteristicStatsEvalType >
    _xsd_ThicknessCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ThicknessCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThicknessCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThreadCharacteristicStatsEvalType >
    _xsd_ThreadCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThreadCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToroidicityCharacteristicStatsEvalType >
    _xsd_ToroidicityCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidicityCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToroidicityCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TotalRunoutCharacteristicStatsEvalType >
    _xsd_TotalRunoutCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"TotalRunoutCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TotalRunoutCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedAttributeCharacteristicStatsEvalType >
    _xsd_UserDefinedAttributeCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAttributeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedAttributeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedLinearCharacteristicStatsEvalType >
    _xsd_UserDefinedLinearCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedLinearCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedLinearCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedAngularCharacteristicStatsEvalType >
    _xsd_UserDefinedAngularCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAngularCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedAngularCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedAreaCharacteristicStatsEvalType >
    _xsd_UserDefinedAreaCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedAreaCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedAreaCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedForceCharacteristicStatsEvalType >
    _xsd_UserDefinedForceCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedForceCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedForceCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedMassCharacteristicStatsEvalType >
    _xsd_UserDefinedMassCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedMassCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedMassCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedPressureCharacteristicStatsEvalType >
    _xsd_UserDefinedPressureCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedPressureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedPressureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedSpeedCharacteristicStatsEvalType >
    _xsd_UserDefinedSpeedCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedSpeedCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedSpeedCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedTemperatureCharacteristicStatsEvalType >
    _xsd_UserDefinedTemperatureCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedTemperatureCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedTemperatureCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedTimeCharacteristicStatsEvalType >
    _xsd_UserDefinedTimeCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedTimeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedTimeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedUnitCharacteristicStatsEvalType >
    _xsd_UserDefinedUnitCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedUnitCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedUnitCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WidthCharacteristicStatsEvalType >
    _xsd_WidthCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WidthCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WidthCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldFilletCharacteristicStatsEvalType >
    _xsd_WeldFilletCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFilletCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldFilletCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldPlugCharacteristicStatsEvalType >
    _xsd_WeldPlugCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldPlugCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldPlugCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldSlotCharacteristicStatsEvalType >
    _xsd_WeldSlotCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSlotCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldSlotCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldSpotCharacteristicStatsEvalType >
    _xsd_WeldSpotCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSpotCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldSpotCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldStudCharacteristicStatsEvalType >
    _xsd_WeldStudCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldStudCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldStudCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldSeamCharacteristicStatsEvalType >
    _xsd_WeldSeamCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSeamCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldSeamCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldSurfacingCharacteristicStatsEvalType >
    _xsd_WeldSurfacingCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSurfacingCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldSurfacingCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldEdgeCharacteristicStatsEvalType >
    _xsd_WeldEdgeCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldEdgeCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldEdgeCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldSquareCharacteristicStatsEvalType >
    _xsd_WeldSquareCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldSquareCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldSquareCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldBevelCharacteristicStatsEvalType >
    _xsd_WeldBevelCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldBevelCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldBevelCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldVCharacteristicStatsEvalType >
    _xsd_WeldVCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldVCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldVCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldUCharacteristicStatsEvalType >
    _xsd_WeldUCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldUCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldUCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldJCharacteristicStatsEvalType >
    _xsd_WeldJCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldJCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldJCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldFlareVCharacteristicStatsEvalType >
    _xsd_WeldFlareVCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFlareVCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldFlareVCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldFlareBevelCharacteristicStatsEvalType >
    _xsd_WeldFlareBevelCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldFlareBevelCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldFlareBevelCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldScarfCharacteristicStatsEvalType >
    _xsd_WeldScarfCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldScarfCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldScarfCharacteristicStatsEvalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WeldCompoundCharacteristicStatsEvalType >
    _xsd_WeldCompoundCharacteristicStats_element_serializer_init (
      L"CharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      L"WeldCompoundCharacteristicStats",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WeldCompoundCharacteristicStatsEvalType >);


    void
    operator<< (xercesc::DOMElement& e, const CharacteristicsStatsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CharacteristicStats
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (CharacteristicsStatsType::CharacteristicStats_const_iterator
             b (i.CharacteristicStats ().begin ()), n (i.CharacteristicStats ().end ());
             b != n; ++b)
        {
          const CharacteristicsStatsType::CharacteristicStats_type& x (*b);

          if (typeid (CharacteristicsStatsType::CharacteristicStats_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CharacteristicStats",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CharacteristicStats",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AverageFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureMeasurement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const AverageFeatureType::FeatureMeasurement_type& x (i.FeatureMeasurement ());
        if (typeid (AverageFeatureType::FeatureMeasurement_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"FeatureMeasurement",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"FeatureMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // MeasuredIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeasuredIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AverageFeaturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AverageFeature
      //
      for (AverageFeaturesType::AverageFeature_const_iterator
           b (i.AverageFeature ().begin ()), n (i.AverageFeature ().end ());
           b != n; ++b)
      {
        const AverageFeaturesType::AverageFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AverageFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_SummaryAverage_element_serializer_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryAverage",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_SummaryMaximum_element_serializer_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryMaximum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_SummaryMinimum_element_serializer_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryMinimum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_SummaryRange_element_serializer_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryRange",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StatsMeasuredDecimalType >
    _xsd_SummaryStandardDeviation_element_serializer_init (
      L"SummaryStatsValue",
      L"http://qifstandards.org/xsd/qif3",
      L"SummaryStandardDeviation",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StatsMeasuredDecimalType >);


    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // TypeOfSummary
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TypeOfSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TypeOfSummary ();
      }

      // SummaryStatsValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SummaryStatisticsType::SummaryStatsValue_const_iterator
             b (i.SummaryStatsValue ().begin ()), n (i.SummaryStatsValue ().end ());
             b != n; ++b)
        {
          const SummaryStatisticsType::SummaryStatsValue_type& x (*b);

          if (typeid (SummaryStatisticsType::SummaryStatsValue_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SummaryStatsValue",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"SummaryStatsValue",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatsSummary
      //
      for (SummariesStatisticsType::StatsSummary_const_iterator
           b (i.StatsSummary ().begin ()), n (i.StatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsType::StatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsLinearType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsLinearType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearStatsSummary
      //
      for (SummariesStatisticsLinearType::LinearStatsSummary_const_iterator
           b (i.LinearStatsSummary ().begin ()), n (i.LinearStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsLinearType::LinearStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsAngularType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsAngularType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AngularStatsSummary
      //
      for (SummariesStatisticsAngularType::AngularStatsSummary_const_iterator
           b (i.AngularStatsSummary ().begin ()), n (i.AngularStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsAngularType::AngularStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsAreaType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaStatsSummary
      //
      for (SummariesStatisticsAreaType::AreaStatsSummary_const_iterator
           b (i.AreaStatsSummary ().begin ()), n (i.AreaStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsAreaType::AreaStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsForceType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsForceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ForceStatsSummary
      //
      for (SummariesStatisticsForceType::ForceStatsSummary_const_iterator
           b (i.ForceStatsSummary ().begin ()), n (i.ForceStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsForceType::ForceStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsMassType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsMassType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MassStatsSummary
      //
      for (SummariesStatisticsMassType::MassStatsSummary_const_iterator
           b (i.MassStatsSummary ().begin ()), n (i.MassStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsMassType::MassStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsPressureType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsPressureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PressureStatsSummary
      //
      for (SummariesStatisticsPressureType::PressureStatsSummary_const_iterator
           b (i.PressureStatsSummary ().begin ()), n (i.PressureStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsPressureType::PressureStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsSpeedType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsSpeedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SpeedStatsSummary
      //
      for (SummariesStatisticsSpeedType::SpeedStatsSummary_const_iterator
           b (i.SpeedStatsSummary ().begin ()), n (i.SpeedStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsSpeedType::SpeedStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsTemperatureType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsTemperatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TemperatureStatsSummary
      //
      for (SummariesStatisticsTemperatureType::TemperatureStatsSummary_const_iterator
           b (i.TemperatureStatsSummary ().begin ()), n (i.TemperatureStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsTemperatureType::TemperatureStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsTimeType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsTimeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TimeStatsSummary
      //
      for (SummariesStatisticsTimeType::TimeStatsSummary_const_iterator
           b (i.TimeStatsSummary ().begin ()), n (i.TimeStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsTimeType::TimeStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatisticsUserDefinedUnitType& i)
    {
      e << static_cast< const ::xsd::qif30::SummaryStatisticsType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummariesStatisticsUserDefinedUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // UserDefinedUnitStatsSummary
      //
      for (SummariesStatisticsUserDefinedUnitType::UserDefinedUnitStatsSummary_const_iterator
           b (i.UserDefinedUnitStatsSummary ().begin ()), n (i.UserDefinedUnitStatsSummary ().end ());
           b != n; ++b)
      {
        const SummariesStatisticsUserDefinedUnitType::UserDefinedUnitStatsSummary_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitStatsSummary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AssignableCauseEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AssignableCauseEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AssignableCauseEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const AssignableCauseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // AssignableCauseEnum
      //
      if (i.AssignableCauseEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssignableCauseEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AssignableCauseEnum ();
      }

      // CorrectiveActionIds
      //
      if (i.CorrectiveActionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CorrectiveActionIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AssignableCausesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AssignableCause
      //
      for (AssignableCausesType::AssignableCause_const_iterator
           b (i.AssignableCause ().begin ()), n (i.AssignableCause ().end ());
           b != n; ++b)
      {
        const AssignableCausesType::AssignableCause_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssignableCause",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ActionToTakeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ActionToTakeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ActionToTakeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CorrectiveActionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // ActionToTake
      //
      if (i.ActionToTake ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActionToTake",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActionToTake ();
      }

      // ActionToTakeEnum
      //
      if (i.ActionToTakeEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActionToTakeEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActionToTakeEnum ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CorrectiveActionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CorrectiveAction
      //
      for (CorrectiveActionsType::CorrectiveAction_const_iterator
           b (i.CorrectiveAction ().begin ()), n (i.CorrectiveAction ().end ());
           b != n; ++b)
      {
        const CorrectiveActionsType::CorrectiveAction_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveAction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StudyIssueType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Traceability
      //
      if (i.Traceability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Traceability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Traceability ();
      }

      // AssignableCauseIds
      //
      if (i.AssignableCauseIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssignableCauseIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AssignableCauseIds ();
      }

      // CorrectiveActionIds
      //
      if (i.CorrectiveActionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CorrectiveActionIds ();
      }

      // Resolution
      //
      if (i.Resolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Resolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Resolution ();
      }

      // CharacteristicMeasurementIds
      //
      if (i.CharacteristicMeasurementIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicMeasurementIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicMeasurementIds ();
      }

      // SubgroupIds
      //
      if (i.SubgroupIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubgroupIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ControlIssueEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ControlIssueEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ControlIssueEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ControlIssueType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ControlIssueEnum
      //
      if (i.ControlIssueEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlIssueEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ControlIssueEnum ();
      }

      // OtherControlIssue
      //
      if (i.OtherControlIssue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherControlIssue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherControlIssue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ControlIssueDetailsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ControlIssue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlIssue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ControlIssue ();
      }

      // ControlMethodId
      //
      if (i.ControlMethodId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlMethodId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ControlMethodId ();
      }

      // StudyIssueId
      //
      if (i.StudyIssueId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StudyIssueId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StudyIssueId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ControlIssueDetailsListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ControlIssueDetails
      //
      for (ControlIssueDetailsListType::ControlIssueDetails_const_iterator
           b (i.ControlIssueDetails ().begin ()), n (i.ControlIssueDetails ().end ());
           b != n; ++b)
      {
        const ControlIssueDetailsListType::ControlIssueDetails_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlIssueDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

