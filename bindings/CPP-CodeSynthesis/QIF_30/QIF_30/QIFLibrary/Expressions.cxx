// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Expressions.hxx"

namespace xsd
{
  namespace qif30
  {
    // SamplingCategoryIsType
    //

    const SamplingCategoryIsType::val_type& SamplingCategoryIsType::
    val () const
    {
      return this->val_.get ();
    }

    SamplingCategoryIsType::val_type& SamplingCategoryIsType::
    val ()
    {
      return this->val_.get ();
    }

    void SamplingCategoryIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }


    // FeatureIsDatumType
    //


    // FeatureIsInternalType
    //


    // CharacteristicIsType
    //

    const CharacteristicIsType::val_type& CharacteristicIsType::
    val () const
    {
      return this->val_.get ();
    }

    CharacteristicIsType::val_type& CharacteristicIsType::
    val ()
    {
      return this->val_.get ();
    }

    void CharacteristicIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void CharacteristicIsType::
    val (::std::unique_ptr< val_type > x)
    {
      this->val_.set (std::move (x));
    }


    // FeatureTypeIsType
    //

    const FeatureTypeIsType::val_type& FeatureTypeIsType::
    val () const
    {
      return this->val_.get ();
    }

    FeatureTypeIsType::val_type& FeatureTypeIsType::
    val ()
    {
      return this->val_.get ();
    }

    void FeatureTypeIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void FeatureTypeIsType::
    val (::std::unique_ptr< val_type > x)
    {
      this->val_.set (std::move (x));
    }


    // ShapeClassIsType
    //

    const ShapeClassIsType::val_type& ShapeClassIsType::
    val () const
    {
      return this->val_.get ();
    }

    ShapeClassIsType::val_type& ShapeClassIsType::
    val ()
    {
      return this->val_.get ();
    }

    void ShapeClassIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void ShapeClassIsType::
    val (::std::unique_ptr< val_type > x)
    {
      this->val_.set (std::move (x));
    }


    // PointSamplingStrategyEnumBaseType
    //

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType ()
    : ::xml_schema::nmtoken ()
    {
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (value v)
    : ::xml_schema::nmtoken (_xsd_PointSamplingStrategyEnumBaseType_literals_[v])
    {
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const PointSamplingStrategyEnumBaseType& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    PointSamplingStrategyEnumBaseType& PointSamplingStrategyEnumBaseType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_PointSamplingStrategyEnumBaseType_literals_[v]);

      return *this;
    }


    // PointPointSamplingStrategyEnumType
    //

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const PointPointSamplingStrategyEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    PointPointSamplingStrategyEnumType& PointPointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // OpenCurvePointSamplingStrategyEnumType
    //

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const OpenCurvePointSamplingStrategyEnumType& v,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    OpenCurvePointSamplingStrategyEnumType& OpenCurvePointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // ClosedCurvePointSamplingStrategyEnumType
    //

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ClosedCurvePointSamplingStrategyEnumType_literals_[v])
    {
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const ClosedCurvePointSamplingStrategyEnumType& v,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ClosedCurvePointSamplingStrategyEnumType& ClosedCurvePointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ClosedCurvePointSamplingStrategyEnumType_literals_[v]);

      return *this;
    }


    // PointDefinedPointSamplingStrategyEnumType
    //

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_PointDefinedPointSamplingStrategyEnumType_literals_[v])
    {
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const PointDefinedPointSamplingStrategyEnumType& v,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    PointDefinedPointSamplingStrategyEnumType& PointDefinedPointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_PointDefinedPointSamplingStrategyEnumType_literals_[v]);

      return *this;
    }


    // ConePointSamplingStrategyEnumType
    //

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const ConePointSamplingStrategyEnumType& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    ConePointSamplingStrategyEnumType& ConePointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // ElongatedCylinderPointSamplingStrategyEnumType
    //

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const ElongatedCylinderPointSamplingStrategyEnumType& v,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    ElongatedCylinderPointSamplingStrategyEnumType& ElongatedCylinderPointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // ExtrudedCrossSectionPointSamplingStrategyEnumType
    //

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const ExtrudedCrossSectionPointSamplingStrategyEnumType& v,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType& ExtrudedCrossSectionPointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // SpherePointSamplingStrategyEnumType
    //

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const SpherePointSamplingStrategyEnumType& v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    SpherePointSamplingStrategyEnumType& SpherePointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // SurfaceOfRevolutionPointSamplingStrategyEnumType
    //

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const SurfaceOfRevolutionPointSamplingStrategyEnumType& v,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType& SurfaceOfRevolutionPointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // PlanePointSamplingStrategyEnumType
    //

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType ()
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType ()
    {
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (value v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const wchar_t* v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const ::std::wstring& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v)
    {
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const PlanePointSamplingStrategyEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (v, f, c)
    {
    }

    PlanePointSamplingStrategyEnumType& PlanePointSamplingStrategyEnumType::
    operator= (value v)
    {
      static_cast< ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (*this) = v;

      return *this;
    }


    // CharacteristicTypeEnumType
    //

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CharacteristicTypeEnumType_literals_[v])
    {
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const CharacteristicTypeEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CharacteristicTypeEnumType& CharacteristicTypeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CharacteristicTypeEnumType_literals_[v]);

      return *this;
    }


    // FeatureTypeEnumType
    //

    FeatureTypeEnumType::
    FeatureTypeEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_FeatureTypeEnumType_literals_[v])
    {
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const FeatureTypeEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    FeatureTypeEnumType& FeatureTypeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_FeatureTypeEnumType_literals_[v]);

      return *this;
    }


    // DMEClassNameEnumType
    //

    DMEClassNameEnumType::
    DMEClassNameEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DMEClassNameEnumType_literals_[v])
    {
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const DMEClassNameEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DMEClassNameEnumType& DMEClassNameEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DMEClassNameEnumType_literals_[v]);

      return *this;
    }


    // ArithmeticComparisonEnumType
    //

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ArithmeticComparisonEnumType_literals_[v])
    {
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const ArithmeticComparisonEnumType& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ArithmeticComparisonEnumType& ArithmeticComparisonEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ArithmeticComparisonEnumType_literals_[v]);

      return *this;
    }


    // ArithmeticParameterBaseType
    //

    const ArithmeticParameterBaseType::Parameter_type& ArithmeticParameterBaseType::
    Parameter () const
    {
      return this->Parameter_.get ();
    }

    ArithmeticParameterBaseType::Parameter_type& ArithmeticParameterBaseType::
    Parameter ()
    {
      return this->Parameter_.get ();
    }

    void ArithmeticParameterBaseType::
    Parameter (const Parameter_type& x)
    {
      this->Parameter_.set (x);
    }

    void ArithmeticParameterBaseType::
    Parameter (::std::unique_ptr< Parameter_type > x)
    {
      this->Parameter_.set (std::move (x));
    }


    // ArithmeticFeatureParameterType
    //

    const ArithmeticFeatureParameterType::FeatureTypeEnum_optional& ArithmeticFeatureParameterType::
    FeatureTypeEnum () const
    {
      return this->FeatureTypeEnum_;
    }

    ArithmeticFeatureParameterType::FeatureTypeEnum_optional& ArithmeticFeatureParameterType::
    FeatureTypeEnum ()
    {
      return this->FeatureTypeEnum_;
    }

    void ArithmeticFeatureParameterType::
    FeatureTypeEnum (const FeatureTypeEnum_type& x)
    {
      this->FeatureTypeEnum_.set (x);
    }

    void ArithmeticFeatureParameterType::
    FeatureTypeEnum (const FeatureTypeEnum_optional& x)
    {
      this->FeatureTypeEnum_ = x;
    }

    void ArithmeticFeatureParameterType::
    FeatureTypeEnum (::std::unique_ptr< FeatureTypeEnum_type > x)
    {
      this->FeatureTypeEnum_.set (std::move (x));
    }


    // ArithmeticCharacteristicParameterType
    //

    const ArithmeticCharacteristicParameterType::CharacteristicTypeEnum_optional& ArithmeticCharacteristicParameterType::
    CharacteristicTypeEnum () const
    {
      return this->CharacteristicTypeEnum_;
    }

    ArithmeticCharacteristicParameterType::CharacteristicTypeEnum_optional& ArithmeticCharacteristicParameterType::
    CharacteristicTypeEnum ()
    {
      return this->CharacteristicTypeEnum_;
    }

    void ArithmeticCharacteristicParameterType::
    CharacteristicTypeEnum (const CharacteristicTypeEnum_type& x)
    {
      this->CharacteristicTypeEnum_.set (x);
    }

    void ArithmeticCharacteristicParameterType::
    CharacteristicTypeEnum (const CharacteristicTypeEnum_optional& x)
    {
      this->CharacteristicTypeEnum_ = x;
    }

    void ArithmeticCharacteristicParameterType::
    CharacteristicTypeEnum (::std::unique_ptr< CharacteristicTypeEnum_type > x)
    {
      this->CharacteristicTypeEnum_.set (std::move (x));
    }


    // ArithmeticDMEParameterType
    //

    const ArithmeticDMEParameterType::DMEClassNameEnum_type& ArithmeticDMEParameterType::
    DMEClassNameEnum () const
    {
      return this->DMEClassNameEnum_.get ();
    }

    ArithmeticDMEParameterType::DMEClassNameEnum_type& ArithmeticDMEParameterType::
    DMEClassNameEnum ()
    {
      return this->DMEClassNameEnum_.get ();
    }

    void ArithmeticDMEParameterType::
    DMEClassNameEnum (const DMEClassNameEnum_type& x)
    {
      this->DMEClassNameEnum_.set (x);
    }

    void ArithmeticDMEParameterType::
    DMEClassNameEnum (::std::unique_ptr< DMEClassNameEnum_type > x)
    {
      this->DMEClassNameEnum_.set (std::move (x));
    }


    // ArithmeticPartParameterType
    //


    // CharacteristicToleranceType
    //


    // FeatureLengthType
    //


    // FeatureAreaType
    //


    // FeatureSizeType
    //
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // SamplingCategoryIsType
    //

    SamplingCategoryIsType::
    SamplingCategoryIsType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (this)
    {
    }

    SamplingCategoryIsType::
    SamplingCategoryIsType (const val_type& val)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    SamplingCategoryIsType::
    SamplingCategoryIsType (const SamplingCategoryIsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    SamplingCategoryIsType::
    SamplingCategoryIsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SamplingCategoryIsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    SamplingCategoryIsType* SamplingCategoryIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SamplingCategoryIsType (*this, f, c);
    }

    SamplingCategoryIsType& SamplingCategoryIsType::
    operator= (const SamplingCategoryIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    SamplingCategoryIsType::
    ~SamplingCategoryIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SamplingCategoryIsType >
    _xsd_SamplingCategoryIsType_type_factory_init (
      L"SamplingCategoryIsType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureIsDatumType
    //

    FeatureIsDatumType::
    FeatureIsDatumType ()
    : ::xsd::qif30::BooleanExpressionBaseType ()
    {
    }

    FeatureIsDatumType::
    FeatureIsDatumType (const FeatureIsDatumType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c)
    {
    }

    FeatureIsDatumType::
    FeatureIsDatumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f, c)
    {
    }

    FeatureIsDatumType::
    FeatureIsDatumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (a, f, c)
    {
    }

    FeatureIsDatumType::
    FeatureIsDatumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (s, e, f, c)
    {
    }

    FeatureIsDatumType* FeatureIsDatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureIsDatumType (*this, f, c);
    }

    FeatureIsDatumType::
    ~FeatureIsDatumType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureIsDatumType >
    _xsd_FeatureIsDatumType_type_factory_init (
      L"FeatureIsDatumType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureIsInternalType
    //

    FeatureIsInternalType::
    FeatureIsInternalType ()
    : ::xsd::qif30::BooleanExpressionBaseType ()
    {
    }

    FeatureIsInternalType::
    FeatureIsInternalType (const FeatureIsInternalType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c)
    {
    }

    FeatureIsInternalType::
    FeatureIsInternalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f, c)
    {
    }

    FeatureIsInternalType::
    FeatureIsInternalType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (a, f, c)
    {
    }

    FeatureIsInternalType::
    FeatureIsInternalType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (s, e, f, c)
    {
    }

    FeatureIsInternalType* FeatureIsInternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureIsInternalType (*this, f, c);
    }

    FeatureIsInternalType::
    ~FeatureIsInternalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureIsInternalType >
    _xsd_FeatureIsInternalType_type_factory_init (
      L"FeatureIsInternalType",
      L"http://qifstandards.org/xsd/qif3");

    // CharacteristicIsType
    //

    CharacteristicIsType::
    CharacteristicIsType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (this)
    {
    }

    CharacteristicIsType::
    CharacteristicIsType (const val_type& val)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    CharacteristicIsType::
    CharacteristicIsType (const CharacteristicIsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    CharacteristicIsType::
    CharacteristicIsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CharacteristicIsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    CharacteristicIsType* CharacteristicIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CharacteristicIsType (*this, f, c);
    }

    CharacteristicIsType& CharacteristicIsType::
    operator= (const CharacteristicIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    CharacteristicIsType::
    ~CharacteristicIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CharacteristicIsType >
    _xsd_CharacteristicIsType_type_factory_init (
      L"CharacteristicIsType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureTypeIsType
    //

    FeatureTypeIsType::
    FeatureTypeIsType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (this)
    {
    }

    FeatureTypeIsType::
    FeatureTypeIsType (const val_type& val)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    FeatureTypeIsType::
    FeatureTypeIsType (const FeatureTypeIsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    FeatureTypeIsType::
    FeatureTypeIsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void FeatureTypeIsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    FeatureTypeIsType* FeatureTypeIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureTypeIsType (*this, f, c);
    }

    FeatureTypeIsType& FeatureTypeIsType::
    operator= (const FeatureTypeIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    FeatureTypeIsType::
    ~FeatureTypeIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureTypeIsType >
    _xsd_FeatureTypeIsType_type_factory_init (
      L"FeatureTypeIsType",
      L"http://qifstandards.org/xsd/qif3");

    // ShapeClassIsType
    //

    ShapeClassIsType::
    ShapeClassIsType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (this)
    {
    }

    ShapeClassIsType::
    ShapeClassIsType (const val_type& val)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    ShapeClassIsType::
    ShapeClassIsType (const ShapeClassIsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ShapeClassIsType::
    ShapeClassIsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ShapeClassIsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    ShapeClassIsType* ShapeClassIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShapeClassIsType (*this, f, c);
    }

    ShapeClassIsType& ShapeClassIsType::
    operator= (const ShapeClassIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ShapeClassIsType::
    ~ShapeClassIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ShapeClassIsType >
    _xsd_ShapeClassIsType_type_factory_init (
      L"ShapeClassIsType",
      L"http://qifstandards.org/xsd/qif3");

    // PointSamplingStrategyEnumBaseType
    //

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_PointSamplingStrategyEnumBaseType_convert ();
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_PointSamplingStrategyEnumBaseType_convert ();
    }

    PointSamplingStrategyEnumBaseType::
    PointSamplingStrategyEnumBaseType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_PointSamplingStrategyEnumBaseType_convert ();
    }

    PointSamplingStrategyEnumBaseType* PointSamplingStrategyEnumBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSamplingStrategyEnumBaseType (*this, f, c);
    }

    PointSamplingStrategyEnumBaseType::value PointSamplingStrategyEnumBaseType::
    _xsd_PointSamplingStrategyEnumBaseType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PointSamplingStrategyEnumBaseType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PointSamplingStrategyEnumBaseType_indexes_,
                        _xsd_PointSamplingStrategyEnumBaseType_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_PointSamplingStrategyEnumBaseType_indexes_ + 9 || _xsd_PointSamplingStrategyEnumBaseType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const PointSamplingStrategyEnumBaseType::
    _xsd_PointSamplingStrategyEnumBaseType_literals_[9] =
    {
      L"ORTHOGONALGRID",
      L"BIRDCAGE",
      L"POLARGRID",
      L"SPECIFIEDGRID",
      L"STRATIFIED",
      L"HELIX",
      L"SPIRAL",
      L"SPIDERWEB",
      L"POINTS"
    };

    const PointSamplingStrategyEnumBaseType::value PointSamplingStrategyEnumBaseType::
    _xsd_PointSamplingStrategyEnumBaseType_indexes_[9] =
    {
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::BIRDCAGE,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::HELIX,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::ORTHOGONALGRID,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::POINTS,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::POLARGRID,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::SPECIFIEDGRID,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::SPIDERWEB,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::SPIRAL,
      ::xsd::qif30::PointSamplingStrategyEnumBaseType::STRATIFIED
    };

    // PointPointSamplingStrategyEnumType
    //

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_PointPointSamplingStrategyEnumType_convert ();
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_PointPointSamplingStrategyEnumType_convert ();
    }

    PointPointSamplingStrategyEnumType::
    PointPointSamplingStrategyEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_PointPointSamplingStrategyEnumType_convert ();
    }

    PointPointSamplingStrategyEnumType* PointPointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointPointSamplingStrategyEnumType (*this, f, c);
    }

    PointPointSamplingStrategyEnumType::value PointPointSamplingStrategyEnumType::
    _xsd_PointPointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PointPointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PointPointSamplingStrategyEnumType_indexes_,
                        _xsd_PointPointSamplingStrategyEnumType_indexes_ + 1,
                        *this,
                        c));

      if (i == _xsd_PointPointSamplingStrategyEnumType_indexes_ + 1 || _xsd_PointPointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* PointPointSamplingStrategyEnumType::
    _xsd_PointPointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const PointPointSamplingStrategyEnumType::value PointPointSamplingStrategyEnumType::
    _xsd_PointPointSamplingStrategyEnumType_indexes_[1] =
    {
      ::xsd::qif30::PointPointSamplingStrategyEnumType::POINTS
    };

    // OpenCurvePointSamplingStrategyEnumType
    //

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_OpenCurvePointSamplingStrategyEnumType_convert ();
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_OpenCurvePointSamplingStrategyEnumType_convert ();
    }

    OpenCurvePointSamplingStrategyEnumType::
    OpenCurvePointSamplingStrategyEnumType (const ::std::wstring& s,
                                            const xercesc::DOMElement* e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_OpenCurvePointSamplingStrategyEnumType_convert ();
    }

    OpenCurvePointSamplingStrategyEnumType* OpenCurvePointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OpenCurvePointSamplingStrategyEnumType (*this, f, c);
    }

    OpenCurvePointSamplingStrategyEnumType::value OpenCurvePointSamplingStrategyEnumType::
    _xsd_OpenCurvePointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_OpenCurvePointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_OpenCurvePointSamplingStrategyEnumType_indexes_,
                        _xsd_OpenCurvePointSamplingStrategyEnumType_indexes_ + 1,
                        *this,
                        c));

      if (i == _xsd_OpenCurvePointSamplingStrategyEnumType_indexes_ + 1 || _xsd_OpenCurvePointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* OpenCurvePointSamplingStrategyEnumType::
    _xsd_OpenCurvePointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const OpenCurvePointSamplingStrategyEnumType::value OpenCurvePointSamplingStrategyEnumType::
    _xsd_OpenCurvePointSamplingStrategyEnumType_indexes_[1] =
    {
      ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType::POINTS
    };

    // ClosedCurvePointSamplingStrategyEnumType
    //

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ClosedCurvePointSamplingStrategyEnumType_convert ();
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ClosedCurvePointSamplingStrategyEnumType_convert ();
    }

    ClosedCurvePointSamplingStrategyEnumType::
    ClosedCurvePointSamplingStrategyEnumType (const ::std::wstring& s,
                                              const xercesc::DOMElement* e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ClosedCurvePointSamplingStrategyEnumType_convert ();
    }

    ClosedCurvePointSamplingStrategyEnumType* ClosedCurvePointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ClosedCurvePointSamplingStrategyEnumType (*this, f, c);
    }

    ClosedCurvePointSamplingStrategyEnumType::value ClosedCurvePointSamplingStrategyEnumType::
    _xsd_ClosedCurvePointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ClosedCurvePointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ClosedCurvePointSamplingStrategyEnumType_indexes_,
                        _xsd_ClosedCurvePointSamplingStrategyEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ClosedCurvePointSamplingStrategyEnumType_indexes_ + 2 || _xsd_ClosedCurvePointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ClosedCurvePointSamplingStrategyEnumType::
    _xsd_ClosedCurvePointSamplingStrategyEnumType_literals_[2] =
    {
      L"POINTS",
      L"EQUIDISTANT"
    };

    const ClosedCurvePointSamplingStrategyEnumType::value ClosedCurvePointSamplingStrategyEnumType::
    _xsd_ClosedCurvePointSamplingStrategyEnumType_indexes_[2] =
    {
      ::xsd::qif30::ClosedCurvePointSamplingStrategyEnumType::EQUIDISTANT,
      ::xsd::qif30::ClosedCurvePointSamplingStrategyEnumType::POINTS
    };

    // PointDefinedPointSamplingStrategyEnumType
    //

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_PointDefinedPointSamplingStrategyEnumType_convert ();
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_PointDefinedPointSamplingStrategyEnumType_convert ();
    }

    PointDefinedPointSamplingStrategyEnumType::
    PointDefinedPointSamplingStrategyEnumType (const ::std::wstring& s,
                                               const xercesc::DOMElement* e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_PointDefinedPointSamplingStrategyEnumType_convert ();
    }

    PointDefinedPointSamplingStrategyEnumType* PointDefinedPointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedPointSamplingStrategyEnumType (*this, f, c);
    }

    PointDefinedPointSamplingStrategyEnumType::value PointDefinedPointSamplingStrategyEnumType::
    _xsd_PointDefinedPointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PointDefinedPointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PointDefinedPointSamplingStrategyEnumType_indexes_,
                        _xsd_PointDefinedPointSamplingStrategyEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_PointDefinedPointSamplingStrategyEnumType_indexes_ + 2 || _xsd_PointDefinedPointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const PointDefinedPointSamplingStrategyEnumType::
    _xsd_PointDefinedPointSamplingStrategyEnumType_literals_[2] =
    {
      L"GIVENPOINTS",
      L"POINTS"
    };

    const PointDefinedPointSamplingStrategyEnumType::value PointDefinedPointSamplingStrategyEnumType::
    _xsd_PointDefinedPointSamplingStrategyEnumType_indexes_[2] =
    {
      ::xsd::qif30::PointDefinedPointSamplingStrategyEnumType::GIVENPOINTS,
      ::xsd::qif30::PointDefinedPointSamplingStrategyEnumType::POINTS
    };

    // ConePointSamplingStrategyEnumType
    //

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_ConePointSamplingStrategyEnumType_convert ();
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_ConePointSamplingStrategyEnumType_convert ();
    }

    ConePointSamplingStrategyEnumType::
    ConePointSamplingStrategyEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_ConePointSamplingStrategyEnumType_convert ();
    }

    ConePointSamplingStrategyEnumType* ConePointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConePointSamplingStrategyEnumType (*this, f, c);
    }

    ConePointSamplingStrategyEnumType::value ConePointSamplingStrategyEnumType::
    _xsd_ConePointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ConePointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ConePointSamplingStrategyEnumType_indexes_,
                        _xsd_ConePointSamplingStrategyEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ConePointSamplingStrategyEnumType_indexes_ + 5 || _xsd_ConePointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* ConePointSamplingStrategyEnumType::
    _xsd_ConePointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const ConePointSamplingStrategyEnumType::value ConePointSamplingStrategyEnumType::
    _xsd_ConePointSamplingStrategyEnumType_indexes_[5] =
    {
      ::xsd::qif30::ConePointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::ConePointSamplingStrategyEnumType::POLARGRID,
      ::xsd::qif30::ConePointSamplingStrategyEnumType::SPIDERWEB,
      ::xsd::qif30::ConePointSamplingStrategyEnumType::SPIRAL,
      ::xsd::qif30::ConePointSamplingStrategyEnumType::STRATIFIED
    };

    // ElongatedCylinderPointSamplingStrategyEnumType
    //

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert ();
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert ();
    }

    ElongatedCylinderPointSamplingStrategyEnumType::
    ElongatedCylinderPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                    const xercesc::DOMElement* e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert ();
    }

    ElongatedCylinderPointSamplingStrategyEnumType* ElongatedCylinderPointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderPointSamplingStrategyEnumType (*this, f, c);
    }

    ElongatedCylinderPointSamplingStrategyEnumType::value ElongatedCylinderPointSamplingStrategyEnumType::
    _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ElongatedCylinderPointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ElongatedCylinderPointSamplingStrategyEnumType_indexes_,
                        _xsd_ElongatedCylinderPointSamplingStrategyEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_ElongatedCylinderPointSamplingStrategyEnumType_indexes_ + 6 || _xsd_ElongatedCylinderPointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* ElongatedCylinderPointSamplingStrategyEnumType::
    _xsd_ElongatedCylinderPointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const ElongatedCylinderPointSamplingStrategyEnumType::value ElongatedCylinderPointSamplingStrategyEnumType::
    _xsd_ElongatedCylinderPointSamplingStrategyEnumType_indexes_[6] =
    {
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::BIRDCAGE,
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::HELIX,
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::ORTHOGONALGRID,
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::SPECIFIEDGRID,
      ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType::STRATIFIED
    };

    // ExtrudedCrossSectionPointSamplingStrategyEnumType
    //

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert ();
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert ();
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::
    ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                       const xercesc::DOMElement* e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert ();
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType* ExtrudedCrossSectionPointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionPointSamplingStrategyEnumType (*this, f, c);
    }

    ExtrudedCrossSectionPointSamplingStrategyEnumType::value ExtrudedCrossSectionPointSamplingStrategyEnumType::
    _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_indexes_,
                        _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_indexes_ + 3 || _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* ExtrudedCrossSectionPointSamplingStrategyEnumType::
    _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const ExtrudedCrossSectionPointSamplingStrategyEnumType::value ExtrudedCrossSectionPointSamplingStrategyEnumType::
    _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_indexes_[3] =
    {
      ::xsd::qif30::ExtrudedCrossSectionPointSamplingStrategyEnumType::BIRDCAGE,
      ::xsd::qif30::ExtrudedCrossSectionPointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::ExtrudedCrossSectionPointSamplingStrategyEnumType::STRATIFIED
    };

    // SpherePointSamplingStrategyEnumType
    //

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_SpherePointSamplingStrategyEnumType_convert ();
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_SpherePointSamplingStrategyEnumType_convert ();
    }

    SpherePointSamplingStrategyEnumType::
    SpherePointSamplingStrategyEnumType (const ::std::wstring& s,
                                         const xercesc::DOMElement* e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_SpherePointSamplingStrategyEnumType_convert ();
    }

    SpherePointSamplingStrategyEnumType* SpherePointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpherePointSamplingStrategyEnumType (*this, f, c);
    }

    SpherePointSamplingStrategyEnumType::value SpherePointSamplingStrategyEnumType::
    _xsd_SpherePointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SpherePointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SpherePointSamplingStrategyEnumType_indexes_,
                        _xsd_SpherePointSamplingStrategyEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_SpherePointSamplingStrategyEnumType_indexes_ + 5 || _xsd_SpherePointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* SpherePointSamplingStrategyEnumType::
    _xsd_SpherePointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const SpherePointSamplingStrategyEnumType::value SpherePointSamplingStrategyEnumType::
    _xsd_SpherePointSamplingStrategyEnumType_indexes_[5] =
    {
      ::xsd::qif30::SpherePointSamplingStrategyEnumType::HELIX,
      ::xsd::qif30::SpherePointSamplingStrategyEnumType::ORTHOGONALGRID,
      ::xsd::qif30::SpherePointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::SpherePointSamplingStrategyEnumType::SPECIFIEDGRID,
      ::xsd::qif30::SpherePointSamplingStrategyEnumType::STRATIFIED
    };

    // SurfaceOfRevolutionPointSamplingStrategyEnumType
    //

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert ();
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert ();
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::
    SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                      const xercesc::DOMElement* e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert ();
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType* SurfaceOfRevolutionPointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionPointSamplingStrategyEnumType (*this, f, c);
    }

    SurfaceOfRevolutionPointSamplingStrategyEnumType::value SurfaceOfRevolutionPointSamplingStrategyEnumType::
    _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_indexes_,
                        _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_indexes_ + 6 || _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* SurfaceOfRevolutionPointSamplingStrategyEnumType::
    _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const SurfaceOfRevolutionPointSamplingStrategyEnumType::value SurfaceOfRevolutionPointSamplingStrategyEnumType::
    _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_indexes_[6] =
    {
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::BIRDCAGE,
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::HELIX,
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::ORTHOGONALGRID,
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::SPECIFIEDGRID,
      ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType::STRATIFIED
    };

    // PlanePointSamplingStrategyEnumType
    //

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (e, f, c)
    {
      _xsd_PlanePointSamplingStrategyEnumType_convert ();
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (a, f, c)
    {
      _xsd_PlanePointSamplingStrategyEnumType_convert ();
    }

    PlanePointSamplingStrategyEnumType::
    PlanePointSamplingStrategyEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PointSamplingStrategyEnumBaseType (s, e, f, c)
    {
      _xsd_PlanePointSamplingStrategyEnumType_convert ();
    }

    PlanePointSamplingStrategyEnumType* PlanePointSamplingStrategyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePointSamplingStrategyEnumType (*this, f, c);
    }

    PlanePointSamplingStrategyEnumType::value PlanePointSamplingStrategyEnumType::
    _xsd_PlanePointSamplingStrategyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_PlanePointSamplingStrategyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PlanePointSamplingStrategyEnumType_indexes_,
                        _xsd_PlanePointSamplingStrategyEnumType_indexes_ + 7,
                        *this,
                        c));

      if (i == _xsd_PlanePointSamplingStrategyEnumType_indexes_ + 7 || _xsd_PlanePointSamplingStrategyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const* PlanePointSamplingStrategyEnumType::
    _xsd_PlanePointSamplingStrategyEnumType_literals_ = ::xsd::qif30::PointSamplingStrategyEnumBaseType::_xsd_PointSamplingStrategyEnumBaseType_literals_;

    const PlanePointSamplingStrategyEnumType::value PlanePointSamplingStrategyEnumType::
    _xsd_PlanePointSamplingStrategyEnumType_indexes_[7] =
    {
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::ORTHOGONALGRID,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::POINTS,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::POLARGRID,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::SPECIFIEDGRID,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::SPIDERWEB,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::SPIRAL,
      ::xsd::qif30::PlanePointSamplingStrategyEnumType::STRATIFIED
    };

    // CharacteristicTypeEnumType
    //

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CharacteristicTypeEnumType_convert ();
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CharacteristicTypeEnumType_convert ();
    }

    CharacteristicTypeEnumType::
    CharacteristicTypeEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CharacteristicTypeEnumType_convert ();
    }

    CharacteristicTypeEnumType* CharacteristicTypeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CharacteristicTypeEnumType (*this, f, c);
    }

    CharacteristicTypeEnumType::value CharacteristicTypeEnumType::
    _xsd_CharacteristicTypeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CharacteristicTypeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CharacteristicTypeEnumType_indexes_,
                        _xsd_CharacteristicTypeEnumType_indexes_ + 59,
                        *this,
                        c));

      if (i == _xsd_CharacteristicTypeEnumType_indexes_ + 59 || _xsd_CharacteristicTypeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CharacteristicTypeEnumType::
    _xsd_CharacteristicTypeEnumType_literals_[59] =
    {
      L"ANGLE",
      L"ANGLEBETWEEN",
      L"ANGLECOORDINATE",
      L"ANGLEFROM",
      L"ANGULARITY",
      L"CHORD",
      L"CIRCULARITY",
      L"CIRCULARRUNOUT",
      L"CONCENTRICITY",
      L"CONICALTAPER",
      L"CONICITY",
      L"CURVELENGTH",
      L"CYLINDRICITY",
      L"DEPTH",
      L"DIAMETER",
      L"DISTANCE",
      L"DISTANCEFROM",
      L"ELLIPTICITY",
      L"FLATTAPER",
      L"FLATNESS",
      L"HEIGHT",
      L"LENGTH",
      L"LENGTHCOORDINATE",
      L"LINEPROFILE",
      L"OTHERFORM",
      L"PERPENDICULARITY",
      L"PARALLELISM",
      L"POINTPROFILE",
      L"POSITION",
      L"RADIUS",
      L"SPHERICALDIAMTER",
      L"SPHERICALRADIUS",
      L"SPHERICITY",
      L"SQUARE",
      L"STRAIGHTNESS",
      L"SURFACEPROFILE",
      L"SURFACEPROFILENONUNIFORM",
      L"SYMMETRY",
      L"THICKNESS",
      L"THREAD",
      L"TOROIDICITY",
      L"TOTALRUNOUT",
      L"WELDBEVEL",
      L"WELDEDGE",
      L"WELDFILLET",
      L"WELDFLAREBEVEL",
      L"WELDFLAREV",
      L"WELDJ",
      L"WELDPLUG",
      L"WELDSCARF",
      L"WELDSEAM",
      L"WELDSLOT",
      L"WELDSPOT",
      L"WELDSQUARE",
      L"WELDSTUD",
      L"WELDSURFACING",
      L"WELDU",
      L"WELDV",
      L"WIDTH"
    };

    const CharacteristicTypeEnumType::value CharacteristicTypeEnumType::
    _xsd_CharacteristicTypeEnumType_indexes_[59] =
    {
      ::xsd::qif30::CharacteristicTypeEnumType::ANGLE,
      ::xsd::qif30::CharacteristicTypeEnumType::ANGLEBETWEEN,
      ::xsd::qif30::CharacteristicTypeEnumType::ANGLECOORDINATE,
      ::xsd::qif30::CharacteristicTypeEnumType::ANGLEFROM,
      ::xsd::qif30::CharacteristicTypeEnumType::ANGULARITY,
      ::xsd::qif30::CharacteristicTypeEnumType::CHORD,
      ::xsd::qif30::CharacteristicTypeEnumType::CIRCULARITY,
      ::xsd::qif30::CharacteristicTypeEnumType::CIRCULARRUNOUT,
      ::xsd::qif30::CharacteristicTypeEnumType::CONCENTRICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::CONICALTAPER,
      ::xsd::qif30::CharacteristicTypeEnumType::CONICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::CURVELENGTH,
      ::xsd::qif30::CharacteristicTypeEnumType::CYLINDRICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::DEPTH,
      ::xsd::qif30::CharacteristicTypeEnumType::DIAMETER,
      ::xsd::qif30::CharacteristicTypeEnumType::DISTANCE,
      ::xsd::qif30::CharacteristicTypeEnumType::DISTANCEFROM,
      ::xsd::qif30::CharacteristicTypeEnumType::ELLIPTICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::FLATNESS,
      ::xsd::qif30::CharacteristicTypeEnumType::FLATTAPER,
      ::xsd::qif30::CharacteristicTypeEnumType::HEIGHT,
      ::xsd::qif30::CharacteristicTypeEnumType::LENGTH,
      ::xsd::qif30::CharacteristicTypeEnumType::LENGTHCOORDINATE,
      ::xsd::qif30::CharacteristicTypeEnumType::LINEPROFILE,
      ::xsd::qif30::CharacteristicTypeEnumType::OTHERFORM,
      ::xsd::qif30::CharacteristicTypeEnumType::PARALLELISM,
      ::xsd::qif30::CharacteristicTypeEnumType::PERPENDICULARITY,
      ::xsd::qif30::CharacteristicTypeEnumType::POINTPROFILE,
      ::xsd::qif30::CharacteristicTypeEnumType::POSITION,
      ::xsd::qif30::CharacteristicTypeEnumType::RADIUS,
      ::xsd::qif30::CharacteristicTypeEnumType::SPHERICALDIAMTER,
      ::xsd::qif30::CharacteristicTypeEnumType::SPHERICALRADIUS,
      ::xsd::qif30::CharacteristicTypeEnumType::SPHERICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::SQUARE,
      ::xsd::qif30::CharacteristicTypeEnumType::STRAIGHTNESS,
      ::xsd::qif30::CharacteristicTypeEnumType::SURFACEPROFILE,
      ::xsd::qif30::CharacteristicTypeEnumType::SURFACEPROFILENONUNIFORM,
      ::xsd::qif30::CharacteristicTypeEnumType::SYMMETRY,
      ::xsd::qif30::CharacteristicTypeEnumType::THICKNESS,
      ::xsd::qif30::CharacteristicTypeEnumType::THREAD,
      ::xsd::qif30::CharacteristicTypeEnumType::TOROIDICITY,
      ::xsd::qif30::CharacteristicTypeEnumType::TOTALRUNOUT,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDBEVEL,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDEDGE,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDFILLET,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDFLAREBEVEL,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDFLAREV,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDJ,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDPLUG,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSCARF,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSEAM,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSLOT,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSPOT,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSQUARE,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSTUD,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDSURFACING,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDU,
      ::xsd::qif30::CharacteristicTypeEnumType::WELDV,
      ::xsd::qif30::CharacteristicTypeEnumType::WIDTH
    };

    // FeatureTypeEnumType
    //

    FeatureTypeEnumType::
    FeatureTypeEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_FeatureTypeEnumType_convert ();
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_FeatureTypeEnumType_convert ();
    }

    FeatureTypeEnumType::
    FeatureTypeEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_FeatureTypeEnumType_convert ();
    }

    FeatureTypeEnumType* FeatureTypeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureTypeEnumType (*this, f, c);
    }

    FeatureTypeEnumType::value FeatureTypeEnumType::
    _xsd_FeatureTypeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_FeatureTypeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_FeatureTypeEnumType_indexes_,
                        _xsd_FeatureTypeEnumType_indexes_ + 38,
                        *this,
                        c));

      if (i == _xsd_FeatureTypeEnumType_indexes_ + 38 || _xsd_FeatureTypeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const FeatureTypeEnumType::
    _xsd_FeatureTypeEnumType_literals_[38] =
    {
      L"CIRCLE",
      L"CIRCULARARC",
      L"CONE",
      L"CONICALSEGMENT",
      L"CYLINDER",
      L"CYLINDRICALSEGMENT",
      L"EDGEPOINT",
      L"ELLIPSE",
      L"ELLIPTICALARC",
      L"ELONGATEDCIRCLE",
      L"ELONGATEDCYLINDER",
      L"EXTRUDEDCROSSSECTION",
      L"GROUP",
      L"LINE",
      L"MARKING",
      L"OPPOSITEANGLEDLINES",
      L"OPPOSITEPARALLELLINES",
      L"OPPOSITEANGLEDPLANES",
      L"OPPOSITEPARALLELPLANES",
      L"OTHERCURVE",
      L"OTHERNONSHAPE",
      L"OTHERSHAPE",
      L"OTHERSURFACE",
      L"PATTERN",
      L"PATTERNCIRCLE",
      L"PATTERNCIRCULARARC",
      L"PATTERNLINEAR",
      L"PATTERNPARALLELOGRAM",
      L"PLANE",
      L"POINT",
      L"POINTDEFINEDCURVE",
      L"POINTDEFINEDSURFACE",
      L"SPHERE",
      L"SPHERICALSEGMENT",
      L"SURFACEOFREVOLUTION",
      L"THREADED",
      L"TOROIDALSEGMENT",
      L"TORUS"
    };

    const FeatureTypeEnumType::value FeatureTypeEnumType::
    _xsd_FeatureTypeEnumType_indexes_[38] =
    {
      ::xsd::qif30::FeatureTypeEnumType::CIRCLE,
      ::xsd::qif30::FeatureTypeEnumType::CIRCULARARC,
      ::xsd::qif30::FeatureTypeEnumType::CONE,
      ::xsd::qif30::FeatureTypeEnumType::CONICALSEGMENT,
      ::xsd::qif30::FeatureTypeEnumType::CYLINDER,
      ::xsd::qif30::FeatureTypeEnumType::CYLINDRICALSEGMENT,
      ::xsd::qif30::FeatureTypeEnumType::EDGEPOINT,
      ::xsd::qif30::FeatureTypeEnumType::ELLIPSE,
      ::xsd::qif30::FeatureTypeEnumType::ELLIPTICALARC,
      ::xsd::qif30::FeatureTypeEnumType::ELONGATEDCIRCLE,
      ::xsd::qif30::FeatureTypeEnumType::ELONGATEDCYLINDER,
      ::xsd::qif30::FeatureTypeEnumType::EXTRUDEDCROSSSECTION,
      ::xsd::qif30::FeatureTypeEnumType::GROUP,
      ::xsd::qif30::FeatureTypeEnumType::LINE,
      ::xsd::qif30::FeatureTypeEnumType::MARKING,
      ::xsd::qif30::FeatureTypeEnumType::OPPOSITEANGLEDLINES,
      ::xsd::qif30::FeatureTypeEnumType::OPPOSITEANGLEDPLANES,
      ::xsd::qif30::FeatureTypeEnumType::OPPOSITEPARALLELLINES,
      ::xsd::qif30::FeatureTypeEnumType::OPPOSITEPARALLELPLANES,
      ::xsd::qif30::FeatureTypeEnumType::OTHERCURVE,
      ::xsd::qif30::FeatureTypeEnumType::OTHERNONSHAPE,
      ::xsd::qif30::FeatureTypeEnumType::OTHERSHAPE,
      ::xsd::qif30::FeatureTypeEnumType::OTHERSURFACE,
      ::xsd::qif30::FeatureTypeEnumType::PATTERN,
      ::xsd::qif30::FeatureTypeEnumType::PATTERNCIRCLE,
      ::xsd::qif30::FeatureTypeEnumType::PATTERNCIRCULARARC,
      ::xsd::qif30::FeatureTypeEnumType::PATTERNLINEAR,
      ::xsd::qif30::FeatureTypeEnumType::PATTERNPARALLELOGRAM,
      ::xsd::qif30::FeatureTypeEnumType::PLANE,
      ::xsd::qif30::FeatureTypeEnumType::POINT,
      ::xsd::qif30::FeatureTypeEnumType::POINTDEFINEDCURVE,
      ::xsd::qif30::FeatureTypeEnumType::POINTDEFINEDSURFACE,
      ::xsd::qif30::FeatureTypeEnumType::SPHERE,
      ::xsd::qif30::FeatureTypeEnumType::SPHERICALSEGMENT,
      ::xsd::qif30::FeatureTypeEnumType::SURFACEOFREVOLUTION,
      ::xsd::qif30::FeatureTypeEnumType::THREADED,
      ::xsd::qif30::FeatureTypeEnumType::TOROIDALSEGMENT,
      ::xsd::qif30::FeatureTypeEnumType::TORUS
    };

    // DMEClassNameEnumType
    //

    DMEClassNameEnumType::
    DMEClassNameEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DMEClassNameEnumType_convert ();
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DMEClassNameEnumType_convert ();
    }

    DMEClassNameEnumType::
    DMEClassNameEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DMEClassNameEnumType_convert ();
    }

    DMEClassNameEnumType* DMEClassNameEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEClassNameEnumType (*this, f, c);
    }

    DMEClassNameEnumType::value DMEClassNameEnumType::
    _xsd_DMEClassNameEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DMEClassNameEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DMEClassNameEnumType_indexes_,
                        _xsd_DMEClassNameEnumType_indexes_ + 55,
                        *this,
                        c));

      if (i == _xsd_DMEClassNameEnumType_indexes_ + 55 || _xsd_DMEClassNameEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DMEClassNameEnumType::
    _xsd_DMEClassNameEnumType_literals_[55] =
    {
      L"AACMM",
      L"ALLDMES",
      L"ANALOG_MICROMETER",
      L"AUTOCOLLIMATOR",
      L"CALIPER",
      L"CAPACITIVE_SENSOR",
      L"CARTESIAN_CMM",
      L"CHARGE_COUPLED_DEVICE_CAMERA_SENSOR",
      L"CMM",
      L"COMPLEX_TACTILE_PROBE_SENSOR",
      L"COMPUTED_TOMOGRAPHY",
      L"CONFOCAL_CHROMATIC_SENSOR",
      L"DIAL_CALIPER",
      L"DIGITAL_CALIPER",
      L"DIGITAL_MICROMETER",
      L"DRAW_WIRE_SENSOR",
      L"DVRT_SENSOR",
      L"EDDY_CURRENT_SENSOR",
      L"GAGE",
      L"LASER_RADAR",
      L"LASER_TRACKER",
      L"LASER_TRIANGULATION_SENSOR",
      L"LIGHT_PEN_CMM",
      L"LVDT_SENSOR",
      L"MAGNETO_INDUCTIVE_SENSOR",
      L"MEASUREMENT_ROOM",
      L"MICROMETER",
      L"MICROSCOPE",
      L"MULTIPLE_CARRIAGE_CARTESIAN_CMM",
      L"OPTICAL_COMPARATOR",
      L"PARALLEL_LINK_CMM",
      L"PROBE_TIP",
      L"SIMPLE_TACTILE_PROBE_SENSOR",
      L"SINE_BAR",
      L"STRUCTURED_LIGHT_SENSOR",
      L"TACTILE_PROBE_SENSOR",
      L"THEODOLITE",
      L"TOOL_WITH_CCD_CAMERA_SENSOR",
      L"TOOL_WITH_CAPACITIVE_SENSOR",
      L"TOOL_WITH_COMPLEX_TACTILE_PROBE_SENSOR",
      L"TOOL_WITH_CONFOCAL_CHROMATIC_SENSOR",
      L"TOOL_WITH_DETACHABLE_SENSORS",
      L"TOOL_WITH_DVRT_SENSOR",
      L"TOOL_WITH_DRAW_WIRE_SENSOR",
      L"TOOL_WITH_EDDY_CURRENT_SENSOR",
      L"TOOL_WITH_INTEGRATED_SENSOR",
      L"TOOL_WITH_LVDT_SENSOR",
      L"TOOL_WITH_LASER_TRIANGULATION_SENSOR",
      L"TOOL_WITH_MAGNETOINDUCTIVE_SENSOR",
      L"TOOL_WITH_SIMPLE_TACTILE_PROBE_SENSOR",
      L"TOOL_WITH_STRUCTURED_LIGHT_SENSOR",
      L"TOOL_WITH_ULTRASONIC_SENSOR",
      L"ULTRASONIC_SENSOR",
      L"UNIVERSAL_DEVICE",
      L"UNIVERSAL_LENGTH_MEASURING"
    };

    const DMEClassNameEnumType::value DMEClassNameEnumType::
    _xsd_DMEClassNameEnumType_indexes_[55] =
    {
      ::xsd::qif30::DMEClassNameEnumType::AACMM,
      ::xsd::qif30::DMEClassNameEnumType::ALLDMES,
      ::xsd::qif30::DMEClassNameEnumType::ANALOG_MICROMETER,
      ::xsd::qif30::DMEClassNameEnumType::AUTOCOLLIMATOR,
      ::xsd::qif30::DMEClassNameEnumType::CALIPER,
      ::xsd::qif30::DMEClassNameEnumType::CAPACITIVE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::CARTESIAN_CMM,
      ::xsd::qif30::DMEClassNameEnumType::CHARGE_COUPLED_DEVICE_CAMERA_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::CMM,
      ::xsd::qif30::DMEClassNameEnumType::COMPLEX_TACTILE_PROBE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::COMPUTED_TOMOGRAPHY,
      ::xsd::qif30::DMEClassNameEnumType::CONFOCAL_CHROMATIC_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::DIAL_CALIPER,
      ::xsd::qif30::DMEClassNameEnumType::DIGITAL_CALIPER,
      ::xsd::qif30::DMEClassNameEnumType::DIGITAL_MICROMETER,
      ::xsd::qif30::DMEClassNameEnumType::DRAW_WIRE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::DVRT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::EDDY_CURRENT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::GAGE,
      ::xsd::qif30::DMEClassNameEnumType::LASER_RADAR,
      ::xsd::qif30::DMEClassNameEnumType::LASER_TRACKER,
      ::xsd::qif30::DMEClassNameEnumType::LASER_TRIANGULATION_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::LIGHT_PEN_CMM,
      ::xsd::qif30::DMEClassNameEnumType::LVDT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::MAGNETO_INDUCTIVE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::MEASUREMENT_ROOM,
      ::xsd::qif30::DMEClassNameEnumType::MICROMETER,
      ::xsd::qif30::DMEClassNameEnumType::MICROSCOPE,
      ::xsd::qif30::DMEClassNameEnumType::MULTIPLE_CARRIAGE_CARTESIAN_CMM,
      ::xsd::qif30::DMEClassNameEnumType::OPTICAL_COMPARATOR,
      ::xsd::qif30::DMEClassNameEnumType::PARALLEL_LINK_CMM,
      ::xsd::qif30::DMEClassNameEnumType::PROBE_TIP,
      ::xsd::qif30::DMEClassNameEnumType::SIMPLE_TACTILE_PROBE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::SINE_BAR,
      ::xsd::qif30::DMEClassNameEnumType::STRUCTURED_LIGHT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TACTILE_PROBE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::THEODOLITE,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_CAPACITIVE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_CCD_CAMERA_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_COMPLEX_TACTILE_PROBE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_CONFOCAL_CHROMATIC_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_DETACHABLE_SENSORS,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_DRAW_WIRE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_DVRT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_EDDY_CURRENT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_INTEGRATED_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_LASER_TRIANGULATION_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_LVDT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_MAGNETOINDUCTIVE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_SIMPLE_TACTILE_PROBE_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_STRUCTURED_LIGHT_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::TOOL_WITH_ULTRASONIC_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::ULTRASONIC_SENSOR,
      ::xsd::qif30::DMEClassNameEnumType::UNIVERSAL_DEVICE,
      ::xsd::qif30::DMEClassNameEnumType::UNIVERSAL_LENGTH_MEASURING
    };

    // ArithmeticComparisonEnumType
    //

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ArithmeticComparisonEnumType_convert ();
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ArithmeticComparisonEnumType_convert ();
    }

    ArithmeticComparisonEnumType::
    ArithmeticComparisonEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ArithmeticComparisonEnumType_convert ();
    }

    ArithmeticComparisonEnumType* ArithmeticComparisonEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticComparisonEnumType (*this, f, c);
    }

    ArithmeticComparisonEnumType::value ArithmeticComparisonEnumType::
    _xsd_ArithmeticComparisonEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ArithmeticComparisonEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ArithmeticComparisonEnumType_indexes_,
                        _xsd_ArithmeticComparisonEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ArithmeticComparisonEnumType_indexes_ + 5 || _xsd_ArithmeticComparisonEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ArithmeticComparisonEnumType::
    _xsd_ArithmeticComparisonEnumType_literals_[5] =
    {
      L"EQUAL",
      L"GREATER",
      L"GREATEROREQUAL",
      L"LESS",
      L"LESSOREQUAL"
    };

    const ArithmeticComparisonEnumType::value ArithmeticComparisonEnumType::
    _xsd_ArithmeticComparisonEnumType_indexes_[5] =
    {
      ::xsd::qif30::ArithmeticComparisonEnumType::EQUAL,
      ::xsd::qif30::ArithmeticComparisonEnumType::GREATER,
      ::xsd::qif30::ArithmeticComparisonEnumType::GREATEROREQUAL,
      ::xsd::qif30::ArithmeticComparisonEnumType::LESS,
      ::xsd::qif30::ArithmeticComparisonEnumType::LESSOREQUAL
    };

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CharacteristicIs_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"CharacteristicIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CharacteristicIsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureIsDatum_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureIsDatum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureIsDatumType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureIsInternal_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureIsInternal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureIsInternalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureTypeIs_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureTypeIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureTypeIsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SamplingCategoryIs_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"SamplingCategoryIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SamplingCategoryIsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ShapeClassIs_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ShapeClassIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ShapeClassIsType >);


    // ArithmeticParameterBaseType
    //

    ArithmeticParameterBaseType::
    ArithmeticParameterBaseType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      Parameter_ (this)
    {
    }

    ArithmeticParameterBaseType::
    ArithmeticParameterBaseType (const Parameter_type& Parameter)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      Parameter_ (Parameter, this)
    {
    }

    ArithmeticParameterBaseType::
    ArithmeticParameterBaseType (const ArithmeticParameterBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      Parameter_ (x.Parameter_, f, this)
    {
    }

    ArithmeticParameterBaseType::
    ArithmeticParameterBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      Parameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticParameterBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Parameter
        //
        if (n.name () == L"Parameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parameter_type > r (
            Parameter_traits::create (i, f, this));

          if (!Parameter_.present ())
          {
            this->Parameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Parameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Parameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArithmeticParameterBaseType& ArithmeticParameterBaseType::
    operator= (const ArithmeticParameterBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->Parameter_ = x.Parameter_;
      }

      return *this;
    }

    ArithmeticParameterBaseType::
    ~ArithmeticParameterBaseType ()
    {
    }

    // ArithmeticFeatureParameterType
    //

    ArithmeticFeatureParameterType::
    ArithmeticFeatureParameterType ()
    : ::xsd::qif30::ArithmeticParameterBaseType (),
      FeatureTypeEnum_ (this)
    {
    }

    ArithmeticFeatureParameterType::
    ArithmeticFeatureParameterType (const Parameter_type& Parameter)
    : ::xsd::qif30::ArithmeticParameterBaseType (Parameter),
      FeatureTypeEnum_ (this)
    {
    }

    ArithmeticFeatureParameterType::
    ArithmeticFeatureParameterType (const ArithmeticFeatureParameterType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (x, f, c),
      FeatureTypeEnum_ (x.FeatureTypeEnum_, f, this)
    {
    }

    ArithmeticFeatureParameterType::
    ArithmeticFeatureParameterType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureTypeEnum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticFeatureParameterType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ArithmeticParameterBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureTypeEnum
        //
        if (n.name () == L"FeatureTypeEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureTypeEnum_type > r (
            FeatureTypeEnum_traits::create (i, f, this));

          if (!this->FeatureTypeEnum_)
          {
            this->FeatureTypeEnum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ArithmeticFeatureParameterType* ArithmeticFeatureParameterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticFeatureParameterType (*this, f, c);
    }

    ArithmeticFeatureParameterType& ArithmeticFeatureParameterType::
    operator= (const ArithmeticFeatureParameterType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticParameterBaseType& > (*this) = x;
        this->FeatureTypeEnum_ = x.FeatureTypeEnum_;
      }

      return *this;
    }

    ArithmeticFeatureParameterType::
    ~ArithmeticFeatureParameterType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticFeatureParameterType >
    _xsd_ArithmeticFeatureParameterType_type_factory_init (
      L"ArithmeticFeatureParameterType",
      L"http://qifstandards.org/xsd/qif3");

    // ArithmeticCharacteristicParameterType
    //

    ArithmeticCharacteristicParameterType::
    ArithmeticCharacteristicParameterType ()
    : ::xsd::qif30::ArithmeticParameterBaseType (),
      CharacteristicTypeEnum_ (this)
    {
    }

    ArithmeticCharacteristicParameterType::
    ArithmeticCharacteristicParameterType (const Parameter_type& Parameter)
    : ::xsd::qif30::ArithmeticParameterBaseType (Parameter),
      CharacteristicTypeEnum_ (this)
    {
    }

    ArithmeticCharacteristicParameterType::
    ArithmeticCharacteristicParameterType (const ArithmeticCharacteristicParameterType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (x, f, c),
      CharacteristicTypeEnum_ (x.CharacteristicTypeEnum_, f, this)
    {
    }

    ArithmeticCharacteristicParameterType::
    ArithmeticCharacteristicParameterType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicTypeEnum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticCharacteristicParameterType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ArithmeticParameterBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CharacteristicTypeEnum
        //
        if (n.name () == L"CharacteristicTypeEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicTypeEnum_type > r (
            CharacteristicTypeEnum_traits::create (i, f, this));

          if (!this->CharacteristicTypeEnum_)
          {
            this->CharacteristicTypeEnum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ArithmeticCharacteristicParameterType* ArithmeticCharacteristicParameterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticCharacteristicParameterType (*this, f, c);
    }

    ArithmeticCharacteristicParameterType& ArithmeticCharacteristicParameterType::
    operator= (const ArithmeticCharacteristicParameterType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticParameterBaseType& > (*this) = x;
        this->CharacteristicTypeEnum_ = x.CharacteristicTypeEnum_;
      }

      return *this;
    }

    ArithmeticCharacteristicParameterType::
    ~ArithmeticCharacteristicParameterType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticCharacteristicParameterType >
    _xsd_ArithmeticCharacteristicParameterType_type_factory_init (
      L"ArithmeticCharacteristicParameterType",
      L"http://qifstandards.org/xsd/qif3");

    // ArithmeticDMEParameterType
    //

    ArithmeticDMEParameterType::
    ArithmeticDMEParameterType ()
    : ::xsd::qif30::ArithmeticParameterBaseType (),
      DMEClassNameEnum_ (this)
    {
    }

    ArithmeticDMEParameterType::
    ArithmeticDMEParameterType (const Parameter_type& Parameter,
                                const DMEClassNameEnum_type& DMEClassNameEnum)
    : ::xsd::qif30::ArithmeticParameterBaseType (Parameter),
      DMEClassNameEnum_ (DMEClassNameEnum, this)
    {
    }

    ArithmeticDMEParameterType::
    ArithmeticDMEParameterType (const ArithmeticDMEParameterType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (x, f, c),
      DMEClassNameEnum_ (x.DMEClassNameEnum_, f, this)
    {
    }

    ArithmeticDMEParameterType::
    ArithmeticDMEParameterType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (e, f | ::xml_schema::flags::base, c),
      DMEClassNameEnum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticDMEParameterType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ArithmeticParameterBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEClassNameEnum
        //
        if (n.name () == L"DMEClassNameEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEClassNameEnum_type > r (
            DMEClassNameEnum_traits::create (i, f, this));

          if (!DMEClassNameEnum_.present ())
          {
            this->DMEClassNameEnum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DMEClassNameEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DMEClassNameEnum",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArithmeticDMEParameterType* ArithmeticDMEParameterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticDMEParameterType (*this, f, c);
    }

    ArithmeticDMEParameterType& ArithmeticDMEParameterType::
    operator= (const ArithmeticDMEParameterType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticParameterBaseType& > (*this) = x;
        this->DMEClassNameEnum_ = x.DMEClassNameEnum_;
      }

      return *this;
    }

    ArithmeticDMEParameterType::
    ~ArithmeticDMEParameterType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticDMEParameterType >
    _xsd_ArithmeticDMEParameterType_type_factory_init (
      L"ArithmeticDMEParameterType",
      L"http://qifstandards.org/xsd/qif3");

    // ArithmeticPartParameterType
    //

    ArithmeticPartParameterType::
    ArithmeticPartParameterType ()
    : ::xsd::qif30::ArithmeticParameterBaseType ()
    {
    }

    ArithmeticPartParameterType::
    ArithmeticPartParameterType (const Parameter_type& Parameter)
    : ::xsd::qif30::ArithmeticParameterBaseType (Parameter)
    {
    }

    ArithmeticPartParameterType::
    ArithmeticPartParameterType (const ArithmeticPartParameterType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (x, f, c)
    {
    }

    ArithmeticPartParameterType::
    ArithmeticPartParameterType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticParameterBaseType (e, f, c)
    {
    }

    ArithmeticPartParameterType* ArithmeticPartParameterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticPartParameterType (*this, f, c);
    }

    ArithmeticPartParameterType::
    ~ArithmeticPartParameterType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticPartParameterType >
    _xsd_ArithmeticPartParameterType_type_factory_init (
      L"ArithmeticPartParameterType",
      L"http://qifstandards.org/xsd/qif3");

    // CharacteristicToleranceType
    //

    CharacteristicToleranceType::
    CharacteristicToleranceType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType ()
    {
    }

    CharacteristicToleranceType::
    CharacteristicToleranceType (const CharacteristicToleranceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c)
    {
    }

    CharacteristicToleranceType::
    CharacteristicToleranceType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f, c)
    {
    }

    CharacteristicToleranceType::
    CharacteristicToleranceType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (a, f, c)
    {
    }

    CharacteristicToleranceType::
    CharacteristicToleranceType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (s, e, f, c)
    {
    }

    CharacteristicToleranceType* CharacteristicToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CharacteristicToleranceType (*this, f, c);
    }

    CharacteristicToleranceType::
    ~CharacteristicToleranceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CharacteristicToleranceType >
    _xsd_CharacteristicToleranceType_type_factory_init (
      L"CharacteristicToleranceType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureLengthType
    //

    FeatureLengthType::
    FeatureLengthType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType ()
    {
    }

    FeatureLengthType::
    FeatureLengthType (const FeatureLengthType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c)
    {
    }

    FeatureLengthType::
    FeatureLengthType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f, c)
    {
    }

    FeatureLengthType::
    FeatureLengthType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (a, f, c)
    {
    }

    FeatureLengthType::
    FeatureLengthType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (s, e, f, c)
    {
    }

    FeatureLengthType* FeatureLengthType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureLengthType (*this, f, c);
    }

    FeatureLengthType::
    ~FeatureLengthType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureLengthType >
    _xsd_FeatureLengthType_type_factory_init (
      L"FeatureLengthType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureAreaType
    //

    FeatureAreaType::
    FeatureAreaType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType ()
    {
    }

    FeatureAreaType::
    FeatureAreaType (const FeatureAreaType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c)
    {
    }

    FeatureAreaType::
    FeatureAreaType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f, c)
    {
    }

    FeatureAreaType::
    FeatureAreaType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (a, f, c)
    {
    }

    FeatureAreaType::
    FeatureAreaType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (s, e, f, c)
    {
    }

    FeatureAreaType* FeatureAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureAreaType (*this, f, c);
    }

    FeatureAreaType::
    ~FeatureAreaType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureAreaType >
    _xsd_FeatureAreaType_type_factory_init (
      L"FeatureAreaType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureSizeType
    //

    FeatureSizeType::
    FeatureSizeType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType ()
    {
    }

    FeatureSizeType::
    FeatureSizeType (const FeatureSizeType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c)
    {
    }

    FeatureSizeType::
    FeatureSizeType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f, c)
    {
    }

    FeatureSizeType::
    FeatureSizeType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (a, f, c)
    {
    }

    FeatureSizeType::
    FeatureSizeType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (s, e, f, c)
    {
    }

    FeatureSizeType* FeatureSizeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureSizeType (*this, f, c);
    }

    FeatureSizeType::
    ~FeatureSizeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureSizeType >
    _xsd_FeatureSizeType_type_factory_init (
      L"FeatureSizeType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticFeatureParameter_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticFeatureParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticFeatureParameterType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticCharacteristicParameter_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticCharacteristicParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticCharacteristicParameterType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticDMEParameter_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticDMEParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticDMEParameterType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticPartParameter_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticPartParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticPartParameterType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CharacteristicTolerance_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"CharacteristicTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CharacteristicToleranceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureLength_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureLength",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureLengthType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureArea_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureArea",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureAreaType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureSize_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureSize",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureSizeType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const SamplingCategoryIsType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SamplingCategoryIsType >
    _xsd_SamplingCategoryIsType_type_serializer_init (
      L"SamplingCategoryIsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureIsDatumType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureIsDatumType& i)
    {
      a << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureIsDatumType& i)
    {
      l << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureIsDatumType >
    _xsd_FeatureIsDatumType_type_serializer_init (
      L"FeatureIsDatumType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureIsInternalType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureIsInternalType& i)
    {
      a << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureIsInternalType& i)
    {
      l << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureIsInternalType >
    _xsd_FeatureIsInternalType_type_serializer_init (
      L"FeatureIsInternalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CharacteristicIsType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CharacteristicIsType >
    _xsd_CharacteristicIsType_type_serializer_init (
      L"CharacteristicIsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureTypeIsType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureTypeIsType >
    _xsd_FeatureTypeIsType_type_serializer_init (
      L"FeatureTypeIsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ShapeClassIsType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ShapeClassIsType >
    _xsd_ShapeClassIsType_type_serializer_init (
      L"ShapeClassIsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointSamplingStrategyEnumBaseType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PointSamplingStrategyEnumBaseType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PointSamplingStrategyEnumBaseType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointPointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PointPointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PointPointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const OpenCurvePointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const OpenCurvePointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const OpenCurvePointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ClosedCurvePointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ClosedCurvePointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ClosedCurvePointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedPointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PointDefinedPointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PointDefinedPointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ConePointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ConePointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ConePointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderPointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ElongatedCylinderPointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ElongatedCylinderPointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionPointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ExtrudedCrossSectionPointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ExtrudedCrossSectionPointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SpherePointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SpherePointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SpherePointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionPointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SurfaceOfRevolutionPointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SurfaceOfRevolutionPointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PlanePointSamplingStrategyEnumType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PlanePointSamplingStrategyEnumType& i)
    {
      a << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PlanePointSamplingStrategyEnumType& i)
    {
      l << static_cast< const ::xsd::qif30::PointSamplingStrategyEnumBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CharacteristicTypeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CharacteristicTypeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CharacteristicTypeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureTypeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureTypeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureTypeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DMEClassNameEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DMEClassNameEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DMEClassNameEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ArithmeticComparisonEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ArithmeticComparisonEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ArithmeticComparisonEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CharacteristicIsType >
    _xsd_CharacteristicIs_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"CharacteristicIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CharacteristicIsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureIsDatumType >
    _xsd_FeatureIsDatum_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureIsDatum",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureIsDatumType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureIsInternalType >
    _xsd_FeatureIsInternal_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureIsInternal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureIsInternalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureTypeIsType >
    _xsd_FeatureTypeIs_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureTypeIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureTypeIsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SamplingCategoryIsType >
    _xsd_SamplingCategoryIs_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"SamplingCategoryIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SamplingCategoryIsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ShapeClassIsType >
    _xsd_ShapeClassIs_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ShapeClassIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ShapeClassIsType >);


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticParameterBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // Parameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Parameter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArithmeticFeatureParameterType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticParameterBaseType& > (i);

      // FeatureTypeEnum
      //
      if (i.FeatureTypeEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureTypeEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureTypeEnum ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticFeatureParameterType >
    _xsd_ArithmeticFeatureParameterType_type_serializer_init (
      L"ArithmeticFeatureParameterType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticCharacteristicParameterType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticParameterBaseType& > (i);

      // CharacteristicTypeEnum
      //
      if (i.CharacteristicTypeEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicTypeEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicTypeEnum ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticCharacteristicParameterType >
    _xsd_ArithmeticCharacteristicParameterType_type_serializer_init (
      L"ArithmeticCharacteristicParameterType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticDMEParameterType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticParameterBaseType& > (i);

      // DMEClassNameEnum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEClassNameEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DMEClassNameEnum ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticDMEParameterType >
    _xsd_ArithmeticDMEParameterType_type_serializer_init (
      L"ArithmeticDMEParameterType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticPartParameterType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticParameterBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticPartParameterType >
    _xsd_ArithmeticPartParameterType_type_serializer_init (
      L"ArithmeticPartParameterType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CharacteristicToleranceType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CharacteristicToleranceType& i)
    {
      a << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CharacteristicToleranceType& i)
    {
      l << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CharacteristicToleranceType >
    _xsd_CharacteristicToleranceType_type_serializer_init (
      L"CharacteristicToleranceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureLengthType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureLengthType& i)
    {
      a << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureLengthType& i)
    {
      l << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureLengthType >
    _xsd_FeatureLengthType_type_serializer_init (
      L"FeatureLengthType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureAreaType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureAreaType& i)
    {
      a << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureAreaType& i)
    {
      l << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureAreaType >
    _xsd_FeatureAreaType_type_serializer_init (
      L"FeatureAreaType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureSizeType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const FeatureSizeType& i)
    {
      a << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureSizeType& i)
    {
      l << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureSizeType >
    _xsd_FeatureSizeType_type_serializer_init (
      L"FeatureSizeType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticFeatureParameterType >
    _xsd_ArithmeticFeatureParameter_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticFeatureParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticFeatureParameterType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticCharacteristicParameterType >
    _xsd_ArithmeticCharacteristicParameter_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticCharacteristicParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticCharacteristicParameterType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticDMEParameterType >
    _xsd_ArithmeticDMEParameter_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticDMEParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticDMEParameterType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticPartParameterType >
    _xsd_ArithmeticPartParameter_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticPartParameter",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticPartParameterType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CharacteristicToleranceType >
    _xsd_CharacteristicTolerance_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"CharacteristicTolerance",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CharacteristicToleranceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureLengthType >
    _xsd_FeatureLength_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureLength",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureLengthType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureAreaType >
    _xsd_FeatureArea_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureArea",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureAreaType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureSizeType >
    _xsd_FeatureSize_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureSize",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureSizeType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

