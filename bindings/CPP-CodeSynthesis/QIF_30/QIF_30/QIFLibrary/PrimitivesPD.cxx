// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PrimitivesPD.hxx"

namespace xsd
{
  namespace qif30
  {
    // ColorType
    //


    // QuaternionType
    //

    const QuaternionType::Value_type& QuaternionType::
    Value () const
    {
      return this->Value_.get ();
    }

    QuaternionType::Value_type& QuaternionType::
    Value ()
    {
      return this->Value_.get ();
    }

    void QuaternionType::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void QuaternionType::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }


    // NodeBaseType
    //

    const NodeBaseType::label_optional& NodeBaseType::
    label () const
    {
      return this->label_;
    }

    NodeBaseType::label_optional& NodeBaseType::
    label ()
    {
      return this->label_;
    }

    void NodeBaseType::
    label (const label_type& x)
    {
      this->label_.set (x);
    }

    void NodeBaseType::
    label (const label_optional& x)
    {
      this->label_ = x;
    }

    void NodeBaseType::
    label (::std::unique_ptr< label_type > x)
    {
      this->label_.set (std::move (x));
    }


    // NodeWithIdBaseType
    //

    const NodeWithIdBaseType::Attributes_optional& NodeWithIdBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    NodeWithIdBaseType::Attributes_optional& NodeWithIdBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void NodeWithIdBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void NodeWithIdBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void NodeWithIdBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const NodeWithIdBaseType::id_type& NodeWithIdBaseType::
    id () const
    {
      return this->id_.get ();
    }

    NodeWithIdBaseType::id_type& NodeWithIdBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void NodeWithIdBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void NodeWithIdBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // TransparencyType
    //


    // DrawableBaseType
    //

    const DrawableBaseType::color_optional& DrawableBaseType::
    color () const
    {
      return this->color_;
    }

    DrawableBaseType::color_optional& DrawableBaseType::
    color ()
    {
      return this->color_;
    }

    void DrawableBaseType::
    color (const color_type& x)
    {
      this->color_.set (x);
    }

    void DrawableBaseType::
    color (const color_optional& x)
    {
      this->color_ = x;
    }

    void DrawableBaseType::
    color (::std::unique_ptr< color_type > x)
    {
      this->color_.set (std::move (x));
    }

    const DrawableBaseType::transparency_type& DrawableBaseType::
    transparency () const
    {
      return this->transparency_.get ();
    }

    DrawableBaseType::transparency_type& DrawableBaseType::
    transparency ()
    {
      return this->transparency_.get ();
    }

    void DrawableBaseType::
    transparency (const transparency_type& x)
    {
      this->transparency_.set (x);
    }

    void DrawableBaseType::
    transparency (::std::unique_ptr< transparency_type > x)
    {
      this->transparency_.set (std::move (x));
    }

    DrawableBaseType::transparency_type DrawableBaseType::
    transparency_default_value ()
    {
      return transparency_type (.0);
    }

    const DrawableBaseType::hidden_type& DrawableBaseType::
    hidden () const
    {
      return this->hidden_.get ();
    }

    DrawableBaseType::hidden_type& DrawableBaseType::
    hidden ()
    {
      return this->hidden_.get ();
    }

    void DrawableBaseType::
    hidden (const hidden_type& x)
    {
      this->hidden_.set (x);
    }

    DrawableBaseType::hidden_type DrawableBaseType::
    hidden_default_value ()
    {
      return hidden_type (false);
    }

    const DrawableBaseType::size_optional& DrawableBaseType::
    size () const
    {
      return this->size_;
    }

    DrawableBaseType::size_optional& DrawableBaseType::
    size ()
    {
      return this->size_;
    }

    void DrawableBaseType::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void DrawableBaseType::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    void DrawableBaseType::
    size (::std::unique_ptr< size_type > x)
    {
      this->size_.set (std::move (x));
    }


    // AuthorType
    //

    const AuthorType::Name_optional& AuthorType::
    Name () const
    {
      return this->Name_;
    }

    AuthorType::Name_optional& AuthorType::
    Name ()
    {
      return this->Name_;
    }

    void AuthorType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void AuthorType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void AuthorType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const AuthorType::Organization_optional& AuthorType::
    Organization () const
    {
      return this->Organization_;
    }

    AuthorType::Organization_optional& AuthorType::
    Organization ()
    {
      return this->Organization_;
    }

    void AuthorType::
    Organization (const Organization_type& x)
    {
      this->Organization_.set (x);
    }

    void AuthorType::
    Organization (const Organization_optional& x)
    {
      this->Organization_ = x;
    }

    void AuthorType::
    Organization (::std::unique_ptr< Organization_type > x)
    {
      this->Organization_.set (std::move (x));
    }


    // ApplicationType
    //

    const ApplicationType::Name_type& ApplicationType::
    Name () const
    {
      return this->Name_.get ();
    }

    ApplicationType::Name_type& ApplicationType::
    Name ()
    {
      return this->Name_.get ();
    }

    void ApplicationType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void ApplicationType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const ApplicationType::Organization_optional& ApplicationType::
    Organization () const
    {
      return this->Organization_;
    }

    ApplicationType::Organization_optional& ApplicationType::
    Organization ()
    {
      return this->Organization_;
    }

    void ApplicationType::
    Organization (const Organization_type& x)
    {
      this->Organization_.set (x);
    }

    void ApplicationType::
    Organization (const Organization_optional& x)
    {
      this->Organization_ = x;
    }

    void ApplicationType::
    Organization (::std::unique_ptr< Organization_type > x)
    {
      this->Organization_.set (std::move (x));
    }

    const ApplicationType::AddonName_optional& ApplicationType::
    AddonName () const
    {
      return this->AddonName_;
    }

    ApplicationType::AddonName_optional& ApplicationType::
    AddonName ()
    {
      return this->AddonName_;
    }

    void ApplicationType::
    AddonName (const AddonName_type& x)
    {
      this->AddonName_.set (x);
    }

    void ApplicationType::
    AddonName (const AddonName_optional& x)
    {
      this->AddonName_ = x;
    }

    void ApplicationType::
    AddonName (::std::unique_ptr< AddonName_type > x)
    {
      this->AddonName_.set (std::move (x));
    }

    const ApplicationType::AddonOrganization_optional& ApplicationType::
    AddonOrganization () const
    {
      return this->AddonOrganization_;
    }

    ApplicationType::AddonOrganization_optional& ApplicationType::
    AddonOrganization ()
    {
      return this->AddonOrganization_;
    }

    void ApplicationType::
    AddonOrganization (const AddonOrganization_type& x)
    {
      this->AddonOrganization_.set (x);
    }

    void ApplicationType::
    AddonOrganization (const AddonOrganization_optional& x)
    {
      this->AddonOrganization_ = x;
    }

    void ApplicationType::
    AddonOrganization (::std::unique_ptr< AddonOrganization_type > x)
    {
      this->AddonOrganization_.set (std::move (x));
    }


    // EdgeOrientedType
    //

    const EdgeOrientedType::turned_type& EdgeOrientedType::
    turned () const
    {
      return this->turned_.get ();
    }

    EdgeOrientedType::turned_type& EdgeOrientedType::
    turned ()
    {
      return this->turned_.get ();
    }

    void EdgeOrientedType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    EdgeOrientedType::turned_type EdgeOrientedType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // LineStyleEnumType
    //

    LineStyleEnumType::
    LineStyleEnumType ()
    : ::xml_schema::string ()
    {
    }

    LineStyleEnumType::
    LineStyleEnumType (value v)
    : ::xml_schema::string (_xsd_LineStyleEnumType_literals_[v])
    {
    }

    LineStyleEnumType::
    LineStyleEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    LineStyleEnumType::
    LineStyleEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    LineStyleEnumType::
    LineStyleEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LineStyleEnumType::
    LineStyleEnumType (const LineStyleEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LineStyleEnumType& LineStyleEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LineStyleEnumType_literals_[v]);

      return *this;
    }


    // LineStyleType
    //

    const LineStyleType::thickness_type& LineStyleType::
    thickness () const
    {
      return this->thickness_.get ();
    }

    LineStyleType::thickness_type& LineStyleType::
    thickness ()
    {
      return this->thickness_.get ();
    }

    void LineStyleType::
    thickness (const thickness_type& x)
    {
      this->thickness_.set (x);
    }

    LineStyleType::thickness_type LineStyleType::
    thickness_default_value ()
    {
      return thickness_type (1ULL);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // ColorType
    //

    ColorType::
    ColorType ()
    : ::xsd::qif30::ListIntType ()
    {
    }

    ColorType::
    ColorType (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base)
    {
    }

    ColorType::
    ColorType (const ColorType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c)
    {
    }

    ColorType::
    ColorType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f, c)
    {
    }

    ColorType::
    ColorType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (a, f, c)
    {
    }

    ColorType::
    ColorType (const ::std::wstring& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (s, e, f, c)
    {
    }

    ColorType* ColorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ColorType (*this, f, c);
    }

    ColorType::
    ~ColorType ()
    {
    }

    // QuaternionType
    //

    QuaternionType::
    QuaternionType ()
    : ::xml_schema::type (),
      Value_ (this)
    {
    }

    QuaternionType::
    QuaternionType (const Value_type& Value)
    : ::xml_schema::type (),
      Value_ (Value, this)
    {
    }

    QuaternionType::
    QuaternionType (const QuaternionType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Value_ (x.Value_, f, this)
    {
    }

    QuaternionType::
    QuaternionType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QuaternionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        if (n.name () == L"Value" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    QuaternionType* QuaternionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QuaternionType (*this, f, c);
    }

    QuaternionType& QuaternionType::
    operator= (const QuaternionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Value_ = x.Value_;
      }

      return *this;
    }

    QuaternionType::
    ~QuaternionType ()
    {
    }

    // NodeBaseType
    //

    NodeBaseType::
    NodeBaseType ()
    : ::xml_schema::type (),
      label_ (this)
    {
    }

    NodeBaseType::
    NodeBaseType (const NodeBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      label_ (x.label_, f, this)
    {
    }

    NodeBaseType::
    NodeBaseType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      label_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void NodeBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"label" && n.namespace_ ().empty ())
        {
          this->label_.set (label_traits::create (i, f, this));
          continue;
        }
      }
    }

    NodeBaseType& NodeBaseType::
    operator= (const NodeBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->label_ = x.label_;
      }

      return *this;
    }

    NodeBaseType::
    ~NodeBaseType ()
    {
    }

    // NodeWithIdBaseType
    //

    NodeWithIdBaseType::
    NodeWithIdBaseType ()
    : ::xsd::qif30::NodeBaseType (),
      Attributes_ (this),
      id_ (this)
    {
    }

    NodeWithIdBaseType::
    NodeWithIdBaseType (const id_type& id)
    : ::xsd::qif30::NodeBaseType (),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    NodeWithIdBaseType::
    NodeWithIdBaseType (const NodeWithIdBaseType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::NodeBaseType (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    NodeWithIdBaseType::
    NodeWithIdBaseType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::NodeBaseType (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NodeWithIdBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    NodeWithIdBaseType& NodeWithIdBaseType::
    operator= (const NodeWithIdBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeBaseType& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    NodeWithIdBaseType::
    ~NodeWithIdBaseType ()
    {
    }

    // TransparencyType
    //

    TransparencyType::
    TransparencyType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
    {
    }

    TransparencyType::
    TransparencyType (const ::xml_schema::double_& _xsd_double__base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
    {
    }

    TransparencyType::
    TransparencyType (const TransparencyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    TransparencyType::
    TransparencyType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    TransparencyType::
    TransparencyType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    TransparencyType::
    TransparencyType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    TransparencyType* TransparencyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransparencyType (*this, f, c);
    }

    TransparencyType::
    ~TransparencyType ()
    {
    }

    // DrawableBaseType
    //

    DrawableBaseType::
    DrawableBaseType ()
    : ::xsd::qif30::NodeWithIdBaseType (),
      color_ (this),
      transparency_ (transparency_default_value (), this),
      hidden_ (hidden_default_value (), this),
      size_ (this)
    {
    }

    DrawableBaseType::
    DrawableBaseType (const id_type& id)
    : ::xsd::qif30::NodeWithIdBaseType (id),
      color_ (this),
      transparency_ (transparency_default_value (), this),
      hidden_ (hidden_default_value (), this),
      size_ (this)
    {
    }

    DrawableBaseType::
    DrawableBaseType (const DrawableBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c),
      color_ (x.color_, f, this),
      transparency_ (x.transparency_, f, this),
      hidden_ (x.hidden_, f, this),
      size_ (x.size_, f, this)
    {
    }

    DrawableBaseType::
    DrawableBaseType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f | ::xml_schema::flags::base, c),
      color_ (this),
      transparency_ (this),
      hidden_ (this),
      size_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DrawableBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NodeWithIdBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"color" && n.namespace_ ().empty ())
        {
          this->color_.set (color_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"transparency" && n.namespace_ ().empty ())
        {
          this->transparency_.set (transparency_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"hidden" && n.namespace_ ().empty ())
        {
          this->hidden_.set (hidden_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }
      }

      if (!transparency_.present ())
      {
        this->transparency_.set (transparency_default_value ());
      }

      if (!hidden_.present ())
      {
        this->hidden_.set (hidden_default_value ());
      }
    }

    DrawableBaseType& DrawableBaseType::
    operator= (const DrawableBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NodeWithIdBaseType& > (*this) = x;
        this->color_ = x.color_;
        this->transparency_ = x.transparency_;
        this->hidden_ = x.hidden_;
        this->size_ = x.size_;
      }

      return *this;
    }

    DrawableBaseType::
    ~DrawableBaseType ()
    {
    }

    // AuthorType
    //

    AuthorType::
    AuthorType ()
    : ::xml_schema::type (),
      Name_ (this),
      Organization_ (this)
    {
    }

    AuthorType::
    AuthorType (const AuthorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Organization_ (x.Organization_, f, this)
    {
    }

    AuthorType::
    AuthorType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Organization_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AuthorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Organization
        //
        if (n.name () == L"Organization" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Organization_type > r (
            Organization_traits::create (i, f, this));

          if (!this->Organization_)
          {
            this->Organization_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AuthorType* AuthorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AuthorType (*this, f, c);
    }

    AuthorType& AuthorType::
    operator= (const AuthorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Organization_ = x.Organization_;
      }

      return *this;
    }

    AuthorType::
    ~AuthorType ()
    {
    }

    // ApplicationType
    //

    ApplicationType::
    ApplicationType ()
    : ::xml_schema::type (),
      Name_ (this),
      Organization_ (this),
      AddonName_ (this),
      AddonOrganization_ (this)
    {
    }

    ApplicationType::
    ApplicationType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Organization_ (this),
      AddonName_ (this),
      AddonOrganization_ (this)
    {
    }

    ApplicationType::
    ApplicationType (const ApplicationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Organization_ (x.Organization_, f, this),
      AddonName_ (x.AddonName_, f, this),
      AddonOrganization_ (x.AddonOrganization_, f, this)
    {
    }

    ApplicationType::
    ApplicationType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Organization_ (this),
      AddonName_ (this),
      AddonOrganization_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ApplicationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Organization
        //
        if (n.name () == L"Organization" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Organization_type > r (
            Organization_traits::create (i, f, this));

          if (!this->Organization_)
          {
            this->Organization_.set (::std::move (r));
            continue;
          }
        }

        // AddonName
        //
        if (n.name () == L"AddonName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AddonName_type > r (
            AddonName_traits::create (i, f, this));

          if (!this->AddonName_)
          {
            this->AddonName_.set (::std::move (r));
            continue;
          }
        }

        // AddonOrganization
        //
        if (n.name () == L"AddonOrganization" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AddonOrganization_type > r (
            AddonOrganization_traits::create (i, f, this));

          if (!this->AddonOrganization_)
          {
            this->AddonOrganization_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ApplicationType* ApplicationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ApplicationType (*this, f, c);
    }

    ApplicationType& ApplicationType::
    operator= (const ApplicationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Organization_ = x.Organization_;
        this->AddonName_ = x.AddonName_;
        this->AddonOrganization_ = x.AddonOrganization_;
      }

      return *this;
    }

    ApplicationType::
    ~ApplicationType ()
    {
    }

    // EdgeOrientedType
    //

    EdgeOrientedType::
    EdgeOrientedType ()
    : ::xsd::qif30::ElementReferenceType (),
      turned_ (turned_default_value (), this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const Id_type& Id)
    : ::xsd::qif30::ElementReferenceType (Id),
      turned_ (turned_default_value (), this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (::std::unique_ptr< Id_type > Id)
    : ::xsd::qif30::ElementReferenceType (std::move (Id)),
      turned_ (turned_default_value (), this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const EdgeOrientedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ElementReferenceType (x, f, c),
      turned_ (x.turned_, f, this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ElementReferenceType (e, f | ::xml_schema::flags::base, c),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeOrientedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ElementReferenceType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    EdgeOrientedType* EdgeOrientedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeOrientedType (*this, f, c);
    }

    EdgeOrientedType& EdgeOrientedType::
    operator= (const EdgeOrientedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ElementReferenceType& > (*this) = x;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    EdgeOrientedType::
    ~EdgeOrientedType ()
    {
    }

    // LineStyleEnumType
    //

    LineStyleEnumType::
    LineStyleEnumType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LineStyleEnumType_convert ();
    }

    LineStyleEnumType::
    LineStyleEnumType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LineStyleEnumType_convert ();
    }

    LineStyleEnumType::
    LineStyleEnumType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LineStyleEnumType_convert ();
    }

    LineStyleEnumType* LineStyleEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineStyleEnumType (*this, f, c);
    }

    LineStyleEnumType::value LineStyleEnumType::
    _xsd_LineStyleEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LineStyleEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LineStyleEnumType_indexes_,
                        _xsd_LineStyleEnumType_indexes_ + 21,
                        *this,
                        c));

      if (i == _xsd_LineStyleEnumType_indexes_ + 21 || _xsd_LineStyleEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LineStyleEnumType::
    _xsd_LineStyleEnumType_literals_[21] =
    {
      L"SOLID",
      L"DOT",
      L"DASH",
      L"DASH_DOT",
      L"DASH_DOT_DOT",
      L"DASH_DOT_DOT_DOT",
      L"DASH_DASH_DOT",
      L"DASH_DASH_DOT_DOT",
      L"DASH_DASH_DOT_DOT_DOT",
      L"SHORT_DASH",
      L"LONG_DASH",
      L"MEDIUM_LONG_DASH",
      L"MEDIUM_DASH_SHORT_DASH_SHORT_DASH",
      L"LONG_DASH_SHORT_DASH",
      L"LONG_DASH_SHORT_DASH_SHORT_DASH",
      L"LONG_DASH_DOT_DOT",
      L"LONG_DASH_DOT",
      L"MEDIUM_DASH_DOT_SHORT_DASH_DOT",
      L"SPARSE_DOT",
      L"CENTERLINE",
      L"PHANTOM"
    };

    const LineStyleEnumType::value LineStyleEnumType::
    _xsd_LineStyleEnumType_indexes_[21] =
    {
      ::xsd::qif30::LineStyleEnumType::CENTERLINE,
      ::xsd::qif30::LineStyleEnumType::DASH,
      ::xsd::qif30::LineStyleEnumType::DASH_DASH_DOT,
      ::xsd::qif30::LineStyleEnumType::DASH_DASH_DOT_DOT,
      ::xsd::qif30::LineStyleEnumType::DASH_DASH_DOT_DOT_DOT,
      ::xsd::qif30::LineStyleEnumType::DASH_DOT,
      ::xsd::qif30::LineStyleEnumType::DASH_DOT_DOT,
      ::xsd::qif30::LineStyleEnumType::DASH_DOT_DOT_DOT,
      ::xsd::qif30::LineStyleEnumType::DOT,
      ::xsd::qif30::LineStyleEnumType::LONG_DASH,
      ::xsd::qif30::LineStyleEnumType::LONG_DASH_DOT,
      ::xsd::qif30::LineStyleEnumType::LONG_DASH_DOT_DOT,
      ::xsd::qif30::LineStyleEnumType::LONG_DASH_SHORT_DASH,
      ::xsd::qif30::LineStyleEnumType::LONG_DASH_SHORT_DASH_SHORT_DASH,
      ::xsd::qif30::LineStyleEnumType::MEDIUM_DASH_DOT_SHORT_DASH_DOT,
      ::xsd::qif30::LineStyleEnumType::MEDIUM_DASH_SHORT_DASH_SHORT_DASH,
      ::xsd::qif30::LineStyleEnumType::MEDIUM_LONG_DASH,
      ::xsd::qif30::LineStyleEnumType::PHANTOM,
      ::xsd::qif30::LineStyleEnumType::SHORT_DASH,
      ::xsd::qif30::LineStyleEnumType::SOLID,
      ::xsd::qif30::LineStyleEnumType::SPARSE_DOT
    };

    // LineStyleType
    //

    LineStyleType::
    LineStyleType ()
    : ::xsd::qif30::LineStyleEnumType (),
      thickness_ (thickness_default_value (), this)
    {
    }

    LineStyleType::
    LineStyleType (::xsd::qif30::LineStyleEnumType::value _xsd_LineStyleEnumType_base)
    : ::xsd::qif30::LineStyleEnumType (_xsd_LineStyleEnumType_base),
      thickness_ (thickness_default_value (), this)
    {
    }

    LineStyleType::
    LineStyleType (const wchar_t* _xsd_string_base)
    : ::xsd::qif30::LineStyleEnumType (_xsd_string_base),
      thickness_ (thickness_default_value (), this)
    {
    }

    LineStyleType::
    LineStyleType (const ::std::wstring& _xsd_string_base)
    : ::xsd::qif30::LineStyleEnumType (_xsd_string_base),
      thickness_ (thickness_default_value (), this)
    {
    }

    LineStyleType::
    LineStyleType (const ::xsd::qif30::LineStyleEnumType& _xsd_LineStyleEnumType_base)
    : ::xsd::qif30::LineStyleEnumType (_xsd_LineStyleEnumType_base),
      thickness_ (thickness_default_value (), this)
    {
    }

    LineStyleType::
    LineStyleType (const LineStyleType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::LineStyleEnumType (x, f, c),
      thickness_ (x.thickness_, f, this)
    {
    }

    LineStyleType::
    LineStyleType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::LineStyleEnumType (e, f | ::xml_schema::flags::base, c),
      thickness_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LineStyleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"thickness" && n.namespace_ ().empty ())
        {
          this->thickness_.set (thickness_traits::create (i, f, this));
          continue;
        }
      }

      if (!thickness_.present ())
      {
        this->thickness_.set (thickness_default_value ());
      }
    }

    LineStyleType* LineStyleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineStyleType (*this, f, c);
    }

    LineStyleType& LineStyleType::
    operator= (const LineStyleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LineStyleEnumType& > (*this) = x;
        this->thickness_ = x.thickness_;
      }

      return *this;
    }

    LineStyleType::
    ~LineStyleType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const ColorType& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ColorType& i)
    {
      a << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ColorType& i)
    {
      l << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QuaternionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Value
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Value",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Value ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NodeBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // label
      //
      if (i.label ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"label",
            e));

        a << *i.label ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NodeWithIdBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeBaseType& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransparencyType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TransparencyType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TransparencyType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DrawableBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);

      // color
      //
      if (i.color ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"color",
            e));

        a << *i.color ();
      }

      // transparency
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"transparency",
            e));

        a << i.transparency ();
      }

      // hidden
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"hidden",
            e));

        a << i.hidden ();
      }

      // size
      //
      if (i.size ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"size",
            e));

        a << *i.size ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AuthorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Organization
      //
      if (i.Organization ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Organization",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Organization ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ApplicationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Organization
      //
      if (i.Organization ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Organization",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Organization ();
      }

      // AddonName
      //
      if (i.AddonName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AddonName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AddonName ();
      }

      // AddonOrganization
      //
      if (i.AddonOrganization ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AddonOrganization",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AddonOrganization ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgeOrientedType& i)
    {
      e << static_cast< const ::xsd::qif30::ElementReferenceType& > (i);

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineStyleEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LineStyleEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LineStyleEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LineStyleType& i)
    {
      e << static_cast< const ::xsd::qif30::LineStyleEnumType& > (i);

      // thickness
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"thickness",
            e));

        a << i.thickness ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

