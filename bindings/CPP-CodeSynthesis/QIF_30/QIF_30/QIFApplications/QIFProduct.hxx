// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFAPPLICATIONS_QIFPRODUCT_HXX
#define CXX___QIFAPPLICATIONS_QIFPRODUCT_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class ProductType;
    class AsmPathType;
    class AsmPathsType;
    class ValidationPartAssemblyType;
    class ValidationPartAssemblyInstancesType;
    class ValidationPartAssemblyInstanceType;
    class PartAssemblyBaseType;
    class PartType;
    class FoldersPartType;
    class FoldersAssemblyType;
    class FolderPartAssemblyBaseType;
    class FolderPartType;
    class FolderAssemblyType;
    class AssemblyType;
    class PartFamilyType;
    class PartSetType;
    class AssemblySetType;
    class ComponentType;
    class ComponentSetType;
    class PrintedDrawingType;
    class GDTEnumType;
    class TopologyEnumType;
    class DigitalModelType;
    class DefinitionExternalType;
    class DigitalDrawingType;
    class PhysicalModelType;
    class PartAssemblyHeaderType;
    class ProductHeaderType;
    class LayerType;
    class LayerSetType;
    class PartNoteSetType;
    class PartNoteType;
    class NoteType;
    class NoteFormEnumType;
    class NoteSetType;
    class NoteFlagType;
    class NoteFlagSetType;
    class FileInternalType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Geometry.hxx"

#include "../QIFLibrary/Topology.hxx"

#include "../QIFLibrary/Auxiliary.hxx"

#include "../QIFLibrary/Visualization.hxx"

#include "../QIFLibrary/Traceability.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL ProductType: public ::xml_schema::type
    {
      public:
      // Header
      //
      typedef ::xsd::qif30::ProductHeaderType Header_type;
      typedef ::xsd::cxx::tree::optional< Header_type > Header_optional;
      typedef ::xsd::cxx::tree::traits< Header_type, wchar_t > Header_traits;

      const Header_optional&
      Header () const;

      Header_optional&
      Header ();

      void
      Header (const Header_type& x);

      void
      Header (const Header_optional& x);

      void
      Header (::std::unique_ptr< Header_type > p);

      // GeometrySet
      //
      typedef ::xsd::qif30::GeometrySetType GeometrySet_type;
      typedef ::xsd::cxx::tree::optional< GeometrySet_type > GeometrySet_optional;
      typedef ::xsd::cxx::tree::traits< GeometrySet_type, wchar_t > GeometrySet_traits;

      const GeometrySet_optional&
      GeometrySet () const;

      GeometrySet_optional&
      GeometrySet ();

      void
      GeometrySet (const GeometrySet_type& x);

      void
      GeometrySet (const GeometrySet_optional& x);

      void
      GeometrySet (::std::unique_ptr< GeometrySet_type > p);

      // TopologySet
      //
      typedef ::xsd::qif30::TopologySetType TopologySet_type;
      typedef ::xsd::cxx::tree::optional< TopologySet_type > TopologySet_optional;
      typedef ::xsd::cxx::tree::traits< TopologySet_type, wchar_t > TopologySet_traits;

      const TopologySet_optional&
      TopologySet () const;

      TopologySet_optional&
      TopologySet ();

      void
      TopologySet (const TopologySet_type& x);

      void
      TopologySet (const TopologySet_optional& x);

      void
      TopologySet (::std::unique_ptr< TopologySet_type > p);

      // NoteSet
      //
      typedef ::xsd::qif30::NoteSetType NoteSet_type;
      typedef ::xsd::cxx::tree::optional< NoteSet_type > NoteSet_optional;
      typedef ::xsd::cxx::tree::traits< NoteSet_type, wchar_t > NoteSet_traits;

      const NoteSet_optional&
      NoteSet () const;

      NoteSet_optional&
      NoteSet ();

      void
      NoteSet (const NoteSet_type& x);

      void
      NoteSet (const NoteSet_optional& x);

      void
      NoteSet (::std::unique_ptr< NoteSet_type > p);

      // NoteFlagSet
      //
      typedef ::xsd::qif30::NoteFlagSetType NoteFlagSet_type;
      typedef ::xsd::cxx::tree::optional< NoteFlagSet_type > NoteFlagSet_optional;
      typedef ::xsd::cxx::tree::traits< NoteFlagSet_type, wchar_t > NoteFlagSet_traits;

      const NoteFlagSet_optional&
      NoteFlagSet () const;

      NoteFlagSet_optional&
      NoteFlagSet ();

      void
      NoteFlagSet (const NoteFlagSet_type& x);

      void
      NoteFlagSet (const NoteFlagSet_optional& x);

      void
      NoteFlagSet (::std::unique_ptr< NoteFlagSet_type > p);

      // PartNoteSet
      //
      typedef ::xsd::qif30::PartNoteSetType PartNoteSet_type;
      typedef ::xsd::cxx::tree::optional< PartNoteSet_type > PartNoteSet_optional;
      typedef ::xsd::cxx::tree::traits< PartNoteSet_type, wchar_t > PartNoteSet_traits;

      const PartNoteSet_optional&
      PartNoteSet () const;

      PartNoteSet_optional&
      PartNoteSet ();

      void
      PartNoteSet (const PartNoteSet_type& x);

      void
      PartNoteSet (const PartNoteSet_optional& x);

      void
      PartNoteSet (::std::unique_ptr< PartNoteSet_type > p);

      // ViewSet
      //
      typedef ::xsd::qif30::ViewSetType ViewSet_type;
      typedef ::xsd::cxx::tree::optional< ViewSet_type > ViewSet_optional;
      typedef ::xsd::cxx::tree::traits< ViewSet_type, wchar_t > ViewSet_traits;

      const ViewSet_optional&
      ViewSet () const;

      ViewSet_optional&
      ViewSet ();

      void
      ViewSet (const ViewSet_type& x);

      void
      ViewSet (const ViewSet_optional& x);

      void
      ViewSet (::std::unique_ptr< ViewSet_type > p);

      // LayerSet
      //
      typedef ::xsd::qif30::LayerSetType LayerSet_type;
      typedef ::xsd::cxx::tree::optional< LayerSet_type > LayerSet_optional;
      typedef ::xsd::cxx::tree::traits< LayerSet_type, wchar_t > LayerSet_traits;

      const LayerSet_optional&
      LayerSet () const;

      LayerSet_optional&
      LayerSet ();

      void
      LayerSet (const LayerSet_type& x);

      void
      LayerSet (const LayerSet_optional& x);

      void
      LayerSet (::std::unique_ptr< LayerSet_type > p);

      // CoordinateSystemSet
      //
      typedef ::xsd::qif30::CoordinateSystemSetType CoordinateSystemSet_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemSet_type > CoordinateSystemSet_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemSet_type, wchar_t > CoordinateSystemSet_traits;

      const CoordinateSystemSet_optional&
      CoordinateSystemSet () const;

      CoordinateSystemSet_optional&
      CoordinateSystemSet ();

      void
      CoordinateSystemSet (const CoordinateSystemSet_type& x);

      void
      CoordinateSystemSet (const CoordinateSystemSet_optional& x);

      void
      CoordinateSystemSet (::std::unique_ptr< CoordinateSystemSet_type > p);

      // VisualizationSet
      //
      typedef ::xsd::qif30::VisualizationSetType VisualizationSet_type;
      typedef ::xsd::cxx::tree::optional< VisualizationSet_type > VisualizationSet_optional;
      typedef ::xsd::cxx::tree::traits< VisualizationSet_type, wchar_t > VisualizationSet_traits;

      const VisualizationSet_optional&
      VisualizationSet () const;

      VisualizationSet_optional&
      VisualizationSet ();

      void
      VisualizationSet (const VisualizationSet_type& x);

      void
      VisualizationSet (const VisualizationSet_optional& x);

      void
      VisualizationSet (::std::unique_ptr< VisualizationSet_type > p);

      // AuxiliarySet
      //
      typedef ::xsd::qif30::AuxiliarySetType AuxiliarySet_type;
      typedef ::xsd::cxx::tree::optional< AuxiliarySet_type > AuxiliarySet_optional;
      typedef ::xsd::cxx::tree::traits< AuxiliarySet_type, wchar_t > AuxiliarySet_traits;

      const AuxiliarySet_optional&
      AuxiliarySet () const;

      AuxiliarySet_optional&
      AuxiliarySet ();

      void
      AuxiliarySet (const AuxiliarySet_type& x);

      void
      AuxiliarySet (const AuxiliarySet_optional& x);

      void
      AuxiliarySet (::std::unique_ptr< AuxiliarySet_type > p);

      // PartSet
      //
      typedef ::xsd::qif30::PartSetType PartSet_type;
      typedef ::xsd::cxx::tree::optional< PartSet_type > PartSet_optional;
      typedef ::xsd::cxx::tree::traits< PartSet_type, wchar_t > PartSet_traits;

      const PartSet_optional&
      PartSet () const;

      PartSet_optional&
      PartSet ();

      void
      PartSet (const PartSet_type& x);

      void
      PartSet (const PartSet_optional& x);

      void
      PartSet (::std::unique_ptr< PartSet_type > p);

      // AssemblySet
      //
      typedef ::xsd::qif30::AssemblySetType AssemblySet_type;
      typedef ::xsd::cxx::tree::optional< AssemblySet_type > AssemblySet_optional;
      typedef ::xsd::cxx::tree::traits< AssemblySet_type, wchar_t > AssemblySet_traits;

      const AssemblySet_optional&
      AssemblySet () const;

      AssemblySet_optional&
      AssemblySet ();

      void
      AssemblySet (const AssemblySet_type& x);

      void
      AssemblySet (const AssemblySet_optional& x);

      void
      AssemblySet (::std::unique_ptr< AssemblySet_type > p);

      // ComponentSet
      //
      typedef ::xsd::qif30::ComponentSetType ComponentSet_type;
      typedef ::xsd::cxx::tree::optional< ComponentSet_type > ComponentSet_optional;
      typedef ::xsd::cxx::tree::traits< ComponentSet_type, wchar_t > ComponentSet_traits;

      const ComponentSet_optional&
      ComponentSet () const;

      ComponentSet_optional&
      ComponentSet ();

      void
      ComponentSet (const ComponentSet_type& x);

      void
      ComponentSet (const ComponentSet_optional& x);

      void
      ComponentSet (::std::unique_ptr< ComponentSet_type > p);

      // RootPart
      //
      typedef ::xsd::qif30::ElementReferenceType RootPart_type;
      typedef ::xsd::cxx::tree::optional< RootPart_type > RootPart_optional;
      typedef ::xsd::cxx::tree::traits< RootPart_type, wchar_t > RootPart_traits;

      const RootPart_optional&
      RootPart () const;

      RootPart_optional&
      RootPart ();

      void
      RootPart (const RootPart_type& x);

      void
      RootPart (const RootPart_optional& x);

      void
      RootPart (::std::unique_ptr< RootPart_type > p);

      // RootAssembly
      //
      typedef ::xsd::qif30::ElementReferenceType RootAssembly_type;
      typedef ::xsd::cxx::tree::optional< RootAssembly_type > RootAssembly_optional;
      typedef ::xsd::cxx::tree::traits< RootAssembly_type, wchar_t > RootAssembly_traits;

      const RootAssembly_optional&
      RootAssembly () const;

      RootAssembly_optional&
      RootAssembly ();

      void
      RootAssembly (const RootAssembly_type& x);

      void
      RootAssembly (const RootAssembly_optional& x);

      void
      RootAssembly (::std::unique_ptr< RootAssembly_type > p);

      // RootComponent
      //
      typedef ::xsd::qif30::ElementReferenceType RootComponent_type;
      typedef ::xsd::cxx::tree::optional< RootComponent_type > RootComponent_optional;
      typedef ::xsd::cxx::tree::traits< RootComponent_type, wchar_t > RootComponent_traits;

      const RootComponent_optional&
      RootComponent () const;

      RootComponent_optional&
      RootComponent ();

      void
      RootComponent (const RootComponent_type& x);

      void
      RootComponent (const RootComponent_optional& x);

      void
      RootComponent (::std::unique_ptr< RootComponent_type > p);

      // AsmPaths
      //
      typedef ::xsd::qif30::AsmPathsType AsmPaths_type;
      typedef ::xsd::cxx::tree::optional< AsmPaths_type > AsmPaths_optional;
      typedef ::xsd::cxx::tree::traits< AsmPaths_type, wchar_t > AsmPaths_traits;

      const AsmPaths_optional&
      AsmPaths () const;

      AsmPaths_optional&
      AsmPaths ();

      void
      AsmPaths (const AsmPaths_type& x);

      void
      AsmPaths (const AsmPaths_optional& x);

      void
      AsmPaths (::std::unique_ptr< AsmPaths_type > p);

      // MaterialLibrary
      //
      typedef ::xsd::qif30::MaterialsType MaterialLibrary_type;
      typedef ::xsd::cxx::tree::optional< MaterialLibrary_type > MaterialLibrary_optional;
      typedef ::xsd::cxx::tree::traits< MaterialLibrary_type, wchar_t > MaterialLibrary_traits;

      const MaterialLibrary_optional&
      MaterialLibrary () const;

      MaterialLibrary_optional&
      MaterialLibrary ();

      void
      MaterialLibrary (const MaterialLibrary_type& x);

      void
      MaterialLibrary (const MaterialLibrary_optional& x);

      void
      MaterialLibrary (::std::unique_ptr< MaterialLibrary_type > p);

      // Constructors.
      //
      ProductType ();

      ProductType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ProductType (const ProductType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ProductType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductType&
      operator= (const ProductType& x);

      virtual 
      ~ProductType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Header_optional Header_;
      GeometrySet_optional GeometrySet_;
      TopologySet_optional TopologySet_;
      NoteSet_optional NoteSet_;
      NoteFlagSet_optional NoteFlagSet_;
      PartNoteSet_optional PartNoteSet_;
      ViewSet_optional ViewSet_;
      LayerSet_optional LayerSet_;
      CoordinateSystemSet_optional CoordinateSystemSet_;
      VisualizationSet_optional VisualizationSet_;
      AuxiliarySet_optional AuxiliarySet_;
      PartSet_optional PartSet_;
      AssemblySet_optional AssemblySet_;
      ComponentSet_optional ComponentSet_;
      RootPart_optional RootPart_;
      RootAssembly_optional RootAssembly_;
      RootComponent_optional RootComponent_;
      AsmPaths_optional AsmPaths_;
      MaterialLibrary_optional MaterialLibrary_;
    };

    class QIF30_SYMBOL_DECL AsmPathType: public ::xml_schema::type
    {
      public:
      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ComponentIds_type;
      typedef ::xsd::cxx::tree::optional< ComponentIds_type > ComponentIds_optional;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_optional&
      ComponentIds () const;

      ComponentIds_optional&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (const ComponentIds_optional& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      AsmPathType ();

      AsmPathType (const id_type&);

      AsmPathType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      AsmPathType (const AsmPathType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual AsmPathType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AsmPathType&
      operator= (const AsmPathType& x);

      virtual 
      ~AsmPathType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ComponentIds_optional ComponentIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL AsmPathsType: public ::xml_schema::type
    {
      public:
      // AsmPath
      //
      typedef ::xsd::qif30::AsmPathType AsmPath_type;
      typedef ::xsd::cxx::tree::sequence< AsmPath_type > AsmPath_sequence;
      typedef xsd::cxx::tree::sequence< AsmPath_type >::iterator AsmPath_iterator;
      typedef xsd::cxx::tree::sequence< AsmPath_type >::const_iterator AsmPath_const_iterator;
      typedef ::xsd::cxx::tree::traits< AsmPath_type, wchar_t > AsmPath_traits;

      const AsmPath_sequence&
      AsmPath () const;

      AsmPath_sequence&
      AsmPath ();

      void
      AsmPath (const AsmPath_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AsmPathsType ();

      AsmPathsType (const n_type&);

      AsmPathsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      AsmPathsType (const AsmPathsType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual AsmPathsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AsmPathsType&
      operator= (const AsmPathsType& x);

      virtual 
      ~AsmPathsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AsmPath_sequence AsmPath_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ValidationPartAssemblyType: public ::xml_schema::type
    {
      public:
      // Area
      //
      typedef ::xml_schema::double_ Area_type;
      typedef ::xsd::cxx::tree::optional< Area_type > Area_optional;
      typedef ::xsd::cxx::tree::traits< Area_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Area_traits;

      const Area_optional&
      Area () const;

      Area_optional&
      Area ();

      void
      Area (const Area_type& x);

      void
      Area (const Area_optional& x);

      // Centroid
      //
      typedef ::xsd::qif30::PointSimpleType Centroid_type;
      typedef ::xsd::cxx::tree::optional< Centroid_type > Centroid_optional;
      typedef ::xsd::cxx::tree::traits< Centroid_type, wchar_t > Centroid_traits;

      const Centroid_optional&
      Centroid () const;

      Centroid_optional&
      Centroid ();

      void
      Centroid (const Centroid_type& x);

      void
      Centroid (const Centroid_optional& x);

      void
      Centroid (::std::unique_ptr< Centroid_type > p);

      // Volume
      //
      typedef ::xml_schema::double_ Volume_type;
      typedef ::xsd::cxx::tree::optional< Volume_type > Volume_optional;
      typedef ::xsd::cxx::tree::traits< Volume_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Volume_traits;

      const Volume_optional&
      Volume () const;

      Volume_optional&
      Volume ();

      void
      Volume (const Volume_type& x);

      void
      Volume (const Volume_optional& x);

      // Box
      //
      typedef ::xsd::qif30::BoundingBoxAxisAlignedType Box_type;
      typedef ::xsd::cxx::tree::optional< Box_type > Box_optional;
      typedef ::xsd::cxx::tree::traits< Box_type, wchar_t > Box_traits;

      const Box_optional&
      Box () const;

      Box_optional&
      Box ();

      void
      Box (const Box_type& x);

      void
      Box (const Box_optional& x);

      void
      Box (::std::unique_ptr< Box_type > p);

      // FacePoints
      //
      typedef ::xsd::qif30::ValidationPointsType FacePoints_type;
      typedef ::xsd::cxx::tree::optional< FacePoints_type > FacePoints_optional;
      typedef ::xsd::cxx::tree::traits< FacePoints_type, wchar_t > FacePoints_traits;

      const FacePoints_optional&
      FacePoints () const;

      FacePoints_optional&
      FacePoints ();

      void
      FacePoints (const FacePoints_type& x);

      void
      FacePoints (const FacePoints_optional& x);

      void
      FacePoints (::std::unique_ptr< FacePoints_type > p);

      // EdgePoints
      //
      typedef ::xsd::qif30::ValidationPointsType EdgePoints_type;
      typedef ::xsd::cxx::tree::optional< EdgePoints_type > EdgePoints_optional;
      typedef ::xsd::cxx::tree::traits< EdgePoints_type, wchar_t > EdgePoints_traits;

      const EdgePoints_optional&
      EdgePoints () const;

      EdgePoints_optional&
      EdgePoints ();

      void
      EdgePoints (const EdgePoints_type& x);

      void
      EdgePoints (const EdgePoints_optional& x);

      void
      EdgePoints (::std::unique_ptr< EdgePoints_type > p);

      // Instances
      //
      typedef ::xsd::qif30::ValidationPartAssemblyInstancesType Instances_type;
      typedef ::xsd::cxx::tree::optional< Instances_type > Instances_optional;
      typedef ::xsd::cxx::tree::traits< Instances_type, wchar_t > Instances_traits;

      const Instances_optional&
      Instances () const;

      Instances_optional&
      Instances ();

      void
      Instances (const Instances_type& x);

      void
      Instances (const Instances_optional& x);

      void
      Instances (::std::unique_ptr< Instances_type > p);

      // Constructors.
      //
      ValidationPartAssemblyType ();

      ValidationPartAssemblyType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ValidationPartAssemblyType (const ValidationPartAssemblyType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ValidationPartAssemblyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationPartAssemblyType&
      operator= (const ValidationPartAssemblyType& x);

      virtual 
      ~ValidationPartAssemblyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Area_optional Area_;
      Centroid_optional Centroid_;
      Volume_optional Volume_;
      Box_optional Box_;
      FacePoints_optional FacePoints_;
      EdgePoints_optional EdgePoints_;
      Instances_optional Instances_;
    };

    class QIF30_SYMBOL_DECL ValidationPartAssemblyInstancesType: public ::xml_schema::type
    {
      public:
      // Instance
      //
      typedef ::xsd::qif30::ValidationPartAssemblyInstanceType Instance_type;
      typedef ::xsd::cxx::tree::sequence< Instance_type > Instance_sequence;
      typedef xsd::cxx::tree::sequence< Instance_type >::iterator Instance_iterator;
      typedef xsd::cxx::tree::sequence< Instance_type >::const_iterator Instance_const_iterator;
      typedef ::xsd::cxx::tree::traits< Instance_type, wchar_t > Instance_traits;

      const Instance_sequence&
      Instance () const;

      Instance_sequence&
      Instance ();

      void
      Instance (const Instance_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ValidationPartAssemblyInstancesType ();

      ValidationPartAssemblyInstancesType (const n_type&);

      ValidationPartAssemblyInstancesType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ValidationPartAssemblyInstancesType (const ValidationPartAssemblyInstancesType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ValidationPartAssemblyInstancesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationPartAssemblyInstancesType&
      operator= (const ValidationPartAssemblyInstancesType& x);

      virtual 
      ~ValidationPartAssemblyInstancesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Instance_sequence Instance_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ValidationPartAssemblyInstanceType: public ::xml_schema::type
    {
      public:
      // AsmPathId
      //
      typedef ::xsd::qif30::QIFReferenceType AsmPathId_type;
      typedef ::xsd::cxx::tree::traits< AsmPathId_type, wchar_t > AsmPathId_traits;

      const AsmPathId_type&
      AsmPathId () const;

      AsmPathId_type&
      AsmPathId ();

      void
      AsmPathId (const AsmPathId_type& x);

      void
      AsmPathId (::std::unique_ptr< AsmPathId_type > p);

      // Centroid
      //
      typedef ::xsd::qif30::PointSimpleType Centroid_type;
      typedef ::xsd::cxx::tree::optional< Centroid_type > Centroid_optional;
      typedef ::xsd::cxx::tree::traits< Centroid_type, wchar_t > Centroid_traits;

      const Centroid_optional&
      Centroid () const;

      Centroid_optional&
      Centroid ();

      void
      Centroid (const Centroid_type& x);

      void
      Centroid (const Centroid_optional& x);

      void
      Centroid (::std::unique_ptr< Centroid_type > p);

      // Box
      //
      typedef ::xsd::qif30::BoundingBoxAxisAlignedType Box_type;
      typedef ::xsd::cxx::tree::optional< Box_type > Box_optional;
      typedef ::xsd::cxx::tree::traits< Box_type, wchar_t > Box_traits;

      const Box_optional&
      Box () const;

      Box_optional&
      Box ();

      void
      Box (const Box_type& x);

      void
      Box (const Box_optional& x);

      void
      Box (::std::unique_ptr< Box_type > p);

      // Constructors.
      //
      ValidationPartAssemblyInstanceType ();

      ValidationPartAssemblyInstanceType (const AsmPathId_type&);

      ValidationPartAssemblyInstanceType (::std::unique_ptr< AsmPathId_type >);

      ValidationPartAssemblyInstanceType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ValidationPartAssemblyInstanceType (const ValidationPartAssemblyInstanceType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ValidationPartAssemblyInstanceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationPartAssemblyInstanceType&
      operator= (const ValidationPartAssemblyInstanceType& x);

      virtual 
      ~ValidationPartAssemblyInstanceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AsmPathId_type > AsmPathId_;
      Centroid_optional Centroid_;
      Box_optional Box_;
    };

    class QIF30_SYMBOL_DECL PartAssemblyBaseType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // Validation
      //
      typedef ::xsd::qif30::ValidationPartAssemblyType Validation_type;
      typedef ::xsd::cxx::tree::optional< Validation_type > Validation_optional;
      typedef ::xsd::cxx::tree::traits< Validation_type, wchar_t > Validation_traits;

      const Validation_optional&
      Validation () const;

      Validation_optional&
      Validation ();

      void
      Validation (const Validation_type& x);

      void
      Validation (const Validation_optional& x);

      void
      Validation (::std::unique_ptr< Validation_type > p);

      // Header
      //
      typedef ::xsd::qif30::PartAssemblyHeaderType Header_type;
      typedef ::xsd::cxx::tree::optional< Header_type > Header_optional;
      typedef ::xsd::cxx::tree::traits< Header_type, wchar_t > Header_traits;

      const Header_optional&
      Header () const;

      Header_optional&
      Header ();

      void
      Header (const Header_type& x);

      void
      Header (const Header_optional& x);

      void
      Header (::std::unique_ptr< Header_type > p);

      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // ModelNumber
      //
      typedef ::xml_schema::string ModelNumber_type;
      typedef ::xsd::cxx::tree::optional< ModelNumber_type > ModelNumber_optional;
      typedef ::xsd::cxx::tree::traits< ModelNumber_type, wchar_t > ModelNumber_traits;

      const ModelNumber_optional&
      ModelNumber () const;

      ModelNumber_optional&
      ModelNumber ();

      void
      ModelNumber (const ModelNumber_type& x);

      void
      ModelNumber (const ModelNumber_optional& x);

      void
      ModelNumber (::std::unique_ptr< ModelNumber_type > p);

      // Version
      //
      typedef ::xml_schema::string Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // SecurityClassification
      //
      typedef ::xsd::qif30::SecurityClassificationType SecurityClassification_type;
      typedef ::xsd::cxx::tree::optional< SecurityClassification_type > SecurityClassification_optional;
      typedef ::xsd::cxx::tree::traits< SecurityClassification_type, wchar_t > SecurityClassification_traits;

      const SecurityClassification_optional&
      SecurityClassification () const;

      SecurityClassification_optional&
      SecurityClassification ();

      void
      SecurityClassification (const SecurityClassification_type& x);

      void
      SecurityClassification (const SecurityClassification_optional& x);

      void
      SecurityClassification (::std::unique_ptr< SecurityClassification_type > p);

      // ExportControlClassification
      //
      typedef ::xml_schema::string ExportControlClassification_type;
      typedef ::xsd::cxx::tree::optional< ExportControlClassification_type > ExportControlClassification_optional;
      typedef ::xsd::cxx::tree::traits< ExportControlClassification_type, wchar_t > ExportControlClassification_traits;

      const ExportControlClassification_optional&
      ExportControlClassification () const;

      ExportControlClassification_optional&
      ExportControlClassification ();

      void
      ExportControlClassification (const ExportControlClassification_type& x);

      void
      ExportControlClassification (const ExportControlClassification_optional& x);

      void
      ExportControlClassification (::std::unique_ptr< ExportControlClassification_type > p);

      // FeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalIds_type > FeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, wchar_t > FeatureNominalIds_traits;

      const FeatureNominalIds_optional&
      FeatureNominalIds () const;

      FeatureNominalIds_optional&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (const FeatureNominalIds_optional& x);

      void
      FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > p);

      // FeatureZoneIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureZoneIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureZoneIds_type > FeatureZoneIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureZoneIds_type, wchar_t > FeatureZoneIds_traits;

      const FeatureZoneIds_optional&
      FeatureZoneIds () const;

      FeatureZoneIds_optional&
      FeatureZoneIds ();

      void
      FeatureZoneIds (const FeatureZoneIds_type& x);

      void
      FeatureZoneIds (const FeatureZoneIds_optional& x);

      void
      FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > p);

      // CharacteristicNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicNominalIds_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicNominalIds_type > CharacteristicNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominalIds_type, wchar_t > CharacteristicNominalIds_traits;

      const CharacteristicNominalIds_optional&
      CharacteristicNominalIds () const;

      CharacteristicNominalIds_optional&
      CharacteristicNominalIds ();

      void
      CharacteristicNominalIds (const CharacteristicNominalIds_type& x);

      void
      CharacteristicNominalIds (const CharacteristicNominalIds_optional& x);

      void
      CharacteristicNominalIds (::std::unique_ptr< CharacteristicNominalIds_type > p);

      // NoteIds
      //
      typedef ::xsd::qif30::ArrayReferenceType NoteIds_type;
      typedef ::xsd::cxx::tree::optional< NoteIds_type > NoteIds_optional;
      typedef ::xsd::cxx::tree::traits< NoteIds_type, wchar_t > NoteIds_traits;

      const NoteIds_optional&
      NoteIds () const;

      NoteIds_optional&
      NoteIds ();

      void
      NoteIds (const NoteIds_type& x);

      void
      NoteIds (const NoteIds_optional& x);

      void
      NoteIds (::std::unique_ptr< NoteIds_type > p);

      // PartNoteIds
      //
      typedef ::xsd::qif30::ArrayReferenceType PartNoteIds_type;
      typedef ::xsd::cxx::tree::optional< PartNoteIds_type > PartNoteIds_optional;
      typedef ::xsd::cxx::tree::traits< PartNoteIds_type, wchar_t > PartNoteIds_traits;

      const PartNoteIds_optional&
      PartNoteIds () const;

      PartNoteIds_optional&
      PartNoteIds ();

      void
      PartNoteIds (const PartNoteIds_type& x);

      void
      PartNoteIds (const PartNoteIds_optional& x);

      void
      PartNoteIds (::std::unique_ptr< PartNoteIds_type > p);

      // DatumDefinitionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType DatumDefinitionIds_type;
      typedef ::xsd::cxx::tree::optional< DatumDefinitionIds_type > DatumDefinitionIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionIds_type, wchar_t > DatumDefinitionIds_traits;

      const DatumDefinitionIds_optional&
      DatumDefinitionIds () const;

      DatumDefinitionIds_optional&
      DatumDefinitionIds ();

      void
      DatumDefinitionIds (const DatumDefinitionIds_type& x);

      void
      DatumDefinitionIds (const DatumDefinitionIds_optional& x);

      void
      DatumDefinitionIds (::std::unique_ptr< DatumDefinitionIds_type > p);

      // DatumTargetDefinitionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType DatumTargetDefinitionIds_type;
      typedef ::xsd::cxx::tree::optional< DatumTargetDefinitionIds_type > DatumTargetDefinitionIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumTargetDefinitionIds_type, wchar_t > DatumTargetDefinitionIds_traits;

      const DatumTargetDefinitionIds_optional&
      DatumTargetDefinitionIds () const;

      DatumTargetDefinitionIds_optional&
      DatumTargetDefinitionIds ();

      void
      DatumTargetDefinitionIds (const DatumTargetDefinitionIds_type& x);

      void
      DatumTargetDefinitionIds (const DatumTargetDefinitionIds_optional& x);

      void
      DatumTargetDefinitionIds (::std::unique_ptr< DatumTargetDefinitionIds_type > p);

      // DatumReferenceFrameIds
      //
      typedef ::xsd::qif30::ArrayReferenceType DatumReferenceFrameIds_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameIds_type > DatumReferenceFrameIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameIds_type, wchar_t > DatumReferenceFrameIds_traits;

      const DatumReferenceFrameIds_optional&
      DatumReferenceFrameIds () const;

      DatumReferenceFrameIds_optional&
      DatumReferenceFrameIds ();

      void
      DatumReferenceFrameIds (const DatumReferenceFrameIds_type& x);

      void
      DatumReferenceFrameIds (const DatumReferenceFrameIds_optional& x);

      void
      DatumReferenceFrameIds (::std::unique_ptr< DatumReferenceFrameIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // CoordinateSystemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CoordinateSystemIds_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemIds_type > CoordinateSystemIds_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemIds_type, wchar_t > CoordinateSystemIds_traits;

      const CoordinateSystemIds_optional&
      CoordinateSystemIds () const;

      CoordinateSystemIds_optional&
      CoordinateSystemIds ();

      void
      CoordinateSystemIds (const CoordinateSystemIds_type& x);

      void
      CoordinateSystemIds (const CoordinateSystemIds_optional& x);

      void
      CoordinateSystemIds (::std::unique_ptr< CoordinateSystemIds_type > p);

      // AuxiliaryIds
      //
      typedef ::xsd::qif30::ArrayReferenceType AuxiliaryIds_type;
      typedef ::xsd::cxx::tree::optional< AuxiliaryIds_type > AuxiliaryIds_optional;
      typedef ::xsd::cxx::tree::traits< AuxiliaryIds_type, wchar_t > AuxiliaryIds_traits;

      const AuxiliaryIds_optional&
      AuxiliaryIds () const;

      AuxiliaryIds_optional&
      AuxiliaryIds ();

      void
      AuxiliaryIds (const AuxiliaryIds_type& x);

      void
      AuxiliaryIds (const AuxiliaryIds_optional& x);

      void
      AuxiliaryIds (::std::unique_ptr< AuxiliaryIds_type > p);

      // ViewIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ViewIds_type;
      typedef ::xsd::cxx::tree::optional< ViewIds_type > ViewIds_optional;
      typedef ::xsd::cxx::tree::traits< ViewIds_type, wchar_t > ViewIds_traits;

      const ViewIds_optional&
      ViewIds () const;

      ViewIds_optional&
      ViewIds ();

      void
      ViewIds (const ViewIds_type& x);

      void
      ViewIds (const ViewIds_optional& x);

      void
      ViewIds (::std::unique_ptr< ViewIds_type > p);

      // PointCloudIds
      //
      typedef ::xsd::qif30::ArrayReferenceType PointCloudIds_type;
      typedef ::xsd::cxx::tree::optional< PointCloudIds_type > PointCloudIds_optional;
      typedef ::xsd::cxx::tree::traits< PointCloudIds_type, wchar_t > PointCloudIds_traits;

      const PointCloudIds_optional&
      PointCloudIds () const;

      PointCloudIds_optional&
      PointCloudIds ();

      void
      PointCloudIds (const PointCloudIds_type& x);

      void
      PointCloudIds (const PointCloudIds_optional& x);

      void
      PointCloudIds (::std::unique_ptr< PointCloudIds_type > p);

      // originMassProperty
      //
      typedef ::xsd::qif30::PointSimpleType originMassProperty_type;
      typedef ::xsd::cxx::tree::optional< originMassProperty_type > originMassProperty_optional;
      typedef ::xsd::cxx::tree::traits< originMassProperty_type, wchar_t > originMassProperty_traits;

      const originMassProperty_optional&
      originMassProperty () const;

      originMassProperty_optional&
      originMassProperty ();

      void
      originMassProperty (const originMassProperty_type& x);

      void
      originMassProperty (const originMassProperty_optional& x);

      void
      originMassProperty (::std::unique_ptr< originMassProperty_type > p);

      // materialIndex
      //
      typedef ::xsd::qif30::NaturalType materialIndex_type;
      typedef ::xsd::cxx::tree::optional< materialIndex_type > materialIndex_optional;
      typedef ::xsd::cxx::tree::traits< materialIndex_type, wchar_t > materialIndex_traits;

      const materialIndex_optional&
      materialIndex () const;

      materialIndex_optional&
      materialIndex ();

      void
      materialIndex (const materialIndex_type& x);

      void
      materialIndex (const materialIndex_optional& x);

      void
      materialIndex (::std::unique_ptr< materialIndex_type > p);

      // Constructors.
      //
      PartAssemblyBaseType ();

      PartAssemblyBaseType (const id_type&);

      PartAssemblyBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      PartAssemblyBaseType (const PartAssemblyBaseType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual PartAssemblyBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PartAssemblyBaseType&
      operator= (const PartAssemblyBaseType& x);

      virtual 
      ~PartAssemblyBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Validation_optional Validation_;
      Header_optional Header_;
      UUID_optional UUID_;
      ModelNumber_optional ModelNumber_;
      Version_optional Version_;
      SecurityClassification_optional SecurityClassification_;
      ExportControlClassification_optional ExportControlClassification_;
      FeatureNominalIds_optional FeatureNominalIds_;
      FeatureZoneIds_optional FeatureZoneIds_;
      CharacteristicNominalIds_optional CharacteristicNominalIds_;
      NoteIds_optional NoteIds_;
      PartNoteIds_optional PartNoteIds_;
      DatumDefinitionIds_optional DatumDefinitionIds_;
      DatumTargetDefinitionIds_optional DatumTargetDefinitionIds_;
      DatumReferenceFrameIds_optional DatumReferenceFrameIds_;
      BodyIds_optional BodyIds_;
      CoordinateSystemIds_optional CoordinateSystemIds_;
      AuxiliaryIds_optional AuxiliaryIds_;
      ViewIds_optional ViewIds_;
      PointCloudIds_optional PointCloudIds_;
      originMassProperty_optional originMassProperty_;
      materialIndex_optional materialIndex_;
    };

    class QIF30_SYMBOL_DECL PartType: public ::xsd::qif30::PartAssemblyBaseType
    {
      public:
      // DefinitionExternal
      //
      typedef ::xsd::qif30::DefinitionExternalType DefinitionExternal_type;
      typedef ::xsd::cxx::tree::optional< DefinitionExternal_type > DefinitionExternal_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionExternal_type, wchar_t > DefinitionExternal_traits;

      const DefinitionExternal_optional&
      DefinitionExternal () const;

      DefinitionExternal_optional&
      DefinitionExternal ();

      void
      DefinitionExternal (const DefinitionExternal_type& x);

      void
      DefinitionExternal (const DefinitionExternal_optional& x);

      void
      DefinitionExternal (::std::unique_ptr< DefinitionExternal_type > p);

      // PartFamily
      //
      typedef ::xsd::qif30::PartFamilyType PartFamily_type;
      typedef ::xsd::cxx::tree::optional< PartFamily_type > PartFamily_optional;
      typedef ::xsd::cxx::tree::traits< PartFamily_type, wchar_t > PartFamily_traits;

      const PartFamily_optional&
      PartFamily () const;

      PartFamily_optional&
      PartFamily ();

      void
      PartFamily (const PartFamily_type& x);

      void
      PartFamily (const PartFamily_optional& x);

      void
      PartFamily (::std::unique_ptr< PartFamily_type > p);

      // FoldersPart
      //
      typedef ::xsd::qif30::FoldersPartType FoldersPart_type;
      typedef ::xsd::cxx::tree::optional< FoldersPart_type > FoldersPart_optional;
      typedef ::xsd::cxx::tree::traits< FoldersPart_type, wchar_t > FoldersPart_traits;

      const FoldersPart_optional&
      FoldersPart () const;

      FoldersPart_optional&
      FoldersPart ();

      void
      FoldersPart (const FoldersPart_type& x);

      void
      FoldersPart (const FoldersPart_optional& x);

      void
      FoldersPart (::std::unique_ptr< FoldersPart_type > p);

      // Constructors.
      //
      PartType ();

      PartType (const id_type&);

      PartType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      PartType (const PartType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual PartType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartType&
      operator= (const PartType& x);

      virtual 
      ~PartType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DefinitionExternal_optional DefinitionExternal_;
      PartFamily_optional PartFamily_;
      FoldersPart_optional FoldersPart_;
    };

    class QIF30_SYMBOL_DECL FoldersPartType: public ::xml_schema::type
    {
      public:
      // FolderPart
      //
      typedef ::xsd::qif30::FolderPartType FolderPart_type;
      typedef ::xsd::cxx::tree::sequence< FolderPart_type > FolderPart_sequence;
      typedef xsd::cxx::tree::sequence< FolderPart_type >::iterator FolderPart_iterator;
      typedef xsd::cxx::tree::sequence< FolderPart_type >::const_iterator FolderPart_const_iterator;
      typedef ::xsd::cxx::tree::traits< FolderPart_type, wchar_t > FolderPart_traits;

      const FolderPart_sequence&
      FolderPart () const;

      FolderPart_sequence&
      FolderPart ();

      void
      FolderPart (const FolderPart_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FoldersPartType ();

      FoldersPartType (const n_type&);

      FoldersPartType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FoldersPartType (const FoldersPartType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual FoldersPartType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FoldersPartType&
      operator= (const FoldersPartType& x);

      virtual 
      ~FoldersPartType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FolderPart_sequence FolderPart_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FoldersAssemblyType: public ::xml_schema::type
    {
      public:
      // FolderAssembly
      //
      typedef ::xsd::qif30::FolderAssemblyType FolderAssembly_type;
      typedef ::xsd::cxx::tree::sequence< FolderAssembly_type > FolderAssembly_sequence;
      typedef xsd::cxx::tree::sequence< FolderAssembly_type >::iterator FolderAssembly_iterator;
      typedef xsd::cxx::tree::sequence< FolderAssembly_type >::const_iterator FolderAssembly_const_iterator;
      typedef ::xsd::cxx::tree::traits< FolderAssembly_type, wchar_t > FolderAssembly_traits;

      const FolderAssembly_sequence&
      FolderAssembly () const;

      FolderAssembly_sequence&
      FolderAssembly ();

      void
      FolderAssembly (const FolderAssembly_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FoldersAssemblyType ();

      FoldersAssemblyType (const n_type&);

      FoldersAssemblyType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FoldersAssemblyType (const FoldersAssemblyType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FoldersAssemblyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FoldersAssemblyType&
      operator= (const FoldersAssemblyType& x);

      virtual 
      ~FoldersAssemblyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FolderAssembly_sequence FolderAssembly_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FolderPartAssemblyBaseType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // FolderIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FolderIds_type;
      typedef ::xsd::cxx::tree::optional< FolderIds_type > FolderIds_optional;
      typedef ::xsd::cxx::tree::traits< FolderIds_type, wchar_t > FolderIds_traits;

      const FolderIds_optional&
      FolderIds () const;

      FolderIds_optional&
      FolderIds ();

      void
      FolderIds (const FolderIds_type& x);

      void
      FolderIds (const FolderIds_optional& x);

      void
      FolderIds (::std::unique_ptr< FolderIds_type > p);

      // FeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalIds_type > FeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, wchar_t > FeatureNominalIds_traits;

      const FeatureNominalIds_optional&
      FeatureNominalIds () const;

      FeatureNominalIds_optional&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (const FeatureNominalIds_optional& x);

      void
      FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > p);

      // FeatureZoneIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureZoneIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureZoneIds_type > FeatureZoneIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureZoneIds_type, wchar_t > FeatureZoneIds_traits;

      const FeatureZoneIds_optional&
      FeatureZoneIds () const;

      FeatureZoneIds_optional&
      FeatureZoneIds ();

      void
      FeatureZoneIds (const FeatureZoneIds_type& x);

      void
      FeatureZoneIds (const FeatureZoneIds_optional& x);

      void
      FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > p);

      // CharacteristicNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType CharacteristicNominalIds_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicNominalIds_type > CharacteristicNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominalIds_type, wchar_t > CharacteristicNominalIds_traits;

      const CharacteristicNominalIds_optional&
      CharacteristicNominalIds () const;

      CharacteristicNominalIds_optional&
      CharacteristicNominalIds ();

      void
      CharacteristicNominalIds (const CharacteristicNominalIds_type& x);

      void
      CharacteristicNominalIds (const CharacteristicNominalIds_optional& x);

      void
      CharacteristicNominalIds (::std::unique_ptr< CharacteristicNominalIds_type > p);

      // NoteIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType NoteIds_type;
      typedef ::xsd::cxx::tree::optional< NoteIds_type > NoteIds_optional;
      typedef ::xsd::cxx::tree::traits< NoteIds_type, wchar_t > NoteIds_traits;

      const NoteIds_optional&
      NoteIds () const;

      NoteIds_optional&
      NoteIds ();

      void
      NoteIds (const NoteIds_type& x);

      void
      NoteIds (const NoteIds_optional& x);

      void
      NoteIds (::std::unique_ptr< NoteIds_type > p);

      // PartNoteIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType PartNoteIds_type;
      typedef ::xsd::cxx::tree::optional< PartNoteIds_type > PartNoteIds_optional;
      typedef ::xsd::cxx::tree::traits< PartNoteIds_type, wchar_t > PartNoteIds_traits;

      const PartNoteIds_optional&
      PartNoteIds () const;

      PartNoteIds_optional&
      PartNoteIds ();

      void
      PartNoteIds (const PartNoteIds_type& x);

      void
      PartNoteIds (const PartNoteIds_optional& x);

      void
      PartNoteIds (::std::unique_ptr< PartNoteIds_type > p);

      // DatumDefinitionIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType DatumDefinitionIds_type;
      typedef ::xsd::cxx::tree::optional< DatumDefinitionIds_type > DatumDefinitionIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionIds_type, wchar_t > DatumDefinitionIds_traits;

      const DatumDefinitionIds_optional&
      DatumDefinitionIds () const;

      DatumDefinitionIds_optional&
      DatumDefinitionIds ();

      void
      DatumDefinitionIds (const DatumDefinitionIds_type& x);

      void
      DatumDefinitionIds (const DatumDefinitionIds_optional& x);

      void
      DatumDefinitionIds (::std::unique_ptr< DatumDefinitionIds_type > p);

      // DatumTargetDefinitionIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType DatumTargetDefinitionIds_type;
      typedef ::xsd::cxx::tree::optional< DatumTargetDefinitionIds_type > DatumTargetDefinitionIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumTargetDefinitionIds_type, wchar_t > DatumTargetDefinitionIds_traits;

      const DatumTargetDefinitionIds_optional&
      DatumTargetDefinitionIds () const;

      DatumTargetDefinitionIds_optional&
      DatumTargetDefinitionIds ();

      void
      DatumTargetDefinitionIds (const DatumTargetDefinitionIds_type& x);

      void
      DatumTargetDefinitionIds (const DatumTargetDefinitionIds_optional& x);

      void
      DatumTargetDefinitionIds (::std::unique_ptr< DatumTargetDefinitionIds_type > p);

      // DatumReferenceFrameIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType DatumReferenceFrameIds_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameIds_type > DatumReferenceFrameIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameIds_type, wchar_t > DatumReferenceFrameIds_traits;

      const DatumReferenceFrameIds_optional&
      DatumReferenceFrameIds () const;

      DatumReferenceFrameIds_optional&
      DatumReferenceFrameIds ();

      void
      DatumReferenceFrameIds (const DatumReferenceFrameIds_type& x);

      void
      DatumReferenceFrameIds (const DatumReferenceFrameIds_optional& x);

      void
      DatumReferenceFrameIds (::std::unique_ptr< DatumReferenceFrameIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // CoordinateSystemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CoordinateSystemIds_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemIds_type > CoordinateSystemIds_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemIds_type, wchar_t > CoordinateSystemIds_traits;

      const CoordinateSystemIds_optional&
      CoordinateSystemIds () const;

      CoordinateSystemIds_optional&
      CoordinateSystemIds ();

      void
      CoordinateSystemIds (const CoordinateSystemIds_type& x);

      void
      CoordinateSystemIds (const CoordinateSystemIds_optional& x);

      void
      CoordinateSystemIds (::std::unique_ptr< CoordinateSystemIds_type > p);

      // AuxiliaryIds
      //
      typedef ::xsd::qif30::ArrayReferenceType AuxiliaryIds_type;
      typedef ::xsd::cxx::tree::optional< AuxiliaryIds_type > AuxiliaryIds_optional;
      typedef ::xsd::cxx::tree::traits< AuxiliaryIds_type, wchar_t > AuxiliaryIds_traits;

      const AuxiliaryIds_optional&
      AuxiliaryIds () const;

      AuxiliaryIds_optional&
      AuxiliaryIds ();

      void
      AuxiliaryIds (const AuxiliaryIds_type& x);

      void
      AuxiliaryIds (const AuxiliaryIds_optional& x);

      void
      AuxiliaryIds (::std::unique_ptr< AuxiliaryIds_type > p);

      // ViewIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ViewIds_type;
      typedef ::xsd::cxx::tree::optional< ViewIds_type > ViewIds_optional;
      typedef ::xsd::cxx::tree::traits< ViewIds_type, wchar_t > ViewIds_traits;

      const ViewIds_optional&
      ViewIds () const;

      ViewIds_optional&
      ViewIds ();

      void
      ViewIds (const ViewIds_type& x);

      void
      ViewIds (const ViewIds_optional& x);

      void
      ViewIds (::std::unique_ptr< ViewIds_type > p);

      // PointCloudIds
      //
      typedef ::xsd::qif30::ArrayReferenceType PointCloudIds_type;
      typedef ::xsd::cxx::tree::optional< PointCloudIds_type > PointCloudIds_optional;
      typedef ::xsd::cxx::tree::traits< PointCloudIds_type, wchar_t > PointCloudIds_traits;

      const PointCloudIds_optional&
      PointCloudIds () const;

      PointCloudIds_optional&
      PointCloudIds ();

      void
      PointCloudIds (const PointCloudIds_type& x);

      void
      PointCloudIds (const PointCloudIds_optional& x);

      void
      PointCloudIds (::std::unique_ptr< PointCloudIds_type > p);

      // Constructors.
      //
      FolderPartAssemblyBaseType ();

      FolderPartAssemblyBaseType (const id_type&);

      FolderPartAssemblyBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      FolderPartAssemblyBaseType (const FolderPartAssemblyBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual FolderPartAssemblyBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FolderPartAssemblyBaseType&
      operator= (const FolderPartAssemblyBaseType& x);

      virtual 
      ~FolderPartAssemblyBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FolderIds_optional FolderIds_;
      FeatureNominalIds_optional FeatureNominalIds_;
      FeatureZoneIds_optional FeatureZoneIds_;
      CharacteristicNominalIds_optional CharacteristicNominalIds_;
      NoteIds_optional NoteIds_;
      PartNoteIds_optional PartNoteIds_;
      DatumDefinitionIds_optional DatumDefinitionIds_;
      DatumTargetDefinitionIds_optional DatumTargetDefinitionIds_;
      DatumReferenceFrameIds_optional DatumReferenceFrameIds_;
      BodyIds_optional BodyIds_;
      CoordinateSystemIds_optional CoordinateSystemIds_;
      AuxiliaryIds_optional AuxiliaryIds_;
      ViewIds_optional ViewIds_;
      PointCloudIds_optional PointCloudIds_;
    };

    class QIF30_SYMBOL_DECL FolderPartType: public ::xsd::qif30::FolderPartAssemblyBaseType
    {
      public:
      // Constructors.
      //
      FolderPartType ();

      FolderPartType (const id_type&);

      FolderPartType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      FolderPartType (const FolderPartType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual FolderPartType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FolderPartType&
      operator= (const FolderPartType&) = default;
#endif

      virtual 
      ~FolderPartType ();
    };

    class QIF30_SYMBOL_DECL FolderAssemblyType: public ::xsd::qif30::FolderPartAssemblyBaseType
    {
      public:
      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ComponentIds_type;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_type&
      ComponentIds () const;

      ComponentIds_type&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // Constructors.
      //
      FolderAssemblyType ();

      FolderAssemblyType (const id_type&,
                          const ComponentIds_type&);

      FolderAssemblyType (const id_type&,
                          ::std::unique_ptr< ComponentIds_type >);

      FolderAssemblyType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FolderAssemblyType (const FolderAssemblyType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FolderAssemblyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FolderAssemblyType&
      operator= (const FolderAssemblyType& x);

      virtual 
      ~FolderAssemblyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ComponentIds_type > ComponentIds_;
    };

    class QIF30_SYMBOL_DECL AssemblyType: public ::xsd::qif30::PartAssemblyBaseType
    {
      public:
      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ComponentIds_type;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_type&
      ComponentIds () const;

      ComponentIds_type&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // DefinitionExternal
      //
      typedef ::xsd::qif30::DefinitionExternalType DefinitionExternal_type;
      typedef ::xsd::cxx::tree::optional< DefinitionExternal_type > DefinitionExternal_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionExternal_type, wchar_t > DefinitionExternal_traits;

      const DefinitionExternal_optional&
      DefinitionExternal () const;

      DefinitionExternal_optional&
      DefinitionExternal ();

      void
      DefinitionExternal (const DefinitionExternal_type& x);

      void
      DefinitionExternal (const DefinitionExternal_optional& x);

      void
      DefinitionExternal (::std::unique_ptr< DefinitionExternal_type > p);

      // FoldersAssembly
      //
      typedef ::xsd::qif30::FoldersAssemblyType FoldersAssembly_type;
      typedef ::xsd::cxx::tree::optional< FoldersAssembly_type > FoldersAssembly_optional;
      typedef ::xsd::cxx::tree::traits< FoldersAssembly_type, wchar_t > FoldersAssembly_traits;

      const FoldersAssembly_optional&
      FoldersAssembly () const;

      FoldersAssembly_optional&
      FoldersAssembly ();

      void
      FoldersAssembly (const FoldersAssembly_type& x);

      void
      FoldersAssembly (const FoldersAssembly_optional& x);

      void
      FoldersAssembly (::std::unique_ptr< FoldersAssembly_type > p);

      // Constructors.
      //
      AssemblyType ();

      AssemblyType (const id_type&,
                    const ComponentIds_type&);

      AssemblyType (const id_type&,
                    ::std::unique_ptr< ComponentIds_type >);

      AssemblyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      AssemblyType (const AssemblyType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual AssemblyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssemblyType&
      operator= (const AssemblyType& x);

      virtual 
      ~AssemblyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ComponentIds_type > ComponentIds_;
      DefinitionExternal_optional DefinitionExternal_;
      FoldersAssembly_optional FoldersAssembly_;
    };

    class QIF30_SYMBOL_DECL PartFamilyType: public ::xml_schema::type
    {
      public:
      // PrimaryShapeClass
      //
      typedef ::xsd::qif30::ShapeClassType PrimaryShapeClass_type;
      typedef ::xsd::cxx::tree::optional< PrimaryShapeClass_type > PrimaryShapeClass_optional;
      typedef ::xsd::cxx::tree::traits< PrimaryShapeClass_type, wchar_t > PrimaryShapeClass_traits;

      const PrimaryShapeClass_optional&
      PrimaryShapeClass () const;

      PrimaryShapeClass_optional&
      PrimaryShapeClass ();

      void
      PrimaryShapeClass (const PrimaryShapeClass_type& x);

      void
      PrimaryShapeClass (const PrimaryShapeClass_optional& x);

      void
      PrimaryShapeClass (::std::unique_ptr< PrimaryShapeClass_type > p);

      // MinimumTolerance
      //
      typedef ::xsd::qif30::LinearValueType MinimumTolerance_type;
      typedef ::xsd::cxx::tree::optional< MinimumTolerance_type > MinimumTolerance_optional;
      typedef ::xsd::cxx::tree::traits< MinimumTolerance_type, wchar_t > MinimumTolerance_traits;

      const MinimumTolerance_optional&
      MinimumTolerance () const;

      MinimumTolerance_optional&
      MinimumTolerance ();

      void
      MinimumTolerance (const MinimumTolerance_type& x);

      void
      MinimumTolerance (const MinimumTolerance_optional& x);

      void
      MinimumTolerance (::std::unique_ptr< MinimumTolerance_type > p);

      // MinimumBoundingBox
      //
      typedef ::xsd::qif30::BoundingBoxType MinimumBoundingBox_type;
      typedef ::xsd::cxx::tree::optional< MinimumBoundingBox_type > MinimumBoundingBox_optional;
      typedef ::xsd::cxx::tree::traits< MinimumBoundingBox_type, wchar_t > MinimumBoundingBox_traits;

      const MinimumBoundingBox_optional&
      MinimumBoundingBox () const;

      MinimumBoundingBox_optional&
      MinimumBoundingBox ();

      void
      MinimumBoundingBox (const MinimumBoundingBox_type& x);

      void
      MinimumBoundingBox (const MinimumBoundingBox_optional& x);

      void
      MinimumBoundingBox (::std::unique_ptr< MinimumBoundingBox_type > p);

      // PrimaryManufacturingMethod
      //
      typedef ::xsd::qif30::ManufacturingMethodType PrimaryManufacturingMethod_type;
      typedef ::xsd::cxx::tree::optional< PrimaryManufacturingMethod_type > PrimaryManufacturingMethod_optional;
      typedef ::xsd::cxx::tree::traits< PrimaryManufacturingMethod_type, wchar_t > PrimaryManufacturingMethod_traits;

      const PrimaryManufacturingMethod_optional&
      PrimaryManufacturingMethod () const;

      PrimaryManufacturingMethod_optional&
      PrimaryManufacturingMethod ();

      void
      PrimaryManufacturingMethod (const PrimaryManufacturingMethod_type& x);

      void
      PrimaryManufacturingMethod (const PrimaryManufacturingMethod_optional& x);

      void
      PrimaryManufacturingMethod (::std::unique_ptr< PrimaryManufacturingMethod_type > p);

      // Constructors.
      //
      PartFamilyType ();

      PartFamilyType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PartFamilyType (const PartFamilyType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PartFamilyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartFamilyType&
      operator= (const PartFamilyType& x);

      virtual 
      ~PartFamilyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PrimaryShapeClass_optional PrimaryShapeClass_;
      MinimumTolerance_optional MinimumTolerance_;
      MinimumBoundingBox_optional MinimumBoundingBox_;
      PrimaryManufacturingMethod_optional PrimaryManufacturingMethod_;
    };

    class QIF30_SYMBOL_DECL PartSetType: public ::xml_schema::type
    {
      public:
      // Part
      //
      typedef ::xsd::qif30::PartType Part_type;
      typedef ::xsd::cxx::tree::sequence< Part_type > Part_sequence;
      typedef xsd::cxx::tree::sequence< Part_type >::iterator Part_iterator;
      typedef xsd::cxx::tree::sequence< Part_type >::const_iterator Part_const_iterator;
      typedef ::xsd::cxx::tree::traits< Part_type, wchar_t > Part_traits;

      const Part_sequence&
      Part () const;

      Part_sequence&
      Part ();

      void
      Part (const Part_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PartSetType ();

      PartSetType (const n_type&);

      PartSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      PartSetType (const PartSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual PartSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartSetType&
      operator= (const PartSetType& x);

      virtual 
      ~PartSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Part_sequence Part_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AssemblySetType: public ::xml_schema::type
    {
      public:
      // Assembly
      //
      typedef ::xsd::qif30::AssemblyType Assembly_type;
      typedef ::xsd::cxx::tree::sequence< Assembly_type > Assembly_sequence;
      typedef xsd::cxx::tree::sequence< Assembly_type >::iterator Assembly_iterator;
      typedef xsd::cxx::tree::sequence< Assembly_type >::const_iterator Assembly_const_iterator;
      typedef ::xsd::cxx::tree::traits< Assembly_type, wchar_t > Assembly_traits;

      const Assembly_sequence&
      Assembly () const;

      Assembly_sequence&
      Assembly ();

      void
      Assembly (const Assembly_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AssemblySetType ();

      AssemblySetType (const n_type&);

      AssemblySetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AssemblySetType (const AssemblySetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AssemblySetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssemblySetType&
      operator= (const AssemblySetType& x);

      virtual 
      ~AssemblySetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Assembly_sequence Assembly_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ComponentType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // Traceability
      //
      typedef ::xsd::qif30::ProductTraceabilityType Traceability_type;
      typedef ::xsd::cxx::tree::optional< Traceability_type > Traceability_optional;
      typedef ::xsd::cxx::tree::traits< Traceability_type, wchar_t > Traceability_traits;

      const Traceability_optional&
      Traceability () const;

      Traceability_optional&
      Traceability ();

      void
      Traceability (const Traceability_type& x);

      void
      Traceability (const Traceability_optional& x);

      void
      Traceability (::std::unique_ptr< Traceability_type > p);

      // Part
      //
      typedef ::xsd::qif30::ElementReferenceType Part_type;
      typedef ::xsd::cxx::tree::optional< Part_type > Part_optional;
      typedef ::xsd::cxx::tree::traits< Part_type, wchar_t > Part_traits;

      const Part_optional&
      Part () const;

      Part_optional&
      Part ();

      void
      Part (const Part_type& x);

      void
      Part (const Part_optional& x);

      void
      Part (::std::unique_ptr< Part_type > p);

      // Assembly
      //
      typedef ::xsd::qif30::ElementReferenceType Assembly_type;
      typedef ::xsd::cxx::tree::optional< Assembly_type > Assembly_optional;
      typedef ::xsd::cxx::tree::traits< Assembly_type, wchar_t > Assembly_traits;

      const Assembly_optional&
      Assembly () const;

      Assembly_optional&
      Assembly ();

      void
      Assembly (const Assembly_type& x);

      void
      Assembly (const Assembly_optional& x);

      void
      Assembly (::std::unique_ptr< Assembly_type > p);

      // Constructors.
      //
      ComponentType ();

      ComponentType (const id_type&);

      ComponentType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ComponentType (const ComponentType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ComponentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComponentType&
      operator= (const ComponentType& x);

      virtual 
      ~ComponentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Transform_optional Transform_;
      UUID_optional UUID_;
      Traceability_optional Traceability_;
      Part_optional Part_;
      Assembly_optional Assembly_;
    };

    class QIF30_SYMBOL_DECL ComponentSetType: public ::xml_schema::type
    {
      public:
      // Component
      //
      typedef ::xsd::qif30::ComponentType Component_type;
      typedef ::xsd::cxx::tree::sequence< Component_type > Component_sequence;
      typedef xsd::cxx::tree::sequence< Component_type >::iterator Component_iterator;
      typedef xsd::cxx::tree::sequence< Component_type >::const_iterator Component_const_iterator;
      typedef ::xsd::cxx::tree::traits< Component_type, wchar_t > Component_traits;

      const Component_sequence&
      Component () const;

      Component_sequence&
      Component ();

      void
      Component (const Component_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ComponentSetType ();

      ComponentSetType (const n_type&);

      ComponentSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ComponentSetType (const ComponentSetType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ComponentSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComponentSetType&
      operator= (const ComponentSetType& x);

      virtual 
      ~ComponentSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Component_sequence Component_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PrintedDrawingType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Version
      //
      typedef ::xml_schema::string Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Author
      //
      typedef ::xsd::qif30::AuthorType Author_type;
      typedef ::xsd::cxx::tree::optional< Author_type > Author_optional;
      typedef ::xsd::cxx::tree::traits< Author_type, wchar_t > Author_traits;

      const Author_optional&
      Author () const;

      Author_optional&
      Author ();

      void
      Author (const Author_type& x);

      void
      Author (const Author_optional& x);

      void
      Author (::std::unique_ptr< Author_type > p);

      // DrawingNumber
      //
      typedef ::xml_schema::string DrawingNumber_type;
      typedef ::xsd::cxx::tree::optional< DrawingNumber_type > DrawingNumber_optional;
      typedef ::xsd::cxx::tree::traits< DrawingNumber_type, wchar_t > DrawingNumber_traits;

      const DrawingNumber_optional&
      DrawingNumber () const;

      DrawingNumber_optional&
      DrawingNumber ();

      void
      DrawingNumber (const DrawingNumber_type& x);

      void
      DrawingNumber (const DrawingNumber_optional& x);

      void
      DrawingNumber (::std::unique_ptr< DrawingNumber_type > p);

      // AdditionalChanges
      //
      typedef ::xml_schema::string AdditionalChanges_type;
      typedef ::xsd::cxx::tree::optional< AdditionalChanges_type > AdditionalChanges_optional;
      typedef ::xsd::cxx::tree::traits< AdditionalChanges_type, wchar_t > AdditionalChanges_traits;

      const AdditionalChanges_optional&
      AdditionalChanges () const;

      AdditionalChanges_optional&
      AdditionalChanges ();

      void
      AdditionalChanges (const AdditionalChanges_type& x);

      void
      AdditionalChanges (const AdditionalChanges_optional& x);

      void
      AdditionalChanges (::std::unique_ptr< AdditionalChanges_type > p);

      // Location
      //
      typedef ::xml_schema::string Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      PrintedDrawingType ();

      PrintedDrawingType (const Name_type&,
                          const id_type&);

      PrintedDrawingType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrintedDrawingType (const PrintedDrawingType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual PrintedDrawingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrintedDrawingType&
      operator= (const PrintedDrawingType& x);

      virtual 
      ~PrintedDrawingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Version_optional Version_;
      Description_optional Description_;
      Author_optional Author_;
      DrawingNumber_optional DrawingNumber_;
      AdditionalChanges_optional AdditionalChanges_;
      Location_optional Location_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL GDTEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        UNKNOWN,
        HUMANREAD,
        MACHINEREAD,
        ABSENT
      };

      GDTEnumType ();

      GDTEnumType (value v);

      GDTEnumType (const wchar_t* v);

      GDTEnumType (const ::std::wstring& v);

      GDTEnumType (const ::xml_schema::string& v);

      GDTEnumType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      GDTEnumType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      GDTEnumType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      GDTEnumType (const GDTEnumType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      GDTEnumType&
      operator= (const GDTEnumType&) = default;
#endif

      virtual GDTEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GDTEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_GDTEnumType_convert ();
      }

      protected:
      value
      _xsd_GDTEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_GDTEnumType_literals_[4];
      static const value _xsd_GDTEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL TopologyEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        UNKNOWN,
        PRESENT,
        ABSENT
      };

      TopologyEnumType ();

      TopologyEnumType (value v);

      TopologyEnumType (const wchar_t* v);

      TopologyEnumType (const ::std::wstring& v);

      TopologyEnumType (const ::xml_schema::string& v);

      TopologyEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TopologyEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TopologyEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TopologyEnumType (const TopologyEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      TopologyEnumType&
      operator= (const TopologyEnumType&) = default;
#endif

      virtual TopologyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TopologyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_TopologyEnumType_convert ();
      }

      protected:
      value
      _xsd_TopologyEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_TopologyEnumType_literals_[3];
      static const value _xsd_TopologyEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL DigitalModelType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // File
      //
      typedef ::xsd::qif30::FileType File_type;
      typedef ::xsd::cxx::tree::traits< File_type, wchar_t > File_traits;

      const File_type&
      File () const;

      File_type&
      File ();

      void
      File (const File_type& x);

      void
      File (::std::unique_ptr< File_type > p);

      // Application
      //
      typedef ::xsd::qif30::ApplicationType Application_type;
      typedef ::xsd::cxx::tree::optional< Application_type > Application_optional;
      typedef ::xsd::cxx::tree::traits< Application_type, wchar_t > Application_traits;

      const Application_optional&
      Application () const;

      Application_optional&
      Application ();

      void
      Application (const Application_type& x);

      void
      Application (const Application_optional& x);

      void
      Application (::std::unique_ptr< Application_type > p);

      // Author
      //
      typedef ::xsd::qif30::AuthorType Author_type;
      typedef ::xsd::cxx::tree::optional< Author_type > Author_optional;
      typedef ::xsd::cxx::tree::traits< Author_type, wchar_t > Author_traits;

      const Author_optional&
      Author () const;

      Author_optional&
      Author ();

      void
      Author (const Author_type& x);

      void
      Author (const Author_optional& x);

      void
      Author (::std::unique_ptr< Author_type > p);

      // ApplicationSource
      //
      typedef ::xsd::qif30::ApplicationType ApplicationSource_type;
      typedef ::xsd::cxx::tree::optional< ApplicationSource_type > ApplicationSource_optional;
      typedef ::xsd::cxx::tree::traits< ApplicationSource_type, wchar_t > ApplicationSource_traits;

      const ApplicationSource_optional&
      ApplicationSource () const;

      ApplicationSource_optional&
      ApplicationSource ();

      void
      ApplicationSource (const ApplicationSource_type& x);

      void
      ApplicationSource (const ApplicationSource_optional& x);

      void
      ApplicationSource (::std::unique_ptr< ApplicationSource_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Units
      //
      typedef ::xsd::qif30::OtherUnitsType Units_type;
      typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
      typedef ::xsd::cxx::tree::traits< Units_type, wchar_t > Units_traits;

      const Units_optional&
      Units () const;

      Units_optional&
      Units ();

      void
      Units (const Units_type& x);

      void
      Units (const Units_optional& x);

      void
      Units (::std::unique_ptr< Units_type > p);

      // GDT
      //
      typedef ::xsd::qif30::GDTEnumType GDT_type;
      typedef ::xsd::cxx::tree::optional< GDT_type > GDT_optional;
      typedef ::xsd::cxx::tree::traits< GDT_type, wchar_t > GDT_traits;

      const GDT_optional&
      GDT () const;

      GDT_optional&
      GDT ();

      void
      GDT (const GDT_type& x);

      void
      GDT (const GDT_optional& x);

      void
      GDT (::std::unique_ptr< GDT_type > p);

      static const GDT_type&
      GDT_default_value ();

      // Topology
      //
      typedef ::xsd::qif30::TopologyEnumType Topology_type;
      typedef ::xsd::cxx::tree::optional< Topology_type > Topology_optional;
      typedef ::xsd::cxx::tree::traits< Topology_type, wchar_t > Topology_traits;

      const Topology_optional&
      Topology () const;

      Topology_optional&
      Topology ();

      void
      Topology (const Topology_type& x);

      void
      Topology (const Topology_optional& x);

      void
      Topology (::std::unique_ptr< Topology_type > p);

      static const Topology_type&
      Topology_default_value ();

      // Entities
      //
      typedef ::xsd::qif30::EntitiesExternalType Entities_type;
      typedef ::xsd::cxx::tree::optional< Entities_type > Entities_optional;
      typedef ::xsd::cxx::tree::traits< Entities_type, wchar_t > Entities_traits;

      const Entities_optional&
      Entities () const;

      Entities_optional&
      Entities ();

      void
      Entities (const Entities_type& x);

      void
      Entities (const Entities_optional& x);

      void
      Entities (::std::unique_ptr< Entities_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DigitalModelType ();

      DigitalModelType (const Name_type&,
                        const File_type&,
                        const id_type&);

      DigitalModelType (const Name_type&,
                        ::std::unique_ptr< File_type >,
                        const id_type&);

      DigitalModelType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      DigitalModelType (const DigitalModelType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual DigitalModelType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DigitalModelType&
      operator= (const DigitalModelType& x);

      virtual 
      ~DigitalModelType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      ::xsd::cxx::tree::one< File_type > File_;
      Application_optional Application_;
      Author_optional Author_;
      ApplicationSource_optional ApplicationSource_;
      Description_optional Description_;
      Units_optional Units_;
      GDT_optional GDT_;
      static const GDT_type GDT_default_value_;
      Topology_optional Topology_;
      static const Topology_type Topology_default_value_;
      Entities_optional Entities_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL DefinitionExternalType: public ::xml_schema::type
    {
      public:
      // PrintedDrawing
      //
      typedef ::xsd::qif30::PrintedDrawingType PrintedDrawing_type;
      typedef ::xsd::cxx::tree::sequence< PrintedDrawing_type > PrintedDrawing_sequence;
      typedef xsd::cxx::tree::sequence< PrintedDrawing_type >::iterator PrintedDrawing_iterator;
      typedef xsd::cxx::tree::sequence< PrintedDrawing_type >::const_iterator PrintedDrawing_const_iterator;
      typedef ::xsd::cxx::tree::traits< PrintedDrawing_type, wchar_t > PrintedDrawing_traits;

      const PrintedDrawing_sequence&
      PrintedDrawing () const;

      PrintedDrawing_sequence&
      PrintedDrawing ();

      void
      PrintedDrawing (const PrintedDrawing_sequence& s);

      // DigitalDrawing
      //
      typedef ::xsd::qif30::DigitalDrawingType DigitalDrawing_type;
      typedef ::xsd::cxx::tree::sequence< DigitalDrawing_type > DigitalDrawing_sequence;
      typedef xsd::cxx::tree::sequence< DigitalDrawing_type >::iterator DigitalDrawing_iterator;
      typedef xsd::cxx::tree::sequence< DigitalDrawing_type >::const_iterator DigitalDrawing_const_iterator;
      typedef ::xsd::cxx::tree::traits< DigitalDrawing_type, wchar_t > DigitalDrawing_traits;

      const DigitalDrawing_sequence&
      DigitalDrawing () const;

      DigitalDrawing_sequence&
      DigitalDrawing ();

      void
      DigitalDrawing (const DigitalDrawing_sequence& s);

      // DigitalModel
      //
      typedef ::xsd::qif30::DigitalModelType DigitalModel_type;
      typedef ::xsd::cxx::tree::sequence< DigitalModel_type > DigitalModel_sequence;
      typedef xsd::cxx::tree::sequence< DigitalModel_type >::iterator DigitalModel_iterator;
      typedef xsd::cxx::tree::sequence< DigitalModel_type >::const_iterator DigitalModel_const_iterator;
      typedef ::xsd::cxx::tree::traits< DigitalModel_type, wchar_t > DigitalModel_traits;

      const DigitalModel_sequence&
      DigitalModel () const;

      DigitalModel_sequence&
      DigitalModel ();

      void
      DigitalModel (const DigitalModel_sequence& s);

      // PhysicalModel
      //
      typedef ::xsd::qif30::PhysicalModelType PhysicalModel_type;
      typedef ::xsd::cxx::tree::sequence< PhysicalModel_type > PhysicalModel_sequence;
      typedef xsd::cxx::tree::sequence< PhysicalModel_type >::iterator PhysicalModel_iterator;
      typedef xsd::cxx::tree::sequence< PhysicalModel_type >::const_iterator PhysicalModel_const_iterator;
      typedef ::xsd::cxx::tree::traits< PhysicalModel_type, wchar_t > PhysicalModel_traits;

      const PhysicalModel_sequence&
      PhysicalModel () const;

      PhysicalModel_sequence&
      PhysicalModel ();

      void
      PhysicalModel (const PhysicalModel_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DefinitionExternalType ();

      DefinitionExternalType (const n_type&,
                              const id_type&);

      DefinitionExternalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      DefinitionExternalType (const DefinitionExternalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual DefinitionExternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefinitionExternalType&
      operator= (const DefinitionExternalType& x);

      virtual 
      ~DefinitionExternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PrintedDrawing_sequence PrintedDrawing_;
      DigitalDrawing_sequence DigitalDrawing_;
      DigitalModel_sequence DigitalModel_;
      PhysicalModel_sequence PhysicalModel_;
      ::xsd::cxx::tree::one< n_type > n_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL DigitalDrawingType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // File
      //
      typedef ::xsd::qif30::FileType File_type;
      typedef ::xsd::cxx::tree::traits< File_type, wchar_t > File_traits;

      const File_type&
      File () const;

      File_type&
      File ();

      void
      File (const File_type& x);

      void
      File (::std::unique_ptr< File_type > p);

      // Application
      //
      typedef ::xsd::qif30::ApplicationType Application_type;
      typedef ::xsd::cxx::tree::optional< Application_type > Application_optional;
      typedef ::xsd::cxx::tree::traits< Application_type, wchar_t > Application_traits;

      const Application_optional&
      Application () const;

      Application_optional&
      Application ();

      void
      Application (const Application_type& x);

      void
      Application (const Application_optional& x);

      void
      Application (::std::unique_ptr< Application_type > p);

      // Author
      //
      typedef ::xsd::qif30::AuthorType Author_type;
      typedef ::xsd::cxx::tree::optional< Author_type > Author_optional;
      typedef ::xsd::cxx::tree::traits< Author_type, wchar_t > Author_traits;

      const Author_optional&
      Author () const;

      Author_optional&
      Author ();

      void
      Author (const Author_type& x);

      void
      Author (const Author_optional& x);

      void
      Author (::std::unique_ptr< Author_type > p);

      // ApplicationSource
      //
      typedef ::xsd::qif30::ApplicationType ApplicationSource_type;
      typedef ::xsd::cxx::tree::optional< ApplicationSource_type > ApplicationSource_optional;
      typedef ::xsd::cxx::tree::traits< ApplicationSource_type, wchar_t > ApplicationSource_traits;

      const ApplicationSource_optional&
      ApplicationSource () const;

      ApplicationSource_optional&
      ApplicationSource ();

      void
      ApplicationSource (const ApplicationSource_type& x);

      void
      ApplicationSource (const ApplicationSource_optional& x);

      void
      ApplicationSource (::std::unique_ptr< ApplicationSource_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Entities
      //
      typedef ::xsd::qif30::EntitiesExternalType Entities_type;
      typedef ::xsd::cxx::tree::optional< Entities_type > Entities_optional;
      typedef ::xsd::cxx::tree::traits< Entities_type, wchar_t > Entities_traits;

      const Entities_optional&
      Entities () const;

      Entities_optional&
      Entities ();

      void
      Entities (const Entities_type& x);

      void
      Entities (const Entities_optional& x);

      void
      Entities (::std::unique_ptr< Entities_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DigitalDrawingType ();

      DigitalDrawingType (const Name_type&,
                          const File_type&,
                          const id_type&);

      DigitalDrawingType (const Name_type&,
                          ::std::unique_ptr< File_type >,
                          const id_type&);

      DigitalDrawingType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DigitalDrawingType (const DigitalDrawingType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual DigitalDrawingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DigitalDrawingType&
      operator= (const DigitalDrawingType& x);

      virtual 
      ~DigitalDrawingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      ::xsd::cxx::tree::one< File_type > File_;
      Application_optional Application_;
      Author_optional Author_;
      ApplicationSource_optional ApplicationSource_;
      Description_optional Description_;
      Entities_optional Entities_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL PhysicalModelType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Version
      //
      typedef ::xml_schema::string Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Author
      //
      typedef ::xsd::qif30::AuthorType Author_type;
      typedef ::xsd::cxx::tree::optional< Author_type > Author_optional;
      typedef ::xsd::cxx::tree::traits< Author_type, wchar_t > Author_traits;

      const Author_optional&
      Author () const;

      Author_optional&
      Author ();

      void
      Author (const Author_type& x);

      void
      Author (const Author_optional& x);

      void
      Author (::std::unique_ptr< Author_type > p);

      // Location
      //
      typedef ::xml_schema::string Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // ModelNumber
      //
      typedef ::xml_schema::string ModelNumber_type;
      typedef ::xsd::cxx::tree::optional< ModelNumber_type > ModelNumber_optional;
      typedef ::xsd::cxx::tree::traits< ModelNumber_type, wchar_t > ModelNumber_traits;

      const ModelNumber_optional&
      ModelNumber () const;

      ModelNumber_optional&
      ModelNumber ();

      void
      ModelNumber (const ModelNumber_type& x);

      void
      ModelNumber (const ModelNumber_optional& x);

      void
      ModelNumber (::std::unique_ptr< ModelNumber_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      PhysicalModelType ();

      PhysicalModelType (const Name_type&,
                         const id_type&);

      PhysicalModelType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PhysicalModelType (const PhysicalModelType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PhysicalModelType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PhysicalModelType&
      operator= (const PhysicalModelType& x);

      virtual 
      ~PhysicalModelType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Version_optional Version_;
      Description_optional Description_;
      Author_optional Author_;
      Location_optional Location_;
      ModelNumber_optional ModelNumber_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL PartAssemblyHeaderType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // File
      //
      typedef ::xsd::qif30::FileInternalType File_type;
      typedef ::xsd::cxx::tree::optional< File_type > File_optional;
      typedef ::xsd::cxx::tree::traits< File_type, wchar_t > File_traits;

      const File_optional&
      File () const;

      File_optional&
      File ();

      void
      File (const File_type& x);

      void
      File (const File_optional& x);

      void
      File (::std::unique_ptr< File_type > p);

      // Application
      //
      typedef ::xsd::qif30::ApplicationType Application_type;
      typedef ::xsd::cxx::tree::optional< Application_type > Application_optional;
      typedef ::xsd::cxx::tree::traits< Application_type, wchar_t > Application_traits;

      const Application_optional&
      Application () const;

      Application_optional&
      Application ();

      void
      Application (const Application_type& x);

      void
      Application (const Application_optional& x);

      void
      Application (::std::unique_ptr< Application_type > p);

      // Author
      //
      typedef ::xsd::qif30::AuthorType Author_type;
      typedef ::xsd::cxx::tree::optional< Author_type > Author_optional;
      typedef ::xsd::cxx::tree::traits< Author_type, wchar_t > Author_traits;

      const Author_optional&
      Author () const;

      Author_optional&
      Author ();

      void
      Author (const Author_type& x);

      void
      Author (const Author_optional& x);

      void
      Author (::std::unique_ptr< Author_type > p);

      // ApplicationSource
      //
      typedef ::xsd::qif30::ApplicationType ApplicationSource_type;
      typedef ::xsd::cxx::tree::optional< ApplicationSource_type > ApplicationSource_optional;
      typedef ::xsd::cxx::tree::traits< ApplicationSource_type, wchar_t > ApplicationSource_traits;

      const ApplicationSource_optional&
      ApplicationSource () const;

      ApplicationSource_optional&
      ApplicationSource ();

      void
      ApplicationSource (const ApplicationSource_type& x);

      void
      ApplicationSource (const ApplicationSource_optional& x);

      void
      ApplicationSource (::std::unique_ptr< ApplicationSource_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      PartAssemblyHeaderType ();

      PartAssemblyHeaderType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      PartAssemblyHeaderType (const PartAssemblyHeaderType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual PartAssemblyHeaderType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartAssemblyHeaderType&
      operator= (const PartAssemblyHeaderType& x);

      virtual 
      ~PartAssemblyHeaderType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Name_optional Name_;
      File_optional File_;
      Application_optional Application_;
      Author_optional Author_;
      ApplicationSource_optional ApplicationSource_;
      Description_optional Description_;
    };

    class QIF30_SYMBOL_DECL ProductHeaderType: public ::xsd::qif30::PartAssemblyHeaderType
    {
      public:
      // ScaleCoefficient
      //
      typedef ::xml_schema::double_ ScaleCoefficient_type;
      typedef ::xsd::cxx::tree::optional< ScaleCoefficient_type > ScaleCoefficient_optional;
      typedef ::xsd::cxx::tree::traits< ScaleCoefficient_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > ScaleCoefficient_traits;

      const ScaleCoefficient_optional&
      ScaleCoefficient () const;

      ScaleCoefficient_optional&
      ScaleCoefficient ();

      void
      ScaleCoefficient (const ScaleCoefficient_type& x);

      void
      ScaleCoefficient (const ScaleCoefficient_optional& x);

      static ScaleCoefficient_type
      ScaleCoefficient_default_value ();

      // ModelTolerance
      //
      typedef ::xml_schema::double_ ModelTolerance_type;
      typedef ::xsd::cxx::tree::optional< ModelTolerance_type > ModelTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ModelTolerance_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > ModelTolerance_traits;

      const ModelTolerance_optional&
      ModelTolerance () const;

      ModelTolerance_optional&
      ModelTolerance ();

      void
      ModelTolerance (const ModelTolerance_type& x);

      void
      ModelTolerance (const ModelTolerance_optional& x);

      // MassPropertyTolerance
      //
      typedef ::xml_schema::double_ MassPropertyTolerance_type;
      typedef ::xsd::cxx::tree::optional< MassPropertyTolerance_type > MassPropertyTolerance_optional;
      typedef ::xsd::cxx::tree::traits< MassPropertyTolerance_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > MassPropertyTolerance_traits;

      const MassPropertyTolerance_optional&
      MassPropertyTolerance () const;

      MassPropertyTolerance_optional&
      MassPropertyTolerance ();

      void
      MassPropertyTolerance (const MassPropertyTolerance_type& x);

      void
      MassPropertyTolerance (const MassPropertyTolerance_optional& x);

      // Constructors.
      //
      ProductHeaderType ();

      ProductHeaderType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ProductHeaderType (const ProductHeaderType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ProductHeaderType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductHeaderType&
      operator= (const ProductHeaderType& x);

      virtual 
      ~ProductHeaderType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ScaleCoefficient_optional ScaleCoefficient_;
      ModelTolerance_optional ModelTolerance_;
      MassPropertyTolerance_optional MassPropertyTolerance_;
    };

    class QIF30_SYMBOL_DECL LayerType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // ElementIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ElementIds_type;
      typedef ::xsd::cxx::tree::optional< ElementIds_type > ElementIds_optional;
      typedef ::xsd::cxx::tree::traits< ElementIds_type, wchar_t > ElementIds_traits;

      const ElementIds_optional&
      ElementIds () const;

      ElementIds_optional&
      ElementIds ();

      void
      ElementIds (const ElementIds_type& x);

      void
      ElementIds (const ElementIds_optional& x);

      void
      ElementIds (::std::unique_ptr< ElementIds_type > p);

      // applyColor
      //
      typedef ::xml_schema::boolean applyColor_type;
      typedef ::xsd::cxx::tree::traits< applyColor_type, wchar_t > applyColor_traits;

      const applyColor_type&
      applyColor () const;

      applyColor_type&
      applyColor ();

      void
      applyColor (const applyColor_type& x);

      static applyColor_type
      applyColor_default_value ();

      // index
      //
      typedef ::xml_schema::unsigned_int index_type;
      typedef ::xsd::cxx::tree::traits< index_type, wchar_t > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // Constructors.
      //
      LayerType ();

      LayerType (const id_type&,
                 const index_type&);

      LayerType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      LayerType (const LayerType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual LayerType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LayerType&
      operator= (const LayerType& x);

      virtual 
      ~LayerType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ElementIds_optional ElementIds_;
      ::xsd::cxx::tree::one< applyColor_type > applyColor_;
      ::xsd::cxx::tree::one< index_type > index_;
    };

    class QIF30_SYMBOL_DECL LayerSetType: public ::xml_schema::type
    {
      public:
      // Layer
      //
      typedef ::xsd::qif30::LayerType Layer_type;
      typedef ::xsd::cxx::tree::sequence< Layer_type > Layer_sequence;
      typedef xsd::cxx::tree::sequence< Layer_type >::iterator Layer_iterator;
      typedef xsd::cxx::tree::sequence< Layer_type >::const_iterator Layer_const_iterator;
      typedef ::xsd::cxx::tree::traits< Layer_type, wchar_t > Layer_traits;

      const Layer_sequence&
      Layer () const;

      Layer_sequence&
      Layer ();

      void
      Layer (const Layer_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LayerSetType ();

      LayerSetType (const n_type&);

      LayerSetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LayerSetType (const LayerSetType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LayerSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LayerSetType&
      operator= (const LayerSetType& x);

      virtual 
      ~LayerSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Layer_sequence Layer_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PartNoteSetType: public ::xml_schema::type
    {
      public:
      // PartNote
      //
      typedef ::xsd::qif30::PartNoteType PartNote_type;
      typedef ::xsd::cxx::tree::sequence< PartNote_type > PartNote_sequence;
      typedef xsd::cxx::tree::sequence< PartNote_type >::iterator PartNote_iterator;
      typedef xsd::cxx::tree::sequence< PartNote_type >::const_iterator PartNote_const_iterator;
      typedef ::xsd::cxx::tree::traits< PartNote_type, wchar_t > PartNote_traits;

      const PartNote_sequence&
      PartNote () const;

      PartNote_sequence&
      PartNote ();

      void
      PartNote (const PartNote_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PartNoteSetType ();

      PartNoteSetType (const n_type&);

      PartNoteSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PartNoteSetType (const PartNoteSetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PartNoteSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartNoteSetType&
      operator= (const PartNoteSetType& x);

      virtual 
      ~PartNoteSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PartNote_sequence PartNote_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PartNoteType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // Text
      //
      typedef ::xml_schema::string Text_type;
      typedef ::xsd::cxx::tree::optional< Text_type > Text_optional;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_optional&
      Text () const;

      Text_optional&
      Text ();

      void
      Text (const Text_type& x);

      void
      Text (const Text_optional& x);

      void
      Text (::std::unique_ptr< Text_type > p);

      // PartNoteIds
      //
      typedef ::xsd::qif30::ArrayReferenceType PartNoteIds_type;
      typedef ::xsd::cxx::tree::optional< PartNoteIds_type > PartNoteIds_optional;
      typedef ::xsd::cxx::tree::traits< PartNoteIds_type, wchar_t > PartNoteIds_traits;

      const PartNoteIds_optional&
      PartNoteIds () const;

      PartNoteIds_optional&
      PartNoteIds ();

      void
      PartNoteIds (const PartNoteIds_type& x);

      void
      PartNoteIds (const PartNoteIds_optional& x);

      void
      PartNoteIds (::std::unique_ptr< PartNoteIds_type > p);

      // Constructors.
      //
      PartNoteType ();

      PartNoteType (const id_type&);

      PartNoteType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      PartNoteType (const PartNoteType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual PartNoteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartNoteType&
      operator= (const PartNoteType& x);

      virtual 
      ~PartNoteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Text_optional Text_;
      PartNoteIds_optional PartNoteIds_;
    };

    class QIF30_SYMBOL_DECL NoteType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // EntityInternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityInternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityInternalIds_type > EntityInternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityInternalIds_type, wchar_t > EntityInternalIds_traits;

      const EntityInternalIds_optional&
      EntityInternalIds () const;

      EntityInternalIds_optional&
      EntityInternalIds ();

      void
      EntityInternalIds (const EntityInternalIds_type& x);

      void
      EntityInternalIds (const EntityInternalIds_optional& x);

      void
      EntityInternalIds (::std::unique_ptr< EntityInternalIds_type > p);

      // EntityExternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityExternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityExternalIds_type > EntityExternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityExternalIds_type, wchar_t > EntityExternalIds_traits;

      const EntityExternalIds_optional&
      EntityExternalIds () const;

      EntityExternalIds_optional&
      EntityExternalIds ();

      void
      EntityExternalIds (const EntityExternalIds_type& x);

      void
      EntityExternalIds (const EntityExternalIds_optional& x);

      void
      EntityExternalIds (::std::unique_ptr< EntityExternalIds_type > p);

      // Text
      //
      typedef ::xml_schema::string Text_type;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_type&
      Text () const;

      Text_type&
      Text ();

      void
      Text (const Text_type& x);

      void
      Text (::std::unique_ptr< Text_type > p);

      // form
      //
      typedef ::xsd::qif30::NoteFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      static const form_type&
      form_default_value ();

      // Constructors.
      //
      NoteType ();

      NoteType (const id_type&,
                const Text_type&);

      NoteType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      NoteType (const NoteType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual NoteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NoteType&
      operator= (const NoteType& x);

      virtual 
      ~NoteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      EntityInternalIds_optional EntityInternalIds_;
      EntityExternalIds_optional EntityExternalIds_;
      ::xsd::cxx::tree::one< Text_type > Text_;
      ::xsd::cxx::tree::one< form_type > form_;
      static const form_type form_default_value_;
    };

    class QIF30_SYMBOL_DECL NoteFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        cxx_3D,
        SCREEN
      };

      NoteFormEnumType ();

      NoteFormEnumType (value v);

      NoteFormEnumType (const wchar_t* v);

      NoteFormEnumType (const ::std::wstring& v);

      NoteFormEnumType (const ::xml_schema::string& v);

      NoteFormEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      NoteFormEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      NoteFormEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      NoteFormEnumType (const NoteFormEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      NoteFormEnumType&
      operator= (const NoteFormEnumType&) = default;
#endif

      virtual NoteFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NoteFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NoteFormEnumType_convert ();
      }

      protected:
      value
      _xsd_NoteFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_NoteFormEnumType_literals_[2];
      static const value _xsd_NoteFormEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL NoteSetType: public ::xml_schema::type
    {
      public:
      // Note
      //
      typedef ::xsd::qif30::NoteType Note_type;
      typedef ::xsd::cxx::tree::sequence< Note_type > Note_sequence;
      typedef xsd::cxx::tree::sequence< Note_type >::iterator Note_iterator;
      typedef xsd::cxx::tree::sequence< Note_type >::const_iterator Note_const_iterator;
      typedef ::xsd::cxx::tree::traits< Note_type, wchar_t > Note_traits;

      const Note_sequence&
      Note () const;

      Note_sequence&
      Note ();

      void
      Note (const Note_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NoteSetType ();

      NoteSetType (const n_type&);

      NoteSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NoteSetType (const NoteSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual NoteSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NoteSetType&
      operator= (const NoteSetType& x);

      virtual 
      ~NoteSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Note_sequence Note_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL NoteFlagType: public ::xsd::qif30::NoteType
    {
      public:
      // TextHidden
      //
      typedef ::xml_schema::string TextHidden_type;
      typedef ::xsd::cxx::tree::optional< TextHidden_type > TextHidden_optional;
      typedef ::xsd::cxx::tree::traits< TextHidden_type, wchar_t > TextHidden_traits;

      const TextHidden_optional&
      TextHidden () const;

      TextHidden_optional&
      TextHidden ();

      void
      TextHidden (const TextHidden_type& x);

      void
      TextHidden (const TextHidden_optional& x);

      void
      TextHidden (::std::unique_ptr< TextHidden_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::optional< URI_type > URI_optional;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_optional&
      URI () const;

      URI_optional&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (const URI_optional& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // Constructors.
      //
      NoteFlagType ();

      NoteFlagType (const id_type&,
                    const Text_type&);

      NoteFlagType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      NoteFlagType (const NoteFlagType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual NoteFlagType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NoteFlagType&
      operator= (const NoteFlagType& x);

      virtual 
      ~NoteFlagType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TextHidden_optional TextHidden_;
      URI_optional URI_;
    };

    class QIF30_SYMBOL_DECL NoteFlagSetType: public ::xml_schema::type
    {
      public:
      // NoteFlag
      //
      typedef ::xsd::qif30::NoteFlagType NoteFlag_type;
      typedef ::xsd::cxx::tree::sequence< NoteFlag_type > NoteFlag_sequence;
      typedef xsd::cxx::tree::sequence< NoteFlag_type >::iterator NoteFlag_iterator;
      typedef xsd::cxx::tree::sequence< NoteFlag_type >::const_iterator NoteFlag_const_iterator;
      typedef ::xsd::cxx::tree::traits< NoteFlag_type, wchar_t > NoteFlag_traits;

      const NoteFlag_sequence&
      NoteFlag () const;

      NoteFlag_sequence&
      NoteFlag ();

      void
      NoteFlag (const NoteFlag_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NoteFlagSetType ();

      NoteFlagSetType (const n_type&);

      NoteFlagSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      NoteFlagSetType (const NoteFlagSetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual NoteFlagSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NoteFlagSetType&
      operator= (const NoteFlagSetType& x);

      virtual 
      ~NoteFlagSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NoteFlag_sequence NoteFlag_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FileInternalType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Constructors.
      //
      FileInternalType ();

      FileInternalType (const Name_type&);

      FileInternalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      FileInternalType (const FileInternalType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual FileInternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileInternalType&
      operator= (const FileInternalType& x);

      virtual 
      ~FileInternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Version_optional Version_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProductType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AsmPathType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AsmPathsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationPartAssemblyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationPartAssemblyInstancesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationPartAssemblyInstanceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartAssemblyBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FoldersPartType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FoldersAssemblyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FolderPartAssemblyBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FolderPartType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FolderAssemblyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssemblyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartFamilyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssemblySetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ComponentType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ComponentSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PrintedDrawingType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GDTEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const GDTEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const GDTEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TopologyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const TopologyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const TopologyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DigitalModelType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DefinitionExternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DigitalDrawingType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PhysicalModelType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartAssemblyHeaderType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProductHeaderType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LayerType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LayerSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartNoteSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartNoteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NoteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NoteFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const NoteFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const NoteFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NoteSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NoteFlagType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NoteFlagSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FileInternalType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFAPPLICATIONS_QIFPRODUCT_HXX
