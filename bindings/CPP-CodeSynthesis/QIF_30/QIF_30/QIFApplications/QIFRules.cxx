// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFRules.hxx"

namespace xsd
{
  namespace qif30
  {
    // QIFRulesType
    //

    const QIFRulesType::Version_optional& QIFRulesType::
    Version () const
    {
      return this->Version_;
    }

    QIFRulesType::Version_optional& QIFRulesType::
    Version ()
    {
      return this->Version_;
    }

    void QIFRulesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void QIFRulesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void QIFRulesType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits () const
    {
      return this->RulesUnits_;
    }

    QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits ()
    {
      return this->RulesUnits_;
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_type& x)
    {
      this->RulesUnits_.set (x);
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_optional& x)
    {
      this->RulesUnits_ = x;
    }

    void QIFRulesType::
    RulesUnits (::std::unique_ptr< RulesUnits_type > x)
    {
      this->RulesUnits_.set (std::move (x));
    }

    const QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules () const
    {
      return this->FeatureRules_;
    }

    QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules ()
    {
      return this->FeatureRules_;
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_type& x)
    {
      this->FeatureRules_.set (x);
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_optional& x)
    {
      this->FeatureRules_ = x;
    }

    void QIFRulesType::
    FeatureRules (::std::unique_ptr< FeatureRules_type > x)
    {
      this->FeatureRules_.set (std::move (x));
    }

    const QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules () const
    {
      return this->DMESelectionRules_;
    }

    QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules ()
    {
      return this->DMESelectionRules_;
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_type& x)
    {
      this->DMESelectionRules_.set (x);
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_optional& x)
    {
      this->DMESelectionRules_ = x;
    }

    void QIFRulesType::
    DMESelectionRules (::std::unique_ptr< DMESelectionRules_type > x)
    {
      this->DMESelectionRules_.set (std::move (x));
    }


    // RulesUnitsType
    //

    const RulesUnitsType::AreaUnit_optional& RulesUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    RulesUnitsType::AreaUnit_optional& RulesUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void RulesUnitsType::
    AreaUnit (const AreaUnit_type& x)
    {
      this->AreaUnit_.set (x);
    }

    void RulesUnitsType::
    AreaUnit (const AreaUnit_optional& x)
    {
      this->AreaUnit_ = x;
    }

    void RulesUnitsType::
    AreaUnit (::std::unique_ptr< AreaUnit_type > x)
    {
      this->AreaUnit_.set (std::move (x));
    }

    const RulesUnitsType::AngularUnit_optional& RulesUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    RulesUnitsType::AngularUnit_optional& RulesUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void RulesUnitsType::
    AngularUnit (const AngularUnit_type& x)
    {
      this->AngularUnit_.set (x);
    }

    void RulesUnitsType::
    AngularUnit (const AngularUnit_optional& x)
    {
      this->AngularUnit_ = x;
    }

    void RulesUnitsType::
    AngularUnit (::std::unique_ptr< AngularUnit_type > x)
    {
      this->AngularUnit_.set (std::move (x));
    }

    const RulesUnitsType::ForceUnit_optional& RulesUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    RulesUnitsType::ForceUnit_optional& RulesUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void RulesUnitsType::
    ForceUnit (const ForceUnit_type& x)
    {
      this->ForceUnit_.set (x);
    }

    void RulesUnitsType::
    ForceUnit (const ForceUnit_optional& x)
    {
      this->ForceUnit_ = x;
    }

    void RulesUnitsType::
    ForceUnit (::std::unique_ptr< ForceUnit_type > x)
    {
      this->ForceUnit_.set (std::move (x));
    }

    const RulesUnitsType::LinearUnit_optional& RulesUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    RulesUnitsType::LinearUnit_optional& RulesUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void RulesUnitsType::
    LinearUnit (const LinearUnit_type& x)
    {
      this->LinearUnit_.set (x);
    }

    void RulesUnitsType::
    LinearUnit (const LinearUnit_optional& x)
    {
      this->LinearUnit_ = x;
    }

    void RulesUnitsType::
    LinearUnit (::std::unique_ptr< LinearUnit_type > x)
    {
      this->LinearUnit_.set (std::move (x));
    }

    const RulesUnitsType::MassUnit_optional& RulesUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    RulesUnitsType::MassUnit_optional& RulesUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void RulesUnitsType::
    MassUnit (const MassUnit_type& x)
    {
      this->MassUnit_.set (x);
    }

    void RulesUnitsType::
    MassUnit (const MassUnit_optional& x)
    {
      this->MassUnit_ = x;
    }

    void RulesUnitsType::
    MassUnit (::std::unique_ptr< MassUnit_type > x)
    {
      this->MassUnit_.set (std::move (x));
    }

    const RulesUnitsType::PressureUnit_optional& RulesUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    RulesUnitsType::PressureUnit_optional& RulesUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void RulesUnitsType::
    PressureUnit (const PressureUnit_type& x)
    {
      this->PressureUnit_.set (x);
    }

    void RulesUnitsType::
    PressureUnit (const PressureUnit_optional& x)
    {
      this->PressureUnit_ = x;
    }

    void RulesUnitsType::
    PressureUnit (::std::unique_ptr< PressureUnit_type > x)
    {
      this->PressureUnit_.set (std::move (x));
    }

    const RulesUnitsType::SpeedUnit_optional& RulesUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    RulesUnitsType::SpeedUnit_optional& RulesUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void RulesUnitsType::
    SpeedUnit (const SpeedUnit_type& x)
    {
      this->SpeedUnit_.set (x);
    }

    void RulesUnitsType::
    SpeedUnit (const SpeedUnit_optional& x)
    {
      this->SpeedUnit_ = x;
    }

    void RulesUnitsType::
    SpeedUnit (::std::unique_ptr< SpeedUnit_type > x)
    {
      this->SpeedUnit_.set (std::move (x));
    }

    const RulesUnitsType::TemperatureUnit_optional& RulesUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    RulesUnitsType::TemperatureUnit_optional& RulesUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void RulesUnitsType::
    TemperatureUnit (const TemperatureUnit_type& x)
    {
      this->TemperatureUnit_.set (x);
    }

    void RulesUnitsType::
    TemperatureUnit (const TemperatureUnit_optional& x)
    {
      this->TemperatureUnit_ = x;
    }

    void RulesUnitsType::
    TemperatureUnit (::std::unique_ptr< TemperatureUnit_type > x)
    {
      this->TemperatureUnit_.set (std::move (x));
    }

    const RulesUnitsType::TimeUnit_optional& RulesUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    RulesUnitsType::TimeUnit_optional& RulesUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void RulesUnitsType::
    TimeUnit (const TimeUnit_type& x)
    {
      this->TimeUnit_.set (x);
    }

    void RulesUnitsType::
    TimeUnit (const TimeUnit_optional& x)
    {
      this->TimeUnit_ = x;
    }

    void RulesUnitsType::
    TimeUnit (::std::unique_ptr< TimeUnit_type > x)
    {
      this->TimeUnit_.set (std::move (x));
    }

    const RulesUnitsType::n_type& RulesUnitsType::
    n () const
    {
      return this->n_.get ();
    }

    RulesUnitsType::n_type& RulesUnitsType::
    n ()
    {
      return this->n_.get ();
    }

    void RulesUnitsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void RulesUnitsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureRulesType
    //

    const FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules () const
    {
      return this->IfThenElseFeatureRules_;
    }

    FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules ()
    {
      return this->IfThenElseFeatureRules_;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_type& x)
    {
      this->IfThenElseFeatureRules_.set (x);
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_optional& x)
    {
      this->IfThenElseFeatureRules_ = x;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (::std::unique_ptr< IfThenElseFeatureRules_type > x)
    {
      this->IfThenElseFeatureRules_.set (std::move (x));
    }

    const FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules () const
    {
      return this->MaxFeatureRules_;
    }

    FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules ()
    {
      return this->MaxFeatureRules_;
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_type& x)
    {
      this->MaxFeatureRules_.set (x);
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_optional& x)
    {
      this->MaxFeatureRules_ = x;
    }

    void FeatureRulesType::
    MaxFeatureRules (::std::unique_ptr< MaxFeatureRules_type > x)
    {
      this->MaxFeatureRules_.set (std::move (x));
    }


    // QIFRuleBaseType
    //

    const QIFRuleBaseType::UUID_optional& QIFRuleBaseType::
    UUID () const
    {
      return this->UUID_;
    }

    QIFRuleBaseType::UUID_optional& QIFRuleBaseType::
    UUID ()
    {
      return this->UUID_;
    }

    void QIFRuleBaseType::
    UUID (const UUID_type& x)
    {
      this->UUID_.set (x);
    }

    void QIFRuleBaseType::
    UUID (const UUID_optional& x)
    {
      this->UUID_ = x;
    }

    void QIFRuleBaseType::
    UUID (::std::unique_ptr< UUID_type > x)
    {
      this->UUID_.set (std::move (x));
    }

    const QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name () const
    {
      return this->name_;
    }

    QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name ()
    {
      return this->name_;
    }

    void QIFRuleBaseType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void QIFRuleBaseType::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void QIFRuleBaseType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }


    // IfThenElseFeatureRulesType
    //

    const IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void IfThenElseFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void IfThenElseFeatureRulesType::
    Else (::std::unique_ptr< Else_type > x)
    {
      this->Else_.set (std::move (x));
    }

    const IfThenElseFeatureRulesType::n_type& IfThenElseFeatureRulesType::
    n () const
    {
      return this->n_.get ();
    }

    IfThenElseFeatureRulesType::n_type& IfThenElseFeatureRulesType::
    n ()
    {
      return this->n_.get ();
    }

    void IfThenElseFeatureRulesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void IfThenElseFeatureRulesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MaxFeatureRulesType
    //

    const MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void MaxFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void MaxFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void MaxFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void MaxFeatureRulesType::
    Else (::std::unique_ptr< Else_type > x)
    {
      this->Else_.set (std::move (x));
    }

    const MaxFeatureRulesType::n_type& MaxFeatureRulesType::
    n () const
    {
      return this->n_.get ();
    }

    MaxFeatureRulesType::n_type& MaxFeatureRulesType::
    n ()
    {
      return this->n_.get ();
    }

    void MaxFeatureRulesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MaxFeatureRulesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointRuleBaseType
    //


    // IfThenFeatureRuleType
    //

    const IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_optional& x)
    {
      this->BooleanExpression_ = x;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (::std::unique_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (std::move (x));
    }

    const IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_;
    }

    IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_;
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_optional& x)
    {
      this->ThenPoints_ = x;
    }

    void IfThenFeatureRuleType::
    ThenPoints (::std::unique_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (std::move (x));
    }


    // ElseRuleType
    //

    const ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_.get ();
    }

    ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_.get ();
    }

    void ElseRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void ElseRuleType::
    ThenPoints (::std::unique_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (std::move (x));
    }


    // ThenPointsType
    //

    const ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints () const
    {
      return this->NumberOfPoints_;
    }

    ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints ()
    {
      return this->NumberOfPoints_;
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_type& x)
    {
      this->NumberOfPoints_.set (x);
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_optional& x)
    {
      this->NumberOfPoints_ = x;
    }

    const ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints () const
    {
      return this->MinPoints_;
    }

    ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints ()
    {
      return this->MinPoints_;
    }

    void ThenPointsType::
    MinPoints (const MinPoints_type& x)
    {
      this->MinPoints_.set (x);
    }

    void ThenPointsType::
    MinPoints (const MinPoints_optional& x)
    {
      this->MinPoints_ = x;
    }

    const ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity () const
    {
      return this->PointDensity_;
    }

    ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity ()
    {
      return this->PointDensity_;
    }

    void ThenPointsType::
    PointDensity (const PointDensity_type& x)
    {
      this->PointDensity_.set (x);
    }

    void ThenPointsType::
    PointDensity (const PointDensity_optional& x)
    {
      this->PointDensity_ = x;
    }

    void ThenPointsType::
    PointDensity (::std::unique_ptr< PointDensity_type > x)
    {
      this->PointDensity_.set (std::move (x));
    }

    const ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity () const
    {
      return this->MinPointDensity_;
    }

    ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity ()
    {
      return this->MinPointDensity_;
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_type& x)
    {
      this->MinPointDensity_.set (x);
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_optional& x)
    {
      this->MinPointDensity_ = x;
    }

    void ThenPointsType::
    MinPointDensity (::std::unique_ptr< MinPointDensity_type > x)
    {
      this->MinPointDensity_.set (std::move (x));
    }


    // IfThenCircleRuleType
    //

    const IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // CirclePointSamplingStrategyType
    //

    const CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenCircularArcRuleType
    //

    const IfThenCircularArcRuleType::ThenPointStrategy_optional& IfThenCircularArcRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCircularArcRuleType::ThenPointStrategy_optional& IfThenCircularArcRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCircularArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCircularArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCircularArcRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenCircularArcRuleType::ThenFittingAlgorithm_optional& IfThenCircularArcRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCircularArcRuleType::ThenFittingAlgorithm_optional& IfThenCircularArcRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCircularArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCircularArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCircularArcRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // CircularArcPointSamplingStrategyType
    //

    const CircularArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CircularArcPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CircularArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CircularArcPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CircularArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CircularArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CircularArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const CircularArcPointSamplingStrategyType::UserDefinedStrategy_optional& CircularArcPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CircularArcPointSamplingStrategyType::UserDefinedStrategy_optional& CircularArcPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CircularArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CircularArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CircularArcPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenConeRuleType
    //

    const IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ConePointSamplingStrategyType
    //

    const ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenConicalSegmentRuleType
    //

    const IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ConicalSegmentPointSamplingStrategyType
    //

    const ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenCylinderRuleType
    //

    const IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // CylinderPointSamplingStrategyType
    //

    const CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenCylindricalSegmentRuleType
    //

    const IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // CylindricalSegmentPointSamplingStrategyType
    //

    const CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenEllipseRuleType
    //

    const IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // EllipsePointSamplingStrategyType
    //

    const EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenEllipticalArcRuleType
    //

    const IfThenEllipticalArcRuleType::ThenPointStrategy_optional& IfThenEllipticalArcRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenEllipticalArcRuleType::ThenPointStrategy_optional& IfThenEllipticalArcRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenEllipticalArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenEllipticalArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenEllipticalArcRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenEllipticalArcRuleType::ThenFittingAlgorithm_optional& IfThenEllipticalArcRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenEllipticalArcRuleType::ThenFittingAlgorithm_optional& IfThenEllipticalArcRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenEllipticalArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenEllipticalArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenEllipticalArcRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // EllipticalArcPointSamplingStrategyType
    //

    const EllipticalArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipticalArcPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    EllipticalArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipticalArcPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void EllipticalArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void EllipticalArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void EllipticalArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const EllipticalArcPointSamplingStrategyType::UserDefinedStrategy_optional& EllipticalArcPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    EllipticalArcPointSamplingStrategyType::UserDefinedStrategy_optional& EllipticalArcPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void EllipticalArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void EllipticalArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void EllipticalArcPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenElongatedCircleRuleType
    //

    const IfThenElongatedCircleRuleType::ThenPointStrategy_optional& IfThenElongatedCircleRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenElongatedCircleRuleType::ThenPointStrategy_optional& IfThenElongatedCircleRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenElongatedCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenElongatedCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenElongatedCircleRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenElongatedCircleRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCircleRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenElongatedCircleRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCircleRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenElongatedCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenElongatedCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenElongatedCircleRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ElongatedCirclePointSamplingStrategyType
    //

    const ElongatedCirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCirclePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ElongatedCirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCirclePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ElongatedCirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ElongatedCirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ElongatedCirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ElongatedCirclePointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCirclePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ElongatedCirclePointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCirclePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ElongatedCirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ElongatedCirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ElongatedCirclePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenElongatedCylinderRuleType
    //

    const IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ElongatedCylinderPointSamplingStrategyType
    //

    const ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenExtrudedCrossSectionRuleType
    //

    const IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ExtrudedCrossSectionPointSamplingStrategyType
    //

    const ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenLineRuleType
    //

    const IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // LinePointSamplingStrategyType
    //

    const LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenOppositeAngledLinesRuleType
    //

    const IfThenOppositeAngledLinesRuleType::ThenPointStrategy_optional& IfThenOppositeAngledLinesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeAngledLinesRuleType::ThenPointStrategy_optional& IfThenOppositeAngledLinesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenOppositeAngledLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeAngledLinesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeAngledLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeAngledLinesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeAngledLinesRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // OppositeAngledLinesPointSamplingStrategyType
    //

    const OppositeAngledLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeAngledLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeAngledLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeAngledLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const OppositeAngledLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeAngledLinesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeAngledLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeAngledLinesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenOppositeAngledPlanesRuleType
    //

    const IfThenOppositeAngledPlanesRuleType::ThenPointStrategy_optional& IfThenOppositeAngledPlanesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeAngledPlanesRuleType::ThenPointStrategy_optional& IfThenOppositeAngledPlanesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenOppositeAngledPlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeAngledPlanesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeAngledPlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeAngledPlanesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeAngledPlanesRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // OppositeAngledPlanesPointSamplingStrategyType
    //

    const OppositeAngledPlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeAngledPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeAngledPlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeAngledPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const OppositeAngledPlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeAngledPlanesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeAngledPlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeAngledPlanesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenOppositeParallelLinesRuleType
    //

    const IfThenOppositeParallelLinesRuleType::ThenPointStrategy_optional& IfThenOppositeParallelLinesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeParallelLinesRuleType::ThenPointStrategy_optional& IfThenOppositeParallelLinesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenOppositeParallelLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeParallelLinesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeParallelLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeParallelLinesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeParallelLinesRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // OppositeParallelLinesPointSamplingStrategyType
    //

    const OppositeParallelLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeParallelLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeParallelLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeParallelLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const OppositeParallelLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeParallelLinesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeParallelLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeParallelLinesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenOppositeParallelPlanesRuleType
    //

    const IfThenOppositeParallelPlanesRuleType::ThenPointStrategy_optional& IfThenOppositeParallelPlanesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeParallelPlanesRuleType::ThenPointStrategy_optional& IfThenOppositeParallelPlanesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenOppositeParallelPlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeParallelPlanesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeParallelPlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeParallelPlanesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeParallelPlanesRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // OppositeParallelPlanesPointSamplingStrategyType
    //

    const OppositeParallelPlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeParallelPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeParallelPlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeParallelPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const OppositeParallelPlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeParallelPlanesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeParallelPlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeParallelPlanesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenPlaneRuleType
    //

    const IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // PlanePointSamplingStrategyType
    //

    const PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenPointDefinedCurveRuleType
    //

    const IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // PointDefinedCurvePointSamplingStrategyType
    //

    const PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenPointDefinedSurfaceRuleType
    //

    const IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // PointDefinedSurfacePointSamplingStrategyType
    //

    const PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenPointRuleType
    //

    const IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }


    // PointPointSamplingStrategyType
    //

    const PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenSphereRuleType
    //

    const IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // SpherePointSamplingStrategyType
    //

    const SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenSphericalSegmentRuleType
    //

    const IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // SphericalSegmentPointSamplingStrategyType
    //

    const SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenSurfaceOfRevolutionRuleType
    //

    const IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // SurfaceOfRevolutionPointSamplingStrategyType
    //

    const SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenToroidalSegmentRuleType
    //

    const IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // ToroidalSegmentPointSamplingStrategyType
    //

    const ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenTorusRuleType
    //

    const IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (std::move (x));
    }

    const IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (std::move (x));
    }


    // TorusPointSamplingStrategyType
    //

    const TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (std::move (x));
    }

    const TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (std::move (x));
    }


    // IfThenSurfaceRuleType
    //


    // IfThenCurveRuleType
    //


    // DMESelectionRulesType
    //

    const DMESelectionRulesType::DMEDecisionRule_sequence& DMESelectionRulesType::
    DMEDecisionRule () const
    {
      return this->DMEDecisionRule_;
    }

    DMESelectionRulesType::DMEDecisionRule_sequence& DMESelectionRulesType::
    DMEDecisionRule ()
    {
      return this->DMEDecisionRule_;
    }

    void DMESelectionRulesType::
    DMEDecisionRule (const DMEDecisionRule_sequence& s)
    {
      this->DMEDecisionRule_ = s;
    }

    const DMESelectionRulesType::defaultDesirability_type& DMESelectionRulesType::
    defaultDesirability () const
    {
      return this->defaultDesirability_.get ();
    }

    DMESelectionRulesType::defaultDesirability_type& DMESelectionRulesType::
    defaultDesirability ()
    {
      return this->defaultDesirability_.get ();
    }

    void DMESelectionRulesType::
    defaultDesirability (const defaultDesirability_type& x)
    {
      this->defaultDesirability_.set (x);
    }

    void DMESelectionRulesType::
    defaultDesirability (::std::unique_ptr< defaultDesirability_type > x)
    {
      this->defaultDesirability_.set (std::move (x));
    }

    DMESelectionRulesType::defaultDesirability_type DMESelectionRulesType::
    defaultDesirability_default_value ()
    {
      return defaultDesirability_type (1.0);
    }

    const DMESelectionRulesType::n_type& DMESelectionRulesType::
    n () const
    {
      return this->n_.get ();
    }

    DMESelectionRulesType::n_type& DMESelectionRulesType::
    n ()
    {
      return this->n_.get ();
    }

    void DMESelectionRulesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DMESelectionRulesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DMEThenType
    //

    const DMEThenType::DMEDecision_sequence& DMEThenType::
    DMEDecision () const
    {
      return this->DMEDecision_;
    }

    DMEThenType::DMEDecision_sequence& DMEThenType::
    DMEDecision ()
    {
      return this->DMEDecision_;
    }

    void DMEThenType::
    DMEDecision (const DMEDecision_sequence& s)
    {
      this->DMEDecision_ = s;
    }

    const DMEThenType::n_type& DMEThenType::
    n () const
    {
      return this->n_.get ();
    }

    DMEThenType::n_type& DMEThenType::
    n ()
    {
      return this->n_.get ();
    }

    void DMEThenType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DMEThenType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DMEDecisionBaseType
    //

    const DMEDecisionBaseType::Applicability_type& DMEDecisionBaseType::
    Applicability () const
    {
      return this->Applicability_.get ();
    }

    DMEDecisionBaseType::Applicability_type& DMEDecisionBaseType::
    Applicability ()
    {
      return this->Applicability_.get ();
    }

    void DMEDecisionBaseType::
    Applicability (const Applicability_type& x)
    {
      this->Applicability_.set (x);
    }

    void DMEDecisionBaseType::
    Applicability (::std::unique_ptr< Applicability_type > x)
    {
      this->Applicability_.set (std::move (x));
    }


    // ApplicabilityBaseType
    //


    // QIFMustType
    //


    // QIFMustNotType
    //


    // QIFMayType
    //

    const QIFMayType::desirability_optional& QIFMayType::
    desirability () const
    {
      return this->desirability_;
    }

    QIFMayType::desirability_optional& QIFMayType::
    desirability ()
    {
      return this->desirability_;
    }

    void QIFMayType::
    desirability (const desirability_type& x)
    {
      this->desirability_.set (x);
    }

    void QIFMayType::
    desirability (const desirability_optional& x)
    {
      this->desirability_ = x;
    }

    void QIFMayType::
    desirability (::std::unique_ptr< desirability_type > x)
    {
      this->desirability_.set (std::move (x));
    }


    // DMEDecisionClassType
    //

    const DMEDecisionClassType::DMEClassName_type& DMEDecisionClassType::
    DMEClassName () const
    {
      return this->DMEClassName_.get ();
    }

    DMEDecisionClassType::DMEClassName_type& DMEDecisionClassType::
    DMEClassName ()
    {
      return this->DMEClassName_.get ();
    }

    void DMEDecisionClassType::
    DMEClassName (const DMEClassName_type& x)
    {
      this->DMEClassName_.set (x);
    }

    void DMEDecisionClassType::
    DMEClassName (::std::unique_ptr< DMEClassName_type > x)
    {
      this->DMEClassName_.set (std::move (x));
    }

    const DMEDecisionClassType::ParameterConstraints_optional& DMEDecisionClassType::
    ParameterConstraints () const
    {
      return this->ParameterConstraints_;
    }

    DMEDecisionClassType::ParameterConstraints_optional& DMEDecisionClassType::
    ParameterConstraints ()
    {
      return this->ParameterConstraints_;
    }

    void DMEDecisionClassType::
    ParameterConstraints (const ParameterConstraints_type& x)
    {
      this->ParameterConstraints_.set (x);
    }

    void DMEDecisionClassType::
    ParameterConstraints (const ParameterConstraints_optional& x)
    {
      this->ParameterConstraints_ = x;
    }

    void DMEDecisionClassType::
    ParameterConstraints (::std::unique_ptr< ParameterConstraints_type > x)
    {
      this->ParameterConstraints_.set (std::move (x));
    }


    // DMEParameterConstraintSetType
    //

    const DMEParameterConstraintSetType::DMEParameterConstraint_sequence& DMEParameterConstraintSetType::
    DMEParameterConstraint () const
    {
      return this->DMEParameterConstraint_;
    }

    DMEParameterConstraintSetType::DMEParameterConstraint_sequence& DMEParameterConstraintSetType::
    DMEParameterConstraint ()
    {
      return this->DMEParameterConstraint_;
    }

    void DMEParameterConstraintSetType::
    DMEParameterConstraint (const DMEParameterConstraint_sequence& s)
    {
      this->DMEParameterConstraint_ = s;
    }

    const DMEParameterConstraintSetType::n_type& DMEParameterConstraintSetType::
    n () const
    {
      return this->n_.get ();
    }

    DMEParameterConstraintSetType::n_type& DMEParameterConstraintSetType::
    n ()
    {
      return this->n_.get ();
    }

    void DMEParameterConstraintSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DMEParameterConstraintSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DMEParameterConstraintType
    //

    const DMEParameterConstraintType::ParameterName_type& DMEParameterConstraintType::
    ParameterName () const
    {
      return this->ParameterName_.get ();
    }

    DMEParameterConstraintType::ParameterName_type& DMEParameterConstraintType::
    ParameterName ()
    {
      return this->ParameterName_.get ();
    }

    void DMEParameterConstraintType::
    ParameterName (const ParameterName_type& x)
    {
      this->ParameterName_.set (x);
    }

    void DMEParameterConstraintType::
    ParameterName (::std::unique_ptr< ParameterName_type > x)
    {
      this->ParameterName_.set (std::move (x));
    }

    const DMEParameterConstraintType::Comparison_type& DMEParameterConstraintType::
    Comparison () const
    {
      return this->Comparison_.get ();
    }

    DMEParameterConstraintType::Comparison_type& DMEParameterConstraintType::
    Comparison ()
    {
      return this->Comparison_.get ();
    }

    void DMEParameterConstraintType::
    Comparison (const Comparison_type& x)
    {
      this->Comparison_.set (x);
    }

    void DMEParameterConstraintType::
    Comparison (::std::unique_ptr< Comparison_type > x)
    {
      this->Comparison_.set (std::move (x));
    }

    const DMEParameterConstraintType::ArithmeticExpression_type& DMEParameterConstraintType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_.get ();
    }

    DMEParameterConstraintType::ArithmeticExpression_type& DMEParameterConstraintType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_.get ();
    }

    void DMEParameterConstraintType::
    ArithmeticExpression (const ArithmeticExpression_type& x)
    {
      this->ArithmeticExpression_.set (x);
    }

    void DMEParameterConstraintType::
    ArithmeticExpression (::std::unique_ptr< ArithmeticExpression_type > x)
    {
      this->ArithmeticExpression_.set (std::move (x));
    }


    // DMEDecisionIdType
    //

    const DMEDecisionIdType::DMEId_type& DMEDecisionIdType::
    DMEId () const
    {
      return this->DMEId_.get ();
    }

    DMEDecisionIdType::DMEId_type& DMEDecisionIdType::
    DMEId ()
    {
      return this->DMEId_.get ();
    }

    void DMEDecisionIdType::
    DMEId (const DMEId_type& x)
    {
      this->DMEId_.set (x);
    }

    void DMEDecisionIdType::
    DMEId (::std::unique_ptr< DMEId_type > x)
    {
      this->DMEId_.set (std::move (x));
    }


    // DMEDecisionMakeModelType
    //

    const DMEDecisionMakeModelType::Manufacturer_type& DMEDecisionMakeModelType::
    Manufacturer () const
    {
      return this->Manufacturer_.get ();
    }

    DMEDecisionMakeModelType::Manufacturer_type& DMEDecisionMakeModelType::
    Manufacturer ()
    {
      return this->Manufacturer_.get ();
    }

    void DMEDecisionMakeModelType::
    Manufacturer (const Manufacturer_type& x)
    {
      this->Manufacturer_.set (x);
    }

    void DMEDecisionMakeModelType::
    Manufacturer (::std::unique_ptr< Manufacturer_type > x)
    {
      this->Manufacturer_.set (std::move (x));
    }

    const DMEDecisionMakeModelType::ModelNumber_type& DMEDecisionMakeModelType::
    ModelNumber () const
    {
      return this->ModelNumber_.get ();
    }

    DMEDecisionMakeModelType::ModelNumber_type& DMEDecisionMakeModelType::
    ModelNumber ()
    {
      return this->ModelNumber_.get ();
    }

    void DMEDecisionMakeModelType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void DMEDecisionMakeModelType::
    ModelNumber (::std::unique_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const DMEDecisionMakeModelType::SerialNumber_optional& DMEDecisionMakeModelType::
    SerialNumber () const
    {
      return this->SerialNumber_;
    }

    DMEDecisionMakeModelType::SerialNumber_optional& DMEDecisionMakeModelType::
    SerialNumber ()
    {
      return this->SerialNumber_;
    }

    void DMEDecisionMakeModelType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void DMEDecisionMakeModelType::
    SerialNumber (const SerialNumber_optional& x)
    {
      this->SerialNumber_ = x;
    }

    void DMEDecisionMakeModelType::
    SerialNumber (::std::unique_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (std::move (x));
    }


    // IfThenDMERuleType
    //

    const IfThenDMERuleType::BooleanExpression_optional& IfThenDMERuleType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    IfThenDMERuleType::BooleanExpression_optional& IfThenDMERuleType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void IfThenDMERuleType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void IfThenDMERuleType::
    BooleanExpression (const BooleanExpression_optional& x)
    {
      this->BooleanExpression_ = x;
    }

    void IfThenDMERuleType::
    BooleanExpression (::std::unique_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (std::move (x));
    }

    const IfThenDMERuleType::DMEThen_type& IfThenDMERuleType::
    DMEThen () const
    {
      return this->DMEThen_.get ();
    }

    IfThenDMERuleType::DMEThen_type& IfThenDMERuleType::
    DMEThen ()
    {
      return this->DMEThen_.get ();
    }

    void IfThenDMERuleType::
    DMEThen (const DMEThen_type& x)
    {
      this->DMEThen_.set (x);
    }

    void IfThenDMERuleType::
    DMEThen (::std::unique_ptr< DMEThen_type > x)
    {
      this->DMEThen_.set (std::move (x));
    }


    // ZeroToOneType
    //
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // QIFRulesType
    //

    QIFRulesType::
    QIFRulesType ()
    : ::xml_schema::type (),
      Version_ (this),
      RulesUnits_ (this),
      FeatureRules_ (this),
      DMESelectionRules_ (this)
    {
    }

    QIFRulesType::
    QIFRulesType (const QIFRulesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      RulesUnits_ (x.RulesUnits_, f, this),
      FeatureRules_ (x.FeatureRules_, f, this),
      DMESelectionRules_ (x.DMESelectionRules_, f, this)
    {
    }

    QIFRulesType::
    QIFRulesType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      RulesUnits_ (this),
      FeatureRules_ (this),
      DMESelectionRules_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QIFRulesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // RulesUnits
        //
        if (n.name () == L"RulesUnits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RulesUnits_type > r (
            RulesUnits_traits::create (i, f, this));

          if (!this->RulesUnits_)
          {
            this->RulesUnits_.set (::std::move (r));
            continue;
          }
        }

        // FeatureRules
        //
        if (n.name () == L"FeatureRules" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureRules_type > r (
            FeatureRules_traits::create (i, f, this));

          if (!this->FeatureRules_)
          {
            this->FeatureRules_.set (::std::move (r));
            continue;
          }
        }

        // DMESelectionRules
        //
        if (n.name () == L"DMESelectionRules" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMESelectionRules_type > r (
            DMESelectionRules_traits::create (i, f, this));

          if (!this->DMESelectionRules_)
          {
            this->DMESelectionRules_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    QIFRulesType* QIFRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFRulesType (*this, f, c);
    }

    QIFRulesType& QIFRulesType::
    operator= (const QIFRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->RulesUnits_ = x.RulesUnits_;
        this->FeatureRules_ = x.FeatureRules_;
        this->DMESelectionRules_ = x.DMESelectionRules_;
      }

      return *this;
    }

    QIFRulesType::
    ~QIFRulesType ()
    {
    }

    // RulesUnitsType
    //

    RulesUnitsType::
    RulesUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (this)
    {
    }

    RulesUnitsType::
    RulesUnitsType (const n_type& n)
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (n, this)
    {
    }

    RulesUnitsType::
    RulesUnitsType (const RulesUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this),
      n_ (x.n_, f, this)
    {
    }

    RulesUnitsType::
    RulesUnitsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void RulesUnitsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AreaUnit
        //
        if (n.name () == L"AreaUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          if (!this->AreaUnit_)
          {
            this->AreaUnit_.set (::std::move (r));
            continue;
          }
        }

        // AngularUnit
        //
        if (n.name () == L"AngularUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          if (!this->AngularUnit_)
          {
            this->AngularUnit_.set (::std::move (r));
            continue;
          }
        }

        // ForceUnit
        //
        if (n.name () == L"ForceUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          if (!this->ForceUnit_)
          {
            this->ForceUnit_.set (::std::move (r));
            continue;
          }
        }

        // LinearUnit
        //
        if (n.name () == L"LinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          if (!this->LinearUnit_)
          {
            this->LinearUnit_.set (::std::move (r));
            continue;
          }
        }

        // MassUnit
        //
        if (n.name () == L"MassUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          if (!this->MassUnit_)
          {
            this->MassUnit_.set (::std::move (r));
            continue;
          }
        }

        // PressureUnit
        //
        if (n.name () == L"PressureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          if (!this->PressureUnit_)
          {
            this->PressureUnit_.set (::std::move (r));
            continue;
          }
        }

        // SpeedUnit
        //
        if (n.name () == L"SpeedUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          if (!this->SpeedUnit_)
          {
            this->SpeedUnit_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureUnit
        //
        if (n.name () == L"TemperatureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          if (!this->TemperatureUnit_)
          {
            this->TemperatureUnit_.set (::std::move (r));
            continue;
          }
        }

        // TimeUnit
        //
        if (n.name () == L"TimeUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          if (!this->TimeUnit_)
          {
            this->TimeUnit_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    RulesUnitsType* RulesUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RulesUnitsType (*this, f, c);
    }

    RulesUnitsType& RulesUnitsType::
    operator= (const RulesUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaUnit_ = x.AreaUnit_;
        this->AngularUnit_ = x.AngularUnit_;
        this->ForceUnit_ = x.ForceUnit_;
        this->LinearUnit_ = x.LinearUnit_;
        this->MassUnit_ = x.MassUnit_;
        this->PressureUnit_ = x.PressureUnit_;
        this->SpeedUnit_ = x.SpeedUnit_;
        this->TemperatureUnit_ = x.TemperatureUnit_;
        this->TimeUnit_ = x.TimeUnit_;
        this->n_ = x.n_;
      }

      return *this;
    }

    RulesUnitsType::
    ~RulesUnitsType ()
    {
    }

    // FeatureRulesType
    //

    FeatureRulesType::
    FeatureRulesType ()
    : ::xml_schema::type (),
      IfThenElseFeatureRules_ (this),
      MaxFeatureRules_ (this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const FeatureRulesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenElseFeatureRules_ (x.IfThenElseFeatureRules_, f, this),
      MaxFeatureRules_ (x.MaxFeatureRules_, f, this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenElseFeatureRules_ (this),
      MaxFeatureRules_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IfThenElseFeatureRules
        //
        if (n.name () == L"IfThenElseFeatureRules" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IfThenElseFeatureRules_type > r (
            IfThenElseFeatureRules_traits::create (i, f, this));

          if (!this->IfThenElseFeatureRules_)
          {
            this->IfThenElseFeatureRules_.set (::std::move (r));
            continue;
          }
        }

        // MaxFeatureRules
        //
        if (n.name () == L"MaxFeatureRules" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFeatureRules_type > r (
            MaxFeatureRules_traits::create (i, f, this));

          if (!this->MaxFeatureRules_)
          {
            this->MaxFeatureRules_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureRulesType* FeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureRulesType (*this, f, c);
    }

    FeatureRulesType& FeatureRulesType::
    operator= (const FeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IfThenElseFeatureRules_ = x.IfThenElseFeatureRules_;
        this->MaxFeatureRules_ = x.MaxFeatureRules_;
      }

      return *this;
    }

    FeatureRulesType::
    ~FeatureRulesType ()
    {
    }

    // QIFRuleBaseType
    //

    QIFRuleBaseType::
    QIFRuleBaseType ()
    : ::xml_schema::type (),
      UUID_ (this),
      name_ (this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const QIFRuleBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UUID_ (x.UUID_, f, this),
      name_ (x.name_, f, this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UUID_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void QIFRuleBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UUID
        //
        if (n.name () == L"UUID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UUID_type > r (
            UUID_traits::create (i, f, this));

          if (!this->UUID_)
          {
            this->UUID_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }
    }

    QIFRuleBaseType& QIFRuleBaseType::
    operator= (const QIFRuleBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->UUID_ = x.UUID_;
        this->name_ = x.name_;
      }

      return *this;
    }

    QIFRuleBaseType::
    ~QIFRuleBaseType ()
    {
    }

    // IfThenElseFeatureRulesType
    //

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const n_type& n)
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (n, this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const IfThenElseFeatureRulesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this),
      n_ (x.n_, f, this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenElseFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IfThenFeatureRule
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"IfThenFeatureRule",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< IfThenFeatureRule_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< IfThenFeatureRule_type > r (
              dynamic_cast< IfThenFeatureRule_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->IfThenFeatureRule_.push_back (::std::move (r));
            continue;
          }
        }

        // Else
        //
        if (n.name () == L"Else" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    IfThenElseFeatureRulesType* IfThenElseFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElseFeatureRulesType (*this, f, c);
    }

    IfThenElseFeatureRulesType& IfThenElseFeatureRulesType::
    operator= (const IfThenElseFeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IfThenFeatureRule_ = x.IfThenFeatureRule_;
        this->Else_ = x.Else_;
        this->n_ = x.n_;
      }

      return *this;
    }

    IfThenElseFeatureRulesType::
    ~IfThenElseFeatureRulesType ()
    {
    }

    // MaxFeatureRulesType
    //

    MaxFeatureRulesType::
    MaxFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const n_type& n)
    : ::xml_schema::type (),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (n, this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const MaxFeatureRulesType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (this),
      Else_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MaxFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IfThenFeatureRule
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"IfThenFeatureRule",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< IfThenFeatureRule_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< IfThenFeatureRule_type > r (
              dynamic_cast< IfThenFeatureRule_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->IfThenFeatureRule_.push_back (::std::move (r));
            continue;
          }
        }

        // Else
        //
        if (n.name () == L"Else" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MaxFeatureRulesType* MaxFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaxFeatureRulesType (*this, f, c);
    }

    MaxFeatureRulesType& MaxFeatureRulesType::
    operator= (const MaxFeatureRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IfThenFeatureRule_ = x.IfThenFeatureRule_;
        this->Else_ = x.Else_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MaxFeatureRulesType::
    ~MaxFeatureRulesType ()
    {
    }

    // PointRuleBaseType
    //

    PointRuleBaseType::
    PointRuleBaseType ()
    : ::xsd::qif30::QIFRuleBaseType ()
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const PointRuleBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::QIFRuleBaseType (x, f, c)
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::QIFRuleBaseType (e, f, c)
    {
    }

    PointRuleBaseType::
    ~PointRuleBaseType ()
    {
    }

    // IfThenFeatureRuleType
    //

    IfThenFeatureRuleType::
    IfThenFeatureRuleType ()
    : ::xsd::qif30::PointRuleBaseType (),
      BooleanExpression_ (this),
      ThenPoints_ (this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const IfThenFeatureRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::PointRuleBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      ThenPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenFeatureRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointRuleBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BooleanExpression_)
            {
              ::std::unique_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BooleanExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        // ThenPoints
        //
        if (n.name () == L"ThenPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!this->ThenPoints_)
          {
            this->ThenPoints_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenFeatureRuleType* IfThenFeatureRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenFeatureRuleType (*this, f, c);
    }

    IfThenFeatureRuleType& IfThenFeatureRuleType::
    operator= (const IfThenFeatureRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointRuleBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->ThenPoints_ = x.ThenPoints_;
      }

      return *this;
    }

    IfThenFeatureRuleType::
    ~IfThenFeatureRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenFeatureRuleType >
    _xsd_IfThenFeatureRuleType_type_factory_init (
      L"IfThenFeatureRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ElseRuleType
    //

    ElseRuleType::
    ElseRuleType ()
    : ::xsd::qif30::PointRuleBaseType (),
      ThenPoints_ (this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ThenPoints_type& ThenPoints)
    : ::xsd::qif30::PointRuleBaseType (),
      ThenPoints_ (ThenPoints, this)
    {
    }

    ElseRuleType::
    ElseRuleType (::std::unique_ptr< ThenPoints_type > ThenPoints)
    : ::xsd::qif30::PointRuleBaseType (),
      ThenPoints_ (std::move (ThenPoints), this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ElseRuleType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::PointRuleBaseType (x, f, c),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    ElseRuleType::
    ElseRuleType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      ThenPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElseRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointRuleBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPoints
        //
        if (n.name () == L"ThenPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!ThenPoints_.present ())
          {
            this->ThenPoints_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ThenPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThenPoints",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElseRuleType* ElseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElseRuleType (*this, f, c);
    }

    ElseRuleType& ElseRuleType::
    operator= (const ElseRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointRuleBaseType& > (*this) = x;
        this->ThenPoints_ = x.ThenPoints_;
      }

      return *this;
    }

    ElseRuleType::
    ~ElseRuleType ()
    {
    }

    // ThenPointsType
    //

    ThenPointsType::
    ThenPointsType ()
    : ::xml_schema::type (),
      NumberOfPoints_ (this),
      MinPoints_ (this),
      PointDensity_ (this),
      MinPointDensity_ (this)
    {
    }

    ThenPointsType::
    ThenPointsType (const ThenPointsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NumberOfPoints_ (x.NumberOfPoints_, f, this),
      MinPoints_ (x.MinPoints_, f, this),
      PointDensity_ (x.PointDensity_, f, this),
      MinPointDensity_ (x.MinPointDensity_, f, this)
    {
    }

    ThenPointsType::
    ThenPointsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NumberOfPoints_ (this),
      MinPoints_ (this),
      PointDensity_ (this),
      MinPointDensity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThenPointsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfPoints
        //
        if (n.name () == L"NumberOfPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NumberOfPoints_)
          {
            this->NumberOfPoints_.set (NumberOfPoints_traits::create (i, f, this));
            continue;
          }
        }

        // MinPoints
        //
        if (n.name () == L"MinPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->MinPoints_)
          {
            this->MinPoints_.set (MinPoints_traits::create (i, f, this));
            continue;
          }
        }

        // PointDensity
        //
        if (n.name () == L"PointDensity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointDensity_type > r (
            PointDensity_traits::create (i, f, this));

          if (!this->PointDensity_)
          {
            this->PointDensity_.set (::std::move (r));
            continue;
          }
        }

        // MinPointDensity
        //
        if (n.name () == L"MinPointDensity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPointDensity_type > r (
            MinPointDensity_traits::create (i, f, this));

          if (!this->MinPointDensity_)
          {
            this->MinPointDensity_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThenPointsType* ThenPointsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThenPointsType (*this, f, c);
    }

    ThenPointsType& ThenPointsType::
    operator= (const ThenPointsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NumberOfPoints_ = x.NumberOfPoints_;
        this->MinPoints_ = x.MinPoints_;
        this->PointDensity_ = x.PointDensity_;
        this->MinPointDensity_ = x.MinPointDensity_;
      }

      return *this;
    }

    ThenPointsType::
    ~ThenPointsType ()
    {
    }

    // IfThenCircleRuleType
    //

    IfThenCircleRuleType::
    IfThenCircleRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const IfThenCircleRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCircleRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenCircleRuleType* IfThenCircleRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCircleRuleType (*this, f, c);
    }

    IfThenCircleRuleType& IfThenCircleRuleType::
    operator= (const IfThenCircleRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCircleRuleType::
    ~IfThenCircleRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenCircleRuleType >
    _xsd_IfThenCircleRuleType_type_factory_init (
      L"IfThenCircleRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // CirclePointSamplingStrategyType
    //

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const CirclePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CirclePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CirclePointSamplingStrategyType* CirclePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CirclePointSamplingStrategyType (*this, f, c);
    }

    CirclePointSamplingStrategyType& CirclePointSamplingStrategyType::
    operator= (const CirclePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CirclePointSamplingStrategyType::
    ~CirclePointSamplingStrategyType ()
    {
    }

    // IfThenCircularArcRuleType
    //

    IfThenCircularArcRuleType::
    IfThenCircularArcRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCircularArcRuleType::
    IfThenCircularArcRuleType (const IfThenCircularArcRuleType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCircularArcRuleType::
    IfThenCircularArcRuleType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCircularArcRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenCircularArcRuleType* IfThenCircularArcRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCircularArcRuleType (*this, f, c);
    }

    IfThenCircularArcRuleType& IfThenCircularArcRuleType::
    operator= (const IfThenCircularArcRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCircularArcRuleType::
    ~IfThenCircularArcRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenCircularArcRuleType >
    _xsd_IfThenCircularArcRuleType_type_factory_init (
      L"IfThenCircularArcRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // CircularArcPointSamplingStrategyType
    //

    CircularArcPointSamplingStrategyType::
    CircularArcPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CircularArcPointSamplingStrategyType::
    CircularArcPointSamplingStrategyType (const CircularArcPointSamplingStrategyType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CircularArcPointSamplingStrategyType::
    CircularArcPointSamplingStrategyType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcPointSamplingStrategyType* CircularArcPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcPointSamplingStrategyType (*this, f, c);
    }

    CircularArcPointSamplingStrategyType& CircularArcPointSamplingStrategyType::
    operator= (const CircularArcPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CircularArcPointSamplingStrategyType::
    ~CircularArcPointSamplingStrategyType ()
    {
    }

    // IfThenConeRuleType
    //

    IfThenConeRuleType::
    IfThenConeRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const IfThenConeRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenConeRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenConeRuleType* IfThenConeRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConeRuleType (*this, f, c);
    }

    IfThenConeRuleType& IfThenConeRuleType::
    operator= (const IfThenConeRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenConeRuleType::
    ~IfThenConeRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenConeRuleType >
    _xsd_IfThenConeRuleType_type_factory_init (
      L"IfThenConeRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ConePointSamplingStrategyType
    //

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const ConePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConePointSamplingStrategyType* ConePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConePointSamplingStrategyType (*this, f, c);
    }

    ConePointSamplingStrategyType& ConePointSamplingStrategyType::
    operator= (const ConePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ConePointSamplingStrategyType::
    ~ConePointSamplingStrategyType ()
    {
    }

    // IfThenConicalSegmentRuleType
    //

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const IfThenConicalSegmentRuleType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenConicalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenConicalSegmentRuleType* IfThenConicalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConicalSegmentRuleType (*this, f, c);
    }

    IfThenConicalSegmentRuleType& IfThenConicalSegmentRuleType::
    operator= (const IfThenConicalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenConicalSegmentRuleType::
    ~IfThenConicalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRuleType_type_factory_init (
      L"IfThenConicalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalSegmentPointSamplingStrategyType
    //

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const ConicalSegmentPointSamplingStrategyType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentPointSamplingStrategyType* ConicalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ConicalSegmentPointSamplingStrategyType& ConicalSegmentPointSamplingStrategyType::
    operator= (const ConicalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ConicalSegmentPointSamplingStrategyType::
    ~ConicalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenCylinderRuleType
    //

    IfThenCylinderRuleType::
    IfThenCylinderRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const IfThenCylinderRuleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenCylinderRuleType* IfThenCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylinderRuleType (*this, f, c);
    }

    IfThenCylinderRuleType& IfThenCylinderRuleType::
    operator= (const IfThenCylinderRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCylinderRuleType::
    ~IfThenCylinderRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenCylinderRuleType >
    _xsd_IfThenCylinderRuleType_type_factory_init (
      L"IfThenCylinderRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // CylinderPointSamplingStrategyType
    //

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const CylinderPointSamplingStrategyType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderPointSamplingStrategyType* CylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderPointSamplingStrategyType (*this, f, c);
    }

    CylinderPointSamplingStrategyType& CylinderPointSamplingStrategyType::
    operator= (const CylinderPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CylinderPointSamplingStrategyType::
    ~CylinderPointSamplingStrategyType ()
    {
    }

    // IfThenCylindricalSegmentRuleType
    //

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const IfThenCylindricalSegmentRuleType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenCylindricalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenCylindricalSegmentRuleType* IfThenCylindricalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylindricalSegmentRuleType (*this, f, c);
    }

    IfThenCylindricalSegmentRuleType& IfThenCylindricalSegmentRuleType::
    operator= (const IfThenCylindricalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenCylindricalSegmentRuleType::
    ~IfThenCylindricalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRuleType_type_factory_init (
      L"IfThenCylindricalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalSegmentPointSamplingStrategyType
    //

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const CylindricalSegmentPointSamplingStrategyType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentPointSamplingStrategyType* CylindricalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentPointSamplingStrategyType (*this, f, c);
    }

    CylindricalSegmentPointSamplingStrategyType& CylindricalSegmentPointSamplingStrategyType::
    operator= (const CylindricalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    CylindricalSegmentPointSamplingStrategyType::
    ~CylindricalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenEllipseRuleType
    //

    IfThenEllipseRuleType::
    IfThenEllipseRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const IfThenEllipseRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenEllipseRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenEllipseRuleType* IfThenEllipseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenEllipseRuleType (*this, f, c);
    }

    IfThenEllipseRuleType& IfThenEllipseRuleType::
    operator= (const IfThenEllipseRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenEllipseRuleType::
    ~IfThenEllipseRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenEllipseRuleType >
    _xsd_IfThenEllipseRuleType_type_factory_init (
      L"IfThenEllipseRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipsePointSamplingStrategyType
    //

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const EllipsePointSamplingStrategyType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipsePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipsePointSamplingStrategyType* EllipsePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipsePointSamplingStrategyType (*this, f, c);
    }

    EllipsePointSamplingStrategyType& EllipsePointSamplingStrategyType::
    operator= (const EllipsePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    EllipsePointSamplingStrategyType::
    ~EllipsePointSamplingStrategyType ()
    {
    }

    // IfThenEllipticalArcRuleType
    //

    IfThenEllipticalArcRuleType::
    IfThenEllipticalArcRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenEllipticalArcRuleType::
    IfThenEllipticalArcRuleType (const IfThenEllipticalArcRuleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenEllipticalArcRuleType::
    IfThenEllipticalArcRuleType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenEllipticalArcRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenEllipticalArcRuleType* IfThenEllipticalArcRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenEllipticalArcRuleType (*this, f, c);
    }

    IfThenEllipticalArcRuleType& IfThenEllipticalArcRuleType::
    operator= (const IfThenEllipticalArcRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenEllipticalArcRuleType::
    ~IfThenEllipticalArcRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenEllipticalArcRuleType >
    _xsd_IfThenEllipticalArcRuleType_type_factory_init (
      L"IfThenEllipticalArcRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticalArcPointSamplingStrategyType
    //

    EllipticalArcPointSamplingStrategyType::
    EllipticalArcPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    EllipticalArcPointSamplingStrategyType::
    EllipticalArcPointSamplingStrategyType (const EllipticalArcPointSamplingStrategyType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    EllipticalArcPointSamplingStrategyType::
    EllipticalArcPointSamplingStrategyType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcPointSamplingStrategyType* EllipticalArcPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcPointSamplingStrategyType (*this, f, c);
    }

    EllipticalArcPointSamplingStrategyType& EllipticalArcPointSamplingStrategyType::
    operator= (const EllipticalArcPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    EllipticalArcPointSamplingStrategyType::
    ~EllipticalArcPointSamplingStrategyType ()
    {
    }

    // IfThenElongatedCircleRuleType
    //

    IfThenElongatedCircleRuleType::
    IfThenElongatedCircleRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenElongatedCircleRuleType::
    IfThenElongatedCircleRuleType (const IfThenElongatedCircleRuleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenElongatedCircleRuleType::
    IfThenElongatedCircleRuleType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenElongatedCircleRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenElongatedCircleRuleType* IfThenElongatedCircleRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElongatedCircleRuleType (*this, f, c);
    }

    IfThenElongatedCircleRuleType& IfThenElongatedCircleRuleType::
    operator= (const IfThenElongatedCircleRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenElongatedCircleRuleType::
    ~IfThenElongatedCircleRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenElongatedCircleRuleType >
    _xsd_IfThenElongatedCircleRuleType_type_factory_init (
      L"IfThenElongatedCircleRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCirclePointSamplingStrategyType
    //

    ElongatedCirclePointSamplingStrategyType::
    ElongatedCirclePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ElongatedCirclePointSamplingStrategyType::
    ElongatedCirclePointSamplingStrategyType (const ElongatedCirclePointSamplingStrategyType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ElongatedCirclePointSamplingStrategyType::
    ElongatedCirclePointSamplingStrategyType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCirclePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCirclePointSamplingStrategyType* ElongatedCirclePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCirclePointSamplingStrategyType (*this, f, c);
    }

    ElongatedCirclePointSamplingStrategyType& ElongatedCirclePointSamplingStrategyType::
    operator= (const ElongatedCirclePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ElongatedCirclePointSamplingStrategyType::
    ~ElongatedCirclePointSamplingStrategyType ()
    {
    }

    // IfThenElongatedCylinderRuleType
    //

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const IfThenElongatedCylinderRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenElongatedCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenElongatedCylinderRuleType* IfThenElongatedCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElongatedCylinderRuleType (*this, f, c);
    }

    IfThenElongatedCylinderRuleType& IfThenElongatedCylinderRuleType::
    operator= (const IfThenElongatedCylinderRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenElongatedCylinderRuleType::
    ~IfThenElongatedCylinderRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRuleType_type_factory_init (
      L"IfThenElongatedCylinderRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCylinderPointSamplingStrategyType
    //

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const ElongatedCylinderPointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderPointSamplingStrategyType* ElongatedCylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderPointSamplingStrategyType (*this, f, c);
    }

    ElongatedCylinderPointSamplingStrategyType& ElongatedCylinderPointSamplingStrategyType::
    operator= (const ElongatedCylinderPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ElongatedCylinderPointSamplingStrategyType::
    ~ElongatedCylinderPointSamplingStrategyType ()
    {
    }

    // IfThenExtrudedCrossSectionRuleType
    //

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const IfThenExtrudedCrossSectionRuleType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenExtrudedCrossSectionRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenExtrudedCrossSectionRuleType* IfThenExtrudedCrossSectionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenExtrudedCrossSectionRuleType (*this, f, c);
    }

    IfThenExtrudedCrossSectionRuleType& IfThenExtrudedCrossSectionRuleType::
    operator= (const IfThenExtrudedCrossSectionRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenExtrudedCrossSectionRuleType::
    ~IfThenExtrudedCrossSectionRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRuleType_type_factory_init (
      L"IfThenExtrudedCrossSectionRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ExtrudedCrossSectionPointSamplingStrategyType
    //

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const ExtrudedCrossSectionPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionPointSamplingStrategyType* ExtrudedCrossSectionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionPointSamplingStrategyType (*this, f, c);
    }

    ExtrudedCrossSectionPointSamplingStrategyType& ExtrudedCrossSectionPointSamplingStrategyType::
    operator= (const ExtrudedCrossSectionPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ~ExtrudedCrossSectionPointSamplingStrategyType ()
    {
    }

    // IfThenLineRuleType
    //

    IfThenLineRuleType::
    IfThenLineRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const IfThenLineRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenLineRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenLineRuleType* IfThenLineRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenLineRuleType (*this, f, c);
    }

    IfThenLineRuleType& IfThenLineRuleType::
    operator= (const IfThenLineRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenLineRuleType::
    ~IfThenLineRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenLineRuleType >
    _xsd_IfThenLineRuleType_type_factory_init (
      L"IfThenLineRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // LinePointSamplingStrategyType
    //

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const LinePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LinePointSamplingStrategyType* LinePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePointSamplingStrategyType (*this, f, c);
    }

    LinePointSamplingStrategyType& LinePointSamplingStrategyType::
    operator= (const LinePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    LinePointSamplingStrategyType::
    ~LinePointSamplingStrategyType ()
    {
    }

    // IfThenOppositeAngledLinesRuleType
    //

    IfThenOppositeAngledLinesRuleType::
    IfThenOppositeAngledLinesRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositeAngledLinesRuleType::
    IfThenOppositeAngledLinesRuleType (const IfThenOppositeAngledLinesRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeAngledLinesRuleType::
    IfThenOppositeAngledLinesRuleType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeAngledLinesRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeAngledLinesRuleType* IfThenOppositeAngledLinesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeAngledLinesRuleType (*this, f, c);
    }

    IfThenOppositeAngledLinesRuleType& IfThenOppositeAngledLinesRuleType::
    operator= (const IfThenOppositeAngledLinesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositeAngledLinesRuleType::
    ~IfThenOppositeAngledLinesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenOppositeAngledLinesRuleType >
    _xsd_IfThenOppositeAngledLinesRuleType_type_factory_init (
      L"IfThenOppositeAngledLinesRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledLinesPointSamplingStrategyType
    //

    OppositeAngledLinesPointSamplingStrategyType::
    OppositeAngledLinesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositeAngledLinesPointSamplingStrategyType::
    OppositeAngledLinesPointSamplingStrategyType (const OppositeAngledLinesPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeAngledLinesPointSamplingStrategyType::
    OppositeAngledLinesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesPointSamplingStrategyType* OppositeAngledLinesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesPointSamplingStrategyType (*this, f, c);
    }

    OppositeAngledLinesPointSamplingStrategyType& OppositeAngledLinesPointSamplingStrategyType::
    operator= (const OppositeAngledLinesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositeAngledLinesPointSamplingStrategyType::
    ~OppositeAngledLinesPointSamplingStrategyType ()
    {
    }

    // IfThenOppositeAngledPlanesRuleType
    //

    IfThenOppositeAngledPlanesRuleType::
    IfThenOppositeAngledPlanesRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositeAngledPlanesRuleType::
    IfThenOppositeAngledPlanesRuleType (const IfThenOppositeAngledPlanesRuleType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeAngledPlanesRuleType::
    IfThenOppositeAngledPlanesRuleType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeAngledPlanesRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeAngledPlanesRuleType* IfThenOppositeAngledPlanesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeAngledPlanesRuleType (*this, f, c);
    }

    IfThenOppositeAngledPlanesRuleType& IfThenOppositeAngledPlanesRuleType::
    operator= (const IfThenOppositeAngledPlanesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositeAngledPlanesRuleType::
    ~IfThenOppositeAngledPlanesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenOppositeAngledPlanesRuleType >
    _xsd_IfThenOppositeAngledPlanesRuleType_type_factory_init (
      L"IfThenOppositeAngledPlanesRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledPlanesPointSamplingStrategyType
    //

    OppositeAngledPlanesPointSamplingStrategyType::
    OppositeAngledPlanesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositeAngledPlanesPointSamplingStrategyType::
    OppositeAngledPlanesPointSamplingStrategyType (const OppositeAngledPlanesPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeAngledPlanesPointSamplingStrategyType::
    OppositeAngledPlanesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesPointSamplingStrategyType* OppositeAngledPlanesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesPointSamplingStrategyType (*this, f, c);
    }

    OppositeAngledPlanesPointSamplingStrategyType& OppositeAngledPlanesPointSamplingStrategyType::
    operator= (const OppositeAngledPlanesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositeAngledPlanesPointSamplingStrategyType::
    ~OppositeAngledPlanesPointSamplingStrategyType ()
    {
    }

    // IfThenOppositeParallelLinesRuleType
    //

    IfThenOppositeParallelLinesRuleType::
    IfThenOppositeParallelLinesRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositeParallelLinesRuleType::
    IfThenOppositeParallelLinesRuleType (const IfThenOppositeParallelLinesRuleType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeParallelLinesRuleType::
    IfThenOppositeParallelLinesRuleType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeParallelLinesRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeParallelLinesRuleType* IfThenOppositeParallelLinesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeParallelLinesRuleType (*this, f, c);
    }

    IfThenOppositeParallelLinesRuleType& IfThenOppositeParallelLinesRuleType::
    operator= (const IfThenOppositeParallelLinesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositeParallelLinesRuleType::
    ~IfThenOppositeParallelLinesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenOppositeParallelLinesRuleType >
    _xsd_IfThenOppositeParallelLinesRuleType_type_factory_init (
      L"IfThenOppositeParallelLinesRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelLinesPointSamplingStrategyType
    //

    OppositeParallelLinesPointSamplingStrategyType::
    OppositeParallelLinesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositeParallelLinesPointSamplingStrategyType::
    OppositeParallelLinesPointSamplingStrategyType (const OppositeParallelLinesPointSamplingStrategyType& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeParallelLinesPointSamplingStrategyType::
    OppositeParallelLinesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesPointSamplingStrategyType* OppositeParallelLinesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesPointSamplingStrategyType (*this, f, c);
    }

    OppositeParallelLinesPointSamplingStrategyType& OppositeParallelLinesPointSamplingStrategyType::
    operator= (const OppositeParallelLinesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositeParallelLinesPointSamplingStrategyType::
    ~OppositeParallelLinesPointSamplingStrategyType ()
    {
    }

    // IfThenOppositeParallelPlanesRuleType
    //

    IfThenOppositeParallelPlanesRuleType::
    IfThenOppositeParallelPlanesRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenOppositeParallelPlanesRuleType::
    IfThenOppositeParallelPlanesRuleType (const IfThenOppositeParallelPlanesRuleType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeParallelPlanesRuleType::
    IfThenOppositeParallelPlanesRuleType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeParallelPlanesRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeParallelPlanesRuleType* IfThenOppositeParallelPlanesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeParallelPlanesRuleType (*this, f, c);
    }

    IfThenOppositeParallelPlanesRuleType& IfThenOppositeParallelPlanesRuleType::
    operator= (const IfThenOppositeParallelPlanesRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenOppositeParallelPlanesRuleType::
    ~IfThenOppositeParallelPlanesRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenOppositeParallelPlanesRuleType >
    _xsd_IfThenOppositeParallelPlanesRuleType_type_factory_init (
      L"IfThenOppositeParallelPlanesRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelPlanesPointSamplingStrategyType
    //

    OppositeParallelPlanesPointSamplingStrategyType::
    OppositeParallelPlanesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    OppositeParallelPlanesPointSamplingStrategyType::
    OppositeParallelPlanesPointSamplingStrategyType (const OppositeParallelPlanesPointSamplingStrategyType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeParallelPlanesPointSamplingStrategyType::
    OppositeParallelPlanesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesPointSamplingStrategyType* OppositeParallelPlanesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesPointSamplingStrategyType (*this, f, c);
    }

    OppositeParallelPlanesPointSamplingStrategyType& OppositeParallelPlanesPointSamplingStrategyType::
    operator= (const OppositeParallelPlanesPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    OppositeParallelPlanesPointSamplingStrategyType::
    ~OppositeParallelPlanesPointSamplingStrategyType ()
    {
    }

    // IfThenPlaneRuleType
    //

    IfThenPlaneRuleType::
    IfThenPlaneRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const IfThenPlaneRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPlaneRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenPlaneRuleType* IfThenPlaneRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPlaneRuleType (*this, f, c);
    }

    IfThenPlaneRuleType& IfThenPlaneRuleType::
    operator= (const IfThenPlaneRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPlaneRuleType::
    ~IfThenPlaneRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenPlaneRuleType >
    _xsd_IfThenPlaneRuleType_type_factory_init (
      L"IfThenPlaneRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // PlanePointSamplingStrategyType
    //

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const PlanePointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlanePointSamplingStrategyType* PlanePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePointSamplingStrategyType (*this, f, c);
    }

    PlanePointSamplingStrategyType& PlanePointSamplingStrategyType::
    operator= (const PlanePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PlanePointSamplingStrategyType::
    ~PlanePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedCurveRuleType
    //

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const IfThenPointDefinedCurveRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedCurveRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedCurveRuleType* IfThenPointDefinedCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedCurveRuleType (*this, f, c);
    }

    IfThenPointDefinedCurveRuleType& IfThenPointDefinedCurveRuleType::
    operator= (const IfThenPointDefinedCurveRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPointDefinedCurveRuleType::
    ~IfThenPointDefinedCurveRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRuleType_type_factory_init (
      L"IfThenPointDefinedCurveRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedCurvePointSamplingStrategyType
    //

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const PointDefinedCurvePointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurvePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurvePointSamplingStrategyType* PointDefinedCurvePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurvePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedCurvePointSamplingStrategyType& PointDefinedCurvePointSamplingStrategyType::
    operator= (const PointDefinedCurvePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointDefinedCurvePointSamplingStrategyType::
    ~PointDefinedCurvePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedSurfaceRuleType
    //

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const IfThenPointDefinedSurfaceRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedSurfaceRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedSurfaceRuleType* IfThenPointDefinedSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedSurfaceRuleType (*this, f, c);
    }

    IfThenPointDefinedSurfaceRuleType& IfThenPointDefinedSurfaceRuleType::
    operator= (const IfThenPointDefinedSurfaceRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenPointDefinedSurfaceRuleType::
    ~IfThenPointDefinedSurfaceRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRuleType_type_factory_init (
      L"IfThenPointDefinedSurfaceRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedSurfacePointSamplingStrategyType
    //

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const PointDefinedSurfacePointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfacePointSamplingStrategyType* PointDefinedSurfacePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfacePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedSurfacePointSamplingStrategyType& PointDefinedSurfacePointSamplingStrategyType::
    operator= (const PointDefinedSurfacePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointDefinedSurfacePointSamplingStrategyType::
    ~PointDefinedSurfacePointSamplingStrategyType ()
    {
    }

    // IfThenPointRuleType
    //

    IfThenPointRuleType::
    IfThenPointRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const IfThenPointRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenPointRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenPointRuleType* IfThenPointRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointRuleType (*this, f, c);
    }

    IfThenPointRuleType& IfThenPointRuleType::
    operator= (const IfThenPointRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
      }

      return *this;
    }

    IfThenPointRuleType::
    ~IfThenPointRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenPointRuleType >
    _xsd_IfThenPointRuleType_type_factory_init (
      L"IfThenPointRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // PointPointSamplingStrategyType
    //

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const PointPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointPointSamplingStrategyType* PointPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointPointSamplingStrategyType (*this, f, c);
    }

    PointPointSamplingStrategyType& PointPointSamplingStrategyType::
    operator= (const PointPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    PointPointSamplingStrategyType::
    ~PointPointSamplingStrategyType ()
    {
    }

    // IfThenSphereRuleType
    //

    IfThenSphereRuleType::
    IfThenSphereRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const IfThenSphereRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSphereRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenSphereRuleType* IfThenSphereRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphereRuleType (*this, f, c);
    }

    IfThenSphereRuleType& IfThenSphereRuleType::
    operator= (const IfThenSphereRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSphereRuleType::
    ~IfThenSphereRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenSphereRuleType >
    _xsd_IfThenSphereRuleType_type_factory_init (
      L"IfThenSphereRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // SpherePointSamplingStrategyType
    //

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const SpherePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpherePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SpherePointSamplingStrategyType* SpherePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpherePointSamplingStrategyType (*this, f, c);
    }

    SpherePointSamplingStrategyType& SpherePointSamplingStrategyType::
    operator= (const SpherePointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SpherePointSamplingStrategyType::
    ~SpherePointSamplingStrategyType ()
    {
    }

    // IfThenSphericalSegmentRuleType
    //

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const IfThenSphericalSegmentRuleType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSphericalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenSphericalSegmentRuleType* IfThenSphericalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphericalSegmentRuleType (*this, f, c);
    }

    IfThenSphericalSegmentRuleType& IfThenSphericalSegmentRuleType::
    operator= (const IfThenSphericalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSphericalSegmentRuleType::
    ~IfThenSphericalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRuleType_type_factory_init (
      L"IfThenSphericalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalSegmentPointSamplingStrategyType
    //

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const SphericalSegmentPointSamplingStrategyType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentPointSamplingStrategyType* SphericalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentPointSamplingStrategyType (*this, f, c);
    }

    SphericalSegmentPointSamplingStrategyType& SphericalSegmentPointSamplingStrategyType::
    operator= (const SphericalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SphericalSegmentPointSamplingStrategyType::
    ~SphericalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceOfRevolutionRuleType
    //

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const IfThenSurfaceOfRevolutionRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenSurfaceOfRevolutionRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenSurfaceOfRevolutionRuleType* IfThenSurfaceOfRevolutionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceOfRevolutionRuleType (*this, f, c);
    }

    IfThenSurfaceOfRevolutionRuleType& IfThenSurfaceOfRevolutionRuleType::
    operator= (const IfThenSurfaceOfRevolutionRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenSurfaceOfRevolutionRuleType::
    ~IfThenSurfaceOfRevolutionRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRuleType_type_factory_init (
      L"IfThenSurfaceOfRevolutionRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceOfRevolutionPointSamplingStrategyType
    //

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const SurfaceOfRevolutionPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionPointSamplingStrategyType* SurfaceOfRevolutionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionPointSamplingStrategyType (*this, f, c);
    }

    SurfaceOfRevolutionPointSamplingStrategyType& SurfaceOfRevolutionPointSamplingStrategyType::
    operator= (const SurfaceOfRevolutionPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    ~SurfaceOfRevolutionPointSamplingStrategyType ()
    {
    }

    // IfThenToroidalSegmentRuleType
    //

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const IfThenToroidalSegmentRuleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenToroidalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenToroidalSegmentRuleType* IfThenToroidalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenToroidalSegmentRuleType (*this, f, c);
    }

    IfThenToroidalSegmentRuleType& IfThenToroidalSegmentRuleType::
    operator= (const IfThenToroidalSegmentRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenToroidalSegmentRuleType::
    ~IfThenToroidalSegmentRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRuleType_type_factory_init (
      L"IfThenToroidalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidalSegmentPointSamplingStrategyType
    //

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const ToroidalSegmentPointSamplingStrategyType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentPointSamplingStrategyType* ToroidalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ToroidalSegmentPointSamplingStrategyType& ToroidalSegmentPointSamplingStrategyType::
    operator= (const ToroidalSegmentPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    ToroidalSegmentPointSamplingStrategyType::
    ~ToroidalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenTorusRuleType
    //

    IfThenTorusRuleType::
    IfThenTorusRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType (),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const IfThenTorusRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (this),
      ThenFittingAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenTorusRuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThenPointStrategy
        //
        if (n.name () == L"ThenPointStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (::std::move (r));
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == L"ThenFittingAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    IfThenTorusRuleType* IfThenTorusRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenTorusRuleType (*this, f, c);
    }

    IfThenTorusRuleType& IfThenTorusRuleType::
    operator= (const IfThenTorusRuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::IfThenFeatureRuleType& > (*this) = x;
        this->ThenPointStrategy_ = x.ThenPointStrategy_;
        this->ThenFittingAlgorithm_ = x.ThenFittingAlgorithm_;
      }

      return *this;
    }

    IfThenTorusRuleType::
    ~IfThenTorusRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenTorusRuleType >
    _xsd_IfThenTorusRuleType_type_factory_init (
      L"IfThenTorusRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // TorusPointSamplingStrategyType
    //

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const TorusPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (this),
      UserDefinedStrategy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == L"PointSamplingStrategyEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == L"UserDefinedStrategy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusPointSamplingStrategyType* TorusPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusPointSamplingStrategyType (*this, f, c);
    }

    TorusPointSamplingStrategyType& TorusPointSamplingStrategyType::
    operator= (const TorusPointSamplingStrategyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSamplingStrategyEnum_ = x.PointSamplingStrategyEnum_;
        this->UserDefinedStrategy_ = x.UserDefinedStrategy_;
      }

      return *this;
    }

    TorusPointSamplingStrategyType::
    ~TorusPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceRuleType
    //

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType ()
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const IfThenSurfaceRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenSurfaceRuleType* IfThenSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceRuleType (*this, f, c);
    }

    IfThenSurfaceRuleType::
    ~IfThenSurfaceRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRuleType_type_factory_init (
      L"IfThenSurfaceRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // IfThenCurveRuleType
    //

    IfThenCurveRuleType::
    IfThenCurveRuleType ()
    : ::xsd::qif30::IfThenFeatureRuleType ()
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const IfThenCurveRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenCurveRuleType* IfThenCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCurveRuleType (*this, f, c);
    }

    IfThenCurveRuleType::
    ~IfThenCurveRuleType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfThenCurveRuleType >
    _xsd_IfThenCurveRuleType_type_factory_init (
      L"IfThenCurveRuleType",
      L"http://qifstandards.org/xsd/qif3");

    // DMESelectionRulesType
    //

    DMESelectionRulesType::
    DMESelectionRulesType ()
    : ::xml_schema::type (),
      DMEDecisionRule_ (this),
      defaultDesirability_ (defaultDesirability_default_value (), this),
      n_ (this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const n_type& n)
    : ::xml_schema::type (),
      DMEDecisionRule_ (this),
      defaultDesirability_ (defaultDesirability_default_value (), this),
      n_ (n, this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const DMESelectionRulesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DMEDecisionRule_ (x.DMEDecisionRule_, f, this),
      defaultDesirability_ (x.defaultDesirability_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DMEDecisionRule_ (this),
      defaultDesirability_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DMESelectionRulesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEDecisionRule
        //
        if (n.name () == L"DMEDecisionRule" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEDecisionRule_type > r (
            DMEDecisionRule_traits::create (i, f, this));

          this->DMEDecisionRule_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"defaultDesirability" && n.namespace_ ().empty ())
        {
          this->defaultDesirability_.set (defaultDesirability_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!defaultDesirability_.present ())
      {
        this->defaultDesirability_.set (defaultDesirability_default_value ());
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DMESelectionRulesType* DMESelectionRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMESelectionRulesType (*this, f, c);
    }

    DMESelectionRulesType& DMESelectionRulesType::
    operator= (const DMESelectionRulesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DMEDecisionRule_ = x.DMEDecisionRule_;
        this->defaultDesirability_ = x.defaultDesirability_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DMESelectionRulesType::
    ~DMESelectionRulesType ()
    {
    }

    // DMEThenType
    //

    DMEThenType::
    DMEThenType ()
    : ::xml_schema::type (),
      DMEDecision_ (this),
      n_ (this)
    {
    }

    DMEThenType::
    DMEThenType (const n_type& n)
    : ::xml_schema::type (),
      DMEDecision_ (this),
      n_ (n, this)
    {
    }

    DMEThenType::
    DMEThenType (const DMEThenType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DMEDecision_ (x.DMEDecision_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DMEThenType::
    DMEThenType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DMEDecision_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DMEThenType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEDecision
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"DMEDecision",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DMEDecision_type > r (
              dynamic_cast< DMEDecision_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->DMEDecision_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DMEThenType* DMEThenType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEThenType (*this, f, c);
    }

    DMEThenType& DMEThenType::
    operator= (const DMEThenType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DMEDecision_ = x.DMEDecision_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DMEThenType::
    ~DMEThenType ()
    {
    }

    // DMEDecisionBaseType
    //

    DMEDecisionBaseType::
    DMEDecisionBaseType ()
    : ::xml_schema::type (),
      Applicability_ (this)
    {
    }

    DMEDecisionBaseType::
    DMEDecisionBaseType (const Applicability_type& Applicability)
    : ::xml_schema::type (),
      Applicability_ (Applicability, this)
    {
    }

    DMEDecisionBaseType::
    DMEDecisionBaseType (::std::unique_ptr< Applicability_type > Applicability)
    : ::xml_schema::type (),
      Applicability_ (std::move (Applicability), this)
    {
    }

    DMEDecisionBaseType::
    DMEDecisionBaseType (const DMEDecisionBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Applicability_ (x.Applicability_, f, this)
    {
    }

    DMEDecisionBaseType::
    DMEDecisionBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Applicability_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMEDecisionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Applicability
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Applicability",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Applicability_.present ())
            {
              ::std::unique_ptr< Applicability_type > r (
                dynamic_cast< Applicability_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Applicability_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Applicability_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Applicability",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DMEDecisionBaseType& DMEDecisionBaseType::
    operator= (const DMEDecisionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Applicability_ = x.Applicability_;
      }

      return *this;
    }

    DMEDecisionBaseType::
    ~DMEDecisionBaseType ()
    {
    }

    // ApplicabilityBaseType
    //

    ApplicabilityBaseType::
    ApplicabilityBaseType ()
    : ::xml_schema::type ()
    {
    }

    ApplicabilityBaseType::
    ApplicabilityBaseType (const ApplicabilityBaseType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ApplicabilityBaseType::
    ApplicabilityBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ApplicabilityBaseType::
    ApplicabilityBaseType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ApplicabilityBaseType::
    ApplicabilityBaseType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ApplicabilityBaseType::
    ~ApplicabilityBaseType ()
    {
    }

    // QIFMustType
    //

    QIFMustType::
    QIFMustType ()
    : ::xsd::qif30::ApplicabilityBaseType ()
    {
    }

    QIFMustType::
    QIFMustType (const QIFMustType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (x, f, c)
    {
    }

    QIFMustType::
    QIFMustType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (e, f, c)
    {
    }

    QIFMustType::
    QIFMustType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (a, f, c)
    {
    }

    QIFMustType::
    QIFMustType (const ::std::wstring& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (s, e, f, c)
    {
    }

    QIFMustType* QIFMustType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFMustType (*this, f, c);
    }

    QIFMustType::
    ~QIFMustType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, QIFMustType >
    _xsd_QIFMustType_type_factory_init (
      L"QIFMustType",
      L"http://qifstandards.org/xsd/qif3");

    // QIFMustNotType
    //

    QIFMustNotType::
    QIFMustNotType ()
    : ::xsd::qif30::ApplicabilityBaseType ()
    {
    }

    QIFMustNotType::
    QIFMustNotType (const QIFMustNotType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (x, f, c)
    {
    }

    QIFMustNotType::
    QIFMustNotType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (e, f, c)
    {
    }

    QIFMustNotType::
    QIFMustNotType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (a, f, c)
    {
    }

    QIFMustNotType::
    QIFMustNotType (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (s, e, f, c)
    {
    }

    QIFMustNotType* QIFMustNotType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFMustNotType (*this, f, c);
    }

    QIFMustNotType::
    ~QIFMustNotType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, QIFMustNotType >
    _xsd_QIFMustNotType_type_factory_init (
      L"QIFMustNotType",
      L"http://qifstandards.org/xsd/qif3");

    // QIFMayType
    //

    QIFMayType::
    QIFMayType ()
    : ::xsd::qif30::ApplicabilityBaseType (),
      desirability_ (this)
    {
    }

    QIFMayType::
    QIFMayType (const QIFMayType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (x, f, c),
      desirability_ (x.desirability_, f, this)
    {
    }

    QIFMayType::
    QIFMayType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::ApplicabilityBaseType (e, f | ::xml_schema::flags::base, c),
      desirability_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void QIFMayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"desirability" && n.namespace_ ().empty ())
        {
          this->desirability_.set (desirability_traits::create (i, f, this));
          continue;
        }
      }
    }

    QIFMayType* QIFMayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFMayType (*this, f, c);
    }

    QIFMayType& QIFMayType::
    operator= (const QIFMayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ApplicabilityBaseType& > (*this) = x;
        this->desirability_ = x.desirability_;
      }

      return *this;
    }

    QIFMayType::
    ~QIFMayType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, QIFMayType >
    _xsd_QIFMayType_type_factory_init (
      L"QIFMayType",
      L"http://qifstandards.org/xsd/qif3");

    // DMEDecisionClassType
    //

    DMEDecisionClassType::
    DMEDecisionClassType ()
    : ::xsd::qif30::DMEDecisionBaseType (),
      DMEClassName_ (this),
      ParameterConstraints_ (this)
    {
    }

    DMEDecisionClassType::
    DMEDecisionClassType (const Applicability_type& Applicability,
                          const DMEClassName_type& DMEClassName)
    : ::xsd::qif30::DMEDecisionBaseType (Applicability),
      DMEClassName_ (DMEClassName, this),
      ParameterConstraints_ (this)
    {
    }

    DMEDecisionClassType::
    DMEDecisionClassType (::std::unique_ptr< Applicability_type > Applicability,
                          const DMEClassName_type& DMEClassName)
    : ::xsd::qif30::DMEDecisionBaseType (std::move (Applicability)),
      DMEClassName_ (DMEClassName, this),
      ParameterConstraints_ (this)
    {
    }

    DMEDecisionClassType::
    DMEDecisionClassType (const DMEDecisionClassType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (x, f, c),
      DMEClassName_ (x.DMEClassName_, f, this),
      ParameterConstraints_ (x.ParameterConstraints_, f, this)
    {
    }

    DMEDecisionClassType::
    DMEDecisionClassType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (e, f | ::xml_schema::flags::base, c),
      DMEClassName_ (this),
      ParameterConstraints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMEDecisionClassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DMEDecisionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEClassName
        //
        if (n.name () == L"DMEClassName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEClassName_type > r (
            DMEClassName_traits::create (i, f, this));

          if (!DMEClassName_.present ())
          {
            this->DMEClassName_.set (::std::move (r));
            continue;
          }
        }

        // ParameterConstraints
        //
        if (n.name () == L"ParameterConstraints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParameterConstraints_type > r (
            ParameterConstraints_traits::create (i, f, this));

          if (!this->ParameterConstraints_)
          {
            this->ParameterConstraints_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DMEClassName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DMEClassName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DMEDecisionClassType* DMEDecisionClassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEDecisionClassType (*this, f, c);
    }

    DMEDecisionClassType& DMEDecisionClassType::
    operator= (const DMEDecisionClassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DMEDecisionBaseType& > (*this) = x;
        this->DMEClassName_ = x.DMEClassName_;
        this->ParameterConstraints_ = x.ParameterConstraints_;
      }

      return *this;
    }

    DMEDecisionClassType::
    ~DMEDecisionClassType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DMEDecisionClassType >
    _xsd_DMEDecisionClassType_type_factory_init (
      L"DMEDecisionClassType",
      L"http://qifstandards.org/xsd/qif3");

    // DMEParameterConstraintSetType
    //

    DMEParameterConstraintSetType::
    DMEParameterConstraintSetType ()
    : ::xml_schema::type (),
      DMEParameterConstraint_ (this),
      n_ (this)
    {
    }

    DMEParameterConstraintSetType::
    DMEParameterConstraintSetType (const n_type& n)
    : ::xml_schema::type (),
      DMEParameterConstraint_ (this),
      n_ (n, this)
    {
    }

    DMEParameterConstraintSetType::
    DMEParameterConstraintSetType (const DMEParameterConstraintSetType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DMEParameterConstraint_ (x.DMEParameterConstraint_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DMEParameterConstraintSetType::
    DMEParameterConstraintSetType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DMEParameterConstraint_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DMEParameterConstraintSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEParameterConstraint
        //
        if (n.name () == L"DMEParameterConstraint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEParameterConstraint_type > r (
            DMEParameterConstraint_traits::create (i, f, this));

          this->DMEParameterConstraint_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DMEParameterConstraintSetType* DMEParameterConstraintSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEParameterConstraintSetType (*this, f, c);
    }

    DMEParameterConstraintSetType& DMEParameterConstraintSetType::
    operator= (const DMEParameterConstraintSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DMEParameterConstraint_ = x.DMEParameterConstraint_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DMEParameterConstraintSetType::
    ~DMEParameterConstraintSetType ()
    {
    }

    // DMEParameterConstraintType
    //

    DMEParameterConstraintType::
    DMEParameterConstraintType ()
    : ::xml_schema::type (),
      ParameterName_ (this),
      Comparison_ (this),
      ArithmeticExpression_ (this)
    {
    }

    DMEParameterConstraintType::
    DMEParameterConstraintType (const ParameterName_type& ParameterName,
                                const Comparison_type& Comparison,
                                const ArithmeticExpression_type& ArithmeticExpression)
    : ::xml_schema::type (),
      ParameterName_ (ParameterName, this),
      Comparison_ (Comparison, this),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    DMEParameterConstraintType::
    DMEParameterConstraintType (const ParameterName_type& ParameterName,
                                const Comparison_type& Comparison,
                                ::std::unique_ptr< ArithmeticExpression_type > ArithmeticExpression)
    : ::xml_schema::type (),
      ParameterName_ (ParameterName, this),
      Comparison_ (Comparison, this),
      ArithmeticExpression_ (std::move (ArithmeticExpression), this)
    {
    }

    DMEParameterConstraintType::
    DMEParameterConstraintType (const DMEParameterConstraintType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ParameterName_ (x.ParameterName_, f, this),
      Comparison_ (x.Comparison_, f, this),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    DMEParameterConstraintType::
    DMEParameterConstraintType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ParameterName_ (this),
      Comparison_ (this),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMEParameterConstraintType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ParameterName
        //
        if (n.name () == L"ParameterName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParameterName_type > r (
            ParameterName_traits::create (i, f, this));

          if (!ParameterName_.present ())
          {
            this->ParameterName_.set (::std::move (r));
            continue;
          }
        }

        // Comparison
        //
        if (n.name () == L"Comparison" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Comparison_type > r (
            Comparison_traits::create (i, f, this));

          if (!Comparison_.present ())
          {
            this->Comparison_.set (::std::move (r));
            continue;
          }
        }

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArithmeticExpression_.present ())
            {
              ::std::unique_ptr< ArithmeticExpression_type > r (
                dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArithmeticExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!ParameterName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ParameterName",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Comparison_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Comparison",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ArithmeticExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArithmeticExpression",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DMEParameterConstraintType* DMEParameterConstraintType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEParameterConstraintType (*this, f, c);
    }

    DMEParameterConstraintType& DMEParameterConstraintType::
    operator= (const DMEParameterConstraintType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ParameterName_ = x.ParameterName_;
        this->Comparison_ = x.Comparison_;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    DMEParameterConstraintType::
    ~DMEParameterConstraintType ()
    {
    }

    // DMEDecisionIdType
    //

    DMEDecisionIdType::
    DMEDecisionIdType ()
    : ::xsd::qif30::DMEDecisionBaseType (),
      DMEId_ (this)
    {
    }

    DMEDecisionIdType::
    DMEDecisionIdType (const Applicability_type& Applicability,
                       const DMEId_type& DMEId)
    : ::xsd::qif30::DMEDecisionBaseType (Applicability),
      DMEId_ (DMEId, this)
    {
    }

    DMEDecisionIdType::
    DMEDecisionIdType (const Applicability_type& Applicability,
                       ::std::unique_ptr< DMEId_type > DMEId)
    : ::xsd::qif30::DMEDecisionBaseType (Applicability),
      DMEId_ (std::move (DMEId), this)
    {
    }

    DMEDecisionIdType::
    DMEDecisionIdType (::std::unique_ptr< Applicability_type > Applicability,
                       const DMEId_type& DMEId)
    : ::xsd::qif30::DMEDecisionBaseType (std::move (Applicability)),
      DMEId_ (DMEId, this)
    {
    }

    DMEDecisionIdType::
    DMEDecisionIdType (const DMEDecisionIdType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (x, f, c),
      DMEId_ (x.DMEId_, f, this)
    {
    }

    DMEDecisionIdType::
    DMEDecisionIdType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (e, f | ::xml_schema::flags::base, c),
      DMEId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMEDecisionIdType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DMEDecisionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DMEId
        //
        if (n.name () == L"DMEId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEId_type > r (
            DMEId_traits::create (i, f, this));

          if (!DMEId_.present ())
          {
            this->DMEId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DMEId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DMEId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DMEDecisionIdType* DMEDecisionIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEDecisionIdType (*this, f, c);
    }

    DMEDecisionIdType& DMEDecisionIdType::
    operator= (const DMEDecisionIdType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DMEDecisionBaseType& > (*this) = x;
        this->DMEId_ = x.DMEId_;
      }

      return *this;
    }

    DMEDecisionIdType::
    ~DMEDecisionIdType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DMEDecisionIdType >
    _xsd_DMEDecisionIdType_type_factory_init (
      L"DMEDecisionIdType",
      L"http://qifstandards.org/xsd/qif3");

    // DMEDecisionMakeModelType
    //

    DMEDecisionMakeModelType::
    DMEDecisionMakeModelType ()
    : ::xsd::qif30::DMEDecisionBaseType (),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this)
    {
    }

    DMEDecisionMakeModelType::
    DMEDecisionMakeModelType (const Applicability_type& Applicability,
                              const Manufacturer_type& Manufacturer,
                              const ModelNumber_type& ModelNumber)
    : ::xsd::qif30::DMEDecisionBaseType (Applicability),
      Manufacturer_ (Manufacturer, this),
      ModelNumber_ (ModelNumber, this),
      SerialNumber_ (this)
    {
    }

    DMEDecisionMakeModelType::
    DMEDecisionMakeModelType (::std::unique_ptr< Applicability_type > Applicability,
                              const Manufacturer_type& Manufacturer,
                              const ModelNumber_type& ModelNumber)
    : ::xsd::qif30::DMEDecisionBaseType (std::move (Applicability)),
      Manufacturer_ (Manufacturer, this),
      ModelNumber_ (ModelNumber, this),
      SerialNumber_ (this)
    {
    }

    DMEDecisionMakeModelType::
    DMEDecisionMakeModelType (const DMEDecisionMakeModelType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (x, f, c),
      Manufacturer_ (x.Manufacturer_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this)
    {
    }

    DMEDecisionMakeModelType::
    DMEDecisionMakeModelType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::DMEDecisionBaseType (e, f | ::xml_schema::flags::base, c),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DMEDecisionMakeModelType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DMEDecisionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Manufacturer
        //
        if (n.name () == L"Manufacturer" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Manufacturer_type > r (
            Manufacturer_traits::create (i, f, this));

          if (!Manufacturer_.present ())
          {
            this->Manufacturer_.set (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == L"ModelNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!ModelNumber_.present ())
          {
            this->ModelNumber_.set (::std::move (r));
            continue;
          }
        }

        // SerialNumber
        //
        if (n.name () == L"SerialNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!this->SerialNumber_)
          {
            this->SerialNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Manufacturer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Manufacturer",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ModelNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ModelNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DMEDecisionMakeModelType* DMEDecisionMakeModelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMEDecisionMakeModelType (*this, f, c);
    }

    DMEDecisionMakeModelType& DMEDecisionMakeModelType::
    operator= (const DMEDecisionMakeModelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DMEDecisionBaseType& > (*this) = x;
        this->Manufacturer_ = x.Manufacturer_;
        this->ModelNumber_ = x.ModelNumber_;
        this->SerialNumber_ = x.SerialNumber_;
      }

      return *this;
    }

    DMEDecisionMakeModelType::
    ~DMEDecisionMakeModelType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DMEDecisionMakeModelType >
    _xsd_DMEDecisionMakeModelType_type_factory_init (
      L"DMEDecisionMakeModelType",
      L"http://qifstandards.org/xsd/qif3");

    // IfThenDMERuleType
    //

    IfThenDMERuleType::
    IfThenDMERuleType ()
    : ::xsd::qif30::QIFRuleBaseType (),
      BooleanExpression_ (this),
      DMEThen_ (this)
    {
    }

    IfThenDMERuleType::
    IfThenDMERuleType (const DMEThen_type& DMEThen)
    : ::xsd::qif30::QIFRuleBaseType (),
      BooleanExpression_ (this),
      DMEThen_ (DMEThen, this)
    {
    }

    IfThenDMERuleType::
    IfThenDMERuleType (::std::unique_ptr< DMEThen_type > DMEThen)
    : ::xsd::qif30::QIFRuleBaseType (),
      BooleanExpression_ (this),
      DMEThen_ (std::move (DMEThen), this)
    {
    }

    IfThenDMERuleType::
    IfThenDMERuleType (const IfThenDMERuleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::QIFRuleBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      DMEThen_ (x.DMEThen_, f, this)
    {
    }

    IfThenDMERuleType::
    IfThenDMERuleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::QIFRuleBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      DMEThen_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IfThenDMERuleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::QIFRuleBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BooleanExpression_)
            {
              ::std::unique_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BooleanExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        // DMEThen
        //
        if (n.name () == L"DMEThen" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DMEThen_type > r (
            DMEThen_traits::create (i, f, this));

          if (!DMEThen_.present ())
          {
            this->DMEThen_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DMEThen_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DMEThen",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    IfThenDMERuleType* IfThenDMERuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenDMERuleType (*this, f, c);
    }

    IfThenDMERuleType& IfThenDMERuleType::
    operator= (const IfThenDMERuleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::QIFRuleBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->DMEThen_ = x.DMEThen_;
      }

      return *this;
    }

    IfThenDMERuleType::
    ~IfThenDMERuleType ()
    {
    }

    // ZeroToOneType
    //

    ZeroToOneType::
    ZeroToOneType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
    {
    }

    ZeroToOneType::
    ZeroToOneType (const ::xml_schema::double_& _xsd_double__base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
    {
    }

    ZeroToOneType::
    ZeroToOneType (const ZeroToOneType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    ZeroToOneType::
    ZeroToOneType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    ZeroToOneType::
    ZeroToOneType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    ZeroToOneType::
    ZeroToOneType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    ZeroToOneType* ZeroToOneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZeroToOneType (*this, f, c);
    }

    ZeroToOneType::
    ~ZeroToOneType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenCurveRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCurveRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenCurveRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenSurfaceRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSurfaceRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenSurfaceRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenCircleRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCircleRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenCircleRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenCircularArcRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCircularArcRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenCircularArcRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenConeRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenConeRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenConeRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenConicalSegmentRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenConicalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenConicalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenCylinderRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCylinderRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenCylinderRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenCylindricalSegmentRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCylindricalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenCylindricalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenEllipseRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenEllipseRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenEllipseRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenEllipticalArcRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenEllipticalArcRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenEllipticalArcRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenElongatedCircleRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenElongatedCircleRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenElongatedCircleRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenElongatedCylinderRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenElongatedCylinderRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenElongatedCylinderRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenExtrudedCrossSectionRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenExtrudedCrossSectionRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenExtrudedCrossSectionRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenLineRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenLineRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenLineRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenOppositeAngledLinesRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeAngledLinesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenOppositeAngledLinesRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenOppositeAngledPlanesRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeAngledPlanesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenOppositeAngledPlanesRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenOppositeParallelLinesRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeParallelLinesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenOppositeParallelLinesRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenOppositeParallelPlanesRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeParallelPlanesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenOppositeParallelPlanesRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenPlaneRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPlaneRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenPlaneRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenPointDefinedCurveRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointDefinedCurveRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenPointDefinedCurveRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenPointDefinedSurfaceRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointDefinedSurfaceRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenPointDefinedSurfaceRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenPointRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenPointRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenSphereRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSphereRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenSphereRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenSphericalSegmentRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSphericalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenSphericalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenSurfaceOfRevolutionRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSurfaceOfRevolutionRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenSurfaceOfRevolutionRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenToroidalSegmentRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenToroidalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenToroidalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfThenTorusRule_element_factory_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenTorusRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfThenTorusRuleType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DMEDecisionClass_element_factory_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionClass",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DMEDecisionClassType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DMEDecisionId_element_factory_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DMEDecisionIdType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DMEDecisionMakeModel_element_factory_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionMakeModel",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DMEDecisionMakeModelType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Must_element_factory_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"Must",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::QIFMustType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MustNot_element_factory_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"MustNot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::QIFMustNotType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_May_element_factory_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"May",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::QIFMayType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const QIFRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // RulesUnits
      //
      if (i.RulesUnits ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RulesUnits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RulesUnits ();
      }

      // FeatureRules
      //
      if (i.FeatureRules ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureRules",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureRules ();
      }

      // DMESelectionRules
      //
      if (i.DMESelectionRules ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMESelectionRules",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DMESelectionRules ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RulesUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaUnit
      //
      if (i.AreaUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaUnit ();
      }

      // AngularUnit
      //
      if (i.AngularUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularUnit ();
      }

      // ForceUnit
      //
      if (i.ForceUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceUnit ();
      }

      // LinearUnit
      //
      if (i.LinearUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearUnit ();
      }

      // MassUnit
      //
      if (i.MassUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassUnit ();
      }

      // PressureUnit
      //
      if (i.PressureUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureUnit ();
      }

      // SpeedUnit
      //
      if (i.SpeedUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedUnit ();
      }

      // TemperatureUnit
      //
      if (i.TemperatureUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureUnit ();
      }

      // TimeUnit
      //
      if (i.TimeUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeUnit ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IfThenElseFeatureRules
      //
      if (i.IfThenElseFeatureRules ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IfThenElseFeatureRules",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IfThenElseFeatureRules ();
      }

      // MaxFeatureRules
      //
      if (i.MaxFeatureRules ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFeatureRules",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxFeatureRules ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFRuleBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // UUID
      //
      if (i.UUID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UUID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UUID ();
      }

      // name
      //
      if (i.name ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"name",
            e));

        a << *i.name ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenElseFeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IfThenFeatureRule
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IfThenElseFeatureRulesType::IfThenFeatureRule_const_iterator
             b (i.IfThenFeatureRule ().begin ()), n (i.IfThenFeatureRule ().end ());
             b != n; ++b)
        {
          const IfThenElseFeatureRulesType::IfThenFeatureRule_type& x (*b);

          if (typeid (IfThenElseFeatureRulesType::IfThenFeatureRule_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"IfThenFeatureRule",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"IfThenFeatureRule",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // Else
      //
      if (i.Else ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Else",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Else ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MaxFeatureRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IfThenFeatureRule
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (MaxFeatureRulesType::IfThenFeatureRule_const_iterator
             b (i.IfThenFeatureRule ().begin ()), n (i.IfThenFeatureRule ().end ());
             b != n; ++b)
        {
          const MaxFeatureRulesType::IfThenFeatureRule_type& x (*b);

          if (typeid (MaxFeatureRulesType::IfThenFeatureRule_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"IfThenFeatureRule",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"IfThenFeatureRule",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // Else
      //
      if (i.Else ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Else",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Else ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointRuleBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFRuleBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenFeatureRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::PointRuleBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BooleanExpression ())
        {
          const IfThenFeatureRuleType::BooleanExpression_type& x (*i.BooleanExpression ());
          if (typeid (IfThenFeatureRuleType::BooleanExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BooleanExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // ThenPoints
      //
      if (i.ThenPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenFeatureRuleType >
    _xsd_IfThenFeatureRuleType_type_serializer_init (
      L"IfThenFeatureRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElseRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::PointRuleBaseType& > (i);

      // ThenPoints
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThenPoints ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThenPointsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NumberOfPoints
      //
      if (i.NumberOfPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfPoints ();
      }

      // MinPoints
      //
      if (i.MinPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPoints ();
      }

      // PointDensity
      //
      if (i.PointDensity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointDensity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointDensity ();
      }

      // MinPointDensity
      //
      if (i.MinPointDensity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPointDensity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPointDensity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenCircleRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenCircleRuleType >
    _xsd_IfThenCircleRuleType_type_serializer_init (
      L"IfThenCircleRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CirclePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenCircularArcRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenCircularArcRuleType >
    _xsd_IfThenCircularArcRuleType_type_serializer_init (
      L"IfThenCircularArcRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircularArcPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenConeRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenConeRuleType >
    _xsd_IfThenConeRuleType_type_serializer_init (
      L"IfThenConeRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenConicalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRuleType_type_serializer_init (
      L"IfThenConicalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenCylinderRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenCylinderRuleType >
    _xsd_IfThenCylinderRuleType_type_serializer_init (
      L"IfThenCylinderRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylinderPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenCylindricalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRuleType_type_serializer_init (
      L"IfThenCylindricalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenEllipseRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenEllipseRuleType >
    _xsd_IfThenEllipseRuleType_type_serializer_init (
      L"IfThenEllipseRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipsePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenEllipticalArcRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenEllipticalArcRuleType >
    _xsd_IfThenEllipticalArcRuleType_type_serializer_init (
      L"IfThenEllipticalArcRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenElongatedCircleRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenElongatedCircleRuleType >
    _xsd_IfThenElongatedCircleRuleType_type_serializer_init (
      L"IfThenElongatedCircleRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCirclePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenElongatedCylinderRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRuleType_type_serializer_init (
      L"IfThenElongatedCylinderRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenExtrudedCrossSectionRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRuleType_type_serializer_init (
      L"IfThenExtrudedCrossSectionRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenLineRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenLineRuleType >
    _xsd_IfThenLineRuleType_type_serializer_init (
      L"IfThenLineRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LinePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenOppositeAngledLinesRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenOppositeAngledLinesRuleType >
    _xsd_IfThenOppositeAngledLinesRuleType_type_serializer_init (
      L"IfThenOppositeAngledLinesRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenOppositeAngledPlanesRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenOppositeAngledPlanesRuleType >
    _xsd_IfThenOppositeAngledPlanesRuleType_type_serializer_init (
      L"IfThenOppositeAngledPlanesRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenOppositeParallelLinesRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenOppositeParallelLinesRuleType >
    _xsd_IfThenOppositeParallelLinesRuleType_type_serializer_init (
      L"IfThenOppositeParallelLinesRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenOppositeParallelPlanesRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenOppositeParallelPlanesRuleType >
    _xsd_IfThenOppositeParallelPlanesRuleType_type_serializer_init (
      L"IfThenOppositeParallelPlanesRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenPlaneRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenPlaneRuleType >
    _xsd_IfThenPlaneRuleType_type_serializer_init (
      L"IfThenPlaneRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PlanePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenPointDefinedCurveRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRuleType_type_serializer_init (
      L"IfThenPointDefinedCurveRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurvePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenPointDefinedSurfaceRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRuleType_type_serializer_init (
      L"IfThenPointDefinedSurfaceRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfacePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenPointRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenPointRuleType >
    _xsd_IfThenPointRuleType_type_serializer_init (
      L"IfThenPointRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenSphereRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenSphereRuleType >
    _xsd_IfThenSphereRuleType_type_serializer_init (
      L"IfThenSphereRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SpherePointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenSphericalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRuleType_type_serializer_init (
      L"IfThenSphericalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenSurfaceOfRevolutionRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRuleType_type_serializer_init (
      L"IfThenSurfaceOfRevolutionRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenToroidalSegmentRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRuleType_type_serializer_init (
      L"IfThenToroidalSegmentRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenTorusRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);

      // ThenPointStrategy
      //
      if (i.ThenPointStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenPointStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenPointStrategy ();
      }

      // ThenFittingAlgorithm
      //
      if (i.ThenFittingAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThenFittingAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThenFittingAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenTorusRuleType >
    _xsd_IfThenTorusRuleType_type_serializer_init (
      L"IfThenTorusRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TorusPointSamplingStrategyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSamplingStrategyEnum
      //
      if (i.PointSamplingStrategyEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSamplingStrategyEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSamplingStrategyEnum ();
      }

      // UserDefinedStrategy
      //
      if (i.UserDefinedStrategy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedStrategy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedStrategy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IfThenSurfaceRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRuleType_type_serializer_init (
      L"IfThenSurfaceRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const IfThenCurveRuleType& i)
    {
      e << static_cast< const ::xsd::qif30::IfThenFeatureRuleType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfThenCurveRuleType >
    _xsd_IfThenCurveRuleType_type_serializer_init (
      L"IfThenCurveRuleType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DMESelectionRulesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DMEDecisionRule
      //
      for (DMESelectionRulesType::DMEDecisionRule_const_iterator
           b (i.DMEDecisionRule ().begin ()), n (i.DMEDecisionRule ().end ());
           b != n; ++b)
      {
        const DMESelectionRulesType::DMEDecisionRule_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEDecisionRule",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // defaultDesirability
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"defaultDesirability",
            e));

        a << i.defaultDesirability ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DMEThenType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DMEDecision
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (DMEThenType::DMEDecision_const_iterator
             b (i.DMEDecision ().begin ()), n (i.DMEDecision ().end ());
             b != n; ++b)
        {
          const DMEThenType::DMEDecision_type& x (*b);

          if (typeid (DMEThenType::DMEDecision_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"DMEDecision",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"DMEDecision",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DMEDecisionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Applicability
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const DMEDecisionBaseType::Applicability_type& x (i.Applicability ());
        if (typeid (DMEDecisionBaseType::Applicability_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Applicability",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Applicability",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ApplicabilityBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const ApplicabilityBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const ApplicabilityBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFMustType& i)
    {
      e << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFMustType& i)
    {
      a << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFMustType& i)
    {
      l << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, QIFMustType >
    _xsd_QIFMustType_type_serializer_init (
      L"QIFMustType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const QIFMustNotType& i)
    {
      e << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFMustNotType& i)
    {
      a << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFMustNotType& i)
    {
      l << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, QIFMustNotType >
    _xsd_QIFMustNotType_type_serializer_init (
      L"QIFMustNotType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const QIFMayType& i)
    {
      e << static_cast< const ::xsd::qif30::ApplicabilityBaseType& > (i);

      // desirability
      //
      if (i.desirability ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"desirability",
            e));

        a << *i.desirability ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, QIFMayType >
    _xsd_QIFMayType_type_serializer_init (
      L"QIFMayType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DMEDecisionClassType& i)
    {
      e << static_cast< const ::xsd::qif30::DMEDecisionBaseType& > (i);

      // DMEClassName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEClassName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DMEClassName ();
      }

      // ParameterConstraints
      //
      if (i.ParameterConstraints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParameterConstraints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ParameterConstraints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DMEDecisionClassType >
    _xsd_DMEDecisionClassType_type_serializer_init (
      L"DMEDecisionClassType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DMEParameterConstraintSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DMEParameterConstraint
      //
      for (DMEParameterConstraintSetType::DMEParameterConstraint_const_iterator
           b (i.DMEParameterConstraint ().begin ()), n (i.DMEParameterConstraint ().end ());
           b != n; ++b)
      {
        const DMEParameterConstraintSetType::DMEParameterConstraint_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEParameterConstraint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DMEParameterConstraintType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ParameterName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParameterName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ParameterName ();
      }

      // Comparison
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Comparison",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Comparison ();
      }

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const DMEParameterConstraintType::ArithmeticExpression_type& x (i.ArithmeticExpression ());
        if (typeid (DMEParameterConstraintType::ArithmeticExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArithmeticExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DMEDecisionIdType& i)
    {
      e << static_cast< const ::xsd::qif30::DMEDecisionBaseType& > (i);

      // DMEId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DMEId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DMEDecisionIdType >
    _xsd_DMEDecisionIdType_type_serializer_init (
      L"DMEDecisionIdType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DMEDecisionMakeModelType& i)
    {
      e << static_cast< const ::xsd::qif30::DMEDecisionBaseType& > (i);

      // Manufacturer
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Manufacturer",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Manufacturer ();
      }

      // ModelNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModelNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ModelNumber ();
      }

      // SerialNumber
      //
      if (i.SerialNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SerialNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SerialNumber ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DMEDecisionMakeModelType >
    _xsd_DMEDecisionMakeModelType_type_serializer_init (
      L"DMEDecisionMakeModelType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const IfThenDMERuleType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFRuleBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BooleanExpression ())
        {
          const IfThenDMERuleType::BooleanExpression_type& x (*i.BooleanExpression ());
          if (typeid (IfThenDMERuleType::BooleanExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BooleanExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // DMEThen
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DMEThen",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DMEThen ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ZeroToOneType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ZeroToOneType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ZeroToOneType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenCurveRuleType >
    _xsd_IfThenCurveRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCurveRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenCurveRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenSurfaceRuleType >
    _xsd_IfThenSurfaceRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSurfaceRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenSurfaceRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenCircleRuleType >
    _xsd_IfThenCircleRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCircleRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenCircleRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenCircularArcRuleType >
    _xsd_IfThenCircularArcRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCircularArcRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenCircularArcRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenConeRuleType >
    _xsd_IfThenConeRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenConeRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenConeRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenConicalSegmentRuleType >
    _xsd_IfThenConicalSegmentRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenConicalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenConicalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenCylinderRuleType >
    _xsd_IfThenCylinderRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCylinderRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenCylinderRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenCylindricalSegmentRuleType >
    _xsd_IfThenCylindricalSegmentRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenCylindricalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenCylindricalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenEllipseRuleType >
    _xsd_IfThenEllipseRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenEllipseRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenEllipseRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenEllipticalArcRuleType >
    _xsd_IfThenEllipticalArcRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenEllipticalArcRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenEllipticalArcRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenElongatedCircleRuleType >
    _xsd_IfThenElongatedCircleRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenElongatedCircleRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenElongatedCircleRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenElongatedCylinderRuleType >
    _xsd_IfThenElongatedCylinderRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenElongatedCylinderRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenElongatedCylinderRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenExtrudedCrossSectionRuleType >
    _xsd_IfThenExtrudedCrossSectionRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenExtrudedCrossSectionRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenExtrudedCrossSectionRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenLineRuleType >
    _xsd_IfThenLineRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenLineRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenLineRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenOppositeAngledLinesRuleType >
    _xsd_IfThenOppositeAngledLinesRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeAngledLinesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenOppositeAngledLinesRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenOppositeAngledPlanesRuleType >
    _xsd_IfThenOppositeAngledPlanesRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeAngledPlanesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenOppositeAngledPlanesRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenOppositeParallelLinesRuleType >
    _xsd_IfThenOppositeParallelLinesRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeParallelLinesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenOppositeParallelLinesRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenOppositeParallelPlanesRuleType >
    _xsd_IfThenOppositeParallelPlanesRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenOppositeParallelPlanesRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenOppositeParallelPlanesRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenPlaneRuleType >
    _xsd_IfThenPlaneRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPlaneRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenPlaneRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenPointDefinedCurveRuleType >
    _xsd_IfThenPointDefinedCurveRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointDefinedCurveRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenPointDefinedCurveRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenPointDefinedSurfaceRuleType >
    _xsd_IfThenPointDefinedSurfaceRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointDefinedSurfaceRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenPointDefinedSurfaceRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenPointRuleType >
    _xsd_IfThenPointRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenPointRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenPointRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenSphereRuleType >
    _xsd_IfThenSphereRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSphereRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenSphereRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenSphericalSegmentRuleType >
    _xsd_IfThenSphericalSegmentRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSphericalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenSphericalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenSurfaceOfRevolutionRuleType >
    _xsd_IfThenSurfaceOfRevolutionRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenSurfaceOfRevolutionRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenSurfaceOfRevolutionRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenToroidalSegmentRuleType >
    _xsd_IfThenToroidalSegmentRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenToroidalSegmentRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenToroidalSegmentRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfThenTorusRuleType >
    _xsd_IfThenTorusRule_element_serializer_init (
      L"IfThenFeatureRule",
      L"http://qifstandards.org/xsd/qif3",
      L"IfThenTorusRule",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfThenTorusRuleType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DMEDecisionClassType >
    _xsd_DMEDecisionClass_element_serializer_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionClass",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DMEDecisionClassType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DMEDecisionIdType >
    _xsd_DMEDecisionId_element_serializer_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DMEDecisionIdType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DMEDecisionMakeModelType >
    _xsd_DMEDecisionMakeModel_element_serializer_init (
      L"DMEDecision",
      L"http://qifstandards.org/xsd/qif3",
      L"DMEDecisionMakeModel",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DMEDecisionMakeModelType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::QIFMustType >
    _xsd_Must_element_serializer_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"Must",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::QIFMustType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::QIFMustNotType >
    _xsd_MustNot_element_serializer_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"MustNot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::QIFMustNotType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::QIFMayType >
    _xsd_May_element_serializer_init (
      L"Applicability",
      L"http://qifstandards.org/xsd/qif3",
      L"May",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::QIFMayType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

