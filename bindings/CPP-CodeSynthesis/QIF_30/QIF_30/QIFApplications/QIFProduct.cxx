// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFProduct.hxx"

namespace xsd
{
  namespace qif30
  {
    // ProductType
    //

    const ProductType::Header_optional& ProductType::
    Header () const
    {
      return this->Header_;
    }

    ProductType::Header_optional& ProductType::
    Header ()
    {
      return this->Header_;
    }

    void ProductType::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void ProductType::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void ProductType::
    Header (::std::unique_ptr< Header_type > x)
    {
      this->Header_.set (std::move (x));
    }

    const ProductType::GeometrySet_optional& ProductType::
    GeometrySet () const
    {
      return this->GeometrySet_;
    }

    ProductType::GeometrySet_optional& ProductType::
    GeometrySet ()
    {
      return this->GeometrySet_;
    }

    void ProductType::
    GeometrySet (const GeometrySet_type& x)
    {
      this->GeometrySet_.set (x);
    }

    void ProductType::
    GeometrySet (const GeometrySet_optional& x)
    {
      this->GeometrySet_ = x;
    }

    void ProductType::
    GeometrySet (::std::unique_ptr< GeometrySet_type > x)
    {
      this->GeometrySet_.set (std::move (x));
    }

    const ProductType::TopologySet_optional& ProductType::
    TopologySet () const
    {
      return this->TopologySet_;
    }

    ProductType::TopologySet_optional& ProductType::
    TopologySet ()
    {
      return this->TopologySet_;
    }

    void ProductType::
    TopologySet (const TopologySet_type& x)
    {
      this->TopologySet_.set (x);
    }

    void ProductType::
    TopologySet (const TopologySet_optional& x)
    {
      this->TopologySet_ = x;
    }

    void ProductType::
    TopologySet (::std::unique_ptr< TopologySet_type > x)
    {
      this->TopologySet_.set (std::move (x));
    }

    const ProductType::NoteSet_optional& ProductType::
    NoteSet () const
    {
      return this->NoteSet_;
    }

    ProductType::NoteSet_optional& ProductType::
    NoteSet ()
    {
      return this->NoteSet_;
    }

    void ProductType::
    NoteSet (const NoteSet_type& x)
    {
      this->NoteSet_.set (x);
    }

    void ProductType::
    NoteSet (const NoteSet_optional& x)
    {
      this->NoteSet_ = x;
    }

    void ProductType::
    NoteSet (::std::unique_ptr< NoteSet_type > x)
    {
      this->NoteSet_.set (std::move (x));
    }

    const ProductType::NoteFlagSet_optional& ProductType::
    NoteFlagSet () const
    {
      return this->NoteFlagSet_;
    }

    ProductType::NoteFlagSet_optional& ProductType::
    NoteFlagSet ()
    {
      return this->NoteFlagSet_;
    }

    void ProductType::
    NoteFlagSet (const NoteFlagSet_type& x)
    {
      this->NoteFlagSet_.set (x);
    }

    void ProductType::
    NoteFlagSet (const NoteFlagSet_optional& x)
    {
      this->NoteFlagSet_ = x;
    }

    void ProductType::
    NoteFlagSet (::std::unique_ptr< NoteFlagSet_type > x)
    {
      this->NoteFlagSet_.set (std::move (x));
    }

    const ProductType::PartNoteSet_optional& ProductType::
    PartNoteSet () const
    {
      return this->PartNoteSet_;
    }

    ProductType::PartNoteSet_optional& ProductType::
    PartNoteSet ()
    {
      return this->PartNoteSet_;
    }

    void ProductType::
    PartNoteSet (const PartNoteSet_type& x)
    {
      this->PartNoteSet_.set (x);
    }

    void ProductType::
    PartNoteSet (const PartNoteSet_optional& x)
    {
      this->PartNoteSet_ = x;
    }

    void ProductType::
    PartNoteSet (::std::unique_ptr< PartNoteSet_type > x)
    {
      this->PartNoteSet_.set (std::move (x));
    }

    const ProductType::ViewSet_optional& ProductType::
    ViewSet () const
    {
      return this->ViewSet_;
    }

    ProductType::ViewSet_optional& ProductType::
    ViewSet ()
    {
      return this->ViewSet_;
    }

    void ProductType::
    ViewSet (const ViewSet_type& x)
    {
      this->ViewSet_.set (x);
    }

    void ProductType::
    ViewSet (const ViewSet_optional& x)
    {
      this->ViewSet_ = x;
    }

    void ProductType::
    ViewSet (::std::unique_ptr< ViewSet_type > x)
    {
      this->ViewSet_.set (std::move (x));
    }

    const ProductType::LayerSet_optional& ProductType::
    LayerSet () const
    {
      return this->LayerSet_;
    }

    ProductType::LayerSet_optional& ProductType::
    LayerSet ()
    {
      return this->LayerSet_;
    }

    void ProductType::
    LayerSet (const LayerSet_type& x)
    {
      this->LayerSet_.set (x);
    }

    void ProductType::
    LayerSet (const LayerSet_optional& x)
    {
      this->LayerSet_ = x;
    }

    void ProductType::
    LayerSet (::std::unique_ptr< LayerSet_type > x)
    {
      this->LayerSet_.set (std::move (x));
    }

    const ProductType::CoordinateSystemSet_optional& ProductType::
    CoordinateSystemSet () const
    {
      return this->CoordinateSystemSet_;
    }

    ProductType::CoordinateSystemSet_optional& ProductType::
    CoordinateSystemSet ()
    {
      return this->CoordinateSystemSet_;
    }

    void ProductType::
    CoordinateSystemSet (const CoordinateSystemSet_type& x)
    {
      this->CoordinateSystemSet_.set (x);
    }

    void ProductType::
    CoordinateSystemSet (const CoordinateSystemSet_optional& x)
    {
      this->CoordinateSystemSet_ = x;
    }

    void ProductType::
    CoordinateSystemSet (::std::unique_ptr< CoordinateSystemSet_type > x)
    {
      this->CoordinateSystemSet_.set (std::move (x));
    }

    const ProductType::VisualizationSet_optional& ProductType::
    VisualizationSet () const
    {
      return this->VisualizationSet_;
    }

    ProductType::VisualizationSet_optional& ProductType::
    VisualizationSet ()
    {
      return this->VisualizationSet_;
    }

    void ProductType::
    VisualizationSet (const VisualizationSet_type& x)
    {
      this->VisualizationSet_.set (x);
    }

    void ProductType::
    VisualizationSet (const VisualizationSet_optional& x)
    {
      this->VisualizationSet_ = x;
    }

    void ProductType::
    VisualizationSet (::std::unique_ptr< VisualizationSet_type > x)
    {
      this->VisualizationSet_.set (std::move (x));
    }

    const ProductType::AuxiliarySet_optional& ProductType::
    AuxiliarySet () const
    {
      return this->AuxiliarySet_;
    }

    ProductType::AuxiliarySet_optional& ProductType::
    AuxiliarySet ()
    {
      return this->AuxiliarySet_;
    }

    void ProductType::
    AuxiliarySet (const AuxiliarySet_type& x)
    {
      this->AuxiliarySet_.set (x);
    }

    void ProductType::
    AuxiliarySet (const AuxiliarySet_optional& x)
    {
      this->AuxiliarySet_ = x;
    }

    void ProductType::
    AuxiliarySet (::std::unique_ptr< AuxiliarySet_type > x)
    {
      this->AuxiliarySet_.set (std::move (x));
    }

    const ProductType::PartSet_optional& ProductType::
    PartSet () const
    {
      return this->PartSet_;
    }

    ProductType::PartSet_optional& ProductType::
    PartSet ()
    {
      return this->PartSet_;
    }

    void ProductType::
    PartSet (const PartSet_type& x)
    {
      this->PartSet_.set (x);
    }

    void ProductType::
    PartSet (const PartSet_optional& x)
    {
      this->PartSet_ = x;
    }

    void ProductType::
    PartSet (::std::unique_ptr< PartSet_type > x)
    {
      this->PartSet_.set (std::move (x));
    }

    const ProductType::AssemblySet_optional& ProductType::
    AssemblySet () const
    {
      return this->AssemblySet_;
    }

    ProductType::AssemblySet_optional& ProductType::
    AssemblySet ()
    {
      return this->AssemblySet_;
    }

    void ProductType::
    AssemblySet (const AssemblySet_type& x)
    {
      this->AssemblySet_.set (x);
    }

    void ProductType::
    AssemblySet (const AssemblySet_optional& x)
    {
      this->AssemblySet_ = x;
    }

    void ProductType::
    AssemblySet (::std::unique_ptr< AssemblySet_type > x)
    {
      this->AssemblySet_.set (std::move (x));
    }

    const ProductType::ComponentSet_optional& ProductType::
    ComponentSet () const
    {
      return this->ComponentSet_;
    }

    ProductType::ComponentSet_optional& ProductType::
    ComponentSet ()
    {
      return this->ComponentSet_;
    }

    void ProductType::
    ComponentSet (const ComponentSet_type& x)
    {
      this->ComponentSet_.set (x);
    }

    void ProductType::
    ComponentSet (const ComponentSet_optional& x)
    {
      this->ComponentSet_ = x;
    }

    void ProductType::
    ComponentSet (::std::unique_ptr< ComponentSet_type > x)
    {
      this->ComponentSet_.set (std::move (x));
    }

    const ProductType::RootPart_optional& ProductType::
    RootPart () const
    {
      return this->RootPart_;
    }

    ProductType::RootPart_optional& ProductType::
    RootPart ()
    {
      return this->RootPart_;
    }

    void ProductType::
    RootPart (const RootPart_type& x)
    {
      this->RootPart_.set (x);
    }

    void ProductType::
    RootPart (const RootPart_optional& x)
    {
      this->RootPart_ = x;
    }

    void ProductType::
    RootPart (::std::unique_ptr< RootPart_type > x)
    {
      this->RootPart_.set (std::move (x));
    }

    const ProductType::RootAssembly_optional& ProductType::
    RootAssembly () const
    {
      return this->RootAssembly_;
    }

    ProductType::RootAssembly_optional& ProductType::
    RootAssembly ()
    {
      return this->RootAssembly_;
    }

    void ProductType::
    RootAssembly (const RootAssembly_type& x)
    {
      this->RootAssembly_.set (x);
    }

    void ProductType::
    RootAssembly (const RootAssembly_optional& x)
    {
      this->RootAssembly_ = x;
    }

    void ProductType::
    RootAssembly (::std::unique_ptr< RootAssembly_type > x)
    {
      this->RootAssembly_.set (std::move (x));
    }

    const ProductType::RootComponent_optional& ProductType::
    RootComponent () const
    {
      return this->RootComponent_;
    }

    ProductType::RootComponent_optional& ProductType::
    RootComponent ()
    {
      return this->RootComponent_;
    }

    void ProductType::
    RootComponent (const RootComponent_type& x)
    {
      this->RootComponent_.set (x);
    }

    void ProductType::
    RootComponent (const RootComponent_optional& x)
    {
      this->RootComponent_ = x;
    }

    void ProductType::
    RootComponent (::std::unique_ptr< RootComponent_type > x)
    {
      this->RootComponent_.set (std::move (x));
    }

    const ProductType::AsmPaths_optional& ProductType::
    AsmPaths () const
    {
      return this->AsmPaths_;
    }

    ProductType::AsmPaths_optional& ProductType::
    AsmPaths ()
    {
      return this->AsmPaths_;
    }

    void ProductType::
    AsmPaths (const AsmPaths_type& x)
    {
      this->AsmPaths_.set (x);
    }

    void ProductType::
    AsmPaths (const AsmPaths_optional& x)
    {
      this->AsmPaths_ = x;
    }

    void ProductType::
    AsmPaths (::std::unique_ptr< AsmPaths_type > x)
    {
      this->AsmPaths_.set (std::move (x));
    }

    const ProductType::MaterialLibrary_optional& ProductType::
    MaterialLibrary () const
    {
      return this->MaterialLibrary_;
    }

    ProductType::MaterialLibrary_optional& ProductType::
    MaterialLibrary ()
    {
      return this->MaterialLibrary_;
    }

    void ProductType::
    MaterialLibrary (const MaterialLibrary_type& x)
    {
      this->MaterialLibrary_.set (x);
    }

    void ProductType::
    MaterialLibrary (const MaterialLibrary_optional& x)
    {
      this->MaterialLibrary_ = x;
    }

    void ProductType::
    MaterialLibrary (::std::unique_ptr< MaterialLibrary_type > x)
    {
      this->MaterialLibrary_.set (std::move (x));
    }


    // AsmPathType
    //

    const AsmPathType::ComponentIds_optional& AsmPathType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    AsmPathType::ComponentIds_optional& AsmPathType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void AsmPathType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void AsmPathType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void AsmPathType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const AsmPathType::id_type& AsmPathType::
    id () const
    {
      return this->id_.get ();
    }

    AsmPathType::id_type& AsmPathType::
    id ()
    {
      return this->id_.get ();
    }

    void AsmPathType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AsmPathType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // AsmPathsType
    //

    const AsmPathsType::AsmPath_sequence& AsmPathsType::
    AsmPath () const
    {
      return this->AsmPath_;
    }

    AsmPathsType::AsmPath_sequence& AsmPathsType::
    AsmPath ()
    {
      return this->AsmPath_;
    }

    void AsmPathsType::
    AsmPath (const AsmPath_sequence& s)
    {
      this->AsmPath_ = s;
    }

    const AsmPathsType::n_type& AsmPathsType::
    n () const
    {
      return this->n_.get ();
    }

    AsmPathsType::n_type& AsmPathsType::
    n ()
    {
      return this->n_.get ();
    }

    void AsmPathsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AsmPathsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ValidationPartAssemblyType
    //

    const ValidationPartAssemblyType::Area_optional& ValidationPartAssemblyType::
    Area () const
    {
      return this->Area_;
    }

    ValidationPartAssemblyType::Area_optional& ValidationPartAssemblyType::
    Area ()
    {
      return this->Area_;
    }

    void ValidationPartAssemblyType::
    Area (const Area_type& x)
    {
      this->Area_.set (x);
    }

    void ValidationPartAssemblyType::
    Area (const Area_optional& x)
    {
      this->Area_ = x;
    }

    const ValidationPartAssemblyType::Centroid_optional& ValidationPartAssemblyType::
    Centroid () const
    {
      return this->Centroid_;
    }

    ValidationPartAssemblyType::Centroid_optional& ValidationPartAssemblyType::
    Centroid ()
    {
      return this->Centroid_;
    }

    void ValidationPartAssemblyType::
    Centroid (const Centroid_type& x)
    {
      this->Centroid_.set (x);
    }

    void ValidationPartAssemblyType::
    Centroid (const Centroid_optional& x)
    {
      this->Centroid_ = x;
    }

    void ValidationPartAssemblyType::
    Centroid (::std::unique_ptr< Centroid_type > x)
    {
      this->Centroid_.set (std::move (x));
    }

    const ValidationPartAssemblyType::Volume_optional& ValidationPartAssemblyType::
    Volume () const
    {
      return this->Volume_;
    }

    ValidationPartAssemblyType::Volume_optional& ValidationPartAssemblyType::
    Volume ()
    {
      return this->Volume_;
    }

    void ValidationPartAssemblyType::
    Volume (const Volume_type& x)
    {
      this->Volume_.set (x);
    }

    void ValidationPartAssemblyType::
    Volume (const Volume_optional& x)
    {
      this->Volume_ = x;
    }

    const ValidationPartAssemblyType::Box_optional& ValidationPartAssemblyType::
    Box () const
    {
      return this->Box_;
    }

    ValidationPartAssemblyType::Box_optional& ValidationPartAssemblyType::
    Box ()
    {
      return this->Box_;
    }

    void ValidationPartAssemblyType::
    Box (const Box_type& x)
    {
      this->Box_.set (x);
    }

    void ValidationPartAssemblyType::
    Box (const Box_optional& x)
    {
      this->Box_ = x;
    }

    void ValidationPartAssemblyType::
    Box (::std::unique_ptr< Box_type > x)
    {
      this->Box_.set (std::move (x));
    }

    const ValidationPartAssemblyType::FacePoints_optional& ValidationPartAssemblyType::
    FacePoints () const
    {
      return this->FacePoints_;
    }

    ValidationPartAssemblyType::FacePoints_optional& ValidationPartAssemblyType::
    FacePoints ()
    {
      return this->FacePoints_;
    }

    void ValidationPartAssemblyType::
    FacePoints (const FacePoints_type& x)
    {
      this->FacePoints_.set (x);
    }

    void ValidationPartAssemblyType::
    FacePoints (const FacePoints_optional& x)
    {
      this->FacePoints_ = x;
    }

    void ValidationPartAssemblyType::
    FacePoints (::std::unique_ptr< FacePoints_type > x)
    {
      this->FacePoints_.set (std::move (x));
    }

    const ValidationPartAssemblyType::EdgePoints_optional& ValidationPartAssemblyType::
    EdgePoints () const
    {
      return this->EdgePoints_;
    }

    ValidationPartAssemblyType::EdgePoints_optional& ValidationPartAssemblyType::
    EdgePoints ()
    {
      return this->EdgePoints_;
    }

    void ValidationPartAssemblyType::
    EdgePoints (const EdgePoints_type& x)
    {
      this->EdgePoints_.set (x);
    }

    void ValidationPartAssemblyType::
    EdgePoints (const EdgePoints_optional& x)
    {
      this->EdgePoints_ = x;
    }

    void ValidationPartAssemblyType::
    EdgePoints (::std::unique_ptr< EdgePoints_type > x)
    {
      this->EdgePoints_.set (std::move (x));
    }

    const ValidationPartAssemblyType::Instances_optional& ValidationPartAssemblyType::
    Instances () const
    {
      return this->Instances_;
    }

    ValidationPartAssemblyType::Instances_optional& ValidationPartAssemblyType::
    Instances ()
    {
      return this->Instances_;
    }

    void ValidationPartAssemblyType::
    Instances (const Instances_type& x)
    {
      this->Instances_.set (x);
    }

    void ValidationPartAssemblyType::
    Instances (const Instances_optional& x)
    {
      this->Instances_ = x;
    }

    void ValidationPartAssemblyType::
    Instances (::std::unique_ptr< Instances_type > x)
    {
      this->Instances_.set (std::move (x));
    }


    // ValidationPartAssemblyInstancesType
    //

    const ValidationPartAssemblyInstancesType::Instance_sequence& ValidationPartAssemblyInstancesType::
    Instance () const
    {
      return this->Instance_;
    }

    ValidationPartAssemblyInstancesType::Instance_sequence& ValidationPartAssemblyInstancesType::
    Instance ()
    {
      return this->Instance_;
    }

    void ValidationPartAssemblyInstancesType::
    Instance (const Instance_sequence& s)
    {
      this->Instance_ = s;
    }

    const ValidationPartAssemblyInstancesType::n_type& ValidationPartAssemblyInstancesType::
    n () const
    {
      return this->n_.get ();
    }

    ValidationPartAssemblyInstancesType::n_type& ValidationPartAssemblyInstancesType::
    n ()
    {
      return this->n_.get ();
    }

    void ValidationPartAssemblyInstancesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ValidationPartAssemblyInstancesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ValidationPartAssemblyInstanceType
    //

    const ValidationPartAssemblyInstanceType::AsmPathId_type& ValidationPartAssemblyInstanceType::
    AsmPathId () const
    {
      return this->AsmPathId_.get ();
    }

    ValidationPartAssemblyInstanceType::AsmPathId_type& ValidationPartAssemblyInstanceType::
    AsmPathId ()
    {
      return this->AsmPathId_.get ();
    }

    void ValidationPartAssemblyInstanceType::
    AsmPathId (const AsmPathId_type& x)
    {
      this->AsmPathId_.set (x);
    }

    void ValidationPartAssemblyInstanceType::
    AsmPathId (::std::unique_ptr< AsmPathId_type > x)
    {
      this->AsmPathId_.set (std::move (x));
    }

    const ValidationPartAssemblyInstanceType::Centroid_optional& ValidationPartAssemblyInstanceType::
    Centroid () const
    {
      return this->Centroid_;
    }

    ValidationPartAssemblyInstanceType::Centroid_optional& ValidationPartAssemblyInstanceType::
    Centroid ()
    {
      return this->Centroid_;
    }

    void ValidationPartAssemblyInstanceType::
    Centroid (const Centroid_type& x)
    {
      this->Centroid_.set (x);
    }

    void ValidationPartAssemblyInstanceType::
    Centroid (const Centroid_optional& x)
    {
      this->Centroid_ = x;
    }

    void ValidationPartAssemblyInstanceType::
    Centroid (::std::unique_ptr< Centroid_type > x)
    {
      this->Centroid_.set (std::move (x));
    }

    const ValidationPartAssemblyInstanceType::Box_optional& ValidationPartAssemblyInstanceType::
    Box () const
    {
      return this->Box_;
    }

    ValidationPartAssemblyInstanceType::Box_optional& ValidationPartAssemblyInstanceType::
    Box ()
    {
      return this->Box_;
    }

    void ValidationPartAssemblyInstanceType::
    Box (const Box_type& x)
    {
      this->Box_.set (x);
    }

    void ValidationPartAssemblyInstanceType::
    Box (const Box_optional& x)
    {
      this->Box_ = x;
    }

    void ValidationPartAssemblyInstanceType::
    Box (::std::unique_ptr< Box_type > x)
    {
      this->Box_.set (std::move (x));
    }


    // PartAssemblyBaseType
    //

    const PartAssemblyBaseType::Validation_optional& PartAssemblyBaseType::
    Validation () const
    {
      return this->Validation_;
    }

    PartAssemblyBaseType::Validation_optional& PartAssemblyBaseType::
    Validation ()
    {
      return this->Validation_;
    }

    void PartAssemblyBaseType::
    Validation (const Validation_type& x)
    {
      this->Validation_.set (x);
    }

    void PartAssemblyBaseType::
    Validation (const Validation_optional& x)
    {
      this->Validation_ = x;
    }

    void PartAssemblyBaseType::
    Validation (::std::unique_ptr< Validation_type > x)
    {
      this->Validation_.set (std::move (x));
    }

    const PartAssemblyBaseType::Header_optional& PartAssemblyBaseType::
    Header () const
    {
      return this->Header_;
    }

    PartAssemblyBaseType::Header_optional& PartAssemblyBaseType::
    Header ()
    {
      return this->Header_;
    }

    void PartAssemblyBaseType::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void PartAssemblyBaseType::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void PartAssemblyBaseType::
    Header (::std::unique_ptr< Header_type > x)
    {
      this->Header_.set (std::move (x));
    }

    const PartAssemblyBaseType::UUID_optional& PartAssemblyBaseType::
    UUID () const
    {
      return this->UUID_;
    }

    PartAssemblyBaseType::UUID_optional& PartAssemblyBaseType::
    UUID ()
    {
      return this->UUID_;
    }

    void PartAssemblyBaseType::
    UUID (const UUID_type& x)
    {
      this->UUID_.set (x);
    }

    void PartAssemblyBaseType::
    UUID (const UUID_optional& x)
    {
      this->UUID_ = x;
    }

    void PartAssemblyBaseType::
    UUID (::std::unique_ptr< UUID_type > x)
    {
      this->UUID_.set (std::move (x));
    }

    const PartAssemblyBaseType::ModelNumber_optional& PartAssemblyBaseType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    PartAssemblyBaseType::ModelNumber_optional& PartAssemblyBaseType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void PartAssemblyBaseType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void PartAssemblyBaseType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void PartAssemblyBaseType::
    ModelNumber (::std::unique_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const PartAssemblyBaseType::Version_optional& PartAssemblyBaseType::
    Version () const
    {
      return this->Version_;
    }

    PartAssemblyBaseType::Version_optional& PartAssemblyBaseType::
    Version ()
    {
      return this->Version_;
    }

    void PartAssemblyBaseType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PartAssemblyBaseType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PartAssemblyBaseType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const PartAssemblyBaseType::SecurityClassification_optional& PartAssemblyBaseType::
    SecurityClassification () const
    {
      return this->SecurityClassification_;
    }

    PartAssemblyBaseType::SecurityClassification_optional& PartAssemblyBaseType::
    SecurityClassification ()
    {
      return this->SecurityClassification_;
    }

    void PartAssemblyBaseType::
    SecurityClassification (const SecurityClassification_type& x)
    {
      this->SecurityClassification_.set (x);
    }

    void PartAssemblyBaseType::
    SecurityClassification (const SecurityClassification_optional& x)
    {
      this->SecurityClassification_ = x;
    }

    void PartAssemblyBaseType::
    SecurityClassification (::std::unique_ptr< SecurityClassification_type > x)
    {
      this->SecurityClassification_.set (std::move (x));
    }

    const PartAssemblyBaseType::ExportControlClassification_optional& PartAssemblyBaseType::
    ExportControlClassification () const
    {
      return this->ExportControlClassification_;
    }

    PartAssemblyBaseType::ExportControlClassification_optional& PartAssemblyBaseType::
    ExportControlClassification ()
    {
      return this->ExportControlClassification_;
    }

    void PartAssemblyBaseType::
    ExportControlClassification (const ExportControlClassification_type& x)
    {
      this->ExportControlClassification_.set (x);
    }

    void PartAssemblyBaseType::
    ExportControlClassification (const ExportControlClassification_optional& x)
    {
      this->ExportControlClassification_ = x;
    }

    void PartAssemblyBaseType::
    ExportControlClassification (::std::unique_ptr< ExportControlClassification_type > x)
    {
      this->ExportControlClassification_.set (std::move (x));
    }

    const PartAssemblyBaseType::FeatureNominalIds_optional& PartAssemblyBaseType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_;
    }

    PartAssemblyBaseType::FeatureNominalIds_optional& PartAssemblyBaseType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_;
    }

    void PartAssemblyBaseType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void PartAssemblyBaseType::
    FeatureNominalIds (const FeatureNominalIds_optional& x)
    {
      this->FeatureNominalIds_ = x;
    }

    void PartAssemblyBaseType::
    FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::FeatureZoneIds_optional& PartAssemblyBaseType::
    FeatureZoneIds () const
    {
      return this->FeatureZoneIds_;
    }

    PartAssemblyBaseType::FeatureZoneIds_optional& PartAssemblyBaseType::
    FeatureZoneIds ()
    {
      return this->FeatureZoneIds_;
    }

    void PartAssemblyBaseType::
    FeatureZoneIds (const FeatureZoneIds_type& x)
    {
      this->FeatureZoneIds_.set (x);
    }

    void PartAssemblyBaseType::
    FeatureZoneIds (const FeatureZoneIds_optional& x)
    {
      this->FeatureZoneIds_ = x;
    }

    void PartAssemblyBaseType::
    FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > x)
    {
      this->FeatureZoneIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::CharacteristicNominalIds_optional& PartAssemblyBaseType::
    CharacteristicNominalIds () const
    {
      return this->CharacteristicNominalIds_;
    }

    PartAssemblyBaseType::CharacteristicNominalIds_optional& PartAssemblyBaseType::
    CharacteristicNominalIds ()
    {
      return this->CharacteristicNominalIds_;
    }

    void PartAssemblyBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_type& x)
    {
      this->CharacteristicNominalIds_.set (x);
    }

    void PartAssemblyBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_optional& x)
    {
      this->CharacteristicNominalIds_ = x;
    }

    void PartAssemblyBaseType::
    CharacteristicNominalIds (::std::unique_ptr< CharacteristicNominalIds_type > x)
    {
      this->CharacteristicNominalIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::NoteIds_optional& PartAssemblyBaseType::
    NoteIds () const
    {
      return this->NoteIds_;
    }

    PartAssemblyBaseType::NoteIds_optional& PartAssemblyBaseType::
    NoteIds ()
    {
      return this->NoteIds_;
    }

    void PartAssemblyBaseType::
    NoteIds (const NoteIds_type& x)
    {
      this->NoteIds_.set (x);
    }

    void PartAssemblyBaseType::
    NoteIds (const NoteIds_optional& x)
    {
      this->NoteIds_ = x;
    }

    void PartAssemblyBaseType::
    NoteIds (::std::unique_ptr< NoteIds_type > x)
    {
      this->NoteIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::PartNoteIds_optional& PartAssemblyBaseType::
    PartNoteIds () const
    {
      return this->PartNoteIds_;
    }

    PartAssemblyBaseType::PartNoteIds_optional& PartAssemblyBaseType::
    PartNoteIds ()
    {
      return this->PartNoteIds_;
    }

    void PartAssemblyBaseType::
    PartNoteIds (const PartNoteIds_type& x)
    {
      this->PartNoteIds_.set (x);
    }

    void PartAssemblyBaseType::
    PartNoteIds (const PartNoteIds_optional& x)
    {
      this->PartNoteIds_ = x;
    }

    void PartAssemblyBaseType::
    PartNoteIds (::std::unique_ptr< PartNoteIds_type > x)
    {
      this->PartNoteIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::DatumDefinitionIds_optional& PartAssemblyBaseType::
    DatumDefinitionIds () const
    {
      return this->DatumDefinitionIds_;
    }

    PartAssemblyBaseType::DatumDefinitionIds_optional& PartAssemblyBaseType::
    DatumDefinitionIds ()
    {
      return this->DatumDefinitionIds_;
    }

    void PartAssemblyBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_type& x)
    {
      this->DatumDefinitionIds_.set (x);
    }

    void PartAssemblyBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_optional& x)
    {
      this->DatumDefinitionIds_ = x;
    }

    void PartAssemblyBaseType::
    DatumDefinitionIds (::std::unique_ptr< DatumDefinitionIds_type > x)
    {
      this->DatumDefinitionIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::DatumTargetDefinitionIds_optional& PartAssemblyBaseType::
    DatumTargetDefinitionIds () const
    {
      return this->DatumTargetDefinitionIds_;
    }

    PartAssemblyBaseType::DatumTargetDefinitionIds_optional& PartAssemblyBaseType::
    DatumTargetDefinitionIds ()
    {
      return this->DatumTargetDefinitionIds_;
    }

    void PartAssemblyBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_type& x)
    {
      this->DatumTargetDefinitionIds_.set (x);
    }

    void PartAssemblyBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_optional& x)
    {
      this->DatumTargetDefinitionIds_ = x;
    }

    void PartAssemblyBaseType::
    DatumTargetDefinitionIds (::std::unique_ptr< DatumTargetDefinitionIds_type > x)
    {
      this->DatumTargetDefinitionIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::DatumReferenceFrameIds_optional& PartAssemblyBaseType::
    DatumReferenceFrameIds () const
    {
      return this->DatumReferenceFrameIds_;
    }

    PartAssemblyBaseType::DatumReferenceFrameIds_optional& PartAssemblyBaseType::
    DatumReferenceFrameIds ()
    {
      return this->DatumReferenceFrameIds_;
    }

    void PartAssemblyBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_type& x)
    {
      this->DatumReferenceFrameIds_.set (x);
    }

    void PartAssemblyBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_optional& x)
    {
      this->DatumReferenceFrameIds_ = x;
    }

    void PartAssemblyBaseType::
    DatumReferenceFrameIds (::std::unique_ptr< DatumReferenceFrameIds_type > x)
    {
      this->DatumReferenceFrameIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::BodyIds_optional& PartAssemblyBaseType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    PartAssemblyBaseType::BodyIds_optional& PartAssemblyBaseType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void PartAssemblyBaseType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void PartAssemblyBaseType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void PartAssemblyBaseType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::CoordinateSystemIds_optional& PartAssemblyBaseType::
    CoordinateSystemIds () const
    {
      return this->CoordinateSystemIds_;
    }

    PartAssemblyBaseType::CoordinateSystemIds_optional& PartAssemblyBaseType::
    CoordinateSystemIds ()
    {
      return this->CoordinateSystemIds_;
    }

    void PartAssemblyBaseType::
    CoordinateSystemIds (const CoordinateSystemIds_type& x)
    {
      this->CoordinateSystemIds_.set (x);
    }

    void PartAssemblyBaseType::
    CoordinateSystemIds (const CoordinateSystemIds_optional& x)
    {
      this->CoordinateSystemIds_ = x;
    }

    void PartAssemblyBaseType::
    CoordinateSystemIds (::std::unique_ptr< CoordinateSystemIds_type > x)
    {
      this->CoordinateSystemIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::AuxiliaryIds_optional& PartAssemblyBaseType::
    AuxiliaryIds () const
    {
      return this->AuxiliaryIds_;
    }

    PartAssemblyBaseType::AuxiliaryIds_optional& PartAssemblyBaseType::
    AuxiliaryIds ()
    {
      return this->AuxiliaryIds_;
    }

    void PartAssemblyBaseType::
    AuxiliaryIds (const AuxiliaryIds_type& x)
    {
      this->AuxiliaryIds_.set (x);
    }

    void PartAssemblyBaseType::
    AuxiliaryIds (const AuxiliaryIds_optional& x)
    {
      this->AuxiliaryIds_ = x;
    }

    void PartAssemblyBaseType::
    AuxiliaryIds (::std::unique_ptr< AuxiliaryIds_type > x)
    {
      this->AuxiliaryIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::ViewIds_optional& PartAssemblyBaseType::
    ViewIds () const
    {
      return this->ViewIds_;
    }

    PartAssemblyBaseType::ViewIds_optional& PartAssemblyBaseType::
    ViewIds ()
    {
      return this->ViewIds_;
    }

    void PartAssemblyBaseType::
    ViewIds (const ViewIds_type& x)
    {
      this->ViewIds_.set (x);
    }

    void PartAssemblyBaseType::
    ViewIds (const ViewIds_optional& x)
    {
      this->ViewIds_ = x;
    }

    void PartAssemblyBaseType::
    ViewIds (::std::unique_ptr< ViewIds_type > x)
    {
      this->ViewIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::PointCloudIds_optional& PartAssemblyBaseType::
    PointCloudIds () const
    {
      return this->PointCloudIds_;
    }

    PartAssemblyBaseType::PointCloudIds_optional& PartAssemblyBaseType::
    PointCloudIds ()
    {
      return this->PointCloudIds_;
    }

    void PartAssemblyBaseType::
    PointCloudIds (const PointCloudIds_type& x)
    {
      this->PointCloudIds_.set (x);
    }

    void PartAssemblyBaseType::
    PointCloudIds (const PointCloudIds_optional& x)
    {
      this->PointCloudIds_ = x;
    }

    void PartAssemblyBaseType::
    PointCloudIds (::std::unique_ptr< PointCloudIds_type > x)
    {
      this->PointCloudIds_.set (std::move (x));
    }

    const PartAssemblyBaseType::originMassProperty_optional& PartAssemblyBaseType::
    originMassProperty () const
    {
      return this->originMassProperty_;
    }

    PartAssemblyBaseType::originMassProperty_optional& PartAssemblyBaseType::
    originMassProperty ()
    {
      return this->originMassProperty_;
    }

    void PartAssemblyBaseType::
    originMassProperty (const originMassProperty_type& x)
    {
      this->originMassProperty_.set (x);
    }

    void PartAssemblyBaseType::
    originMassProperty (const originMassProperty_optional& x)
    {
      this->originMassProperty_ = x;
    }

    void PartAssemblyBaseType::
    originMassProperty (::std::unique_ptr< originMassProperty_type > x)
    {
      this->originMassProperty_.set (std::move (x));
    }

    const PartAssemblyBaseType::materialIndex_optional& PartAssemblyBaseType::
    materialIndex () const
    {
      return this->materialIndex_;
    }

    PartAssemblyBaseType::materialIndex_optional& PartAssemblyBaseType::
    materialIndex ()
    {
      return this->materialIndex_;
    }

    void PartAssemblyBaseType::
    materialIndex (const materialIndex_type& x)
    {
      this->materialIndex_.set (x);
    }

    void PartAssemblyBaseType::
    materialIndex (const materialIndex_optional& x)
    {
      this->materialIndex_ = x;
    }

    void PartAssemblyBaseType::
    materialIndex (::std::unique_ptr< materialIndex_type > x)
    {
      this->materialIndex_.set (std::move (x));
    }


    // PartType
    //

    const PartType::DefinitionExternal_optional& PartType::
    DefinitionExternal () const
    {
      return this->DefinitionExternal_;
    }

    PartType::DefinitionExternal_optional& PartType::
    DefinitionExternal ()
    {
      return this->DefinitionExternal_;
    }

    void PartType::
    DefinitionExternal (const DefinitionExternal_type& x)
    {
      this->DefinitionExternal_.set (x);
    }

    void PartType::
    DefinitionExternal (const DefinitionExternal_optional& x)
    {
      this->DefinitionExternal_ = x;
    }

    void PartType::
    DefinitionExternal (::std::unique_ptr< DefinitionExternal_type > x)
    {
      this->DefinitionExternal_.set (std::move (x));
    }

    const PartType::PartFamily_optional& PartType::
    PartFamily () const
    {
      return this->PartFamily_;
    }

    PartType::PartFamily_optional& PartType::
    PartFamily ()
    {
      return this->PartFamily_;
    }

    void PartType::
    PartFamily (const PartFamily_type& x)
    {
      this->PartFamily_.set (x);
    }

    void PartType::
    PartFamily (const PartFamily_optional& x)
    {
      this->PartFamily_ = x;
    }

    void PartType::
    PartFamily (::std::unique_ptr< PartFamily_type > x)
    {
      this->PartFamily_.set (std::move (x));
    }

    const PartType::FoldersPart_optional& PartType::
    FoldersPart () const
    {
      return this->FoldersPart_;
    }

    PartType::FoldersPart_optional& PartType::
    FoldersPart ()
    {
      return this->FoldersPart_;
    }

    void PartType::
    FoldersPart (const FoldersPart_type& x)
    {
      this->FoldersPart_.set (x);
    }

    void PartType::
    FoldersPart (const FoldersPart_optional& x)
    {
      this->FoldersPart_ = x;
    }

    void PartType::
    FoldersPart (::std::unique_ptr< FoldersPart_type > x)
    {
      this->FoldersPart_.set (std::move (x));
    }


    // FoldersPartType
    //

    const FoldersPartType::FolderPart_sequence& FoldersPartType::
    FolderPart () const
    {
      return this->FolderPart_;
    }

    FoldersPartType::FolderPart_sequence& FoldersPartType::
    FolderPart ()
    {
      return this->FolderPart_;
    }

    void FoldersPartType::
    FolderPart (const FolderPart_sequence& s)
    {
      this->FolderPart_ = s;
    }

    const FoldersPartType::n_type& FoldersPartType::
    n () const
    {
      return this->n_.get ();
    }

    FoldersPartType::n_type& FoldersPartType::
    n ()
    {
      return this->n_.get ();
    }

    void FoldersPartType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FoldersPartType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FoldersAssemblyType
    //

    const FoldersAssemblyType::FolderAssembly_sequence& FoldersAssemblyType::
    FolderAssembly () const
    {
      return this->FolderAssembly_;
    }

    FoldersAssemblyType::FolderAssembly_sequence& FoldersAssemblyType::
    FolderAssembly ()
    {
      return this->FolderAssembly_;
    }

    void FoldersAssemblyType::
    FolderAssembly (const FolderAssembly_sequence& s)
    {
      this->FolderAssembly_ = s;
    }

    const FoldersAssemblyType::n_type& FoldersAssemblyType::
    n () const
    {
      return this->n_.get ();
    }

    FoldersAssemblyType::n_type& FoldersAssemblyType::
    n ()
    {
      return this->n_.get ();
    }

    void FoldersAssemblyType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FoldersAssemblyType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FolderPartAssemblyBaseType
    //

    const FolderPartAssemblyBaseType::FolderIds_optional& FolderPartAssemblyBaseType::
    FolderIds () const
    {
      return this->FolderIds_;
    }

    FolderPartAssemblyBaseType::FolderIds_optional& FolderPartAssemblyBaseType::
    FolderIds ()
    {
      return this->FolderIds_;
    }

    void FolderPartAssemblyBaseType::
    FolderIds (const FolderIds_type& x)
    {
      this->FolderIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    FolderIds (const FolderIds_optional& x)
    {
      this->FolderIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    FolderIds (::std::unique_ptr< FolderIds_type > x)
    {
      this->FolderIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::FeatureNominalIds_optional& FolderPartAssemblyBaseType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_;
    }

    FolderPartAssemblyBaseType::FeatureNominalIds_optional& FolderPartAssemblyBaseType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_;
    }

    void FolderPartAssemblyBaseType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    FeatureNominalIds (const FeatureNominalIds_optional& x)
    {
      this->FeatureNominalIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::FeatureZoneIds_optional& FolderPartAssemblyBaseType::
    FeatureZoneIds () const
    {
      return this->FeatureZoneIds_;
    }

    FolderPartAssemblyBaseType::FeatureZoneIds_optional& FolderPartAssemblyBaseType::
    FeatureZoneIds ()
    {
      return this->FeatureZoneIds_;
    }

    void FolderPartAssemblyBaseType::
    FeatureZoneIds (const FeatureZoneIds_type& x)
    {
      this->FeatureZoneIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    FeatureZoneIds (const FeatureZoneIds_optional& x)
    {
      this->FeatureZoneIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > x)
    {
      this->FeatureZoneIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::CharacteristicNominalIds_optional& FolderPartAssemblyBaseType::
    CharacteristicNominalIds () const
    {
      return this->CharacteristicNominalIds_;
    }

    FolderPartAssemblyBaseType::CharacteristicNominalIds_optional& FolderPartAssemblyBaseType::
    CharacteristicNominalIds ()
    {
      return this->CharacteristicNominalIds_;
    }

    void FolderPartAssemblyBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_type& x)
    {
      this->CharacteristicNominalIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_optional& x)
    {
      this->CharacteristicNominalIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    CharacteristicNominalIds (::std::unique_ptr< CharacteristicNominalIds_type > x)
    {
      this->CharacteristicNominalIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::NoteIds_optional& FolderPartAssemblyBaseType::
    NoteIds () const
    {
      return this->NoteIds_;
    }

    FolderPartAssemblyBaseType::NoteIds_optional& FolderPartAssemblyBaseType::
    NoteIds ()
    {
      return this->NoteIds_;
    }

    void FolderPartAssemblyBaseType::
    NoteIds (const NoteIds_type& x)
    {
      this->NoteIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    NoteIds (const NoteIds_optional& x)
    {
      this->NoteIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    NoteIds (::std::unique_ptr< NoteIds_type > x)
    {
      this->NoteIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::PartNoteIds_optional& FolderPartAssemblyBaseType::
    PartNoteIds () const
    {
      return this->PartNoteIds_;
    }

    FolderPartAssemblyBaseType::PartNoteIds_optional& FolderPartAssemblyBaseType::
    PartNoteIds ()
    {
      return this->PartNoteIds_;
    }

    void FolderPartAssemblyBaseType::
    PartNoteIds (const PartNoteIds_type& x)
    {
      this->PartNoteIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    PartNoteIds (const PartNoteIds_optional& x)
    {
      this->PartNoteIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    PartNoteIds (::std::unique_ptr< PartNoteIds_type > x)
    {
      this->PartNoteIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::DatumDefinitionIds_optional& FolderPartAssemblyBaseType::
    DatumDefinitionIds () const
    {
      return this->DatumDefinitionIds_;
    }

    FolderPartAssemblyBaseType::DatumDefinitionIds_optional& FolderPartAssemblyBaseType::
    DatumDefinitionIds ()
    {
      return this->DatumDefinitionIds_;
    }

    void FolderPartAssemblyBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_type& x)
    {
      this->DatumDefinitionIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_optional& x)
    {
      this->DatumDefinitionIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    DatumDefinitionIds (::std::unique_ptr< DatumDefinitionIds_type > x)
    {
      this->DatumDefinitionIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::DatumTargetDefinitionIds_optional& FolderPartAssemblyBaseType::
    DatumTargetDefinitionIds () const
    {
      return this->DatumTargetDefinitionIds_;
    }

    FolderPartAssemblyBaseType::DatumTargetDefinitionIds_optional& FolderPartAssemblyBaseType::
    DatumTargetDefinitionIds ()
    {
      return this->DatumTargetDefinitionIds_;
    }

    void FolderPartAssemblyBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_type& x)
    {
      this->DatumTargetDefinitionIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_optional& x)
    {
      this->DatumTargetDefinitionIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    DatumTargetDefinitionIds (::std::unique_ptr< DatumTargetDefinitionIds_type > x)
    {
      this->DatumTargetDefinitionIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::DatumReferenceFrameIds_optional& FolderPartAssemblyBaseType::
    DatumReferenceFrameIds () const
    {
      return this->DatumReferenceFrameIds_;
    }

    FolderPartAssemblyBaseType::DatumReferenceFrameIds_optional& FolderPartAssemblyBaseType::
    DatumReferenceFrameIds ()
    {
      return this->DatumReferenceFrameIds_;
    }

    void FolderPartAssemblyBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_type& x)
    {
      this->DatumReferenceFrameIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_optional& x)
    {
      this->DatumReferenceFrameIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    DatumReferenceFrameIds (::std::unique_ptr< DatumReferenceFrameIds_type > x)
    {
      this->DatumReferenceFrameIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::BodyIds_optional& FolderPartAssemblyBaseType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    FolderPartAssemblyBaseType::BodyIds_optional& FolderPartAssemblyBaseType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void FolderPartAssemblyBaseType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    BodyIds (::std::unique_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::CoordinateSystemIds_optional& FolderPartAssemblyBaseType::
    CoordinateSystemIds () const
    {
      return this->CoordinateSystemIds_;
    }

    FolderPartAssemblyBaseType::CoordinateSystemIds_optional& FolderPartAssemblyBaseType::
    CoordinateSystemIds ()
    {
      return this->CoordinateSystemIds_;
    }

    void FolderPartAssemblyBaseType::
    CoordinateSystemIds (const CoordinateSystemIds_type& x)
    {
      this->CoordinateSystemIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    CoordinateSystemIds (const CoordinateSystemIds_optional& x)
    {
      this->CoordinateSystemIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    CoordinateSystemIds (::std::unique_ptr< CoordinateSystemIds_type > x)
    {
      this->CoordinateSystemIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::AuxiliaryIds_optional& FolderPartAssemblyBaseType::
    AuxiliaryIds () const
    {
      return this->AuxiliaryIds_;
    }

    FolderPartAssemblyBaseType::AuxiliaryIds_optional& FolderPartAssemblyBaseType::
    AuxiliaryIds ()
    {
      return this->AuxiliaryIds_;
    }

    void FolderPartAssemblyBaseType::
    AuxiliaryIds (const AuxiliaryIds_type& x)
    {
      this->AuxiliaryIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    AuxiliaryIds (const AuxiliaryIds_optional& x)
    {
      this->AuxiliaryIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    AuxiliaryIds (::std::unique_ptr< AuxiliaryIds_type > x)
    {
      this->AuxiliaryIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::ViewIds_optional& FolderPartAssemblyBaseType::
    ViewIds () const
    {
      return this->ViewIds_;
    }

    FolderPartAssemblyBaseType::ViewIds_optional& FolderPartAssemblyBaseType::
    ViewIds ()
    {
      return this->ViewIds_;
    }

    void FolderPartAssemblyBaseType::
    ViewIds (const ViewIds_type& x)
    {
      this->ViewIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    ViewIds (const ViewIds_optional& x)
    {
      this->ViewIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    ViewIds (::std::unique_ptr< ViewIds_type > x)
    {
      this->ViewIds_.set (std::move (x));
    }

    const FolderPartAssemblyBaseType::PointCloudIds_optional& FolderPartAssemblyBaseType::
    PointCloudIds () const
    {
      return this->PointCloudIds_;
    }

    FolderPartAssemblyBaseType::PointCloudIds_optional& FolderPartAssemblyBaseType::
    PointCloudIds ()
    {
      return this->PointCloudIds_;
    }

    void FolderPartAssemblyBaseType::
    PointCloudIds (const PointCloudIds_type& x)
    {
      this->PointCloudIds_.set (x);
    }

    void FolderPartAssemblyBaseType::
    PointCloudIds (const PointCloudIds_optional& x)
    {
      this->PointCloudIds_ = x;
    }

    void FolderPartAssemblyBaseType::
    PointCloudIds (::std::unique_ptr< PointCloudIds_type > x)
    {
      this->PointCloudIds_.set (std::move (x));
    }


    // FolderPartType
    //


    // FolderAssemblyType
    //

    const FolderAssemblyType::ComponentIds_type& FolderAssemblyType::
    ComponentIds () const
    {
      return this->ComponentIds_.get ();
    }

    FolderAssemblyType::ComponentIds_type& FolderAssemblyType::
    ComponentIds ()
    {
      return this->ComponentIds_.get ();
    }

    void FolderAssemblyType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void FolderAssemblyType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }


    // AssemblyType
    //

    const AssemblyType::ComponentIds_type& AssemblyType::
    ComponentIds () const
    {
      return this->ComponentIds_.get ();
    }

    AssemblyType::ComponentIds_type& AssemblyType::
    ComponentIds ()
    {
      return this->ComponentIds_.get ();
    }

    void AssemblyType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void AssemblyType::
    ComponentIds (::std::unique_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (std::move (x));
    }

    const AssemblyType::DefinitionExternal_optional& AssemblyType::
    DefinitionExternal () const
    {
      return this->DefinitionExternal_;
    }

    AssemblyType::DefinitionExternal_optional& AssemblyType::
    DefinitionExternal ()
    {
      return this->DefinitionExternal_;
    }

    void AssemblyType::
    DefinitionExternal (const DefinitionExternal_type& x)
    {
      this->DefinitionExternal_.set (x);
    }

    void AssemblyType::
    DefinitionExternal (const DefinitionExternal_optional& x)
    {
      this->DefinitionExternal_ = x;
    }

    void AssemblyType::
    DefinitionExternal (::std::unique_ptr< DefinitionExternal_type > x)
    {
      this->DefinitionExternal_.set (std::move (x));
    }

    const AssemblyType::FoldersAssembly_optional& AssemblyType::
    FoldersAssembly () const
    {
      return this->FoldersAssembly_;
    }

    AssemblyType::FoldersAssembly_optional& AssemblyType::
    FoldersAssembly ()
    {
      return this->FoldersAssembly_;
    }

    void AssemblyType::
    FoldersAssembly (const FoldersAssembly_type& x)
    {
      this->FoldersAssembly_.set (x);
    }

    void AssemblyType::
    FoldersAssembly (const FoldersAssembly_optional& x)
    {
      this->FoldersAssembly_ = x;
    }

    void AssemblyType::
    FoldersAssembly (::std::unique_ptr< FoldersAssembly_type > x)
    {
      this->FoldersAssembly_.set (std::move (x));
    }


    // PartFamilyType
    //

    const PartFamilyType::PrimaryShapeClass_optional& PartFamilyType::
    PrimaryShapeClass () const
    {
      return this->PrimaryShapeClass_;
    }

    PartFamilyType::PrimaryShapeClass_optional& PartFamilyType::
    PrimaryShapeClass ()
    {
      return this->PrimaryShapeClass_;
    }

    void PartFamilyType::
    PrimaryShapeClass (const PrimaryShapeClass_type& x)
    {
      this->PrimaryShapeClass_.set (x);
    }

    void PartFamilyType::
    PrimaryShapeClass (const PrimaryShapeClass_optional& x)
    {
      this->PrimaryShapeClass_ = x;
    }

    void PartFamilyType::
    PrimaryShapeClass (::std::unique_ptr< PrimaryShapeClass_type > x)
    {
      this->PrimaryShapeClass_.set (std::move (x));
    }

    const PartFamilyType::MinimumTolerance_optional& PartFamilyType::
    MinimumTolerance () const
    {
      return this->MinimumTolerance_;
    }

    PartFamilyType::MinimumTolerance_optional& PartFamilyType::
    MinimumTolerance ()
    {
      return this->MinimumTolerance_;
    }

    void PartFamilyType::
    MinimumTolerance (const MinimumTolerance_type& x)
    {
      this->MinimumTolerance_.set (x);
    }

    void PartFamilyType::
    MinimumTolerance (const MinimumTolerance_optional& x)
    {
      this->MinimumTolerance_ = x;
    }

    void PartFamilyType::
    MinimumTolerance (::std::unique_ptr< MinimumTolerance_type > x)
    {
      this->MinimumTolerance_.set (std::move (x));
    }

    const PartFamilyType::MinimumBoundingBox_optional& PartFamilyType::
    MinimumBoundingBox () const
    {
      return this->MinimumBoundingBox_;
    }

    PartFamilyType::MinimumBoundingBox_optional& PartFamilyType::
    MinimumBoundingBox ()
    {
      return this->MinimumBoundingBox_;
    }

    void PartFamilyType::
    MinimumBoundingBox (const MinimumBoundingBox_type& x)
    {
      this->MinimumBoundingBox_.set (x);
    }

    void PartFamilyType::
    MinimumBoundingBox (const MinimumBoundingBox_optional& x)
    {
      this->MinimumBoundingBox_ = x;
    }

    void PartFamilyType::
    MinimumBoundingBox (::std::unique_ptr< MinimumBoundingBox_type > x)
    {
      this->MinimumBoundingBox_.set (std::move (x));
    }

    const PartFamilyType::PrimaryManufacturingMethod_optional& PartFamilyType::
    PrimaryManufacturingMethod () const
    {
      return this->PrimaryManufacturingMethod_;
    }

    PartFamilyType::PrimaryManufacturingMethod_optional& PartFamilyType::
    PrimaryManufacturingMethod ()
    {
      return this->PrimaryManufacturingMethod_;
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (const PrimaryManufacturingMethod_type& x)
    {
      this->PrimaryManufacturingMethod_.set (x);
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (const PrimaryManufacturingMethod_optional& x)
    {
      this->PrimaryManufacturingMethod_ = x;
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (::std::unique_ptr< PrimaryManufacturingMethod_type > x)
    {
      this->PrimaryManufacturingMethod_.set (std::move (x));
    }


    // PartSetType
    //

    const PartSetType::Part_sequence& PartSetType::
    Part () const
    {
      return this->Part_;
    }

    PartSetType::Part_sequence& PartSetType::
    Part ()
    {
      return this->Part_;
    }

    void PartSetType::
    Part (const Part_sequence& s)
    {
      this->Part_ = s;
    }

    const PartSetType::n_type& PartSetType::
    n () const
    {
      return this->n_.get ();
    }

    PartSetType::n_type& PartSetType::
    n ()
    {
      return this->n_.get ();
    }

    void PartSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PartSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AssemblySetType
    //

    const AssemblySetType::Assembly_sequence& AssemblySetType::
    Assembly () const
    {
      return this->Assembly_;
    }

    AssemblySetType::Assembly_sequence& AssemblySetType::
    Assembly ()
    {
      return this->Assembly_;
    }

    void AssemblySetType::
    Assembly (const Assembly_sequence& s)
    {
      this->Assembly_ = s;
    }

    const AssemblySetType::n_type& AssemblySetType::
    n () const
    {
      return this->n_.get ();
    }

    AssemblySetType::n_type& AssemblySetType::
    n ()
    {
      return this->n_.get ();
    }

    void AssemblySetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AssemblySetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ComponentType
    //

    const ComponentType::Transform_optional& ComponentType::
    Transform () const
    {
      return this->Transform_;
    }

    ComponentType::Transform_optional& ComponentType::
    Transform ()
    {
      return this->Transform_;
    }

    void ComponentType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ComponentType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ComponentType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const ComponentType::UUID_optional& ComponentType::
    UUID () const
    {
      return this->UUID_;
    }

    ComponentType::UUID_optional& ComponentType::
    UUID ()
    {
      return this->UUID_;
    }

    void ComponentType::
    UUID (const UUID_type& x)
    {
      this->UUID_.set (x);
    }

    void ComponentType::
    UUID (const UUID_optional& x)
    {
      this->UUID_ = x;
    }

    void ComponentType::
    UUID (::std::unique_ptr< UUID_type > x)
    {
      this->UUID_.set (std::move (x));
    }

    const ComponentType::Traceability_optional& ComponentType::
    Traceability () const
    {
      return this->Traceability_;
    }

    ComponentType::Traceability_optional& ComponentType::
    Traceability ()
    {
      return this->Traceability_;
    }

    void ComponentType::
    Traceability (const Traceability_type& x)
    {
      this->Traceability_.set (x);
    }

    void ComponentType::
    Traceability (const Traceability_optional& x)
    {
      this->Traceability_ = x;
    }

    void ComponentType::
    Traceability (::std::unique_ptr< Traceability_type > x)
    {
      this->Traceability_.set (std::move (x));
    }

    const ComponentType::Part_optional& ComponentType::
    Part () const
    {
      return this->Part_;
    }

    ComponentType::Part_optional& ComponentType::
    Part ()
    {
      return this->Part_;
    }

    void ComponentType::
    Part (const Part_type& x)
    {
      this->Part_.set (x);
    }

    void ComponentType::
    Part (const Part_optional& x)
    {
      this->Part_ = x;
    }

    void ComponentType::
    Part (::std::unique_ptr< Part_type > x)
    {
      this->Part_.set (std::move (x));
    }

    const ComponentType::Assembly_optional& ComponentType::
    Assembly () const
    {
      return this->Assembly_;
    }

    ComponentType::Assembly_optional& ComponentType::
    Assembly ()
    {
      return this->Assembly_;
    }

    void ComponentType::
    Assembly (const Assembly_type& x)
    {
      this->Assembly_.set (x);
    }

    void ComponentType::
    Assembly (const Assembly_optional& x)
    {
      this->Assembly_ = x;
    }

    void ComponentType::
    Assembly (::std::unique_ptr< Assembly_type > x)
    {
      this->Assembly_.set (std::move (x));
    }


    // ComponentSetType
    //

    const ComponentSetType::Component_sequence& ComponentSetType::
    Component () const
    {
      return this->Component_;
    }

    ComponentSetType::Component_sequence& ComponentSetType::
    Component ()
    {
      return this->Component_;
    }

    void ComponentSetType::
    Component (const Component_sequence& s)
    {
      this->Component_ = s;
    }

    const ComponentSetType::n_type& ComponentSetType::
    n () const
    {
      return this->n_.get ();
    }

    ComponentSetType::n_type& ComponentSetType::
    n ()
    {
      return this->n_.get ();
    }

    void ComponentSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ComponentSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PrintedDrawingType
    //

    const PrintedDrawingType::Name_type& PrintedDrawingType::
    Name () const
    {
      return this->Name_.get ();
    }

    PrintedDrawingType::Name_type& PrintedDrawingType::
    Name ()
    {
      return this->Name_.get ();
    }

    void PrintedDrawingType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PrintedDrawingType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const PrintedDrawingType::Version_optional& PrintedDrawingType::
    Version () const
    {
      return this->Version_;
    }

    PrintedDrawingType::Version_optional& PrintedDrawingType::
    Version ()
    {
      return this->Version_;
    }

    void PrintedDrawingType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PrintedDrawingType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PrintedDrawingType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const PrintedDrawingType::Description_optional& PrintedDrawingType::
    Description () const
    {
      return this->Description_;
    }

    PrintedDrawingType::Description_optional& PrintedDrawingType::
    Description ()
    {
      return this->Description_;
    }

    void PrintedDrawingType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PrintedDrawingType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PrintedDrawingType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const PrintedDrawingType::Author_optional& PrintedDrawingType::
    Author () const
    {
      return this->Author_;
    }

    PrintedDrawingType::Author_optional& PrintedDrawingType::
    Author ()
    {
      return this->Author_;
    }

    void PrintedDrawingType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void PrintedDrawingType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void PrintedDrawingType::
    Author (::std::unique_ptr< Author_type > x)
    {
      this->Author_.set (std::move (x));
    }

    const PrintedDrawingType::DrawingNumber_optional& PrintedDrawingType::
    DrawingNumber () const
    {
      return this->DrawingNumber_;
    }

    PrintedDrawingType::DrawingNumber_optional& PrintedDrawingType::
    DrawingNumber ()
    {
      return this->DrawingNumber_;
    }

    void PrintedDrawingType::
    DrawingNumber (const DrawingNumber_type& x)
    {
      this->DrawingNumber_.set (x);
    }

    void PrintedDrawingType::
    DrawingNumber (const DrawingNumber_optional& x)
    {
      this->DrawingNumber_ = x;
    }

    void PrintedDrawingType::
    DrawingNumber (::std::unique_ptr< DrawingNumber_type > x)
    {
      this->DrawingNumber_.set (std::move (x));
    }

    const PrintedDrawingType::AdditionalChanges_optional& PrintedDrawingType::
    AdditionalChanges () const
    {
      return this->AdditionalChanges_;
    }

    PrintedDrawingType::AdditionalChanges_optional& PrintedDrawingType::
    AdditionalChanges ()
    {
      return this->AdditionalChanges_;
    }

    void PrintedDrawingType::
    AdditionalChanges (const AdditionalChanges_type& x)
    {
      this->AdditionalChanges_.set (x);
    }

    void PrintedDrawingType::
    AdditionalChanges (const AdditionalChanges_optional& x)
    {
      this->AdditionalChanges_ = x;
    }

    void PrintedDrawingType::
    AdditionalChanges (::std::unique_ptr< AdditionalChanges_type > x)
    {
      this->AdditionalChanges_.set (std::move (x));
    }

    const PrintedDrawingType::Location_optional& PrintedDrawingType::
    Location () const
    {
      return this->Location_;
    }

    PrintedDrawingType::Location_optional& PrintedDrawingType::
    Location ()
    {
      return this->Location_;
    }

    void PrintedDrawingType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PrintedDrawingType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PrintedDrawingType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PrintedDrawingType::id_type& PrintedDrawingType::
    id () const
    {
      return this->id_.get ();
    }

    PrintedDrawingType::id_type& PrintedDrawingType::
    id ()
    {
      return this->id_.get ();
    }

    void PrintedDrawingType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PrintedDrawingType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // GDTEnumType
    //

    GDTEnumType::
    GDTEnumType ()
    : ::xml_schema::string ()
    {
    }

    GDTEnumType::
    GDTEnumType (value v)
    : ::xml_schema::string (_xsd_GDTEnumType_literals_[v])
    {
    }

    GDTEnumType::
    GDTEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const GDTEnumType& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    GDTEnumType& GDTEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_GDTEnumType_literals_[v]);

      return *this;
    }


    // TopologyEnumType
    //

    TopologyEnumType::
    TopologyEnumType ()
    : ::xml_schema::string ()
    {
    }

    TopologyEnumType::
    TopologyEnumType (value v)
    : ::xml_schema::string (_xsd_TopologyEnumType_literals_[v])
    {
    }

    TopologyEnumType::
    TopologyEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const TopologyEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    TopologyEnumType& TopologyEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_TopologyEnumType_literals_[v]);

      return *this;
    }


    // DigitalModelType
    //

    const DigitalModelType::Name_type& DigitalModelType::
    Name () const
    {
      return this->Name_.get ();
    }

    DigitalModelType::Name_type& DigitalModelType::
    Name ()
    {
      return this->Name_.get ();
    }

    void DigitalModelType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DigitalModelType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const DigitalModelType::File_type& DigitalModelType::
    File () const
    {
      return this->File_.get ();
    }

    DigitalModelType::File_type& DigitalModelType::
    File ()
    {
      return this->File_.get ();
    }

    void DigitalModelType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void DigitalModelType::
    File (::std::unique_ptr< File_type > x)
    {
      this->File_.set (std::move (x));
    }

    const DigitalModelType::Application_optional& DigitalModelType::
    Application () const
    {
      return this->Application_;
    }

    DigitalModelType::Application_optional& DigitalModelType::
    Application ()
    {
      return this->Application_;
    }

    void DigitalModelType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void DigitalModelType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void DigitalModelType::
    Application (::std::unique_ptr< Application_type > x)
    {
      this->Application_.set (std::move (x));
    }

    const DigitalModelType::Author_optional& DigitalModelType::
    Author () const
    {
      return this->Author_;
    }

    DigitalModelType::Author_optional& DigitalModelType::
    Author ()
    {
      return this->Author_;
    }

    void DigitalModelType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void DigitalModelType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void DigitalModelType::
    Author (::std::unique_ptr< Author_type > x)
    {
      this->Author_.set (std::move (x));
    }

    const DigitalModelType::ApplicationSource_optional& DigitalModelType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    DigitalModelType::ApplicationSource_optional& DigitalModelType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void DigitalModelType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void DigitalModelType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void DigitalModelType::
    ApplicationSource (::std::unique_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (std::move (x));
    }

    const DigitalModelType::Description_optional& DigitalModelType::
    Description () const
    {
      return this->Description_;
    }

    DigitalModelType::Description_optional& DigitalModelType::
    Description ()
    {
      return this->Description_;
    }

    void DigitalModelType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DigitalModelType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DigitalModelType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const DigitalModelType::Units_optional& DigitalModelType::
    Units () const
    {
      return this->Units_;
    }

    DigitalModelType::Units_optional& DigitalModelType::
    Units ()
    {
      return this->Units_;
    }

    void DigitalModelType::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void DigitalModelType::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void DigitalModelType::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const DigitalModelType::GDT_optional& DigitalModelType::
    GDT () const
    {
      return this->GDT_;
    }

    DigitalModelType::GDT_optional& DigitalModelType::
    GDT ()
    {
      return this->GDT_;
    }

    void DigitalModelType::
    GDT (const GDT_type& x)
    {
      this->GDT_.set (x);
    }

    void DigitalModelType::
    GDT (const GDT_optional& x)
    {
      this->GDT_ = x;
    }

    void DigitalModelType::
    GDT (::std::unique_ptr< GDT_type > x)
    {
      this->GDT_.set (std::move (x));
    }

    const DigitalModelType::GDT_type& DigitalModelType::
    GDT_default_value ()
    {
      return GDT_default_value_;
    }

    const DigitalModelType::Topology_optional& DigitalModelType::
    Topology () const
    {
      return this->Topology_;
    }

    DigitalModelType::Topology_optional& DigitalModelType::
    Topology ()
    {
      return this->Topology_;
    }

    void DigitalModelType::
    Topology (const Topology_type& x)
    {
      this->Topology_.set (x);
    }

    void DigitalModelType::
    Topology (const Topology_optional& x)
    {
      this->Topology_ = x;
    }

    void DigitalModelType::
    Topology (::std::unique_ptr< Topology_type > x)
    {
      this->Topology_.set (std::move (x));
    }

    const DigitalModelType::Topology_type& DigitalModelType::
    Topology_default_value ()
    {
      return Topology_default_value_;
    }

    const DigitalModelType::Entities_optional& DigitalModelType::
    Entities () const
    {
      return this->Entities_;
    }

    DigitalModelType::Entities_optional& DigitalModelType::
    Entities ()
    {
      return this->Entities_;
    }

    void DigitalModelType::
    Entities (const Entities_type& x)
    {
      this->Entities_.set (x);
    }

    void DigitalModelType::
    Entities (const Entities_optional& x)
    {
      this->Entities_ = x;
    }

    void DigitalModelType::
    Entities (::std::unique_ptr< Entities_type > x)
    {
      this->Entities_.set (std::move (x));
    }

    const DigitalModelType::id_type& DigitalModelType::
    id () const
    {
      return this->id_.get ();
    }

    DigitalModelType::id_type& DigitalModelType::
    id ()
    {
      return this->id_.get ();
    }

    void DigitalModelType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DigitalModelType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // DefinitionExternalType
    //

    const DefinitionExternalType::PrintedDrawing_sequence& DefinitionExternalType::
    PrintedDrawing () const
    {
      return this->PrintedDrawing_;
    }

    DefinitionExternalType::PrintedDrawing_sequence& DefinitionExternalType::
    PrintedDrawing ()
    {
      return this->PrintedDrawing_;
    }

    void DefinitionExternalType::
    PrintedDrawing (const PrintedDrawing_sequence& s)
    {
      this->PrintedDrawing_ = s;
    }

    const DefinitionExternalType::DigitalDrawing_sequence& DefinitionExternalType::
    DigitalDrawing () const
    {
      return this->DigitalDrawing_;
    }

    DefinitionExternalType::DigitalDrawing_sequence& DefinitionExternalType::
    DigitalDrawing ()
    {
      return this->DigitalDrawing_;
    }

    void DefinitionExternalType::
    DigitalDrawing (const DigitalDrawing_sequence& s)
    {
      this->DigitalDrawing_ = s;
    }

    const DefinitionExternalType::DigitalModel_sequence& DefinitionExternalType::
    DigitalModel () const
    {
      return this->DigitalModel_;
    }

    DefinitionExternalType::DigitalModel_sequence& DefinitionExternalType::
    DigitalModel ()
    {
      return this->DigitalModel_;
    }

    void DefinitionExternalType::
    DigitalModel (const DigitalModel_sequence& s)
    {
      this->DigitalModel_ = s;
    }

    const DefinitionExternalType::PhysicalModel_sequence& DefinitionExternalType::
    PhysicalModel () const
    {
      return this->PhysicalModel_;
    }

    DefinitionExternalType::PhysicalModel_sequence& DefinitionExternalType::
    PhysicalModel ()
    {
      return this->PhysicalModel_;
    }

    void DefinitionExternalType::
    PhysicalModel (const PhysicalModel_sequence& s)
    {
      this->PhysicalModel_ = s;
    }

    const DefinitionExternalType::n_type& DefinitionExternalType::
    n () const
    {
      return this->n_.get ();
    }

    DefinitionExternalType::n_type& DefinitionExternalType::
    n ()
    {
      return this->n_.get ();
    }

    void DefinitionExternalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DefinitionExternalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }

    const DefinitionExternalType::id_type& DefinitionExternalType::
    id () const
    {
      return this->id_.get ();
    }

    DefinitionExternalType::id_type& DefinitionExternalType::
    id ()
    {
      return this->id_.get ();
    }

    void DefinitionExternalType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DefinitionExternalType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // DigitalDrawingType
    //

    const DigitalDrawingType::Name_type& DigitalDrawingType::
    Name () const
    {
      return this->Name_.get ();
    }

    DigitalDrawingType::Name_type& DigitalDrawingType::
    Name ()
    {
      return this->Name_.get ();
    }

    void DigitalDrawingType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DigitalDrawingType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const DigitalDrawingType::File_type& DigitalDrawingType::
    File () const
    {
      return this->File_.get ();
    }

    DigitalDrawingType::File_type& DigitalDrawingType::
    File ()
    {
      return this->File_.get ();
    }

    void DigitalDrawingType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void DigitalDrawingType::
    File (::std::unique_ptr< File_type > x)
    {
      this->File_.set (std::move (x));
    }

    const DigitalDrawingType::Application_optional& DigitalDrawingType::
    Application () const
    {
      return this->Application_;
    }

    DigitalDrawingType::Application_optional& DigitalDrawingType::
    Application ()
    {
      return this->Application_;
    }

    void DigitalDrawingType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void DigitalDrawingType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void DigitalDrawingType::
    Application (::std::unique_ptr< Application_type > x)
    {
      this->Application_.set (std::move (x));
    }

    const DigitalDrawingType::Author_optional& DigitalDrawingType::
    Author () const
    {
      return this->Author_;
    }

    DigitalDrawingType::Author_optional& DigitalDrawingType::
    Author ()
    {
      return this->Author_;
    }

    void DigitalDrawingType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void DigitalDrawingType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void DigitalDrawingType::
    Author (::std::unique_ptr< Author_type > x)
    {
      this->Author_.set (std::move (x));
    }

    const DigitalDrawingType::ApplicationSource_optional& DigitalDrawingType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    DigitalDrawingType::ApplicationSource_optional& DigitalDrawingType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void DigitalDrawingType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void DigitalDrawingType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void DigitalDrawingType::
    ApplicationSource (::std::unique_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (std::move (x));
    }

    const DigitalDrawingType::Description_optional& DigitalDrawingType::
    Description () const
    {
      return this->Description_;
    }

    DigitalDrawingType::Description_optional& DigitalDrawingType::
    Description ()
    {
      return this->Description_;
    }

    void DigitalDrawingType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DigitalDrawingType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DigitalDrawingType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const DigitalDrawingType::Entities_optional& DigitalDrawingType::
    Entities () const
    {
      return this->Entities_;
    }

    DigitalDrawingType::Entities_optional& DigitalDrawingType::
    Entities ()
    {
      return this->Entities_;
    }

    void DigitalDrawingType::
    Entities (const Entities_type& x)
    {
      this->Entities_.set (x);
    }

    void DigitalDrawingType::
    Entities (const Entities_optional& x)
    {
      this->Entities_ = x;
    }

    void DigitalDrawingType::
    Entities (::std::unique_ptr< Entities_type > x)
    {
      this->Entities_.set (std::move (x));
    }

    const DigitalDrawingType::id_type& DigitalDrawingType::
    id () const
    {
      return this->id_.get ();
    }

    DigitalDrawingType::id_type& DigitalDrawingType::
    id ()
    {
      return this->id_.get ();
    }

    void DigitalDrawingType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DigitalDrawingType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // PhysicalModelType
    //

    const PhysicalModelType::Name_type& PhysicalModelType::
    Name () const
    {
      return this->Name_.get ();
    }

    PhysicalModelType::Name_type& PhysicalModelType::
    Name ()
    {
      return this->Name_.get ();
    }

    void PhysicalModelType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PhysicalModelType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const PhysicalModelType::Version_optional& PhysicalModelType::
    Version () const
    {
      return this->Version_;
    }

    PhysicalModelType::Version_optional& PhysicalModelType::
    Version ()
    {
      return this->Version_;
    }

    void PhysicalModelType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PhysicalModelType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PhysicalModelType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const PhysicalModelType::Description_optional& PhysicalModelType::
    Description () const
    {
      return this->Description_;
    }

    PhysicalModelType::Description_optional& PhysicalModelType::
    Description ()
    {
      return this->Description_;
    }

    void PhysicalModelType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PhysicalModelType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PhysicalModelType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const PhysicalModelType::Author_optional& PhysicalModelType::
    Author () const
    {
      return this->Author_;
    }

    PhysicalModelType::Author_optional& PhysicalModelType::
    Author ()
    {
      return this->Author_;
    }

    void PhysicalModelType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void PhysicalModelType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void PhysicalModelType::
    Author (::std::unique_ptr< Author_type > x)
    {
      this->Author_.set (std::move (x));
    }

    const PhysicalModelType::Location_optional& PhysicalModelType::
    Location () const
    {
      return this->Location_;
    }

    PhysicalModelType::Location_optional& PhysicalModelType::
    Location ()
    {
      return this->Location_;
    }

    void PhysicalModelType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PhysicalModelType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PhysicalModelType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PhysicalModelType::ModelNumber_optional& PhysicalModelType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    PhysicalModelType::ModelNumber_optional& PhysicalModelType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void PhysicalModelType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void PhysicalModelType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void PhysicalModelType::
    ModelNumber (::std::unique_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const PhysicalModelType::id_type& PhysicalModelType::
    id () const
    {
      return this->id_.get ();
    }

    PhysicalModelType::id_type& PhysicalModelType::
    id ()
    {
      return this->id_.get ();
    }

    void PhysicalModelType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PhysicalModelType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // PartAssemblyHeaderType
    //

    const PartAssemblyHeaderType::Name_optional& PartAssemblyHeaderType::
    Name () const
    {
      return this->Name_;
    }

    PartAssemblyHeaderType::Name_optional& PartAssemblyHeaderType::
    Name ()
    {
      return this->Name_;
    }

    void PartAssemblyHeaderType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PartAssemblyHeaderType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void PartAssemblyHeaderType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const PartAssemblyHeaderType::File_optional& PartAssemblyHeaderType::
    File () const
    {
      return this->File_;
    }

    PartAssemblyHeaderType::File_optional& PartAssemblyHeaderType::
    File ()
    {
      return this->File_;
    }

    void PartAssemblyHeaderType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void PartAssemblyHeaderType::
    File (const File_optional& x)
    {
      this->File_ = x;
    }

    void PartAssemblyHeaderType::
    File (::std::unique_ptr< File_type > x)
    {
      this->File_.set (std::move (x));
    }

    const PartAssemblyHeaderType::Application_optional& PartAssemblyHeaderType::
    Application () const
    {
      return this->Application_;
    }

    PartAssemblyHeaderType::Application_optional& PartAssemblyHeaderType::
    Application ()
    {
      return this->Application_;
    }

    void PartAssemblyHeaderType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void PartAssemblyHeaderType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void PartAssemblyHeaderType::
    Application (::std::unique_ptr< Application_type > x)
    {
      this->Application_.set (std::move (x));
    }

    const PartAssemblyHeaderType::Author_optional& PartAssemblyHeaderType::
    Author () const
    {
      return this->Author_;
    }

    PartAssemblyHeaderType::Author_optional& PartAssemblyHeaderType::
    Author ()
    {
      return this->Author_;
    }

    void PartAssemblyHeaderType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void PartAssemblyHeaderType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void PartAssemblyHeaderType::
    Author (::std::unique_ptr< Author_type > x)
    {
      this->Author_.set (std::move (x));
    }

    const PartAssemblyHeaderType::ApplicationSource_optional& PartAssemblyHeaderType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    PartAssemblyHeaderType::ApplicationSource_optional& PartAssemblyHeaderType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void PartAssemblyHeaderType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void PartAssemblyHeaderType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void PartAssemblyHeaderType::
    ApplicationSource (::std::unique_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (std::move (x));
    }

    const PartAssemblyHeaderType::Description_optional& PartAssemblyHeaderType::
    Description () const
    {
      return this->Description_;
    }

    PartAssemblyHeaderType::Description_optional& PartAssemblyHeaderType::
    Description ()
    {
      return this->Description_;
    }

    void PartAssemblyHeaderType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PartAssemblyHeaderType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PartAssemblyHeaderType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // ProductHeaderType
    //

    const ProductHeaderType::ScaleCoefficient_optional& ProductHeaderType::
    ScaleCoefficient () const
    {
      return this->ScaleCoefficient_;
    }

    ProductHeaderType::ScaleCoefficient_optional& ProductHeaderType::
    ScaleCoefficient ()
    {
      return this->ScaleCoefficient_;
    }

    void ProductHeaderType::
    ScaleCoefficient (const ScaleCoefficient_type& x)
    {
      this->ScaleCoefficient_.set (x);
    }

    void ProductHeaderType::
    ScaleCoefficient (const ScaleCoefficient_optional& x)
    {
      this->ScaleCoefficient_ = x;
    }

    ProductHeaderType::ScaleCoefficient_type ProductHeaderType::
    ScaleCoefficient_default_value ()
    {
      return ScaleCoefficient_type (1.0);
    }

    const ProductHeaderType::ModelTolerance_optional& ProductHeaderType::
    ModelTolerance () const
    {
      return this->ModelTolerance_;
    }

    ProductHeaderType::ModelTolerance_optional& ProductHeaderType::
    ModelTolerance ()
    {
      return this->ModelTolerance_;
    }

    void ProductHeaderType::
    ModelTolerance (const ModelTolerance_type& x)
    {
      this->ModelTolerance_.set (x);
    }

    void ProductHeaderType::
    ModelTolerance (const ModelTolerance_optional& x)
    {
      this->ModelTolerance_ = x;
    }

    const ProductHeaderType::MassPropertyTolerance_optional& ProductHeaderType::
    MassPropertyTolerance () const
    {
      return this->MassPropertyTolerance_;
    }

    ProductHeaderType::MassPropertyTolerance_optional& ProductHeaderType::
    MassPropertyTolerance ()
    {
      return this->MassPropertyTolerance_;
    }

    void ProductHeaderType::
    MassPropertyTolerance (const MassPropertyTolerance_type& x)
    {
      this->MassPropertyTolerance_.set (x);
    }

    void ProductHeaderType::
    MassPropertyTolerance (const MassPropertyTolerance_optional& x)
    {
      this->MassPropertyTolerance_ = x;
    }


    // LayerType
    //

    const LayerType::ElementIds_optional& LayerType::
    ElementIds () const
    {
      return this->ElementIds_;
    }

    LayerType::ElementIds_optional& LayerType::
    ElementIds ()
    {
      return this->ElementIds_;
    }

    void LayerType::
    ElementIds (const ElementIds_type& x)
    {
      this->ElementIds_.set (x);
    }

    void LayerType::
    ElementIds (const ElementIds_optional& x)
    {
      this->ElementIds_ = x;
    }

    void LayerType::
    ElementIds (::std::unique_ptr< ElementIds_type > x)
    {
      this->ElementIds_.set (std::move (x));
    }

    const LayerType::applyColor_type& LayerType::
    applyColor () const
    {
      return this->applyColor_.get ();
    }

    LayerType::applyColor_type& LayerType::
    applyColor ()
    {
      return this->applyColor_.get ();
    }

    void LayerType::
    applyColor (const applyColor_type& x)
    {
      this->applyColor_.set (x);
    }

    LayerType::applyColor_type LayerType::
    applyColor_default_value ()
    {
      return applyColor_type (false);
    }

    const LayerType::index_type& LayerType::
    index () const
    {
      return this->index_.get ();
    }

    LayerType::index_type& LayerType::
    index ()
    {
      return this->index_.get ();
    }

    void LayerType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }


    // LayerSetType
    //

    const LayerSetType::Layer_sequence& LayerSetType::
    Layer () const
    {
      return this->Layer_;
    }

    LayerSetType::Layer_sequence& LayerSetType::
    Layer ()
    {
      return this->Layer_;
    }

    void LayerSetType::
    Layer (const Layer_sequence& s)
    {
      this->Layer_ = s;
    }

    const LayerSetType::n_type& LayerSetType::
    n () const
    {
      return this->n_.get ();
    }

    LayerSetType::n_type& LayerSetType::
    n ()
    {
      return this->n_.get ();
    }

    void LayerSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LayerSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PartNoteSetType
    //

    const PartNoteSetType::PartNote_sequence& PartNoteSetType::
    PartNote () const
    {
      return this->PartNote_;
    }

    PartNoteSetType::PartNote_sequence& PartNoteSetType::
    PartNote ()
    {
      return this->PartNote_;
    }

    void PartNoteSetType::
    PartNote (const PartNote_sequence& s)
    {
      this->PartNote_ = s;
    }

    const PartNoteSetType::n_type& PartNoteSetType::
    n () const
    {
      return this->n_.get ();
    }

    PartNoteSetType::n_type& PartNoteSetType::
    n ()
    {
      return this->n_.get ();
    }

    void PartNoteSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PartNoteSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PartNoteType
    //

    const PartNoteType::Text_optional& PartNoteType::
    Text () const
    {
      return this->Text_;
    }

    PartNoteType::Text_optional& PartNoteType::
    Text ()
    {
      return this->Text_;
    }

    void PartNoteType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void PartNoteType::
    Text (const Text_optional& x)
    {
      this->Text_ = x;
    }

    void PartNoteType::
    Text (::std::unique_ptr< Text_type > x)
    {
      this->Text_.set (std::move (x));
    }

    const PartNoteType::PartNoteIds_optional& PartNoteType::
    PartNoteIds () const
    {
      return this->PartNoteIds_;
    }

    PartNoteType::PartNoteIds_optional& PartNoteType::
    PartNoteIds ()
    {
      return this->PartNoteIds_;
    }

    void PartNoteType::
    PartNoteIds (const PartNoteIds_type& x)
    {
      this->PartNoteIds_.set (x);
    }

    void PartNoteType::
    PartNoteIds (const PartNoteIds_optional& x)
    {
      this->PartNoteIds_ = x;
    }

    void PartNoteType::
    PartNoteIds (::std::unique_ptr< PartNoteIds_type > x)
    {
      this->PartNoteIds_.set (std::move (x));
    }


    // NoteType
    //

    const NoteType::EntityInternalIds_optional& NoteType::
    EntityInternalIds () const
    {
      return this->EntityInternalIds_;
    }

    NoteType::EntityInternalIds_optional& NoteType::
    EntityInternalIds ()
    {
      return this->EntityInternalIds_;
    }

    void NoteType::
    EntityInternalIds (const EntityInternalIds_type& x)
    {
      this->EntityInternalIds_.set (x);
    }

    void NoteType::
    EntityInternalIds (const EntityInternalIds_optional& x)
    {
      this->EntityInternalIds_ = x;
    }

    void NoteType::
    EntityInternalIds (::std::unique_ptr< EntityInternalIds_type > x)
    {
      this->EntityInternalIds_.set (std::move (x));
    }

    const NoteType::EntityExternalIds_optional& NoteType::
    EntityExternalIds () const
    {
      return this->EntityExternalIds_;
    }

    NoteType::EntityExternalIds_optional& NoteType::
    EntityExternalIds ()
    {
      return this->EntityExternalIds_;
    }

    void NoteType::
    EntityExternalIds (const EntityExternalIds_type& x)
    {
      this->EntityExternalIds_.set (x);
    }

    void NoteType::
    EntityExternalIds (const EntityExternalIds_optional& x)
    {
      this->EntityExternalIds_ = x;
    }

    void NoteType::
    EntityExternalIds (::std::unique_ptr< EntityExternalIds_type > x)
    {
      this->EntityExternalIds_.set (std::move (x));
    }

    const NoteType::Text_type& NoteType::
    Text () const
    {
      return this->Text_.get ();
    }

    NoteType::Text_type& NoteType::
    Text ()
    {
      return this->Text_.get ();
    }

    void NoteType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void NoteType::
    Text (::std::unique_ptr< Text_type > x)
    {
      this->Text_.set (std::move (x));
    }

    const NoteType::form_type& NoteType::
    form () const
    {
      return this->form_.get ();
    }

    NoteType::form_type& NoteType::
    form ()
    {
      return this->form_.get ();
    }

    void NoteType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void NoteType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const NoteType::form_type& NoteType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // NoteFormEnumType
    //

    NoteFormEnumType::
    NoteFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (value v)
    : ::xml_schema::string (_xsd_NoteFormEnumType_literals_[v])
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const NoteFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    NoteFormEnumType& NoteFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_NoteFormEnumType_literals_[v]);

      return *this;
    }


    // NoteSetType
    //

    const NoteSetType::Note_sequence& NoteSetType::
    Note () const
    {
      return this->Note_;
    }

    NoteSetType::Note_sequence& NoteSetType::
    Note ()
    {
      return this->Note_;
    }

    void NoteSetType::
    Note (const Note_sequence& s)
    {
      this->Note_ = s;
    }

    const NoteSetType::n_type& NoteSetType::
    n () const
    {
      return this->n_.get ();
    }

    NoteSetType::n_type& NoteSetType::
    n ()
    {
      return this->n_.get ();
    }

    void NoteSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NoteSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // NoteFlagType
    //

    const NoteFlagType::TextHidden_optional& NoteFlagType::
    TextHidden () const
    {
      return this->TextHidden_;
    }

    NoteFlagType::TextHidden_optional& NoteFlagType::
    TextHidden ()
    {
      return this->TextHidden_;
    }

    void NoteFlagType::
    TextHidden (const TextHidden_type& x)
    {
      this->TextHidden_.set (x);
    }

    void NoteFlagType::
    TextHidden (const TextHidden_optional& x)
    {
      this->TextHidden_ = x;
    }

    void NoteFlagType::
    TextHidden (::std::unique_ptr< TextHidden_type > x)
    {
      this->TextHidden_.set (std::move (x));
    }

    const NoteFlagType::URI_optional& NoteFlagType::
    URI () const
    {
      return this->URI_;
    }

    NoteFlagType::URI_optional& NoteFlagType::
    URI ()
    {
      return this->URI_;
    }

    void NoteFlagType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void NoteFlagType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void NoteFlagType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }


    // NoteFlagSetType
    //

    const NoteFlagSetType::NoteFlag_sequence& NoteFlagSetType::
    NoteFlag () const
    {
      return this->NoteFlag_;
    }

    NoteFlagSetType::NoteFlag_sequence& NoteFlagSetType::
    NoteFlag ()
    {
      return this->NoteFlag_;
    }

    void NoteFlagSetType::
    NoteFlag (const NoteFlag_sequence& s)
    {
      this->NoteFlag_ = s;
    }

    const NoteFlagSetType::n_type& NoteFlagSetType::
    n () const
    {
      return this->n_.get ();
    }

    NoteFlagSetType::n_type& NoteFlagSetType::
    n ()
    {
      return this->n_.get ();
    }

    void NoteFlagSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NoteFlagSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FileInternalType
    //

    const FileInternalType::Name_type& FileInternalType::
    Name () const
    {
      return this->Name_.get ();
    }

    FileInternalType::Name_type& FileInternalType::
    Name ()
    {
      return this->Name_.get ();
    }

    void FileInternalType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FileInternalType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const FileInternalType::Version_optional& FileInternalType::
    Version () const
    {
      return this->Version_;
    }

    FileInternalType::Version_optional& FileInternalType::
    Version ()
    {
      return this->Version_;
    }

    void FileInternalType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void FileInternalType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void FileInternalType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // ProductType
    //

    ProductType::
    ProductType ()
    : ::xml_schema::type (),
      Header_ (this),
      GeometrySet_ (this),
      TopologySet_ (this),
      NoteSet_ (this),
      NoteFlagSet_ (this),
      PartNoteSet_ (this),
      ViewSet_ (this),
      LayerSet_ (this),
      CoordinateSystemSet_ (this),
      VisualizationSet_ (this),
      AuxiliarySet_ (this),
      PartSet_ (this),
      AssemblySet_ (this),
      ComponentSet_ (this),
      RootPart_ (this),
      RootAssembly_ (this),
      RootComponent_ (this),
      AsmPaths_ (this),
      MaterialLibrary_ (this)
    {
    }

    ProductType::
    ProductType (const ProductType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Header_ (x.Header_, f, this),
      GeometrySet_ (x.GeometrySet_, f, this),
      TopologySet_ (x.TopologySet_, f, this),
      NoteSet_ (x.NoteSet_, f, this),
      NoteFlagSet_ (x.NoteFlagSet_, f, this),
      PartNoteSet_ (x.PartNoteSet_, f, this),
      ViewSet_ (x.ViewSet_, f, this),
      LayerSet_ (x.LayerSet_, f, this),
      CoordinateSystemSet_ (x.CoordinateSystemSet_, f, this),
      VisualizationSet_ (x.VisualizationSet_, f, this),
      AuxiliarySet_ (x.AuxiliarySet_, f, this),
      PartSet_ (x.PartSet_, f, this),
      AssemblySet_ (x.AssemblySet_, f, this),
      ComponentSet_ (x.ComponentSet_, f, this),
      RootPart_ (x.RootPart_, f, this),
      RootAssembly_ (x.RootAssembly_, f, this),
      RootComponent_ (x.RootComponent_, f, this),
      AsmPaths_ (x.AsmPaths_, f, this),
      MaterialLibrary_ (x.MaterialLibrary_, f, this)
    {
    }

    ProductType::
    ProductType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Header_ (this),
      GeometrySet_ (this),
      TopologySet_ (this),
      NoteSet_ (this),
      NoteFlagSet_ (this),
      PartNoteSet_ (this),
      ViewSet_ (this),
      LayerSet_ (this),
      CoordinateSystemSet_ (this),
      VisualizationSet_ (this),
      AuxiliarySet_ (this),
      PartSet_ (this),
      AssemblySet_ (this),
      ComponentSet_ (this),
      RootPart_ (this),
      RootAssembly_ (this),
      RootComponent_ (this),
      AsmPaths_ (this),
      MaterialLibrary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProductType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Header
        //
        if (n.name () == L"Header" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Header_type > r (
            Header_traits::create (i, f, this));

          if (!this->Header_)
          {
            this->Header_.set (::std::move (r));
            continue;
          }
        }

        // GeometrySet
        //
        if (n.name () == L"GeometrySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< GeometrySet_type > r (
            GeometrySet_traits::create (i, f, this));

          if (!this->GeometrySet_)
          {
            this->GeometrySet_.set (::std::move (r));
            continue;
          }
        }

        // TopologySet
        //
        if (n.name () == L"TopologySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TopologySet_type > r (
            TopologySet_traits::create (i, f, this));

          if (!this->TopologySet_)
          {
            this->TopologySet_.set (::std::move (r));
            continue;
          }
        }

        // NoteSet
        //
        if (n.name () == L"NoteSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NoteSet_type > r (
            NoteSet_traits::create (i, f, this));

          if (!this->NoteSet_)
          {
            this->NoteSet_.set (::std::move (r));
            continue;
          }
        }

        // NoteFlagSet
        //
        if (n.name () == L"NoteFlagSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NoteFlagSet_type > r (
            NoteFlagSet_traits::create (i, f, this));

          if (!this->NoteFlagSet_)
          {
            this->NoteFlagSet_.set (::std::move (r));
            continue;
          }
        }

        // PartNoteSet
        //
        if (n.name () == L"PartNoteSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartNoteSet_type > r (
            PartNoteSet_traits::create (i, f, this));

          if (!this->PartNoteSet_)
          {
            this->PartNoteSet_.set (::std::move (r));
            continue;
          }
        }

        // ViewSet
        //
        if (n.name () == L"ViewSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ViewSet_type > r (
            ViewSet_traits::create (i, f, this));

          if (!this->ViewSet_)
          {
            this->ViewSet_.set (::std::move (r));
            continue;
          }
        }

        // LayerSet
        //
        if (n.name () == L"LayerSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LayerSet_type > r (
            LayerSet_traits::create (i, f, this));

          if (!this->LayerSet_)
          {
            this->LayerSet_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemSet
        //
        if (n.name () == L"CoordinateSystemSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemSet_type > r (
            CoordinateSystemSet_traits::create (i, f, this));

          if (!this->CoordinateSystemSet_)
          {
            this->CoordinateSystemSet_.set (::std::move (r));
            continue;
          }
        }

        // VisualizationSet
        //
        if (n.name () == L"VisualizationSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VisualizationSet_type > r (
            VisualizationSet_traits::create (i, f, this));

          if (!this->VisualizationSet_)
          {
            this->VisualizationSet_.set (::std::move (r));
            continue;
          }
        }

        // AuxiliarySet
        //
        if (n.name () == L"AuxiliarySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AuxiliarySet_type > r (
            AuxiliarySet_traits::create (i, f, this));

          if (!this->AuxiliarySet_)
          {
            this->AuxiliarySet_.set (::std::move (r));
            continue;
          }
        }

        // PartSet
        //
        if (n.name () == L"PartSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartSet_type > r (
            PartSet_traits::create (i, f, this));

          if (!this->PartSet_)
          {
            this->PartSet_.set (::std::move (r));
            continue;
          }
        }

        // AssemblySet
        //
        if (n.name () == L"AssemblySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssemblySet_type > r (
            AssemblySet_traits::create (i, f, this));

          if (!this->AssemblySet_)
          {
            this->AssemblySet_.set (::std::move (r));
            continue;
          }
        }

        // ComponentSet
        //
        if (n.name () == L"ComponentSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentSet_type > r (
            ComponentSet_traits::create (i, f, this));

          if (!this->ComponentSet_)
          {
            this->ComponentSet_.set (::std::move (r));
            continue;
          }
        }

        // RootPart
        //
        if (n.name () == L"RootPart" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RootPart_type > r (
            RootPart_traits::create (i, f, this));

          if (!this->RootPart_)
          {
            this->RootPart_.set (::std::move (r));
            continue;
          }
        }

        // RootAssembly
        //
        if (n.name () == L"RootAssembly" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RootAssembly_type > r (
            RootAssembly_traits::create (i, f, this));

          if (!this->RootAssembly_)
          {
            this->RootAssembly_.set (::std::move (r));
            continue;
          }
        }

        // RootComponent
        //
        if (n.name () == L"RootComponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RootComponent_type > r (
            RootComponent_traits::create (i, f, this));

          if (!this->RootComponent_)
          {
            this->RootComponent_.set (::std::move (r));
            continue;
          }
        }

        // AsmPaths
        //
        if (n.name () == L"AsmPaths" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AsmPaths_type > r (
            AsmPaths_traits::create (i, f, this));

          if (!this->AsmPaths_)
          {
            this->AsmPaths_.set (::std::move (r));
            continue;
          }
        }

        // MaterialLibrary
        //
        if (n.name () == L"MaterialLibrary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaterialLibrary_type > r (
            MaterialLibrary_traits::create (i, f, this));

          if (!this->MaterialLibrary_)
          {
            this->MaterialLibrary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProductType* ProductType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductType (*this, f, c);
    }

    ProductType& ProductType::
    operator= (const ProductType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Header_ = x.Header_;
        this->GeometrySet_ = x.GeometrySet_;
        this->TopologySet_ = x.TopologySet_;
        this->NoteSet_ = x.NoteSet_;
        this->NoteFlagSet_ = x.NoteFlagSet_;
        this->PartNoteSet_ = x.PartNoteSet_;
        this->ViewSet_ = x.ViewSet_;
        this->LayerSet_ = x.LayerSet_;
        this->CoordinateSystemSet_ = x.CoordinateSystemSet_;
        this->VisualizationSet_ = x.VisualizationSet_;
        this->AuxiliarySet_ = x.AuxiliarySet_;
        this->PartSet_ = x.PartSet_;
        this->AssemblySet_ = x.AssemblySet_;
        this->ComponentSet_ = x.ComponentSet_;
        this->RootPart_ = x.RootPart_;
        this->RootAssembly_ = x.RootAssembly_;
        this->RootComponent_ = x.RootComponent_;
        this->AsmPaths_ = x.AsmPaths_;
        this->MaterialLibrary_ = x.MaterialLibrary_;
      }

      return *this;
    }

    ProductType::
    ~ProductType ()
    {
    }

    // AsmPathType
    //

    AsmPathType::
    AsmPathType ()
    : ::xml_schema::type (),
      ComponentIds_ (this),
      id_ (this)
    {
    }

    AsmPathType::
    AsmPathType (const id_type& id)
    : ::xml_schema::type (),
      ComponentIds_ (this),
      id_ (id, this)
    {
    }

    AsmPathType::
    AsmPathType (const AsmPathType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ComponentIds_ (x.ComponentIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AsmPathType::
    AsmPathType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ComponentIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AsmPathType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    AsmPathType* AsmPathType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AsmPathType (*this, f, c);
    }

    AsmPathType& AsmPathType::
    operator= (const AsmPathType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ComponentIds_ = x.ComponentIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AsmPathType::
    ~AsmPathType ()
    {
    }

    // AsmPathsType
    //

    AsmPathsType::
    AsmPathsType ()
    : ::xml_schema::type (),
      AsmPath_ (this),
      n_ (this)
    {
    }

    AsmPathsType::
    AsmPathsType (const n_type& n)
    : ::xml_schema::type (),
      AsmPath_ (this),
      n_ (n, this)
    {
    }

    AsmPathsType::
    AsmPathsType (const AsmPathsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AsmPath_ (x.AsmPath_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AsmPathsType::
    AsmPathsType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AsmPath_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AsmPathsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AsmPath
        //
        if (n.name () == L"AsmPath" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AsmPath_type > r (
            AsmPath_traits::create (i, f, this));

          this->AsmPath_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AsmPathsType* AsmPathsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AsmPathsType (*this, f, c);
    }

    AsmPathsType& AsmPathsType::
    operator= (const AsmPathsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AsmPath_ = x.AsmPath_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AsmPathsType::
    ~AsmPathsType ()
    {
    }

    // ValidationPartAssemblyType
    //

    ValidationPartAssemblyType::
    ValidationPartAssemblyType ()
    : ::xml_schema::type (),
      Area_ (this),
      Centroid_ (this),
      Volume_ (this),
      Box_ (this),
      FacePoints_ (this),
      EdgePoints_ (this),
      Instances_ (this)
    {
    }

    ValidationPartAssemblyType::
    ValidationPartAssemblyType (const ValidationPartAssemblyType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Area_ (x.Area_, f, this),
      Centroid_ (x.Centroid_, f, this),
      Volume_ (x.Volume_, f, this),
      Box_ (x.Box_, f, this),
      FacePoints_ (x.FacePoints_, f, this),
      EdgePoints_ (x.EdgePoints_, f, this),
      Instances_ (x.Instances_, f, this)
    {
    }

    ValidationPartAssemblyType::
    ValidationPartAssemblyType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Area_ (this),
      Centroid_ (this),
      Volume_ (this),
      Box_ (this),
      FacePoints_ (this),
      EdgePoints_ (this),
      Instances_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationPartAssemblyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Area
        //
        if (n.name () == L"Area" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Area_)
          {
            this->Area_.set (Area_traits::create (i, f, this));
            continue;
          }
        }

        // Centroid
        //
        if (n.name () == L"Centroid" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Centroid_type > r (
            Centroid_traits::create (i, f, this));

          if (!this->Centroid_)
          {
            this->Centroid_.set (::std::move (r));
            continue;
          }
        }

        // Volume
        //
        if (n.name () == L"Volume" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Volume_)
          {
            this->Volume_.set (Volume_traits::create (i, f, this));
            continue;
          }
        }

        // Box
        //
        if (n.name () == L"Box" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Box_type > r (
            Box_traits::create (i, f, this));

          if (!this->Box_)
          {
            this->Box_.set (::std::move (r));
            continue;
          }
        }

        // FacePoints
        //
        if (n.name () == L"FacePoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FacePoints_type > r (
            FacePoints_traits::create (i, f, this));

          if (!this->FacePoints_)
          {
            this->FacePoints_.set (::std::move (r));
            continue;
          }
        }

        // EdgePoints
        //
        if (n.name () == L"EdgePoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgePoints_type > r (
            EdgePoints_traits::create (i, f, this));

          if (!this->EdgePoints_)
          {
            this->EdgePoints_.set (::std::move (r));
            continue;
          }
        }

        // Instances
        //
        if (n.name () == L"Instances" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Instances_type > r (
            Instances_traits::create (i, f, this));

          if (!this->Instances_)
          {
            this->Instances_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ValidationPartAssemblyType* ValidationPartAssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationPartAssemblyType (*this, f, c);
    }

    ValidationPartAssemblyType& ValidationPartAssemblyType::
    operator= (const ValidationPartAssemblyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Area_ = x.Area_;
        this->Centroid_ = x.Centroid_;
        this->Volume_ = x.Volume_;
        this->Box_ = x.Box_;
        this->FacePoints_ = x.FacePoints_;
        this->EdgePoints_ = x.EdgePoints_;
        this->Instances_ = x.Instances_;
      }

      return *this;
    }

    ValidationPartAssemblyType::
    ~ValidationPartAssemblyType ()
    {
    }

    // ValidationPartAssemblyInstancesType
    //

    ValidationPartAssemblyInstancesType::
    ValidationPartAssemblyInstancesType ()
    : ::xml_schema::type (),
      Instance_ (this),
      n_ (this)
    {
    }

    ValidationPartAssemblyInstancesType::
    ValidationPartAssemblyInstancesType (const n_type& n)
    : ::xml_schema::type (),
      Instance_ (this),
      n_ (n, this)
    {
    }

    ValidationPartAssemblyInstancesType::
    ValidationPartAssemblyInstancesType (const ValidationPartAssemblyInstancesType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Instance_ (x.Instance_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ValidationPartAssemblyInstancesType::
    ValidationPartAssemblyInstancesType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Instance_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ValidationPartAssemblyInstancesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Instance
        //
        if (n.name () == L"Instance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Instance_type > r (
            Instance_traits::create (i, f, this));

          this->Instance_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ValidationPartAssemblyInstancesType* ValidationPartAssemblyInstancesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationPartAssemblyInstancesType (*this, f, c);
    }

    ValidationPartAssemblyInstancesType& ValidationPartAssemblyInstancesType::
    operator= (const ValidationPartAssemblyInstancesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Instance_ = x.Instance_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ValidationPartAssemblyInstancesType::
    ~ValidationPartAssemblyInstancesType ()
    {
    }

    // ValidationPartAssemblyInstanceType
    //

    ValidationPartAssemblyInstanceType::
    ValidationPartAssemblyInstanceType ()
    : ::xml_schema::type (),
      AsmPathId_ (this),
      Centroid_ (this),
      Box_ (this)
    {
    }

    ValidationPartAssemblyInstanceType::
    ValidationPartAssemblyInstanceType (const AsmPathId_type& AsmPathId)
    : ::xml_schema::type (),
      AsmPathId_ (AsmPathId, this),
      Centroid_ (this),
      Box_ (this)
    {
    }

    ValidationPartAssemblyInstanceType::
    ValidationPartAssemblyInstanceType (::std::unique_ptr< AsmPathId_type > AsmPathId)
    : ::xml_schema::type (),
      AsmPathId_ (std::move (AsmPathId), this),
      Centroid_ (this),
      Box_ (this)
    {
    }

    ValidationPartAssemblyInstanceType::
    ValidationPartAssemblyInstanceType (const ValidationPartAssemblyInstanceType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AsmPathId_ (x.AsmPathId_, f, this),
      Centroid_ (x.Centroid_, f, this),
      Box_ (x.Box_, f, this)
    {
    }

    ValidationPartAssemblyInstanceType::
    ValidationPartAssemblyInstanceType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AsmPathId_ (this),
      Centroid_ (this),
      Box_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationPartAssemblyInstanceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AsmPathId
        //
        if (n.name () == L"AsmPathId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AsmPathId_type > r (
            AsmPathId_traits::create (i, f, this));

          if (!AsmPathId_.present ())
          {
            this->AsmPathId_.set (::std::move (r));
            continue;
          }
        }

        // Centroid
        //
        if (n.name () == L"Centroid" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Centroid_type > r (
            Centroid_traits::create (i, f, this));

          if (!this->Centroid_)
          {
            this->Centroid_.set (::std::move (r));
            continue;
          }
        }

        // Box
        //
        if (n.name () == L"Box" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Box_type > r (
            Box_traits::create (i, f, this));

          if (!this->Box_)
          {
            this->Box_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AsmPathId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AsmPathId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ValidationPartAssemblyInstanceType* ValidationPartAssemblyInstanceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationPartAssemblyInstanceType (*this, f, c);
    }

    ValidationPartAssemblyInstanceType& ValidationPartAssemblyInstanceType::
    operator= (const ValidationPartAssemblyInstanceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AsmPathId_ = x.AsmPathId_;
        this->Centroid_ = x.Centroid_;
        this->Box_ = x.Box_;
      }

      return *this;
    }

    ValidationPartAssemblyInstanceType::
    ~ValidationPartAssemblyInstanceType ()
    {
    }

    // PartAssemblyBaseType
    //

    PartAssemblyBaseType::
    PartAssemblyBaseType ()
    : ::xsd::qif30::DrawableBaseType (),
      Validation_ (this),
      Header_ (this),
      UUID_ (this),
      ModelNumber_ (this),
      Version_ (this),
      SecurityClassification_ (this),
      ExportControlClassification_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this),
      originMassProperty_ (this),
      materialIndex_ (this)
    {
    }

    PartAssemblyBaseType::
    PartAssemblyBaseType (const id_type& id)
    : ::xsd::qif30::DrawableBaseType (id),
      Validation_ (this),
      Header_ (this),
      UUID_ (this),
      ModelNumber_ (this),
      Version_ (this),
      SecurityClassification_ (this),
      ExportControlClassification_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this),
      originMassProperty_ (this),
      materialIndex_ (this)
    {
    }

    PartAssemblyBaseType::
    PartAssemblyBaseType (const PartAssemblyBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      Validation_ (x.Validation_, f, this),
      Header_ (x.Header_, f, this),
      UUID_ (x.UUID_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      Version_ (x.Version_, f, this),
      SecurityClassification_ (x.SecurityClassification_, f, this),
      ExportControlClassification_ (x.ExportControlClassification_, f, this),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this),
      FeatureZoneIds_ (x.FeatureZoneIds_, f, this),
      CharacteristicNominalIds_ (x.CharacteristicNominalIds_, f, this),
      NoteIds_ (x.NoteIds_, f, this),
      PartNoteIds_ (x.PartNoteIds_, f, this),
      DatumDefinitionIds_ (x.DatumDefinitionIds_, f, this),
      DatumTargetDefinitionIds_ (x.DatumTargetDefinitionIds_, f, this),
      DatumReferenceFrameIds_ (x.DatumReferenceFrameIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this),
      CoordinateSystemIds_ (x.CoordinateSystemIds_, f, this),
      AuxiliaryIds_ (x.AuxiliaryIds_, f, this),
      ViewIds_ (x.ViewIds_, f, this),
      PointCloudIds_ (x.PointCloudIds_, f, this),
      originMassProperty_ (x.originMassProperty_, f, this),
      materialIndex_ (x.materialIndex_, f, this)
    {
    }

    PartAssemblyBaseType::
    PartAssemblyBaseType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      Validation_ (this),
      Header_ (this),
      UUID_ (this),
      ModelNumber_ (this),
      Version_ (this),
      SecurityClassification_ (this),
      ExportControlClassification_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this),
      originMassProperty_ (this),
      materialIndex_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PartAssemblyBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Validation
        //
        if (n.name () == L"Validation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Validation_type > r (
            Validation_traits::create (i, f, this));

          if (!this->Validation_)
          {
            this->Validation_.set (::std::move (r));
            continue;
          }
        }

        // Header
        //
        if (n.name () == L"Header" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Header_type > r (
            Header_traits::create (i, f, this));

          if (!this->Header_)
          {
            this->Header_.set (::std::move (r));
            continue;
          }
        }

        // UUID
        //
        if (n.name () == L"UUID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UUID_type > r (
            UUID_traits::create (i, f, this));

          if (!this->UUID_)
          {
            this->UUID_.set (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == L"ModelNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // SecurityClassification
        //
        if (n.name () == L"SecurityClassification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecurityClassification_type > r (
            SecurityClassification_traits::create (i, f, this));

          if (!this->SecurityClassification_)
          {
            this->SecurityClassification_.set (::std::move (r));
            continue;
          }
        }

        // ExportControlClassification
        //
        if (n.name () == L"ExportControlClassification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExportControlClassification_type > r (
            ExportControlClassification_traits::create (i, f, this));

          if (!this->ExportControlClassification_)
          {
            this->ExportControlClassification_.set (::std::move (r));
            continue;
          }
        }

        // FeatureNominalIds
        //
        if (n.name () == L"FeatureNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!this->FeatureNominalIds_)
          {
            this->FeatureNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // FeatureZoneIds
        //
        if (n.name () == L"FeatureZoneIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureZoneIds_type > r (
            FeatureZoneIds_traits::create (i, f, this));

          if (!this->FeatureZoneIds_)
          {
            this->FeatureZoneIds_.set (::std::move (r));
            continue;
          }
        }

        // CharacteristicNominalIds
        //
        if (n.name () == L"CharacteristicNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicNominalIds_type > r (
            CharacteristicNominalIds_traits::create (i, f, this));

          if (!this->CharacteristicNominalIds_)
          {
            this->CharacteristicNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // NoteIds
        //
        if (n.name () == L"NoteIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NoteIds_type > r (
            NoteIds_traits::create (i, f, this));

          if (!this->NoteIds_)
          {
            this->NoteIds_.set (::std::move (r));
            continue;
          }
        }

        // PartNoteIds
        //
        if (n.name () == L"PartNoteIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartNoteIds_type > r (
            PartNoteIds_traits::create (i, f, this));

          if (!this->PartNoteIds_)
          {
            this->PartNoteIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionIds
        //
        if (n.name () == L"DatumDefinitionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionIds_type > r (
            DatumDefinitionIds_traits::create (i, f, this));

          if (!this->DatumDefinitionIds_)
          {
            this->DatumDefinitionIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumTargetDefinitionIds
        //
        if (n.name () == L"DatumTargetDefinitionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTargetDefinitionIds_type > r (
            DatumTargetDefinitionIds_traits::create (i, f, this));

          if (!this->DatumTargetDefinitionIds_)
          {
            this->DatumTargetDefinitionIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumReferenceFrameIds
        //
        if (n.name () == L"DatumReferenceFrameIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumReferenceFrameIds_type > r (
            DatumReferenceFrameIds_traits::create (i, f, this));

          if (!this->DatumReferenceFrameIds_)
          {
            this->DatumReferenceFrameIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemIds
        //
        if (n.name () == L"CoordinateSystemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemIds_type > r (
            CoordinateSystemIds_traits::create (i, f, this));

          if (!this->CoordinateSystemIds_)
          {
            this->CoordinateSystemIds_.set (::std::move (r));
            continue;
          }
        }

        // AuxiliaryIds
        //
        if (n.name () == L"AuxiliaryIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AuxiliaryIds_type > r (
            AuxiliaryIds_traits::create (i, f, this));

          if (!this->AuxiliaryIds_)
          {
            this->AuxiliaryIds_.set (::std::move (r));
            continue;
          }
        }

        // ViewIds
        //
        if (n.name () == L"ViewIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ViewIds_type > r (
            ViewIds_traits::create (i, f, this));

          if (!this->ViewIds_)
          {
            this->ViewIds_.set (::std::move (r));
            continue;
          }
        }

        // PointCloudIds
        //
        if (n.name () == L"PointCloudIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointCloudIds_type > r (
            PointCloudIds_traits::create (i, f, this));

          if (!this->PointCloudIds_)
          {
            this->PointCloudIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"originMassProperty" && n.namespace_ ().empty ())
        {
          this->originMassProperty_.set (originMassProperty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"materialIndex" && n.namespace_ ().empty ())
        {
          this->materialIndex_.set (materialIndex_traits::create (i, f, this));
          continue;
        }
      }
    }

    PartAssemblyBaseType& PartAssemblyBaseType::
    operator= (const PartAssemblyBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->Validation_ = x.Validation_;
        this->Header_ = x.Header_;
        this->UUID_ = x.UUID_;
        this->ModelNumber_ = x.ModelNumber_;
        this->Version_ = x.Version_;
        this->SecurityClassification_ = x.SecurityClassification_;
        this->ExportControlClassification_ = x.ExportControlClassification_;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
        this->FeatureZoneIds_ = x.FeatureZoneIds_;
        this->CharacteristicNominalIds_ = x.CharacteristicNominalIds_;
        this->NoteIds_ = x.NoteIds_;
        this->PartNoteIds_ = x.PartNoteIds_;
        this->DatumDefinitionIds_ = x.DatumDefinitionIds_;
        this->DatumTargetDefinitionIds_ = x.DatumTargetDefinitionIds_;
        this->DatumReferenceFrameIds_ = x.DatumReferenceFrameIds_;
        this->BodyIds_ = x.BodyIds_;
        this->CoordinateSystemIds_ = x.CoordinateSystemIds_;
        this->AuxiliaryIds_ = x.AuxiliaryIds_;
        this->ViewIds_ = x.ViewIds_;
        this->PointCloudIds_ = x.PointCloudIds_;
        this->originMassProperty_ = x.originMassProperty_;
        this->materialIndex_ = x.materialIndex_;
      }

      return *this;
    }

    PartAssemblyBaseType::
    ~PartAssemblyBaseType ()
    {
    }

    // PartType
    //

    PartType::
    PartType ()
    : ::xsd::qif30::PartAssemblyBaseType (),
      DefinitionExternal_ (this),
      PartFamily_ (this),
      FoldersPart_ (this)
    {
    }

    PartType::
    PartType (const id_type& id)
    : ::xsd::qif30::PartAssemblyBaseType (id),
      DefinitionExternal_ (this),
      PartFamily_ (this),
      FoldersPart_ (this)
    {
    }

    PartType::
    PartType (const PartType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyBaseType (x, f, c),
      DefinitionExternal_ (x.DefinitionExternal_, f, this),
      PartFamily_ (x.PartFamily_, f, this),
      FoldersPart_ (x.FoldersPart_, f, this)
    {
    }

    PartType::
    PartType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyBaseType (e, f | ::xml_schema::flags::base, c),
      DefinitionExternal_ (this),
      PartFamily_ (this),
      FoldersPart_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PartType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PartAssemblyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefinitionExternal
        //
        if (n.name () == L"DefinitionExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefinitionExternal_type > r (
            DefinitionExternal_traits::create (i, f, this));

          if (!this->DefinitionExternal_)
          {
            this->DefinitionExternal_.set (::std::move (r));
            continue;
          }
        }

        // PartFamily
        //
        if (n.name () == L"PartFamily" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartFamily_type > r (
            PartFamily_traits::create (i, f, this));

          if (!this->PartFamily_)
          {
            this->PartFamily_.set (::std::move (r));
            continue;
          }
        }

        // FoldersPart
        //
        if (n.name () == L"FoldersPart" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FoldersPart_type > r (
            FoldersPart_traits::create (i, f, this));

          if (!this->FoldersPart_)
          {
            this->FoldersPart_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PartType* PartType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartType (*this, f, c);
    }

    PartType& PartType::
    operator= (const PartType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PartAssemblyBaseType& > (*this) = x;
        this->DefinitionExternal_ = x.DefinitionExternal_;
        this->PartFamily_ = x.PartFamily_;
        this->FoldersPart_ = x.FoldersPart_;
      }

      return *this;
    }

    PartType::
    ~PartType ()
    {
    }

    // FoldersPartType
    //

    FoldersPartType::
    FoldersPartType ()
    : ::xml_schema::type (),
      FolderPart_ (this),
      n_ (this)
    {
    }

    FoldersPartType::
    FoldersPartType (const n_type& n)
    : ::xml_schema::type (),
      FolderPart_ (this),
      n_ (n, this)
    {
    }

    FoldersPartType::
    FoldersPartType (const FoldersPartType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FolderPart_ (x.FolderPart_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FoldersPartType::
    FoldersPartType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FolderPart_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FoldersPartType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FolderPart
        //
        if (n.name () == L"FolderPart" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FolderPart_type > r (
            FolderPart_traits::create (i, f, this));

          this->FolderPart_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FoldersPartType* FoldersPartType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FoldersPartType (*this, f, c);
    }

    FoldersPartType& FoldersPartType::
    operator= (const FoldersPartType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FolderPart_ = x.FolderPart_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FoldersPartType::
    ~FoldersPartType ()
    {
    }

    // FoldersAssemblyType
    //

    FoldersAssemblyType::
    FoldersAssemblyType ()
    : ::xml_schema::type (),
      FolderAssembly_ (this),
      n_ (this)
    {
    }

    FoldersAssemblyType::
    FoldersAssemblyType (const n_type& n)
    : ::xml_schema::type (),
      FolderAssembly_ (this),
      n_ (n, this)
    {
    }

    FoldersAssemblyType::
    FoldersAssemblyType (const FoldersAssemblyType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FolderAssembly_ (x.FolderAssembly_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FoldersAssemblyType::
    FoldersAssemblyType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FolderAssembly_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FoldersAssemblyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FolderAssembly
        //
        if (n.name () == L"FolderAssembly" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FolderAssembly_type > r (
            FolderAssembly_traits::create (i, f, this));

          this->FolderAssembly_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FoldersAssemblyType* FoldersAssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FoldersAssemblyType (*this, f, c);
    }

    FoldersAssemblyType& FoldersAssemblyType::
    operator= (const FoldersAssemblyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FolderAssembly_ = x.FolderAssembly_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FoldersAssemblyType::
    ~FoldersAssemblyType ()
    {
    }

    // FolderPartAssemblyBaseType
    //

    FolderPartAssemblyBaseType::
    FolderPartAssemblyBaseType ()
    : ::xsd::qif30::DrawableBaseType (),
      FolderIds_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this)
    {
    }

    FolderPartAssemblyBaseType::
    FolderPartAssemblyBaseType (const id_type& id)
    : ::xsd::qif30::DrawableBaseType (id),
      FolderIds_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this)
    {
    }

    FolderPartAssemblyBaseType::
    FolderPartAssemblyBaseType (const FolderPartAssemblyBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      FolderIds_ (x.FolderIds_, f, this),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this),
      FeatureZoneIds_ (x.FeatureZoneIds_, f, this),
      CharacteristicNominalIds_ (x.CharacteristicNominalIds_, f, this),
      NoteIds_ (x.NoteIds_, f, this),
      PartNoteIds_ (x.PartNoteIds_, f, this),
      DatumDefinitionIds_ (x.DatumDefinitionIds_, f, this),
      DatumTargetDefinitionIds_ (x.DatumTargetDefinitionIds_, f, this),
      DatumReferenceFrameIds_ (x.DatumReferenceFrameIds_, f, this),
      BodyIds_ (x.BodyIds_, f, this),
      CoordinateSystemIds_ (x.CoordinateSystemIds_, f, this),
      AuxiliaryIds_ (x.AuxiliaryIds_, f, this),
      ViewIds_ (x.ViewIds_, f, this),
      PointCloudIds_ (x.PointCloudIds_, f, this)
    {
    }

    FolderPartAssemblyBaseType::
    FolderPartAssemblyBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      FolderIds_ (this),
      FeatureNominalIds_ (this),
      FeatureZoneIds_ (this),
      CharacteristicNominalIds_ (this),
      NoteIds_ (this),
      PartNoteIds_ (this),
      DatumDefinitionIds_ (this),
      DatumTargetDefinitionIds_ (this),
      DatumReferenceFrameIds_ (this),
      BodyIds_ (this),
      CoordinateSystemIds_ (this),
      AuxiliaryIds_ (this),
      ViewIds_ (this),
      PointCloudIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FolderPartAssemblyBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FolderIds
        //
        if (n.name () == L"FolderIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FolderIds_type > r (
            FolderIds_traits::create (i, f, this));

          if (!this->FolderIds_)
          {
            this->FolderIds_.set (::std::move (r));
            continue;
          }
        }

        // FeatureNominalIds
        //
        if (n.name () == L"FeatureNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!this->FeatureNominalIds_)
          {
            this->FeatureNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // FeatureZoneIds
        //
        if (n.name () == L"FeatureZoneIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureZoneIds_type > r (
            FeatureZoneIds_traits::create (i, f, this));

          if (!this->FeatureZoneIds_)
          {
            this->FeatureZoneIds_.set (::std::move (r));
            continue;
          }
        }

        // CharacteristicNominalIds
        //
        if (n.name () == L"CharacteristicNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicNominalIds_type > r (
            CharacteristicNominalIds_traits::create (i, f, this));

          if (!this->CharacteristicNominalIds_)
          {
            this->CharacteristicNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // NoteIds
        //
        if (n.name () == L"NoteIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NoteIds_type > r (
            NoteIds_traits::create (i, f, this));

          if (!this->NoteIds_)
          {
            this->NoteIds_.set (::std::move (r));
            continue;
          }
        }

        // PartNoteIds
        //
        if (n.name () == L"PartNoteIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartNoteIds_type > r (
            PartNoteIds_traits::create (i, f, this));

          if (!this->PartNoteIds_)
          {
            this->PartNoteIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumDefinitionIds
        //
        if (n.name () == L"DatumDefinitionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionIds_type > r (
            DatumDefinitionIds_traits::create (i, f, this));

          if (!this->DatumDefinitionIds_)
          {
            this->DatumDefinitionIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumTargetDefinitionIds
        //
        if (n.name () == L"DatumTargetDefinitionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumTargetDefinitionIds_type > r (
            DatumTargetDefinitionIds_traits::create (i, f, this));

          if (!this->DatumTargetDefinitionIds_)
          {
            this->DatumTargetDefinitionIds_.set (::std::move (r));
            continue;
          }
        }

        // DatumReferenceFrameIds
        //
        if (n.name () == L"DatumReferenceFrameIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumReferenceFrameIds_type > r (
            DatumReferenceFrameIds_traits::create (i, f, this));

          if (!this->DatumReferenceFrameIds_)
          {
            this->DatumReferenceFrameIds_.set (::std::move (r));
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == L"BodyIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemIds
        //
        if (n.name () == L"CoordinateSystemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemIds_type > r (
            CoordinateSystemIds_traits::create (i, f, this));

          if (!this->CoordinateSystemIds_)
          {
            this->CoordinateSystemIds_.set (::std::move (r));
            continue;
          }
        }

        // AuxiliaryIds
        //
        if (n.name () == L"AuxiliaryIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AuxiliaryIds_type > r (
            AuxiliaryIds_traits::create (i, f, this));

          if (!this->AuxiliaryIds_)
          {
            this->AuxiliaryIds_.set (::std::move (r));
            continue;
          }
        }

        // ViewIds
        //
        if (n.name () == L"ViewIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ViewIds_type > r (
            ViewIds_traits::create (i, f, this));

          if (!this->ViewIds_)
          {
            this->ViewIds_.set (::std::move (r));
            continue;
          }
        }

        // PointCloudIds
        //
        if (n.name () == L"PointCloudIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointCloudIds_type > r (
            PointCloudIds_traits::create (i, f, this));

          if (!this->PointCloudIds_)
          {
            this->PointCloudIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FolderPartAssemblyBaseType& FolderPartAssemblyBaseType::
    operator= (const FolderPartAssemblyBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->FolderIds_ = x.FolderIds_;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
        this->FeatureZoneIds_ = x.FeatureZoneIds_;
        this->CharacteristicNominalIds_ = x.CharacteristicNominalIds_;
        this->NoteIds_ = x.NoteIds_;
        this->PartNoteIds_ = x.PartNoteIds_;
        this->DatumDefinitionIds_ = x.DatumDefinitionIds_;
        this->DatumTargetDefinitionIds_ = x.DatumTargetDefinitionIds_;
        this->DatumReferenceFrameIds_ = x.DatumReferenceFrameIds_;
        this->BodyIds_ = x.BodyIds_;
        this->CoordinateSystemIds_ = x.CoordinateSystemIds_;
        this->AuxiliaryIds_ = x.AuxiliaryIds_;
        this->ViewIds_ = x.ViewIds_;
        this->PointCloudIds_ = x.PointCloudIds_;
      }

      return *this;
    }

    FolderPartAssemblyBaseType::
    ~FolderPartAssemblyBaseType ()
    {
    }

    // FolderPartType
    //

    FolderPartType::
    FolderPartType ()
    : ::xsd::qif30::FolderPartAssemblyBaseType ()
    {
    }

    FolderPartType::
    FolderPartType (const id_type& id)
    : ::xsd::qif30::FolderPartAssemblyBaseType (id)
    {
    }

    FolderPartType::
    FolderPartType (const FolderPartType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::FolderPartAssemblyBaseType (x, f, c)
    {
    }

    FolderPartType::
    FolderPartType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::FolderPartAssemblyBaseType (e, f, c)
    {
    }

    FolderPartType* FolderPartType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FolderPartType (*this, f, c);
    }

    FolderPartType::
    ~FolderPartType ()
    {
    }

    // FolderAssemblyType
    //

    FolderAssemblyType::
    FolderAssemblyType ()
    : ::xsd::qif30::FolderPartAssemblyBaseType (),
      ComponentIds_ (this)
    {
    }

    FolderAssemblyType::
    FolderAssemblyType (const id_type& id,
                        const ComponentIds_type& ComponentIds)
    : ::xsd::qif30::FolderPartAssemblyBaseType (id),
      ComponentIds_ (ComponentIds, this)
    {
    }

    FolderAssemblyType::
    FolderAssemblyType (const id_type& id,
                        ::std::unique_ptr< ComponentIds_type > ComponentIds)
    : ::xsd::qif30::FolderPartAssemblyBaseType (id),
      ComponentIds_ (std::move (ComponentIds), this)
    {
    }

    FolderAssemblyType::
    FolderAssemblyType (const FolderAssemblyType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FolderPartAssemblyBaseType (x, f, c),
      ComponentIds_ (x.ComponentIds_, f, this)
    {
    }

    FolderAssemblyType::
    FolderAssemblyType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::FolderPartAssemblyBaseType (e, f | ::xml_schema::flags::base, c),
      ComponentIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FolderAssemblyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FolderPartAssemblyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!ComponentIds_.present ())
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ComponentIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ComponentIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FolderAssemblyType* FolderAssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FolderAssemblyType (*this, f, c);
    }

    FolderAssemblyType& FolderAssemblyType::
    operator= (const FolderAssemblyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FolderPartAssemblyBaseType& > (*this) = x;
        this->ComponentIds_ = x.ComponentIds_;
      }

      return *this;
    }

    FolderAssemblyType::
    ~FolderAssemblyType ()
    {
    }

    // AssemblyType
    //

    AssemblyType::
    AssemblyType ()
    : ::xsd::qif30::PartAssemblyBaseType (),
      ComponentIds_ (this),
      DefinitionExternal_ (this),
      FoldersAssembly_ (this)
    {
    }

    AssemblyType::
    AssemblyType (const id_type& id,
                  const ComponentIds_type& ComponentIds)
    : ::xsd::qif30::PartAssemblyBaseType (id),
      ComponentIds_ (ComponentIds, this),
      DefinitionExternal_ (this),
      FoldersAssembly_ (this)
    {
    }

    AssemblyType::
    AssemblyType (const id_type& id,
                  ::std::unique_ptr< ComponentIds_type > ComponentIds)
    : ::xsd::qif30::PartAssemblyBaseType (id),
      ComponentIds_ (std::move (ComponentIds), this),
      DefinitionExternal_ (this),
      FoldersAssembly_ (this)
    {
    }

    AssemblyType::
    AssemblyType (const AssemblyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyBaseType (x, f, c),
      ComponentIds_ (x.ComponentIds_, f, this),
      DefinitionExternal_ (x.DefinitionExternal_, f, this),
      FoldersAssembly_ (x.FoldersAssembly_, f, this)
    {
    }

    AssemblyType::
    AssemblyType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyBaseType (e, f | ::xml_schema::flags::base, c),
      ComponentIds_ (this),
      DefinitionExternal_ (this),
      FoldersAssembly_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AssemblyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PartAssemblyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ComponentIds
        //
        if (n.name () == L"ComponentIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!ComponentIds_.present ())
          {
            this->ComponentIds_.set (::std::move (r));
            continue;
          }
        }

        // DefinitionExternal
        //
        if (n.name () == L"DefinitionExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefinitionExternal_type > r (
            DefinitionExternal_traits::create (i, f, this));

          if (!this->DefinitionExternal_)
          {
            this->DefinitionExternal_.set (::std::move (r));
            continue;
          }
        }

        // FoldersAssembly
        //
        if (n.name () == L"FoldersAssembly" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FoldersAssembly_type > r (
            FoldersAssembly_traits::create (i, f, this));

          if (!this->FoldersAssembly_)
          {
            this->FoldersAssembly_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ComponentIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ComponentIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AssemblyType* AssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssemblyType (*this, f, c);
    }

    AssemblyType& AssemblyType::
    operator= (const AssemblyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PartAssemblyBaseType& > (*this) = x;
        this->ComponentIds_ = x.ComponentIds_;
        this->DefinitionExternal_ = x.DefinitionExternal_;
        this->FoldersAssembly_ = x.FoldersAssembly_;
      }

      return *this;
    }

    AssemblyType::
    ~AssemblyType ()
    {
    }

    // PartFamilyType
    //

    PartFamilyType::
    PartFamilyType ()
    : ::xml_schema::type (),
      PrimaryShapeClass_ (this),
      MinimumTolerance_ (this),
      MinimumBoundingBox_ (this),
      PrimaryManufacturingMethod_ (this)
    {
    }

    PartFamilyType::
    PartFamilyType (const PartFamilyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrimaryShapeClass_ (x.PrimaryShapeClass_, f, this),
      MinimumTolerance_ (x.MinimumTolerance_, f, this),
      MinimumBoundingBox_ (x.MinimumBoundingBox_, f, this),
      PrimaryManufacturingMethod_ (x.PrimaryManufacturingMethod_, f, this)
    {
    }

    PartFamilyType::
    PartFamilyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrimaryShapeClass_ (this),
      MinimumTolerance_ (this),
      MinimumBoundingBox_ (this),
      PrimaryManufacturingMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PartFamilyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PrimaryShapeClass
        //
        if (n.name () == L"PrimaryShapeClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryShapeClass_type > r (
            PrimaryShapeClass_traits::create (i, f, this));

          if (!this->PrimaryShapeClass_)
          {
            this->PrimaryShapeClass_.set (::std::move (r));
            continue;
          }
        }

        // MinimumTolerance
        //
        if (n.name () == L"MinimumTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinimumTolerance_type > r (
            MinimumTolerance_traits::create (i, f, this));

          if (!this->MinimumTolerance_)
          {
            this->MinimumTolerance_.set (::std::move (r));
            continue;
          }
        }

        // MinimumBoundingBox
        //
        if (n.name () == L"MinimumBoundingBox" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinimumBoundingBox_type > r (
            MinimumBoundingBox_traits::create (i, f, this));

          if (!this->MinimumBoundingBox_)
          {
            this->MinimumBoundingBox_.set (::std::move (r));
            continue;
          }
        }

        // PrimaryManufacturingMethod
        //
        if (n.name () == L"PrimaryManufacturingMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryManufacturingMethod_type > r (
            PrimaryManufacturingMethod_traits::create (i, f, this));

          if (!this->PrimaryManufacturingMethod_)
          {
            this->PrimaryManufacturingMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PartFamilyType* PartFamilyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartFamilyType (*this, f, c);
    }

    PartFamilyType& PartFamilyType::
    operator= (const PartFamilyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrimaryShapeClass_ = x.PrimaryShapeClass_;
        this->MinimumTolerance_ = x.MinimumTolerance_;
        this->MinimumBoundingBox_ = x.MinimumBoundingBox_;
        this->PrimaryManufacturingMethod_ = x.PrimaryManufacturingMethod_;
      }

      return *this;
    }

    PartFamilyType::
    ~PartFamilyType ()
    {
    }

    // PartSetType
    //

    PartSetType::
    PartSetType ()
    : ::xml_schema::type (),
      Part_ (this),
      n_ (this)
    {
    }

    PartSetType::
    PartSetType (const n_type& n)
    : ::xml_schema::type (),
      Part_ (this),
      n_ (n, this)
    {
    }

    PartSetType::
    PartSetType (const PartSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Part_ (x.Part_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PartSetType::
    PartSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Part_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PartSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Part
        //
        if (n.name () == L"Part" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Part_type > r (
            Part_traits::create (i, f, this));

          this->Part_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PartSetType* PartSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartSetType (*this, f, c);
    }

    PartSetType& PartSetType::
    operator= (const PartSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Part_ = x.Part_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PartSetType::
    ~PartSetType ()
    {
    }

    // AssemblySetType
    //

    AssemblySetType::
    AssemblySetType ()
    : ::xml_schema::type (),
      Assembly_ (this),
      n_ (this)
    {
    }

    AssemblySetType::
    AssemblySetType (const n_type& n)
    : ::xml_schema::type (),
      Assembly_ (this),
      n_ (n, this)
    {
    }

    AssemblySetType::
    AssemblySetType (const AssemblySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Assembly_ (x.Assembly_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AssemblySetType::
    AssemblySetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Assembly_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AssemblySetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Assembly
        //
        if (n.name () == L"Assembly" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Assembly_type > r (
            Assembly_traits::create (i, f, this));

          this->Assembly_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AssemblySetType* AssemblySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssemblySetType (*this, f, c);
    }

    AssemblySetType& AssemblySetType::
    operator= (const AssemblySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Assembly_ = x.Assembly_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AssemblySetType::
    ~AssemblySetType ()
    {
    }

    // ComponentType
    //

    ComponentType::
    ComponentType ()
    : ::xsd::qif30::DrawableBaseType (),
      Transform_ (this),
      UUID_ (this),
      Traceability_ (this),
      Part_ (this),
      Assembly_ (this)
    {
    }

    ComponentType::
    ComponentType (const id_type& id)
    : ::xsd::qif30::DrawableBaseType (id),
      Transform_ (this),
      UUID_ (this),
      Traceability_ (this),
      Part_ (this),
      Assembly_ (this)
    {
    }

    ComponentType::
    ComponentType (const ComponentType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      Transform_ (x.Transform_, f, this),
      UUID_ (x.UUID_, f, this),
      Traceability_ (x.Traceability_, f, this),
      Part_ (x.Part_, f, this),
      Assembly_ (x.Assembly_, f, this)
    {
    }

    ComponentType::
    ComponentType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      Transform_ (this),
      UUID_ (this),
      Traceability_ (this),
      Part_ (this),
      Assembly_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // UUID
        //
        if (n.name () == L"UUID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UUID_type > r (
            UUID_traits::create (i, f, this));

          if (!this->UUID_)
          {
            this->UUID_.set (::std::move (r));
            continue;
          }
        }

        // Traceability
        //
        if (n.name () == L"Traceability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Traceability_type > r (
            Traceability_traits::create (i, f, this));

          if (!this->Traceability_)
          {
            this->Traceability_.set (::std::move (r));
            continue;
          }
        }

        // Part
        //
        if (n.name () == L"Part" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Part_type > r (
            Part_traits::create (i, f, this));

          if (!this->Part_)
          {
            this->Part_.set (::std::move (r));
            continue;
          }
        }

        // Assembly
        //
        if (n.name () == L"Assembly" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Assembly_type > r (
            Assembly_traits::create (i, f, this));

          if (!this->Assembly_)
          {
            this->Assembly_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ComponentType* ComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentType (*this, f, c);
    }

    ComponentType& ComponentType::
    operator= (const ComponentType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->Transform_ = x.Transform_;
        this->UUID_ = x.UUID_;
        this->Traceability_ = x.Traceability_;
        this->Part_ = x.Part_;
        this->Assembly_ = x.Assembly_;
      }

      return *this;
    }

    ComponentType::
    ~ComponentType ()
    {
    }

    // ComponentSetType
    //

    ComponentSetType::
    ComponentSetType ()
    : ::xml_schema::type (),
      Component_ (this),
      n_ (this)
    {
    }

    ComponentSetType::
    ComponentSetType (const n_type& n)
    : ::xml_schema::type (),
      Component_ (this),
      n_ (n, this)
    {
    }

    ComponentSetType::
    ComponentSetType (const ComponentSetType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Component_ (x.Component_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ComponentSetType::
    ComponentSetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Component_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Component
        //
        if (n.name () == L"Component" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Component_type > r (
            Component_traits::create (i, f, this));

          this->Component_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ComponentSetType* ComponentSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentSetType (*this, f, c);
    }

    ComponentSetType& ComponentSetType::
    operator= (const ComponentSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Component_ = x.Component_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ComponentSetType::
    ~ComponentSetType ()
    {
    }

    // PrintedDrawingType
    //

    PrintedDrawingType::
    PrintedDrawingType ()
    : ::xml_schema::type (),
      Name_ (this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      DrawingNumber_ (this),
      AdditionalChanges_ (this),
      Location_ (this),
      id_ (this)
    {
    }

    PrintedDrawingType::
    PrintedDrawingType (const Name_type& Name,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      DrawingNumber_ (this),
      AdditionalChanges_ (this),
      Location_ (this),
      id_ (id, this)
    {
    }

    PrintedDrawingType::
    PrintedDrawingType (const PrintedDrawingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this),
      Author_ (x.Author_, f, this),
      DrawingNumber_ (x.DrawingNumber_, f, this),
      AdditionalChanges_ (x.AdditionalChanges_, f, this),
      Location_ (x.Location_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PrintedDrawingType::
    PrintedDrawingType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      DrawingNumber_ (this),
      AdditionalChanges_ (this),
      Location_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PrintedDrawingType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Author
        //
        if (n.name () == L"Author" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (::std::move (r));
            continue;
          }
        }

        // DrawingNumber
        //
        if (n.name () == L"DrawingNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DrawingNumber_type > r (
            DrawingNumber_traits::create (i, f, this));

          if (!this->DrawingNumber_)
          {
            this->DrawingNumber_.set (::std::move (r));
            continue;
          }
        }

        // AdditionalChanges
        //
        if (n.name () == L"AdditionalChanges" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AdditionalChanges_type > r (
            AdditionalChanges_traits::create (i, f, this));

          if (!this->AdditionalChanges_)
          {
            this->AdditionalChanges_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    PrintedDrawingType* PrintedDrawingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrintedDrawingType (*this, f, c);
    }

    PrintedDrawingType& PrintedDrawingType::
    operator= (const PrintedDrawingType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Version_ = x.Version_;
        this->Description_ = x.Description_;
        this->Author_ = x.Author_;
        this->DrawingNumber_ = x.DrawingNumber_;
        this->AdditionalChanges_ = x.AdditionalChanges_;
        this->Location_ = x.Location_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PrintedDrawingType::
    ~PrintedDrawingType ()
    {
    }

    // GDTEnumType
    //

    GDTEnumType::
    GDTEnumType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType::
    GDTEnumType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType::
    GDTEnumType (const ::std::wstring& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType* GDTEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GDTEnumType (*this, f, c);
    }

    GDTEnumType::value GDTEnumType::
    _xsd_GDTEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_GDTEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_GDTEnumType_indexes_,
                        _xsd_GDTEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_GDTEnumType_indexes_ + 4 || _xsd_GDTEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const GDTEnumType::
    _xsd_GDTEnumType_literals_[4] =
    {
      L"UNKNOWN",
      L"HUMANREAD",
      L"MACHINEREAD",
      L"ABSENT"
    };

    const GDTEnumType::value GDTEnumType::
    _xsd_GDTEnumType_indexes_[4] =
    {
      ::xsd::qif30::GDTEnumType::ABSENT,
      ::xsd::qif30::GDTEnumType::HUMANREAD,
      ::xsd::qif30::GDTEnumType::MACHINEREAD,
      ::xsd::qif30::GDTEnumType::UNKNOWN
    };

    // TopologyEnumType
    //

    TopologyEnumType::
    TopologyEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType::
    TopologyEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType::
    TopologyEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType* TopologyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologyEnumType (*this, f, c);
    }

    TopologyEnumType::value TopologyEnumType::
    _xsd_TopologyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_TopologyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TopologyEnumType_indexes_,
                        _xsd_TopologyEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_TopologyEnumType_indexes_ + 3 || _xsd_TopologyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const TopologyEnumType::
    _xsd_TopologyEnumType_literals_[3] =
    {
      L"UNKNOWN",
      L"PRESENT",
      L"ABSENT"
    };

    const TopologyEnumType::value TopologyEnumType::
    _xsd_TopologyEnumType_indexes_[3] =
    {
      ::xsd::qif30::TopologyEnumType::ABSENT,
      ::xsd::qif30::TopologyEnumType::PRESENT,
      ::xsd::qif30::TopologyEnumType::UNKNOWN
    };

    // DigitalModelType
    //

    const DigitalModelType::GDT_type DigitalModelType::GDT_default_value_ (
      L"UNKNOWN");

    const DigitalModelType::Topology_type DigitalModelType::Topology_default_value_ (
      L"UNKNOWN");

    DigitalModelType::
    DigitalModelType ()
    : ::xml_schema::type (),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Units_ (this),
      GDT_ (this),
      Topology_ (this),
      Entities_ (this),
      id_ (this)
    {
    }

    DigitalModelType::
    DigitalModelType (const Name_type& Name,
                      const File_type& File,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      File_ (File, this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Units_ (this),
      GDT_ (this),
      Topology_ (this),
      Entities_ (this),
      id_ (id, this)
    {
    }

    DigitalModelType::
    DigitalModelType (const Name_type& Name,
                      ::std::unique_ptr< File_type > File,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      File_ (std::move (File), this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Units_ (this),
      GDT_ (this),
      Topology_ (this),
      Entities_ (this),
      id_ (id, this)
    {
    }

    DigitalModelType::
    DigitalModelType (const DigitalModelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this),
      Units_ (x.Units_, f, this),
      GDT_ (x.GDT_, f, this),
      Topology_ (x.Topology_, f, this),
      Entities_ (x.Entities_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DigitalModelType::
    DigitalModelType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Units_ (this),
      GDT_ (this),
      Topology_ (this),
      Entities_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DigitalModelType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // File
        //
        if (n.name () == L"File" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!File_.present ())
          {
            this->File_.set (::std::move (r));
            continue;
          }
        }

        // Application
        //
        if (n.name () == L"Application" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (::std::move (r));
            continue;
          }
        }

        // Author
        //
        if (n.name () == L"Author" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (::std::move (r));
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == L"ApplicationSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == L"Units" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // GDT
        //
        if (n.name () == L"GDT" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< GDT_type > r (
            GDT_traits::create (i, f, this));

          if (!this->GDT_)
          {
            this->GDT_.set (::std::move (r));
            continue;
          }
        }

        // Topology
        //
        if (n.name () == L"Topology" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Topology_type > r (
            Topology_traits::create (i, f, this));

          if (!this->Topology_)
          {
            this->Topology_.set (::std::move (r));
            continue;
          }
        }

        // Entities
        //
        if (n.name () == L"Entities" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Entities_type > r (
            Entities_traits::create (i, f, this));

          if (!this->Entities_)
          {
            this->Entities_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!File_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"File",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DigitalModelType* DigitalModelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelType (*this, f, c);
    }

    DigitalModelType& DigitalModelType::
    operator= (const DigitalModelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->File_ = x.File_;
        this->Application_ = x.Application_;
        this->Author_ = x.Author_;
        this->ApplicationSource_ = x.ApplicationSource_;
        this->Description_ = x.Description_;
        this->Units_ = x.Units_;
        this->GDT_ = x.GDT_;
        this->Topology_ = x.Topology_;
        this->Entities_ = x.Entities_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DigitalModelType::
    ~DigitalModelType ()
    {
    }

    // DefinitionExternalType
    //

    DefinitionExternalType::
    DefinitionExternalType ()
    : ::xml_schema::type (),
      PrintedDrawing_ (this),
      DigitalDrawing_ (this),
      DigitalModel_ (this),
      PhysicalModel_ (this),
      n_ (this),
      id_ (this)
    {
    }

    DefinitionExternalType::
    DefinitionExternalType (const n_type& n,
                            const id_type& id)
    : ::xml_schema::type (),
      PrintedDrawing_ (this),
      DigitalDrawing_ (this),
      DigitalModel_ (this),
      PhysicalModel_ (this),
      n_ (n, this),
      id_ (id, this)
    {
    }

    DefinitionExternalType::
    DefinitionExternalType (const DefinitionExternalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrintedDrawing_ (x.PrintedDrawing_, f, this),
      DigitalDrawing_ (x.DigitalDrawing_, f, this),
      DigitalModel_ (x.DigitalModel_, f, this),
      PhysicalModel_ (x.PhysicalModel_, f, this),
      n_ (x.n_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DefinitionExternalType::
    DefinitionExternalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrintedDrawing_ (this),
      DigitalDrawing_ (this),
      DigitalModel_ (this),
      PhysicalModel_ (this),
      n_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DefinitionExternalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PrintedDrawing
        //
        if (n.name () == L"PrintedDrawing" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrintedDrawing_type > r (
            PrintedDrawing_traits::create (i, f, this));

          this->PrintedDrawing_.push_back (::std::move (r));
          continue;
        }

        // DigitalDrawing
        //
        if (n.name () == L"DigitalDrawing" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DigitalDrawing_type > r (
            DigitalDrawing_traits::create (i, f, this));

          this->DigitalDrawing_.push_back (::std::move (r));
          continue;
        }

        // DigitalModel
        //
        if (n.name () == L"DigitalModel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DigitalModel_type > r (
            DigitalModel_traits::create (i, f, this));

          this->DigitalModel_.push_back (::std::move (r));
          continue;
        }

        // PhysicalModel
        //
        if (n.name () == L"PhysicalModel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PhysicalModel_type > r (
            PhysicalModel_traits::create (i, f, this));

          this->PhysicalModel_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DefinitionExternalType* DefinitionExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefinitionExternalType (*this, f, c);
    }

    DefinitionExternalType& DefinitionExternalType::
    operator= (const DefinitionExternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrintedDrawing_ = x.PrintedDrawing_;
        this->DigitalDrawing_ = x.DigitalDrawing_;
        this->DigitalModel_ = x.DigitalModel_;
        this->PhysicalModel_ = x.PhysicalModel_;
        this->n_ = x.n_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DefinitionExternalType::
    ~DefinitionExternalType ()
    {
    }

    // DigitalDrawingType
    //

    DigitalDrawingType::
    DigitalDrawingType ()
    : ::xml_schema::type (),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Entities_ (this),
      id_ (this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const Name_type& Name,
                        const File_type& File,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      File_ (File, this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Entities_ (this),
      id_ (id, this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const Name_type& Name,
                        ::std::unique_ptr< File_type > File,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      File_ (std::move (File), this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Entities_ (this),
      id_ (id, this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const DigitalDrawingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this),
      Entities_ (x.Entities_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this),
      Entities_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DigitalDrawingType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // File
        //
        if (n.name () == L"File" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!File_.present ())
          {
            this->File_.set (::std::move (r));
            continue;
          }
        }

        // Application
        //
        if (n.name () == L"Application" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (::std::move (r));
            continue;
          }
        }

        // Author
        //
        if (n.name () == L"Author" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (::std::move (r));
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == L"ApplicationSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Entities
        //
        if (n.name () == L"Entities" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Entities_type > r (
            Entities_traits::create (i, f, this));

          if (!this->Entities_)
          {
            this->Entities_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!File_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"File",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    DigitalDrawingType* DigitalDrawingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalDrawingType (*this, f, c);
    }

    DigitalDrawingType& DigitalDrawingType::
    operator= (const DigitalDrawingType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->File_ = x.File_;
        this->Application_ = x.Application_;
        this->Author_ = x.Author_;
        this->ApplicationSource_ = x.ApplicationSource_;
        this->Description_ = x.Description_;
        this->Entities_ = x.Entities_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DigitalDrawingType::
    ~DigitalDrawingType ()
    {
    }

    // PhysicalModelType
    //

    PhysicalModelType::
    PhysicalModelType ()
    : ::xml_schema::type (),
      Name_ (this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      Location_ (this),
      ModelNumber_ (this),
      id_ (this)
    {
    }

    PhysicalModelType::
    PhysicalModelType (const Name_type& Name,
                       const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      Location_ (this),
      ModelNumber_ (this),
      id_ (id, this)
    {
    }

    PhysicalModelType::
    PhysicalModelType (const PhysicalModelType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this),
      Author_ (x.Author_, f, this),
      Location_ (x.Location_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PhysicalModelType::
    PhysicalModelType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Version_ (this),
      Description_ (this),
      Author_ (this),
      Location_ (this),
      ModelNumber_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PhysicalModelType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Author
        //
        if (n.name () == L"Author" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == L"ModelNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    PhysicalModelType* PhysicalModelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PhysicalModelType (*this, f, c);
    }

    PhysicalModelType& PhysicalModelType::
    operator= (const PhysicalModelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Version_ = x.Version_;
        this->Description_ = x.Description_;
        this->Author_ = x.Author_;
        this->Location_ = x.Location_;
        this->ModelNumber_ = x.ModelNumber_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PhysicalModelType::
    ~PhysicalModelType ()
    {
    }

    // PartAssemblyHeaderType
    //

    PartAssemblyHeaderType::
    PartAssemblyHeaderType ()
    : ::xml_schema::type (),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this)
    {
    }

    PartAssemblyHeaderType::
    PartAssemblyHeaderType (const PartAssemblyHeaderType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    PartAssemblyHeaderType::
    PartAssemblyHeaderType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      File_ (this),
      Application_ (this),
      Author_ (this),
      ApplicationSource_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PartAssemblyHeaderType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // File
        //
        if (n.name () == L"File" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!this->File_)
          {
            this->File_.set (::std::move (r));
            continue;
          }
        }

        // Application
        //
        if (n.name () == L"Application" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (::std::move (r));
            continue;
          }
        }

        // Author
        //
        if (n.name () == L"Author" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (::std::move (r));
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == L"ApplicationSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PartAssemblyHeaderType* PartAssemblyHeaderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartAssemblyHeaderType (*this, f, c);
    }

    PartAssemblyHeaderType& PartAssemblyHeaderType::
    operator= (const PartAssemblyHeaderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->File_ = x.File_;
        this->Application_ = x.Application_;
        this->Author_ = x.Author_;
        this->ApplicationSource_ = x.ApplicationSource_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    PartAssemblyHeaderType::
    ~PartAssemblyHeaderType ()
    {
    }

    // ProductHeaderType
    //

    ProductHeaderType::
    ProductHeaderType ()
    : ::xsd::qif30::PartAssemblyHeaderType (),
      ScaleCoefficient_ (this),
      ModelTolerance_ (this),
      MassPropertyTolerance_ (this)
    {
    }

    ProductHeaderType::
    ProductHeaderType (const ProductHeaderType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyHeaderType (x, f, c),
      ScaleCoefficient_ (x.ScaleCoefficient_, f, this),
      ModelTolerance_ (x.ModelTolerance_, f, this),
      MassPropertyTolerance_ (x.MassPropertyTolerance_, f, this)
    {
    }

    ProductHeaderType::
    ProductHeaderType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::PartAssemblyHeaderType (e, f | ::xml_schema::flags::base, c),
      ScaleCoefficient_ (this),
      ModelTolerance_ (this),
      MassPropertyTolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProductHeaderType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PartAssemblyHeaderType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ScaleCoefficient
        //
        if (n.name () == L"ScaleCoefficient" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ScaleCoefficient_)
          {
            this->ScaleCoefficient_.set (ScaleCoefficient_traits::create (i, f, this));
            continue;
          }
        }

        // ModelTolerance
        //
        if (n.name () == L"ModelTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ModelTolerance_)
          {
            this->ModelTolerance_.set (ModelTolerance_traits::create (i, f, this));
            continue;
          }
        }

        // MassPropertyTolerance
        //
        if (n.name () == L"MassPropertyTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->MassPropertyTolerance_)
          {
            this->MassPropertyTolerance_.set (MassPropertyTolerance_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    ProductHeaderType* ProductHeaderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductHeaderType (*this, f, c);
    }

    ProductHeaderType& ProductHeaderType::
    operator= (const ProductHeaderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PartAssemblyHeaderType& > (*this) = x;
        this->ScaleCoefficient_ = x.ScaleCoefficient_;
        this->ModelTolerance_ = x.ModelTolerance_;
        this->MassPropertyTolerance_ = x.MassPropertyTolerance_;
      }

      return *this;
    }

    ProductHeaderType::
    ~ProductHeaderType ()
    {
    }

    // LayerType
    //

    LayerType::
    LayerType ()
    : ::xsd::qif30::DrawableBaseType (),
      ElementIds_ (this),
      applyColor_ (applyColor_default_value (), this),
      index_ (this)
    {
    }

    LayerType::
    LayerType (const id_type& id,
               const index_type& index)
    : ::xsd::qif30::DrawableBaseType (id),
      ElementIds_ (this),
      applyColor_ (applyColor_default_value (), this),
      index_ (index, this)
    {
    }

    LayerType::
    LayerType (const LayerType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      ElementIds_ (x.ElementIds_, f, this),
      applyColor_ (x.applyColor_, f, this),
      index_ (x.index_, f, this)
    {
    }

    LayerType::
    LayerType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      ElementIds_ (this),
      applyColor_ (this),
      index_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LayerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ElementIds
        //
        if (n.name () == L"ElementIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElementIds_type > r (
            ElementIds_traits::create (i, f, this));

          if (!this->ElementIds_)
          {
            this->ElementIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"applyColor" && n.namespace_ ().empty ())
        {
          this->applyColor_.set (applyColor_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!applyColor_.present ())
      {
        this->applyColor_.set (applyColor_default_value ());
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    LayerType* LayerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LayerType (*this, f, c);
    }

    LayerType& LayerType::
    operator= (const LayerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->ElementIds_ = x.ElementIds_;
        this->applyColor_ = x.applyColor_;
        this->index_ = x.index_;
      }

      return *this;
    }

    LayerType::
    ~LayerType ()
    {
    }

    // LayerSetType
    //

    LayerSetType::
    LayerSetType ()
    : ::xml_schema::type (),
      Layer_ (this),
      n_ (this)
    {
    }

    LayerSetType::
    LayerSetType (const n_type& n)
    : ::xml_schema::type (),
      Layer_ (this),
      n_ (n, this)
    {
    }

    LayerSetType::
    LayerSetType (const LayerSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Layer_ (x.Layer_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LayerSetType::
    LayerSetType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Layer_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LayerSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Layer
        //
        if (n.name () == L"Layer" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Layer_type > r (
            Layer_traits::create (i, f, this));

          this->Layer_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LayerSetType* LayerSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LayerSetType (*this, f, c);
    }

    LayerSetType& LayerSetType::
    operator= (const LayerSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Layer_ = x.Layer_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LayerSetType::
    ~LayerSetType ()
    {
    }

    // PartNoteSetType
    //

    PartNoteSetType::
    PartNoteSetType ()
    : ::xml_schema::type (),
      PartNote_ (this),
      n_ (this)
    {
    }

    PartNoteSetType::
    PartNoteSetType (const n_type& n)
    : ::xml_schema::type (),
      PartNote_ (this),
      n_ (n, this)
    {
    }

    PartNoteSetType::
    PartNoteSetType (const PartNoteSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PartNote_ (x.PartNote_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PartNoteSetType::
    PartNoteSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PartNote_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PartNoteSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PartNote
        //
        if (n.name () == L"PartNote" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartNote_type > r (
            PartNote_traits::create (i, f, this));

          this->PartNote_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PartNoteSetType* PartNoteSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartNoteSetType (*this, f, c);
    }

    PartNoteSetType& PartNoteSetType::
    operator= (const PartNoteSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PartNote_ = x.PartNote_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PartNoteSetType::
    ~PartNoteSetType ()
    {
    }

    // PartNoteType
    //

    PartNoteType::
    PartNoteType ()
    : ::xsd::qif30::DrawableBaseType (),
      Text_ (this),
      PartNoteIds_ (this)
    {
    }

    PartNoteType::
    PartNoteType (const id_type& id)
    : ::xsd::qif30::DrawableBaseType (id),
      Text_ (this),
      PartNoteIds_ (this)
    {
    }

    PartNoteType::
    PartNoteType (const PartNoteType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      Text_ (x.Text_, f, this),
      PartNoteIds_ (x.PartNoteIds_, f, this)
    {
    }

    PartNoteType::
    PartNoteType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      Text_ (this),
      PartNoteIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PartNoteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Text
        //
        if (n.name () == L"Text" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!this->Text_)
          {
            this->Text_.set (::std::move (r));
            continue;
          }
        }

        // PartNoteIds
        //
        if (n.name () == L"PartNoteIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PartNoteIds_type > r (
            PartNoteIds_traits::create (i, f, this));

          if (!this->PartNoteIds_)
          {
            this->PartNoteIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PartNoteType* PartNoteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartNoteType (*this, f, c);
    }

    PartNoteType& PartNoteType::
    operator= (const PartNoteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->Text_ = x.Text_;
        this->PartNoteIds_ = x.PartNoteIds_;
      }

      return *this;
    }

    PartNoteType::
    ~PartNoteType ()
    {
    }

    // NoteType
    //

    const NoteType::form_type NoteType::form_default_value_ (
      L"3D");

    NoteType::
    NoteType ()
    : ::xsd::qif30::DrawableBaseType (),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this),
      Text_ (this),
      form_ (form_default_value (), this)
    {
    }

    NoteType::
    NoteType (const id_type& id,
              const Text_type& Text)
    : ::xsd::qif30::DrawableBaseType (id),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this),
      Text_ (Text, this),
      form_ (form_default_value (), this)
    {
    }

    NoteType::
    NoteType (const NoteType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c),
      EntityInternalIds_ (x.EntityInternalIds_, f, this),
      EntityExternalIds_ (x.EntityExternalIds_, f, this),
      Text_ (x.Text_, f, this),
      form_ (x.form_, f, this)
    {
    }

    NoteType::
    NoteType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this),
      Text_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NoteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DrawableBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EntityInternalIds
        //
        if (n.name () == L"EntityInternalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EntityInternalIds_type > r (
            EntityInternalIds_traits::create (i, f, this));

          if (!this->EntityInternalIds_)
          {
            this->EntityInternalIds_.set (::std::move (r));
            continue;
          }
        }

        // EntityExternalIds
        //
        if (n.name () == L"EntityExternalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EntityExternalIds_type > r (
            EntityExternalIds_traits::create (i, f, this));

          if (!this->EntityExternalIds_)
          {
            this->EntityExternalIds_.set (::std::move (r));
            continue;
          }
        }

        // Text
        //
        if (n.name () == L"Text" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!Text_.present ())
          {
            this->Text_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Text",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    NoteType* NoteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteType (*this, f, c);
    }

    NoteType& NoteType::
    operator= (const NoteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DrawableBaseType& > (*this) = x;
        this->EntityInternalIds_ = x.EntityInternalIds_;
        this->EntityExternalIds_ = x.EntityExternalIds_;
        this->Text_ = x.Text_;
        this->form_ = x.form_;
      }

      return *this;
    }

    NoteType::
    ~NoteType ()
    {
    }

    // NoteFormEnumType
    //

    NoteFormEnumType::
    NoteFormEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType::
    NoteFormEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType* NoteFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFormEnumType (*this, f, c);
    }

    NoteFormEnumType::value NoteFormEnumType::
    _xsd_NoteFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_NoteFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_NoteFormEnumType_indexes_,
                        _xsd_NoteFormEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_NoteFormEnumType_indexes_ + 2 || _xsd_NoteFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const NoteFormEnumType::
    _xsd_NoteFormEnumType_literals_[2] =
    {
      L"3D",
      L"SCREEN"
    };

    const NoteFormEnumType::value NoteFormEnumType::
    _xsd_NoteFormEnumType_indexes_[2] =
    {
      ::xsd::qif30::NoteFormEnumType::cxx_3D,
      ::xsd::qif30::NoteFormEnumType::SCREEN
    };

    // NoteSetType
    //

    NoteSetType::
    NoteSetType ()
    : ::xml_schema::type (),
      Note_ (this),
      n_ (this)
    {
    }

    NoteSetType::
    NoteSetType (const n_type& n)
    : ::xml_schema::type (),
      Note_ (this),
      n_ (n, this)
    {
    }

    NoteSetType::
    NoteSetType (const NoteSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Note_ (x.Note_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NoteSetType::
    NoteSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Note_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NoteSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Note
        //
        if (n.name () == L"Note" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Note_type > r (
            Note_traits::create (i, f, this));

          this->Note_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NoteSetType* NoteSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteSetType (*this, f, c);
    }

    NoteSetType& NoteSetType::
    operator= (const NoteSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Note_ = x.Note_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NoteSetType::
    ~NoteSetType ()
    {
    }

    // NoteFlagType
    //

    NoteFlagType::
    NoteFlagType ()
    : ::xsd::qif30::NoteType (),
      TextHidden_ (this),
      URI_ (this)
    {
    }

    NoteFlagType::
    NoteFlagType (const id_type& id,
                  const Text_type& Text)
    : ::xsd::qif30::NoteType (id,
                              Text),
      TextHidden_ (this),
      URI_ (this)
    {
    }

    NoteFlagType::
    NoteFlagType (const NoteFlagType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::NoteType (x, f, c),
      TextHidden_ (x.TextHidden_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    NoteFlagType::
    NoteFlagType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::NoteType (e, f | ::xml_schema::flags::base, c),
      TextHidden_ (this),
      URI_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NoteFlagType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NoteType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TextHidden
        //
        if (n.name () == L"TextHidden" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TextHidden_type > r (
            TextHidden_traits::create (i, f, this));

          if (!this->TextHidden_)
          {
            this->TextHidden_.set (::std::move (r));
            continue;
          }
        }

        // URI
        //
        if (n.name () == L"URI" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!this->URI_)
          {
            this->URI_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    NoteFlagType* NoteFlagType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFlagType (*this, f, c);
    }

    NoteFlagType& NoteFlagType::
    operator= (const NoteFlagType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NoteType& > (*this) = x;
        this->TextHidden_ = x.TextHidden_;
        this->URI_ = x.URI_;
      }

      return *this;
    }

    NoteFlagType::
    ~NoteFlagType ()
    {
    }

    // NoteFlagSetType
    //

    NoteFlagSetType::
    NoteFlagSetType ()
    : ::xml_schema::type (),
      NoteFlag_ (this),
      n_ (this)
    {
    }

    NoteFlagSetType::
    NoteFlagSetType (const n_type& n)
    : ::xml_schema::type (),
      NoteFlag_ (this),
      n_ (n, this)
    {
    }

    NoteFlagSetType::
    NoteFlagSetType (const NoteFlagSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NoteFlag_ (x.NoteFlag_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NoteFlagSetType::
    NoteFlagSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NoteFlag_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NoteFlagSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NoteFlag
        //
        if (n.name () == L"NoteFlag" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NoteFlag_type > r (
            NoteFlag_traits::create (i, f, this));

          this->NoteFlag_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NoteFlagSetType* NoteFlagSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFlagSetType (*this, f, c);
    }

    NoteFlagSetType& NoteFlagSetType::
    operator= (const NoteFlagSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NoteFlag_ = x.NoteFlag_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NoteFlagSetType::
    ~NoteFlagSetType ()
    {
    }

    // FileInternalType
    //

    FileInternalType::
    FileInternalType ()
    : ::xml_schema::type (),
      Name_ (this),
      Version_ (this)
    {
    }

    FileInternalType::
    FileInternalType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Version_ (this)
    {
    }

    FileInternalType::
    FileInternalType (const FileInternalType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this)
    {
    }

    FileInternalType::
    FileInternalType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Version_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileInternalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FileInternalType* FileInternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileInternalType (*this, f, c);
    }

    FileInternalType& FileInternalType::
    operator= (const FileInternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Version_ = x.Version_;
      }

      return *this;
    }

    FileInternalType::
    ~FileInternalType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const ProductType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Header
      //
      if (i.Header ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Header",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Header ();
      }

      // GeometrySet
      //
      if (i.GeometrySet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GeometrySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.GeometrySet ();
      }

      // TopologySet
      //
      if (i.TopologySet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TopologySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TopologySet ();
      }

      // NoteSet
      //
      if (i.NoteSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NoteSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NoteSet ();
      }

      // NoteFlagSet
      //
      if (i.NoteFlagSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NoteFlagSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NoteFlagSet ();
      }

      // PartNoteSet
      //
      if (i.PartNoteSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartNoteSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartNoteSet ();
      }

      // ViewSet
      //
      if (i.ViewSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ViewSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ViewSet ();
      }

      // LayerSet
      //
      if (i.LayerSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LayerSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LayerSet ();
      }

      // CoordinateSystemSet
      //
      if (i.CoordinateSystemSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemSet ();
      }

      // VisualizationSet
      //
      if (i.VisualizationSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VisualizationSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VisualizationSet ();
      }

      // AuxiliarySet
      //
      if (i.AuxiliarySet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AuxiliarySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AuxiliarySet ();
      }

      // PartSet
      //
      if (i.PartSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartSet ();
      }

      // AssemblySet
      //
      if (i.AssemblySet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssemblySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AssemblySet ();
      }

      // ComponentSet
      //
      if (i.ComponentSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentSet ();
      }

      // RootPart
      //
      if (i.RootPart ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RootPart",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RootPart ();
      }

      // RootAssembly
      //
      if (i.RootAssembly ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RootAssembly",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RootAssembly ();
      }

      // RootComponent
      //
      if (i.RootComponent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RootComponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RootComponent ();
      }

      // AsmPaths
      //
      if (i.AsmPaths ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AsmPaths",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AsmPaths ();
      }

      // MaterialLibrary
      //
      if (i.MaterialLibrary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaterialLibrary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaterialLibrary ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AsmPathType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ComponentIds
      //
      if (i.ComponentIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ComponentIds ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AsmPathsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AsmPath
      //
      for (AsmPathsType::AsmPath_const_iterator
           b (i.AsmPath ().begin ()), n (i.AsmPath ().end ());
           b != n; ++b)
      {
        const AsmPathsType::AsmPath_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AsmPath",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationPartAssemblyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Area
      //
      if (i.Area ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Area",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Area ());
      }

      // Centroid
      //
      if (i.Centroid ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Centroid",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Centroid ();
      }

      // Volume
      //
      if (i.Volume ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Volume",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Volume ());
      }

      // Box
      //
      if (i.Box ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Box",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Box ();
      }

      // FacePoints
      //
      if (i.FacePoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FacePoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FacePoints ();
      }

      // EdgePoints
      //
      if (i.EdgePoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgePoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgePoints ();
      }

      // Instances
      //
      if (i.Instances ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Instances",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Instances ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationPartAssemblyInstancesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Instance
      //
      for (ValidationPartAssemblyInstancesType::Instance_const_iterator
           b (i.Instance ().begin ()), n (i.Instance ().end ());
           b != n; ++b)
      {
        const ValidationPartAssemblyInstancesType::Instance_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Instance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationPartAssemblyInstanceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AsmPathId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AsmPathId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AsmPathId ();
      }

      // Centroid
      //
      if (i.Centroid ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Centroid",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Centroid ();
      }

      // Box
      //
      if (i.Box ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Box",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Box ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartAssemblyBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // Validation
      //
      if (i.Validation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Validation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Validation ();
      }

      // Header
      //
      if (i.Header ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Header",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Header ();
      }

      // UUID
      //
      if (i.UUID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UUID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UUID ();
      }

      // ModelNumber
      //
      if (i.ModelNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModelNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ModelNumber ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // SecurityClassification
      //
      if (i.SecurityClassification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecurityClassification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SecurityClassification ();
      }

      // ExportControlClassification
      //
      if (i.ExportControlClassification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExportControlClassification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExportControlClassification ();
      }

      // FeatureNominalIds
      //
      if (i.FeatureNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureNominalIds ();
      }

      // FeatureZoneIds
      //
      if (i.FeatureZoneIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureZoneIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureZoneIds ();
      }

      // CharacteristicNominalIds
      //
      if (i.CharacteristicNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicNominalIds ();
      }

      // NoteIds
      //
      if (i.NoteIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NoteIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NoteIds ();
      }

      // PartNoteIds
      //
      if (i.PartNoteIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartNoteIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartNoteIds ();
      }

      // DatumDefinitionIds
      //
      if (i.DatumDefinitionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumDefinitionIds ();
      }

      // DatumTargetDefinitionIds
      //
      if (i.DatumTargetDefinitionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTargetDefinitionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumTargetDefinitionIds ();
      }

      // DatumReferenceFrameIds
      //
      if (i.DatumReferenceFrameIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumReferenceFrameIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumReferenceFrameIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }

      // CoordinateSystemIds
      //
      if (i.CoordinateSystemIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemIds ();
      }

      // AuxiliaryIds
      //
      if (i.AuxiliaryIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AuxiliaryIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AuxiliaryIds ();
      }

      // ViewIds
      //
      if (i.ViewIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ViewIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ViewIds ();
      }

      // PointCloudIds
      //
      if (i.PointCloudIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointCloudIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointCloudIds ();
      }

      // originMassProperty
      //
      if (i.originMassProperty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"originMassProperty",
            e));

        a << *i.originMassProperty ();
      }

      // materialIndex
      //
      if (i.materialIndex ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"materialIndex",
            e));

        a << *i.materialIndex ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartType& i)
    {
      e << static_cast< const ::xsd::qif30::PartAssemblyBaseType& > (i);

      // DefinitionExternal
      //
      if (i.DefinitionExternal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinitionExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefinitionExternal ();
      }

      // PartFamily
      //
      if (i.PartFamily ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartFamily",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartFamily ();
      }

      // FoldersPart
      //
      if (i.FoldersPart ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FoldersPart",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FoldersPart ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FoldersPartType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FolderPart
      //
      for (FoldersPartType::FolderPart_const_iterator
           b (i.FolderPart ().begin ()), n (i.FolderPart ().end ());
           b != n; ++b)
      {
        const FoldersPartType::FolderPart_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FolderPart",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FoldersAssemblyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FolderAssembly
      //
      for (FoldersAssemblyType::FolderAssembly_const_iterator
           b (i.FolderAssembly ().begin ()), n (i.FolderAssembly ().end ());
           b != n; ++b)
      {
        const FoldersAssemblyType::FolderAssembly_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FolderAssembly",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FolderPartAssemblyBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // FolderIds
      //
      if (i.FolderIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FolderIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FolderIds ();
      }

      // FeatureNominalIds
      //
      if (i.FeatureNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureNominalIds ();
      }

      // FeatureZoneIds
      //
      if (i.FeatureZoneIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureZoneIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureZoneIds ();
      }

      // CharacteristicNominalIds
      //
      if (i.CharacteristicNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicNominalIds ();
      }

      // NoteIds
      //
      if (i.NoteIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NoteIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NoteIds ();
      }

      // PartNoteIds
      //
      if (i.PartNoteIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartNoteIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartNoteIds ();
      }

      // DatumDefinitionIds
      //
      if (i.DatumDefinitionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumDefinitionIds ();
      }

      // DatumTargetDefinitionIds
      //
      if (i.DatumTargetDefinitionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumTargetDefinitionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumTargetDefinitionIds ();
      }

      // DatumReferenceFrameIds
      //
      if (i.DatumReferenceFrameIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumReferenceFrameIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DatumReferenceFrameIds ();
      }

      // BodyIds
      //
      if (i.BodyIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodyIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodyIds ();
      }

      // CoordinateSystemIds
      //
      if (i.CoordinateSystemIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemIds ();
      }

      // AuxiliaryIds
      //
      if (i.AuxiliaryIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AuxiliaryIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AuxiliaryIds ();
      }

      // ViewIds
      //
      if (i.ViewIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ViewIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ViewIds ();
      }

      // PointCloudIds
      //
      if (i.PointCloudIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointCloudIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointCloudIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FolderPartType& i)
    {
      e << static_cast< const ::xsd::qif30::FolderPartAssemblyBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const FolderAssemblyType& i)
    {
      e << static_cast< const ::xsd::qif30::FolderPartAssemblyBaseType& > (i);

      // ComponentIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ComponentIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AssemblyType& i)
    {
      e << static_cast< const ::xsd::qif30::PartAssemblyBaseType& > (i);

      // ComponentIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ComponentIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ComponentIds ();
      }

      // DefinitionExternal
      //
      if (i.DefinitionExternal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefinitionExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefinitionExternal ();
      }

      // FoldersAssembly
      //
      if (i.FoldersAssembly ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FoldersAssembly",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FoldersAssembly ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartFamilyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrimaryShapeClass
      //
      if (i.PrimaryShapeClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryShapeClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PrimaryShapeClass ();
      }

      // MinimumTolerance
      //
      if (i.MinimumTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinimumTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinimumTolerance ();
      }

      // MinimumBoundingBox
      //
      if (i.MinimumBoundingBox ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinimumBoundingBox",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinimumBoundingBox ();
      }

      // PrimaryManufacturingMethod
      //
      if (i.PrimaryManufacturingMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryManufacturingMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PrimaryManufacturingMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Part
      //
      for (PartSetType::Part_const_iterator
           b (i.Part ().begin ()), n (i.Part ().end ());
           b != n; ++b)
      {
        const PartSetType::Part_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Part",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AssemblySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Assembly
      //
      for (AssemblySetType::Assembly_const_iterator
           b (i.Assembly ().begin ()), n (i.Assembly ().end ());
           b != n; ++b)
      {
        const AssemblySetType::Assembly_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Assembly",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ComponentType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // UUID
      //
      if (i.UUID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UUID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UUID ();
      }

      // Traceability
      //
      if (i.Traceability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Traceability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Traceability ();
      }

      // Part
      //
      if (i.Part ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Part",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Part ();
      }

      // Assembly
      //
      if (i.Assembly ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Assembly",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Assembly ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ComponentSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Component
      //
      for (ComponentSetType::Component_const_iterator
           b (i.Component ().begin ()), n (i.Component ().end ());
           b != n; ++b)
      {
        const ComponentSetType::Component_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Component",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PrintedDrawingType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // Author
      //
      if (i.Author ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Author",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Author ();
      }

      // DrawingNumber
      //
      if (i.DrawingNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DrawingNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DrawingNumber ();
      }

      // AdditionalChanges
      //
      if (i.AdditionalChanges ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AdditionalChanges",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AdditionalChanges ();
      }

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GDTEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const GDTEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const GDTEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TopologyEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TopologyEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TopologyEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DigitalModelType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // File
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"File",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.File ();
      }

      // Application
      //
      if (i.Application ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Application",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Application ();
      }

      // Author
      //
      if (i.Author ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Author",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Author ();
      }

      // ApplicationSource
      //
      if (i.ApplicationSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApplicationSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ApplicationSource ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // Units
      //
      if (i.Units ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Units",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Units ();
      }

      // GDT
      //
      if (i.GDT ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GDT",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.GDT ();
      }

      // Topology
      //
      if (i.Topology ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Topology",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Topology ();
      }

      // Entities
      //
      if (i.Entities ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Entities",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Entities ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DefinitionExternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrintedDrawing
      //
      for (DefinitionExternalType::PrintedDrawing_const_iterator
           b (i.PrintedDrawing ().begin ()), n (i.PrintedDrawing ().end ());
           b != n; ++b)
      {
        const DefinitionExternalType::PrintedDrawing_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrintedDrawing",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // DigitalDrawing
      //
      for (DefinitionExternalType::DigitalDrawing_const_iterator
           b (i.DigitalDrawing ().begin ()), n (i.DigitalDrawing ().end ());
           b != n; ++b)
      {
        const DefinitionExternalType::DigitalDrawing_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DigitalDrawing",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // DigitalModel
      //
      for (DefinitionExternalType::DigitalModel_const_iterator
           b (i.DigitalModel ().begin ()), n (i.DigitalModel ().end ());
           b != n; ++b)
      {
        const DefinitionExternalType::DigitalModel_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DigitalModel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // PhysicalModel
      //
      for (DefinitionExternalType::PhysicalModel_const_iterator
           b (i.PhysicalModel ().begin ()), n (i.PhysicalModel ().end ());
           b != n; ++b)
      {
        const DefinitionExternalType::PhysicalModel_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PhysicalModel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigitalDrawingType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // File
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"File",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.File ();
      }

      // Application
      //
      if (i.Application ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Application",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Application ();
      }

      // Author
      //
      if (i.Author ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Author",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Author ();
      }

      // ApplicationSource
      //
      if (i.ApplicationSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApplicationSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ApplicationSource ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // Entities
      //
      if (i.Entities ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Entities",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Entities ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PhysicalModelType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // Author
      //
      if (i.Author ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Author",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Author ();
      }

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // ModelNumber
      //
      if (i.ModelNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModelNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ModelNumber ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartAssemblyHeaderType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // File
      //
      if (i.File ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"File",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.File ();
      }

      // Application
      //
      if (i.Application ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Application",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Application ();
      }

      // Author
      //
      if (i.Author ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Author",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Author ();
      }

      // ApplicationSource
      //
      if (i.ApplicationSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApplicationSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ApplicationSource ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ProductHeaderType& i)
    {
      e << static_cast< const ::xsd::qif30::PartAssemblyHeaderType& > (i);

      // ScaleCoefficient
      //
      if (i.ScaleCoefficient ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleCoefficient",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.ScaleCoefficient ());
      }

      // ModelTolerance
      //
      if (i.ModelTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModelTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.ModelTolerance ());
      }

      // MassPropertyTolerance
      //
      if (i.MassPropertyTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassPropertyTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.MassPropertyTolerance ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LayerType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // ElementIds
      //
      if (i.ElementIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElementIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ElementIds ();
      }

      // applyColor
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"applyColor",
            e));

        a << i.applyColor ();
      }

      // index
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LayerSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Layer
      //
      for (LayerSetType::Layer_const_iterator
           b (i.Layer ().begin ()), n (i.Layer ().end ());
           b != n; ++b)
      {
        const LayerSetType::Layer_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Layer",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartNoteSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PartNote
      //
      for (PartNoteSetType::PartNote_const_iterator
           b (i.PartNote ().begin ()), n (i.PartNote ().end ());
           b != n; ++b)
      {
        const PartNoteSetType::PartNote_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartNote",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PartNoteType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // Text
      //
      if (i.Text ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Text",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Text ();
      }

      // PartNoteIds
      //
      if (i.PartNoteIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PartNoteIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PartNoteIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NoteType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);

      // EntityInternalIds
      //
      if (i.EntityInternalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EntityInternalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EntityInternalIds ();
      }

      // EntityExternalIds
      //
      if (i.EntityExternalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EntityExternalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EntityExternalIds ();
      }

      // Text
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Text",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Text ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NoteFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const NoteFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NoteFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const NoteSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Note
      //
      for (NoteSetType::Note_const_iterator
           b (i.Note ().begin ()), n (i.Note ().end ());
           b != n; ++b)
      {
        const NoteSetType::Note_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Note",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NoteFlagType& i)
    {
      e << static_cast< const ::xsd::qif30::NoteType& > (i);

      // TextHidden
      //
      if (i.TextHidden ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TextHidden",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TextHidden ();
      }

      // URI
      //
      if (i.URI ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"URI",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.URI ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NoteFlagSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NoteFlag
      //
      for (NoteFlagSetType::NoteFlag_const_iterator
           b (i.NoteFlag ().begin ()), n (i.NoteFlag ().end ());
           b != n; ++b)
      {
        const NoteFlagSetType::NoteFlag_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NoteFlag",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FileInternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

