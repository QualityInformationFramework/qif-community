// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFMeasurementResources.hxx"

namespace xsd
{
  namespace qif30
  {
    // MeasurementResourcesType
    //

    const MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version () const
    {
      return this->Version_;
    }

    MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version ()
    {
      return this->Version_;
    }

    void MeasurementResourcesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void MeasurementResourcesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void MeasurementResourcesType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures () const
    {
      return this->Fixtures_;
    }

    MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures ()
    {
      return this->Fixtures_;
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_type& x)
    {
      this->Fixtures_.set (x);
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_optional& x)
    {
      this->Fixtures_ = x;
    }

    void MeasurementResourcesType::
    Fixtures (::std::unique_ptr< Fixtures_type > x)
    {
      this->Fixtures_.set (std::move (x));
    }

    const MeasurementResourcesType::MeasurementRooms_optional& MeasurementResourcesType::
    MeasurementRooms () const
    {
      return this->MeasurementRooms_;
    }

    MeasurementResourcesType::MeasurementRooms_optional& MeasurementResourcesType::
    MeasurementRooms ()
    {
      return this->MeasurementRooms_;
    }

    void MeasurementResourcesType::
    MeasurementRooms (const MeasurementRooms_type& x)
    {
      this->MeasurementRooms_.set (x);
    }

    void MeasurementResourcesType::
    MeasurementRooms (const MeasurementRooms_optional& x)
    {
      this->MeasurementRooms_ = x;
    }

    void MeasurementResourcesType::
    MeasurementRooms (::std::unique_ptr< MeasurementRooms_type > x)
    {
      this->MeasurementRooms_.set (std::move (x));
    }

    const MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices () const
    {
      return this->MeasurementDevices_;
    }

    MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices ()
    {
      return this->MeasurementDevices_;
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_type& x)
    {
      this->MeasurementDevices_.set (x);
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_optional& x)
    {
      this->MeasurementDevices_ = x;
    }

    void MeasurementResourcesType::
    MeasurementDevices (::std::unique_ptr< MeasurementDevices_type > x)
    {
      this->MeasurementDevices_.set (std::move (x));
    }

    const MeasurementResourcesType::DetachableSensors_optional& MeasurementResourcesType::
    DetachableSensors () const
    {
      return this->DetachableSensors_;
    }

    MeasurementResourcesType::DetachableSensors_optional& MeasurementResourcesType::
    DetachableSensors ()
    {
      return this->DetachableSensors_;
    }

    void MeasurementResourcesType::
    DetachableSensors (const DetachableSensors_type& x)
    {
      this->DetachableSensors_.set (x);
    }

    void MeasurementResourcesType::
    DetachableSensors (const DetachableSensors_optional& x)
    {
      this->DetachableSensors_ = x;
    }

    void MeasurementResourcesType::
    DetachableSensors (::std::unique_ptr< DetachableSensors_type > x)
    {
      this->DetachableSensors_.set (std::move (x));
    }

    const MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools () const
    {
      return this->Tools_;
    }

    MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools ()
    {
      return this->Tools_;
    }

    void MeasurementResourcesType::
    Tools (const Tools_type& x)
    {
      this->Tools_.set (x);
    }

    void MeasurementResourcesType::
    Tools (const Tools_optional& x)
    {
      this->Tools_ = x;
    }

    void MeasurementResourcesType::
    Tools (::std::unique_ptr< Tools_type > x)
    {
      this->Tools_.set (std::move (x));
    }


    // MeasurementResourceBaseType
    //

    const MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name () const
    {
      return this->Name_.get ();
    }

    MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name ()
    {
      return this->Name_.get ();
    }

    void MeasurementResourceBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void MeasurementResourceBaseType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description () const
    {
      return this->Description_;
    }

    MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description ()
    {
      return this->Description_;
    }

    void MeasurementResourceBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void MeasurementResourceBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void MeasurementResourceBaseType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer () const
    {
      return this->Manufacturer_;
    }

    MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer ()
    {
      return this->Manufacturer_;
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_type& x)
    {
      this->Manufacturer_.set (x);
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_optional& x)
    {
      this->Manufacturer_ = x;
    }

    void MeasurementResourceBaseType::
    Manufacturer (::std::unique_ptr< Manufacturer_type > x)
    {
      this->Manufacturer_.set (std::move (x));
    }

    const MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void MeasurementResourceBaseType::
    ModelNumber (::std::unique_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber () const
    {
      return this->SerialNumber_;
    }

    MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber ()
    {
      return this->SerialNumber_;
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_optional& x)
    {
      this->SerialNumber_ = x;
    }

    void MeasurementResourceBaseType::
    SerialNumber (::std::unique_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Mass_optional& MeasurementResourceBaseType::
    Mass () const
    {
      return this->Mass_;
    }

    MeasurementResourceBaseType::Mass_optional& MeasurementResourceBaseType::
    Mass ()
    {
      return this->Mass_;
    }

    void MeasurementResourceBaseType::
    Mass (const Mass_type& x)
    {
      this->Mass_.set (x);
    }

    void MeasurementResourceBaseType::
    Mass (const Mass_optional& x)
    {
      this->Mass_ = x;
    }

    void MeasurementResourceBaseType::
    Mass (::std::unique_ptr< Mass_type > x)
    {
      this->Mass_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Size_optional& MeasurementResourceBaseType::
    Size () const
    {
      return this->Size_;
    }

    MeasurementResourceBaseType::Size_optional& MeasurementResourceBaseType::
    Size ()
    {
      return this->Size_;
    }

    void MeasurementResourceBaseType::
    Size (const Size_type& x)
    {
      this->Size_.set (x);
    }

    void MeasurementResourceBaseType::
    Size (const Size_optional& x)
    {
      this->Size_ = x;
    }

    void MeasurementResourceBaseType::
    Size (::std::unique_ptr< Size_type > x)
    {
      this->Size_.set (std::move (x));
    }

    const MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId () const
    {
      return this->LocationId_;
    }

    MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId ()
    {
      return this->LocationId_;
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_type& x)
    {
      this->LocationId_.set (x);
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_optional& x)
    {
      this->LocationId_ = x;
    }

    void MeasurementResourceBaseType::
    LocationId (::std::unique_ptr< LocationId_type > x)
    {
      this->LocationId_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location () const
    {
      return this->Location_;
    }

    MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location ()
    {
      return this->Location_;
    }

    void MeasurementResourceBaseType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void MeasurementResourceBaseType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void MeasurementResourceBaseType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const MeasurementResourceBaseType::Attributes_optional& MeasurementResourceBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    MeasurementResourceBaseType::Attributes_optional& MeasurementResourceBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void MeasurementResourceBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void MeasurementResourceBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void MeasurementResourceBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurementResourceBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurementResourceBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CarriageType
    //

    const CarriageType::ToolIds_optional& CarriageType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CarriageType::ToolIds_optional& CarriageType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CarriageType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CarriageType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CarriageType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }


    // CarriagesType
    //

    const CarriagesType::Carriage_sequence& CarriagesType::
    Carriage () const
    {
      return this->Carriage_;
    }

    CarriagesType::Carriage_sequence& CarriagesType::
    Carriage ()
    {
      return this->Carriage_;
    }

    void CarriagesType::
    Carriage (const Carriage_sequence& s)
    {
      this->Carriage_ = s;
    }

    const CarriagesType::n_type& CarriagesType::
    n () const
    {
      return this->n_.get ();
    }

    CarriagesType::n_type& CarriagesType::
    n ()
    {
      return this->n_.get ();
    }

    void CarriagesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CarriagesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FixturesType
    //

    const FixturesType::Fixture_sequence& FixturesType::
    Fixture () const
    {
      return this->Fixture_;
    }

    FixturesType::Fixture_sequence& FixturesType::
    Fixture ()
    {
      return this->Fixture_;
    }

    void FixturesType::
    Fixture (const Fixture_sequence& s)
    {
      this->Fixture_ = s;
    }

    const FixturesType::n_type& FixturesType::
    n () const
    {
      return this->n_.get ();
    }

    FixturesType::n_type& FixturesType::
    n ()
    {
      return this->n_.get ();
    }

    void FixturesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FixturesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeasurementRoomType
    //

    const MeasurementRoomType::TemperatureRangeMin_type& MeasurementRoomType::
    TemperatureRangeMin () const
    {
      return this->TemperatureRangeMin_.get ();
    }

    MeasurementRoomType::TemperatureRangeMin_type& MeasurementRoomType::
    TemperatureRangeMin ()
    {
      return this->TemperatureRangeMin_.get ();
    }

    void MeasurementRoomType::
    TemperatureRangeMin (const TemperatureRangeMin_type& x)
    {
      this->TemperatureRangeMin_.set (x);
    }

    void MeasurementRoomType::
    TemperatureRangeMin (::std::unique_ptr< TemperatureRangeMin_type > x)
    {
      this->TemperatureRangeMin_.set (std::move (x));
    }

    const MeasurementRoomType::TemperatureRangeMax_type& MeasurementRoomType::
    TemperatureRangeMax () const
    {
      return this->TemperatureRangeMax_.get ();
    }

    MeasurementRoomType::TemperatureRangeMax_type& MeasurementRoomType::
    TemperatureRangeMax ()
    {
      return this->TemperatureRangeMax_.get ();
    }

    void MeasurementRoomType::
    TemperatureRangeMax (const TemperatureRangeMax_type& x)
    {
      this->TemperatureRangeMax_.set (x);
    }

    void MeasurementRoomType::
    TemperatureRangeMax (::std::unique_ptr< TemperatureRangeMax_type > x)
    {
      this->TemperatureRangeMax_.set (std::move (x));
    }

    const MeasurementRoomType::TemperatureControlMin_type& MeasurementRoomType::
    TemperatureControlMin () const
    {
      return this->TemperatureControlMin_.get ();
    }

    MeasurementRoomType::TemperatureControlMin_type& MeasurementRoomType::
    TemperatureControlMin ()
    {
      return this->TemperatureControlMin_.get ();
    }

    void MeasurementRoomType::
    TemperatureControlMin (const TemperatureControlMin_type& x)
    {
      this->TemperatureControlMin_.set (x);
    }

    void MeasurementRoomType::
    TemperatureControlMin (::std::unique_ptr< TemperatureControlMin_type > x)
    {
      this->TemperatureControlMin_.set (std::move (x));
    }

    const MeasurementRoomType::TemperatureControlMax_type& MeasurementRoomType::
    TemperatureControlMax () const
    {
      return this->TemperatureControlMax_.get ();
    }

    MeasurementRoomType::TemperatureControlMax_type& MeasurementRoomType::
    TemperatureControlMax ()
    {
      return this->TemperatureControlMax_.get ();
    }

    void MeasurementRoomType::
    TemperatureControlMax (const TemperatureControlMax_type& x)
    {
      this->TemperatureControlMax_.set (x);
    }

    void MeasurementRoomType::
    TemperatureControlMax (::std::unique_ptr< TemperatureControlMax_type > x)
    {
      this->TemperatureControlMax_.set (std::move (x));
    }

    const MeasurementRoomType::RelativeHumidityRangeMin_type& MeasurementRoomType::
    RelativeHumidityRangeMin () const
    {
      return this->RelativeHumidityRangeMin_.get ();
    }

    MeasurementRoomType::RelativeHumidityRangeMin_type& MeasurementRoomType::
    RelativeHumidityRangeMin ()
    {
      return this->RelativeHumidityRangeMin_.get ();
    }

    void MeasurementRoomType::
    RelativeHumidityRangeMin (const RelativeHumidityRangeMin_type& x)
    {
      this->RelativeHumidityRangeMin_.set (x);
    }

    void MeasurementRoomType::
    RelativeHumidityRangeMin (::std::unique_ptr< RelativeHumidityRangeMin_type > x)
    {
      this->RelativeHumidityRangeMin_.set (std::move (x));
    }

    const MeasurementRoomType::RelativeHumidityRangeMax_type& MeasurementRoomType::
    RelativeHumidityRangeMax () const
    {
      return this->RelativeHumidityRangeMax_.get ();
    }

    MeasurementRoomType::RelativeHumidityRangeMax_type& MeasurementRoomType::
    RelativeHumidityRangeMax ()
    {
      return this->RelativeHumidityRangeMax_.get ();
    }

    void MeasurementRoomType::
    RelativeHumidityRangeMax (const RelativeHumidityRangeMax_type& x)
    {
      this->RelativeHumidityRangeMax_.set (x);
    }

    void MeasurementRoomType::
    RelativeHumidityRangeMax (::std::unique_ptr< RelativeHumidityRangeMax_type > x)
    {
      this->RelativeHumidityRangeMax_.set (std::move (x));
    }

    const MeasurementRoomType::RelativeHumidityControlMin_type& MeasurementRoomType::
    RelativeHumidityControlMin () const
    {
      return this->RelativeHumidityControlMin_.get ();
    }

    MeasurementRoomType::RelativeHumidityControlMin_type& MeasurementRoomType::
    RelativeHumidityControlMin ()
    {
      return this->RelativeHumidityControlMin_.get ();
    }

    void MeasurementRoomType::
    RelativeHumidityControlMin (const RelativeHumidityControlMin_type& x)
    {
      this->RelativeHumidityControlMin_.set (x);
    }

    void MeasurementRoomType::
    RelativeHumidityControlMin (::std::unique_ptr< RelativeHumidityControlMin_type > x)
    {
      this->RelativeHumidityControlMin_.set (std::move (x));
    }

    const MeasurementRoomType::RelativeHumidityControlMax_type& MeasurementRoomType::
    RelativeHumidityControlMax () const
    {
      return this->RelativeHumidityControlMax_.get ();
    }

    MeasurementRoomType::RelativeHumidityControlMax_type& MeasurementRoomType::
    RelativeHumidityControlMax ()
    {
      return this->RelativeHumidityControlMax_.get ();
    }

    void MeasurementRoomType::
    RelativeHumidityControlMax (const RelativeHumidityControlMax_type& x)
    {
      this->RelativeHumidityControlMax_.set (x);
    }

    void MeasurementRoomType::
    RelativeHumidityControlMax (::std::unique_ptr< RelativeHumidityControlMax_type > x)
    {
      this->RelativeHumidityControlMax_.set (std::move (x));
    }


    // MeasurementRoomsType
    //

    const MeasurementRoomsType::MeasurementRoom_sequence& MeasurementRoomsType::
    MeasurementRoom () const
    {
      return this->MeasurementRoom_;
    }

    MeasurementRoomsType::MeasurementRoom_sequence& MeasurementRoomsType::
    MeasurementRoom ()
    {
      return this->MeasurementRoom_;
    }

    void MeasurementRoomsType::
    MeasurementRoom (const MeasurementRoom_sequence& s)
    {
      this->MeasurementRoom_ = s;
    }

    const MeasurementRoomsType::n_type& MeasurementRoomsType::
    n () const
    {
      return this->n_.get ();
    }

    MeasurementRoomsType::n_type& MeasurementRoomsType::
    n ()
    {
      return this->n_.get ();
    }

    void MeasurementRoomsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MeasurementRoomsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FixtureType
    //


    // SensorType
    //

    const SensorType::ProtectionClass_optional& SensorType::
    ProtectionClass () const
    {
      return this->ProtectionClass_;
    }

    SensorType::ProtectionClass_optional& SensorType::
    ProtectionClass ()
    {
      return this->ProtectionClass_;
    }

    void SensorType::
    ProtectionClass (const ProtectionClass_type& x)
    {
      this->ProtectionClass_.set (x);
    }

    void SensorType::
    ProtectionClass (const ProtectionClass_optional& x)
    {
      this->ProtectionClass_ = x;
    }

    void SensorType::
    ProtectionClass (::std::unique_ptr< ProtectionClass_type > x)
    {
      this->ProtectionClass_.set (std::move (x));
    }

    const SensorType::LinearityError_optional& SensorType::
    LinearityError () const
    {
      return this->LinearityError_;
    }

    SensorType::LinearityError_optional& SensorType::
    LinearityError ()
    {
      return this->LinearityError_;
    }

    void SensorType::
    LinearityError (const LinearityError_type& x)
    {
      this->LinearityError_.set (x);
    }

    void SensorType::
    LinearityError (const LinearityError_optional& x)
    {
      this->LinearityError_ = x;
    }

    void SensorType::
    LinearityError (::std::unique_ptr< LinearityError_type > x)
    {
      this->LinearityError_.set (std::move (x));
    }

    const SensorType::Repeatability_optional& SensorType::
    Repeatability () const
    {
      return this->Repeatability_;
    }

    SensorType::Repeatability_optional& SensorType::
    Repeatability ()
    {
      return this->Repeatability_;
    }

    void SensorType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void SensorType::
    Repeatability (const Repeatability_optional& x)
    {
      this->Repeatability_ = x;
    }

    void SensorType::
    Repeatability (::std::unique_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (std::move (x));
    }

    const SensorType::Sensitivity_optional& SensorType::
    Sensitivity () const
    {
      return this->Sensitivity_;
    }

    SensorType::Sensitivity_optional& SensorType::
    Sensitivity ()
    {
      return this->Sensitivity_;
    }

    void SensorType::
    Sensitivity (const Sensitivity_type& x)
    {
      this->Sensitivity_.set (x);
    }

    void SensorType::
    Sensitivity (const Sensitivity_optional& x)
    {
      this->Sensitivity_ = x;
    }

    const SensorType::Resolution_optional& SensorType::
    Resolution () const
    {
      return this->Resolution_;
    }

    SensorType::Resolution_optional& SensorType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void SensorType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void SensorType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void SensorType::
    Resolution (::std::unique_ptr< Resolution_type > x)
    {
      this->Resolution_.set (std::move (x));
    }

    const SensorType::EnvironmentalRange_optional& SensorType::
    EnvironmentalRange () const
    {
      return this->EnvironmentalRange_;
    }

    SensorType::EnvironmentalRange_optional& SensorType::
    EnvironmentalRange ()
    {
      return this->EnvironmentalRange_;
    }

    void SensorType::
    EnvironmentalRange (const EnvironmentalRange_type& x)
    {
      this->EnvironmentalRange_.set (x);
    }

    void SensorType::
    EnvironmentalRange (const EnvironmentalRange_optional& x)
    {
      this->EnvironmentalRange_ = x;
    }

    void SensorType::
    EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > x)
    {
      this->EnvironmentalRange_.set (std::move (x));
    }


    // LaserType
    //

    const LaserType::LaserSource_optional& LaserType::
    LaserSource () const
    {
      return this->LaserSource_;
    }

    LaserType::LaserSource_optional& LaserType::
    LaserSource ()
    {
      return this->LaserSource_;
    }

    void LaserType::
    LaserSource (const LaserSource_type& x)
    {
      this->LaserSource_.set (x);
    }

    void LaserType::
    LaserSource (const LaserSource_optional& x)
    {
      this->LaserSource_ = x;
    }

    void LaserType::
    LaserSource (::std::unique_ptr< LaserSource_type > x)
    {
      this->LaserSource_.set (std::move (x));
    }

    const LaserType::LaserWaveLength_optional& LaserType::
    LaserWaveLength () const
    {
      return this->LaserWaveLength_;
    }

    LaserType::LaserWaveLength_optional& LaserType::
    LaserWaveLength ()
    {
      return this->LaserWaveLength_;
    }

    void LaserType::
    LaserWaveLength (const LaserWaveLength_type& x)
    {
      this->LaserWaveLength_.set (x);
    }

    void LaserType::
    LaserWaveLength (const LaserWaveLength_optional& x)
    {
      this->LaserWaveLength_ = x;
    }

    void LaserType::
    LaserWaveLength (::std::unique_ptr< LaserWaveLength_type > x)
    {
      this->LaserWaveLength_.set (std::move (x));
    }

    const LaserType::LaserPower_optional& LaserType::
    LaserPower () const
    {
      return this->LaserPower_;
    }

    LaserType::LaserPower_optional& LaserType::
    LaserPower ()
    {
      return this->LaserPower_;
    }

    void LaserType::
    LaserPower (const LaserPower_type& x)
    {
      this->LaserPower_.set (x);
    }

    void LaserType::
    LaserPower (const LaserPower_optional& x)
    {
      this->LaserPower_ = x;
    }

    void LaserType::
    LaserPower (::std::unique_ptr< LaserPower_type > x)
    {
      this->LaserPower_.set (std::move (x));
    }

    const LaserType::LaserSafetyClass_optional& LaserType::
    LaserSafetyClass () const
    {
      return this->LaserSafetyClass_;
    }

    LaserType::LaserSafetyClass_optional& LaserType::
    LaserSafetyClass ()
    {
      return this->LaserSafetyClass_;
    }

    void LaserType::
    LaserSafetyClass (const LaserSafetyClass_type& x)
    {
      this->LaserSafetyClass_.set (x);
    }

    void LaserType::
    LaserSafetyClass (const LaserSafetyClass_optional& x)
    {
      this->LaserSafetyClass_ = x;
    }

    void LaserType::
    LaserSafetyClass (::std::unique_ptr< LaserSafetyClass_type > x)
    {
      this->LaserSafetyClass_.set (std::move (x));
    }

    const LaserType::LaserEffectiveLength_optional& LaserType::
    LaserEffectiveLength () const
    {
      return this->LaserEffectiveLength_;
    }

    LaserType::LaserEffectiveLength_optional& LaserType::
    LaserEffectiveLength ()
    {
      return this->LaserEffectiveLength_;
    }

    void LaserType::
    LaserEffectiveLength (const LaserEffectiveLength_type& x)
    {
      this->LaserEffectiveLength_.set (x);
    }

    void LaserType::
    LaserEffectiveLength (const LaserEffectiveLength_optional& x)
    {
      this->LaserEffectiveLength_ = x;
    }

    void LaserType::
    LaserEffectiveLength (::std::unique_ptr< LaserEffectiveLength_type > x)
    {
      this->LaserEffectiveLength_.set (std::move (x));
    }

    const LaserType::LaserSpotSize_optional& LaserType::
    LaserSpotSize () const
    {
      return this->LaserSpotSize_;
    }

    LaserType::LaserSpotSize_optional& LaserType::
    LaserSpotSize ()
    {
      return this->LaserSpotSize_;
    }

    void LaserType::
    LaserSpotSize (const LaserSpotSize_type& x)
    {
      this->LaserSpotSize_.set (x);
    }

    void LaserType::
    LaserSpotSize (const LaserSpotSize_optional& x)
    {
      this->LaserSpotSize_ = x;
    }

    void LaserType::
    LaserSpotSize (::std::unique_ptr< LaserSpotSize_type > x)
    {
      this->LaserSpotSize_.set (std::move (x));
    }

    const LaserType::LaserPowerSupply_optional& LaserType::
    LaserPowerSupply () const
    {
      return this->LaserPowerSupply_;
    }

    LaserType::LaserPowerSupply_optional& LaserType::
    LaserPowerSupply ()
    {
      return this->LaserPowerSupply_;
    }

    void LaserType::
    LaserPowerSupply (const LaserPowerSupply_type& x)
    {
      this->LaserPowerSupply_.set (x);
    }

    void LaserType::
    LaserPowerSupply (const LaserPowerSupply_optional& x)
    {
      this->LaserPowerSupply_ = x;
    }

    void LaserType::
    LaserPowerSupply (::std::unique_ptr< LaserPowerSupply_type > x)
    {
      this->LaserPowerSupply_.set (std::move (x));
    }


    // DetachableSensorBaseType
    //


    // DetachableSensorsType
    //

    const DetachableSensorsType::DetachableSensor_sequence& DetachableSensorsType::
    DetachableSensor () const
    {
      return this->DetachableSensor_;
    }

    DetachableSensorsType::DetachableSensor_sequence& DetachableSensorsType::
    DetachableSensor ()
    {
      return this->DetachableSensor_;
    }

    void DetachableSensorsType::
    DetachableSensor (const DetachableSensor_sequence& s)
    {
      this->DetachableSensor_ = s;
    }

    const DetachableSensorsType::n_type& DetachableSensorsType::
    n () const
    {
      return this->n_.get ();
    }

    DetachableSensorsType::n_type& DetachableSensorsType::
    n ()
    {
      return this->n_.get ();
    }

    void DetachableSensorsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DetachableSensorsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ToolsType
    //

    const ToolsType::Tool_sequence& ToolsType::
    Tool () const
    {
      return this->Tool_;
    }

    ToolsType::Tool_sequence& ToolsType::
    Tool ()
    {
      return this->Tool_;
    }

    void ToolsType::
    Tool (const Tool_sequence& s)
    {
      this->Tool_ = s;
    }

    const ToolsType::n_type& ToolsType::
    n () const
    {
      return this->n_.get ();
    }

    ToolsType::n_type& ToolsType::
    n ()
    {
      return this->n_.get ();
    }

    void ToolsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ToolsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ToolBaseType
    //


    // ToolWithIntegratedSensorBaseType
    //


    // ToolWithLVDTSensorType
    //

    const ToolWithLVDTSensorType::LVDTSensor_type& ToolWithLVDTSensorType::
    LVDTSensor () const
    {
      return this->LVDTSensor_.get ();
    }

    ToolWithLVDTSensorType::LVDTSensor_type& ToolWithLVDTSensorType::
    LVDTSensor ()
    {
      return this->LVDTSensor_.get ();
    }

    void ToolWithLVDTSensorType::
    LVDTSensor (const LVDTSensor_type& x)
    {
      this->LVDTSensor_.set (x);
    }

    void ToolWithLVDTSensorType::
    LVDTSensor (::std::unique_ptr< LVDTSensor_type > x)
    {
      this->LVDTSensor_.set (std::move (x));
    }


    // ToolWithCapacitiveSensorType
    //

    const ToolWithCapacitiveSensorType::CapacitiveSensor_type& ToolWithCapacitiveSensorType::
    CapacitiveSensor () const
    {
      return this->CapacitiveSensor_.get ();
    }

    ToolWithCapacitiveSensorType::CapacitiveSensor_type& ToolWithCapacitiveSensorType::
    CapacitiveSensor ()
    {
      return this->CapacitiveSensor_.get ();
    }

    void ToolWithCapacitiveSensorType::
    CapacitiveSensor (const CapacitiveSensor_type& x)
    {
      this->CapacitiveSensor_.set (x);
    }

    void ToolWithCapacitiveSensorType::
    CapacitiveSensor (::std::unique_ptr< CapacitiveSensor_type > x)
    {
      this->CapacitiveSensor_.set (std::move (x));
    }


    // ToolWithEddyCurrentSensorType
    //

    const ToolWithEddyCurrentSensorType::EddyCurrentSensor_type& ToolWithEddyCurrentSensorType::
    EddyCurrentSensor () const
    {
      return this->EddyCurrentSensor_.get ();
    }

    ToolWithEddyCurrentSensorType::EddyCurrentSensor_type& ToolWithEddyCurrentSensorType::
    EddyCurrentSensor ()
    {
      return this->EddyCurrentSensor_.get ();
    }

    void ToolWithEddyCurrentSensorType::
    EddyCurrentSensor (const EddyCurrentSensor_type& x)
    {
      this->EddyCurrentSensor_.set (x);
    }

    void ToolWithEddyCurrentSensorType::
    EddyCurrentSensor (::std::unique_ptr< EddyCurrentSensor_type > x)
    {
      this->EddyCurrentSensor_.set (std::move (x));
    }


    // ToolWithConfocalChromaticSensorType
    //

    const ToolWithConfocalChromaticSensorType::ConfocalChromaticSensor_type& ToolWithConfocalChromaticSensorType::
    ConfocalChromaticSensor () const
    {
      return this->ConfocalChromaticSensor_.get ();
    }

    ToolWithConfocalChromaticSensorType::ConfocalChromaticSensor_type& ToolWithConfocalChromaticSensorType::
    ConfocalChromaticSensor ()
    {
      return this->ConfocalChromaticSensor_.get ();
    }

    void ToolWithConfocalChromaticSensorType::
    ConfocalChromaticSensor (const ConfocalChromaticSensor_type& x)
    {
      this->ConfocalChromaticSensor_.set (x);
    }

    void ToolWithConfocalChromaticSensorType::
    ConfocalChromaticSensor (::std::unique_ptr< ConfocalChromaticSensor_type > x)
    {
      this->ConfocalChromaticSensor_.set (std::move (x));
    }


    // ToolWithDrawWireSensorType
    //

    const ToolWithDrawWireSensorType::DrawWireSensor_type& ToolWithDrawWireSensorType::
    DrawWireSensor () const
    {
      return this->DrawWireSensor_.get ();
    }

    ToolWithDrawWireSensorType::DrawWireSensor_type& ToolWithDrawWireSensorType::
    DrawWireSensor ()
    {
      return this->DrawWireSensor_.get ();
    }

    void ToolWithDrawWireSensorType::
    DrawWireSensor (const DrawWireSensor_type& x)
    {
      this->DrawWireSensor_.set (x);
    }

    void ToolWithDrawWireSensorType::
    DrawWireSensor (::std::unique_ptr< DrawWireSensor_type > x)
    {
      this->DrawWireSensor_.set (std::move (x));
    }


    // ToolWithMagnetoInductiveSensorType
    //

    const ToolWithMagnetoInductiveSensorType::MagnetoInductiveSensor_type& ToolWithMagnetoInductiveSensorType::
    MagnetoInductiveSensor () const
    {
      return this->MagnetoInductiveSensor_.get ();
    }

    ToolWithMagnetoInductiveSensorType::MagnetoInductiveSensor_type& ToolWithMagnetoInductiveSensorType::
    MagnetoInductiveSensor ()
    {
      return this->MagnetoInductiveSensor_.get ();
    }

    void ToolWithMagnetoInductiveSensorType::
    MagnetoInductiveSensor (const MagnetoInductiveSensor_type& x)
    {
      this->MagnetoInductiveSensor_.set (x);
    }

    void ToolWithMagnetoInductiveSensorType::
    MagnetoInductiveSensor (::std::unique_ptr< MagnetoInductiveSensor_type > x)
    {
      this->MagnetoInductiveSensor_.set (std::move (x));
    }


    // ToolWithDVRTSensorType
    //

    const ToolWithDVRTSensorType::DVRTSensor_type& ToolWithDVRTSensorType::
    DVRTSensor () const
    {
      return this->DVRTSensor_.get ();
    }

    ToolWithDVRTSensorType::DVRTSensor_type& ToolWithDVRTSensorType::
    DVRTSensor ()
    {
      return this->DVRTSensor_.get ();
    }

    void ToolWithDVRTSensorType::
    DVRTSensor (const DVRTSensor_type& x)
    {
      this->DVRTSensor_.set (x);
    }

    void ToolWithDVRTSensorType::
    DVRTSensor (::std::unique_ptr< DVRTSensor_type > x)
    {
      this->DVRTSensor_.set (std::move (x));
    }


    // ToolWithLaserTriangulationSensorType
    //

    const ToolWithLaserTriangulationSensorType::LaserTriangulationSensor_type& ToolWithLaserTriangulationSensorType::
    LaserTriangulationSensor () const
    {
      return this->LaserTriangulationSensor_.get ();
    }

    ToolWithLaserTriangulationSensorType::LaserTriangulationSensor_type& ToolWithLaserTriangulationSensorType::
    LaserTriangulationSensor ()
    {
      return this->LaserTriangulationSensor_.get ();
    }

    void ToolWithLaserTriangulationSensorType::
    LaserTriangulationSensor (const LaserTriangulationSensor_type& x)
    {
      this->LaserTriangulationSensor_.set (x);
    }

    void ToolWithLaserTriangulationSensorType::
    LaserTriangulationSensor (::std::unique_ptr< LaserTriangulationSensor_type > x)
    {
      this->LaserTriangulationSensor_.set (std::move (x));
    }


    // ToolWithStructuredLightSensorType
    //

    const ToolWithStructuredLightSensorType::StructuredLightSensor_type& ToolWithStructuredLightSensorType::
    StructuredLightSensor () const
    {
      return this->StructuredLightSensor_.get ();
    }

    ToolWithStructuredLightSensorType::StructuredLightSensor_type& ToolWithStructuredLightSensorType::
    StructuredLightSensor ()
    {
      return this->StructuredLightSensor_.get ();
    }

    void ToolWithStructuredLightSensorType::
    StructuredLightSensor (const StructuredLightSensor_type& x)
    {
      this->StructuredLightSensor_.set (x);
    }

    void ToolWithStructuredLightSensorType::
    StructuredLightSensor (::std::unique_ptr< StructuredLightSensor_type > x)
    {
      this->StructuredLightSensor_.set (std::move (x));
    }


    // ToolWithUltrasonicSensorType
    //

    const ToolWithUltrasonicSensorType::UltrasonicSensor_type& ToolWithUltrasonicSensorType::
    UltrasonicSensor () const
    {
      return this->UltrasonicSensor_.get ();
    }

    ToolWithUltrasonicSensorType::UltrasonicSensor_type& ToolWithUltrasonicSensorType::
    UltrasonicSensor ()
    {
      return this->UltrasonicSensor_.get ();
    }

    void ToolWithUltrasonicSensorType::
    UltrasonicSensor (const UltrasonicSensor_type& x)
    {
      this->UltrasonicSensor_.set (x);
    }

    void ToolWithUltrasonicSensorType::
    UltrasonicSensor (::std::unique_ptr< UltrasonicSensor_type > x)
    {
      this->UltrasonicSensor_.set (std::move (x));
    }


    // ToolWithSimpleTactileProbeSensorType
    //

    const ToolWithSimpleTactileProbeSensorType::SimpleTactileProbeSensor_type& ToolWithSimpleTactileProbeSensorType::
    SimpleTactileProbeSensor () const
    {
      return this->SimpleTactileProbeSensor_.get ();
    }

    ToolWithSimpleTactileProbeSensorType::SimpleTactileProbeSensor_type& ToolWithSimpleTactileProbeSensorType::
    SimpleTactileProbeSensor ()
    {
      return this->SimpleTactileProbeSensor_.get ();
    }

    void ToolWithSimpleTactileProbeSensorType::
    SimpleTactileProbeSensor (const SimpleTactileProbeSensor_type& x)
    {
      this->SimpleTactileProbeSensor_.set (x);
    }

    void ToolWithSimpleTactileProbeSensorType::
    SimpleTactileProbeSensor (::std::unique_ptr< SimpleTactileProbeSensor_type > x)
    {
      this->SimpleTactileProbeSensor_.set (std::move (x));
    }


    // ToolWithComplexTactileProbeSensorType
    //

    const ToolWithComplexTactileProbeSensorType::ComplexTactileProbeSensor_type& ToolWithComplexTactileProbeSensorType::
    ComplexTactileProbeSensor () const
    {
      return this->ComplexTactileProbeSensor_.get ();
    }

    ToolWithComplexTactileProbeSensorType::ComplexTactileProbeSensor_type& ToolWithComplexTactileProbeSensorType::
    ComplexTactileProbeSensor ()
    {
      return this->ComplexTactileProbeSensor_.get ();
    }

    void ToolWithComplexTactileProbeSensorType::
    ComplexTactileProbeSensor (const ComplexTactileProbeSensor_type& x)
    {
      this->ComplexTactileProbeSensor_.set (x);
    }

    void ToolWithComplexTactileProbeSensorType::
    ComplexTactileProbeSensor (::std::unique_ptr< ComplexTactileProbeSensor_type > x)
    {
      this->ComplexTactileProbeSensor_.set (std::move (x));
    }


    // ToolWithCCDCameraSensorType
    //

    const ToolWithCCDCameraSensorType::ChargeCoupledDeviceCameraSensor_type& ToolWithCCDCameraSensorType::
    ChargeCoupledDeviceCameraSensor () const
    {
      return this->ChargeCoupledDeviceCameraSensor_.get ();
    }

    ToolWithCCDCameraSensorType::ChargeCoupledDeviceCameraSensor_type& ToolWithCCDCameraSensorType::
    ChargeCoupledDeviceCameraSensor ()
    {
      return this->ChargeCoupledDeviceCameraSensor_.get ();
    }

    void ToolWithCCDCameraSensorType::
    ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_type& x)
    {
      this->ChargeCoupledDeviceCameraSensor_.set (x);
    }

    void ToolWithCCDCameraSensorType::
    ChargeCoupledDeviceCameraSensor (::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > x)
    {
      this->ChargeCoupledDeviceCameraSensor_.set (std::move (x));
    }


    // ToolWithDetachableSensorsType
    //

    const ToolWithDetachableSensorsType::SensorIds_optional& ToolWithDetachableSensorsType::
    SensorIds () const
    {
      return this->SensorIds_;
    }

    ToolWithDetachableSensorsType::SensorIds_optional& ToolWithDetachableSensorsType::
    SensorIds ()
    {
      return this->SensorIds_;
    }

    void ToolWithDetachableSensorsType::
    SensorIds (const SensorIds_type& x)
    {
      this->SensorIds_.set (x);
    }

    void ToolWithDetachableSensorsType::
    SensorIds (const SensorIds_optional& x)
    {
      this->SensorIds_ = x;
    }

    void ToolWithDetachableSensorsType::
    SensorIds (::std::unique_ptr< SensorIds_type > x)
    {
      this->SensorIds_.set (std::move (x));
    }


    // MeasurementDevicesType
    //

    const MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice () const
    {
      return this->MeasurementDevice_;
    }

    MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice ()
    {
      return this->MeasurementDevice_;
    }

    void MeasurementDevicesType::
    MeasurementDevice (const MeasurementDevice_sequence& s)
    {
      this->MeasurementDevice_ = s;
    }

    const MeasurementDevicesType::n_type& MeasurementDevicesType::
    n () const
    {
      return this->n_.get ();
    }

    MeasurementDevicesType::n_type& MeasurementDevicesType::
    n ()
    {
      return this->n_.get ();
    }

    void MeasurementDevicesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MeasurementDevicesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeasurementDeviceType
    //

    const MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations () const
    {
      return this->Calibrations_;
    }

    MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations ()
    {
      return this->Calibrations_;
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_type& x)
    {
      this->Calibrations_.set (x);
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_optional& x)
    {
      this->Calibrations_ = x;
    }

    void MeasurementDeviceType::
    Calibrations (::std::unique_ptr< Calibrations_type > x)
    {
      this->Calibrations_.set (std::move (x));
    }

    const MeasurementDeviceType::EnvironmentalRange_optional& MeasurementDeviceType::
    EnvironmentalRange () const
    {
      return this->EnvironmentalRange_;
    }

    MeasurementDeviceType::EnvironmentalRange_optional& MeasurementDeviceType::
    EnvironmentalRange ()
    {
      return this->EnvironmentalRange_;
    }

    void MeasurementDeviceType::
    EnvironmentalRange (const EnvironmentalRange_type& x)
    {
      this->EnvironmentalRange_.set (x);
    }

    void MeasurementDeviceType::
    EnvironmentalRange (const EnvironmentalRange_optional& x)
    {
      this->EnvironmentalRange_ = x;
    }

    void MeasurementDeviceType::
    EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > x)
    {
      this->EnvironmentalRange_.set (std::move (x));
    }


    // ManualMeasurementDeviceType
    //

    const ManualMeasurementDeviceType::MinMeasuringDistance_optional& ManualMeasurementDeviceType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    ManualMeasurementDeviceType::MinMeasuringDistance_optional& ManualMeasurementDeviceType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void ManualMeasurementDeviceType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void ManualMeasurementDeviceType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void ManualMeasurementDeviceType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const ManualMeasurementDeviceType::MaxMeasuringDistance_optional& ManualMeasurementDeviceType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    ManualMeasurementDeviceType::MaxMeasuringDistance_optional& ManualMeasurementDeviceType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void ManualMeasurementDeviceType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void ManualMeasurementDeviceType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void ManualMeasurementDeviceType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }


    // UniversalDeviceType
    //

    const UniversalDeviceType::Resolution_optional& UniversalDeviceType::
    Resolution () const
    {
      return this->Resolution_;
    }

    UniversalDeviceType::Resolution_optional& UniversalDeviceType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void UniversalDeviceType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void UniversalDeviceType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void UniversalDeviceType::
    Resolution (::std::unique_ptr< Resolution_type > x)
    {
      this->Resolution_.set (std::move (x));
    }

    const UniversalDeviceType::WorkingVolume_optional& UniversalDeviceType::
    WorkingVolume () const
    {
      return this->WorkingVolume_;
    }

    UniversalDeviceType::WorkingVolume_optional& UniversalDeviceType::
    WorkingVolume ()
    {
      return this->WorkingVolume_;
    }

    void UniversalDeviceType::
    WorkingVolume (const WorkingVolume_type& x)
    {
      this->WorkingVolume_.set (x);
    }

    void UniversalDeviceType::
    WorkingVolume (const WorkingVolume_optional& x)
    {
      this->WorkingVolume_ = x;
    }

    void UniversalDeviceType::
    WorkingVolume (::std::unique_ptr< WorkingVolume_type > x)
    {
      this->WorkingVolume_.set (std::move (x));
    }

    const UniversalDeviceType::EffectiveWorkingVolume_optional& UniversalDeviceType::
    EffectiveWorkingVolume () const
    {
      return this->EffectiveWorkingVolume_;
    }

    UniversalDeviceType::EffectiveWorkingVolume_optional& UniversalDeviceType::
    EffectiveWorkingVolume ()
    {
      return this->EffectiveWorkingVolume_;
    }

    void UniversalDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_type& x)
    {
      this->EffectiveWorkingVolume_.set (x);
    }

    void UniversalDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_optional& x)
    {
      this->EffectiveWorkingVolume_ = x;
    }

    void UniversalDeviceType::
    EffectiveWorkingVolume (::std::unique_ptr< EffectiveWorkingVolume_type > x)
    {
      this->EffectiveWorkingVolume_.set (std::move (x));
    }

    const UniversalDeviceType::TemperatureCompensation_optional& UniversalDeviceType::
    TemperatureCompensation () const
    {
      return this->TemperatureCompensation_;
    }

    UniversalDeviceType::TemperatureCompensation_optional& UniversalDeviceType::
    TemperatureCompensation ()
    {
      return this->TemperatureCompensation_;
    }

    void UniversalDeviceType::
    TemperatureCompensation (const TemperatureCompensation_type& x)
    {
      this->TemperatureCompensation_.set (x);
    }

    void UniversalDeviceType::
    TemperatureCompensation (const TemperatureCompensation_optional& x)
    {
      this->TemperatureCompensation_ = x;
    }

    void UniversalDeviceType::
    TemperatureCompensation (::std::unique_ptr< TemperatureCompensation_type > x)
    {
      this->TemperatureCompensation_.set (std::move (x));
    }


    // TemperatureCompensationEnumType
    //

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_TemperatureCompensationEnumType_literals_[v])
    {
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const TemperatureCompensationEnumType& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    TemperatureCompensationEnumType& TemperatureCompensationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_TemperatureCompensationEnumType_literals_[v]);

      return *this;
    }


    // TemperatureCompensationType
    //

    const TemperatureCompensationType::TemperatureCompensationEnum_optional& TemperatureCompensationType::
    TemperatureCompensationEnum () const
    {
      return this->TemperatureCompensationEnum_;
    }

    TemperatureCompensationType::TemperatureCompensationEnum_optional& TemperatureCompensationType::
    TemperatureCompensationEnum ()
    {
      return this->TemperatureCompensationEnum_;
    }

    void TemperatureCompensationType::
    TemperatureCompensationEnum (const TemperatureCompensationEnum_type& x)
    {
      this->TemperatureCompensationEnum_.set (x);
    }

    void TemperatureCompensationType::
    TemperatureCompensationEnum (const TemperatureCompensationEnum_optional& x)
    {
      this->TemperatureCompensationEnum_ = x;
    }

    void TemperatureCompensationType::
    TemperatureCompensationEnum (::std::unique_ptr< TemperatureCompensationEnum_type > x)
    {
      this->TemperatureCompensationEnum_.set (std::move (x));
    }

    const TemperatureCompensationType::OtherTemperatureCompensation_optional& TemperatureCompensationType::
    OtherTemperatureCompensation () const
    {
      return this->OtherTemperatureCompensation_;
    }

    TemperatureCompensationType::OtherTemperatureCompensation_optional& TemperatureCompensationType::
    OtherTemperatureCompensation ()
    {
      return this->OtherTemperatureCompensation_;
    }

    void TemperatureCompensationType::
    OtherTemperatureCompensation (const OtherTemperatureCompensation_type& x)
    {
      this->OtherTemperatureCompensation_.set (x);
    }

    void TemperatureCompensationType::
    OtherTemperatureCompensation (const OtherTemperatureCompensation_optional& x)
    {
      this->OtherTemperatureCompensation_ = x;
    }

    void TemperatureCompensationType::
    OtherTemperatureCompensation (::std::unique_ptr< OtherTemperatureCompensation_type > x)
    {
      this->OtherTemperatureCompensation_.set (std::move (x));
    }


    // WorkingVolumeBaseType
    //


    // ClosedShellSetWorkingVolumeType
    //

    const ClosedShellSetWorkingVolumeType::WorkingClosedShellSet_type& ClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet () const
    {
      return this->WorkingClosedShellSet_.get ();
    }

    ClosedShellSetWorkingVolumeType::WorkingClosedShellSet_type& ClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet ()
    {
      return this->WorkingClosedShellSet_.get ();
    }

    void ClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet (const WorkingClosedShellSet_type& x)
    {
      this->WorkingClosedShellSet_.set (x);
    }

    void ClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet (::std::unique_ptr< WorkingClosedShellSet_type > x)
    {
      this->WorkingClosedShellSet_.set (std::move (x));
    }


    // ClosedShellSetType
    //

    const ClosedShellSetType::PointSet_optional& ClosedShellSetType::
    PointSet () const
    {
      return this->PointSet_;
    }

    ClosedShellSetType::PointSet_optional& ClosedShellSetType::
    PointSet ()
    {
      return this->PointSet_;
    }

    void ClosedShellSetType::
    PointSet (const PointSet_type& x)
    {
      this->PointSet_.set (x);
    }

    void ClosedShellSetType::
    PointSet (const PointSet_optional& x)
    {
      this->PointSet_ = x;
    }

    void ClosedShellSetType::
    PointSet (::std::unique_ptr< PointSet_type > x)
    {
      this->PointSet_.set (std::move (x));
    }

    const ClosedShellSetType::Curve12Set_optional& ClosedShellSetType::
    Curve12Set () const
    {
      return this->Curve12Set_;
    }

    ClosedShellSetType::Curve12Set_optional& ClosedShellSetType::
    Curve12Set ()
    {
      return this->Curve12Set_;
    }

    void ClosedShellSetType::
    Curve12Set (const Curve12Set_type& x)
    {
      this->Curve12Set_.set (x);
    }

    void ClosedShellSetType::
    Curve12Set (const Curve12Set_optional& x)
    {
      this->Curve12Set_ = x;
    }

    void ClosedShellSetType::
    Curve12Set (::std::unique_ptr< Curve12Set_type > x)
    {
      this->Curve12Set_.set (std::move (x));
    }

    const ClosedShellSetType::Curve13Set_optional& ClosedShellSetType::
    Curve13Set () const
    {
      return this->Curve13Set_;
    }

    ClosedShellSetType::Curve13Set_optional& ClosedShellSetType::
    Curve13Set ()
    {
      return this->Curve13Set_;
    }

    void ClosedShellSetType::
    Curve13Set (const Curve13Set_type& x)
    {
      this->Curve13Set_.set (x);
    }

    void ClosedShellSetType::
    Curve13Set (const Curve13Set_optional& x)
    {
      this->Curve13Set_ = x;
    }

    void ClosedShellSetType::
    Curve13Set (::std::unique_ptr< Curve13Set_type > x)
    {
      this->Curve13Set_.set (std::move (x));
    }

    const ClosedShellSetType::SurfaceSet_optional& ClosedShellSetType::
    SurfaceSet () const
    {
      return this->SurfaceSet_;
    }

    ClosedShellSetType::SurfaceSet_optional& ClosedShellSetType::
    SurfaceSet ()
    {
      return this->SurfaceSet_;
    }

    void ClosedShellSetType::
    SurfaceSet (const SurfaceSet_type& x)
    {
      this->SurfaceSet_.set (x);
    }

    void ClosedShellSetType::
    SurfaceSet (const SurfaceSet_optional& x)
    {
      this->SurfaceSet_ = x;
    }

    void ClosedShellSetType::
    SurfaceSet (::std::unique_ptr< SurfaceSet_type > x)
    {
      this->SurfaceSet_.set (std::move (x));
    }

    const ClosedShellSetType::CurveMeshSet_optional& ClosedShellSetType::
    CurveMeshSet () const
    {
      return this->CurveMeshSet_;
    }

    ClosedShellSetType::CurveMeshSet_optional& ClosedShellSetType::
    CurveMeshSet ()
    {
      return this->CurveMeshSet_;
    }

    void ClosedShellSetType::
    CurveMeshSet (const CurveMeshSet_type& x)
    {
      this->CurveMeshSet_.set (x);
    }

    void ClosedShellSetType::
    CurveMeshSet (const CurveMeshSet_optional& x)
    {
      this->CurveMeshSet_ = x;
    }

    void ClosedShellSetType::
    CurveMeshSet (::std::unique_ptr< CurveMeshSet_type > x)
    {
      this->CurveMeshSet_.set (std::move (x));
    }

    const ClosedShellSetType::SurfaceMeshSet_optional& ClosedShellSetType::
    SurfaceMeshSet () const
    {
      return this->SurfaceMeshSet_;
    }

    ClosedShellSetType::SurfaceMeshSet_optional& ClosedShellSetType::
    SurfaceMeshSet ()
    {
      return this->SurfaceMeshSet_;
    }

    void ClosedShellSetType::
    SurfaceMeshSet (const SurfaceMeshSet_type& x)
    {
      this->SurfaceMeshSet_.set (x);
    }

    void ClosedShellSetType::
    SurfaceMeshSet (const SurfaceMeshSet_optional& x)
    {
      this->SurfaceMeshSet_ = x;
    }

    void ClosedShellSetType::
    SurfaceMeshSet (::std::unique_ptr< SurfaceMeshSet_type > x)
    {
      this->SurfaceMeshSet_.set (std::move (x));
    }

    const ClosedShellSetType::VertexSet_optional& ClosedShellSetType::
    VertexSet () const
    {
      return this->VertexSet_;
    }

    ClosedShellSetType::VertexSet_optional& ClosedShellSetType::
    VertexSet ()
    {
      return this->VertexSet_;
    }

    void ClosedShellSetType::
    VertexSet (const VertexSet_type& x)
    {
      this->VertexSet_.set (x);
    }

    void ClosedShellSetType::
    VertexSet (const VertexSet_optional& x)
    {
      this->VertexSet_ = x;
    }

    void ClosedShellSetType::
    VertexSet (::std::unique_ptr< VertexSet_type > x)
    {
      this->VertexSet_.set (std::move (x));
    }

    const ClosedShellSetType::EdgeSet_optional& ClosedShellSetType::
    EdgeSet () const
    {
      return this->EdgeSet_;
    }

    ClosedShellSetType::EdgeSet_optional& ClosedShellSetType::
    EdgeSet ()
    {
      return this->EdgeSet_;
    }

    void ClosedShellSetType::
    EdgeSet (const EdgeSet_type& x)
    {
      this->EdgeSet_.set (x);
    }

    void ClosedShellSetType::
    EdgeSet (const EdgeSet_optional& x)
    {
      this->EdgeSet_ = x;
    }

    void ClosedShellSetType::
    EdgeSet (::std::unique_ptr< EdgeSet_type > x)
    {
      this->EdgeSet_.set (std::move (x));
    }

    const ClosedShellSetType::LoopSet_optional& ClosedShellSetType::
    LoopSet () const
    {
      return this->LoopSet_;
    }

    ClosedShellSetType::LoopSet_optional& ClosedShellSetType::
    LoopSet ()
    {
      return this->LoopSet_;
    }

    void ClosedShellSetType::
    LoopSet (const LoopSet_type& x)
    {
      this->LoopSet_.set (x);
    }

    void ClosedShellSetType::
    LoopSet (const LoopSet_optional& x)
    {
      this->LoopSet_ = x;
    }

    void ClosedShellSetType::
    LoopSet (::std::unique_ptr< LoopSet_type > x)
    {
      this->LoopSet_.set (std::move (x));
    }

    const ClosedShellSetType::FaceSet_optional& ClosedShellSetType::
    FaceSet () const
    {
      return this->FaceSet_;
    }

    ClosedShellSetType::FaceSet_optional& ClosedShellSetType::
    FaceSet ()
    {
      return this->FaceSet_;
    }

    void ClosedShellSetType::
    FaceSet (const FaceSet_type& x)
    {
      this->FaceSet_.set (x);
    }

    void ClosedShellSetType::
    FaceSet (const FaceSet_optional& x)
    {
      this->FaceSet_ = x;
    }

    void ClosedShellSetType::
    FaceSet (::std::unique_ptr< FaceSet_type > x)
    {
      this->FaceSet_.set (std::move (x));
    }

    const ClosedShellSetType::ShellSet_type& ClosedShellSetType::
    ShellSet () const
    {
      return this->ShellSet_.get ();
    }

    ClosedShellSetType::ShellSet_type& ClosedShellSetType::
    ShellSet ()
    {
      return this->ShellSet_.get ();
    }

    void ClosedShellSetType::
    ShellSet (const ShellSet_type& x)
    {
      this->ShellSet_.set (x);
    }

    void ClosedShellSetType::
    ShellSet (::std::unique_ptr< ShellSet_type > x)
    {
      this->ShellSet_.set (std::move (x));
    }


    // CartesianWorkingVolumeType
    //

    const CartesianWorkingVolumeType::XAxisLength_optional& CartesianWorkingVolumeType::
    XAxisLength () const
    {
      return this->XAxisLength_;
    }

    CartesianWorkingVolumeType::XAxisLength_optional& CartesianWorkingVolumeType::
    XAxisLength ()
    {
      return this->XAxisLength_;
    }

    void CartesianWorkingVolumeType::
    XAxisLength (const XAxisLength_type& x)
    {
      this->XAxisLength_.set (x);
    }

    void CartesianWorkingVolumeType::
    XAxisLength (const XAxisLength_optional& x)
    {
      this->XAxisLength_ = x;
    }

    void CartesianWorkingVolumeType::
    XAxisLength (::std::unique_ptr< XAxisLength_type > x)
    {
      this->XAxisLength_.set (std::move (x));
    }

    const CartesianWorkingVolumeType::YAxisLength_optional& CartesianWorkingVolumeType::
    YAxisLength () const
    {
      return this->YAxisLength_;
    }

    CartesianWorkingVolumeType::YAxisLength_optional& CartesianWorkingVolumeType::
    YAxisLength ()
    {
      return this->YAxisLength_;
    }

    void CartesianWorkingVolumeType::
    YAxisLength (const YAxisLength_type& x)
    {
      this->YAxisLength_.set (x);
    }

    void CartesianWorkingVolumeType::
    YAxisLength (const YAxisLength_optional& x)
    {
      this->YAxisLength_ = x;
    }

    void CartesianWorkingVolumeType::
    YAxisLength (::std::unique_ptr< YAxisLength_type > x)
    {
      this->YAxisLength_.set (std::move (x));
    }

    const CartesianWorkingVolumeType::ZAxisLength_optional& CartesianWorkingVolumeType::
    ZAxisLength () const
    {
      return this->ZAxisLength_;
    }

    CartesianWorkingVolumeType::ZAxisLength_optional& CartesianWorkingVolumeType::
    ZAxisLength ()
    {
      return this->ZAxisLength_;
    }

    void CartesianWorkingVolumeType::
    ZAxisLength (const ZAxisLength_type& x)
    {
      this->ZAxisLength_.set (x);
    }

    void CartesianWorkingVolumeType::
    ZAxisLength (const ZAxisLength_optional& x)
    {
      this->ZAxisLength_ = x;
    }

    void CartesianWorkingVolumeType::
    ZAxisLength (::std::unique_ptr< ZAxisLength_type > x)
    {
      this->ZAxisLength_.set (std::move (x));
    }


    // SphericalWorkingVolumeType
    //

    const SphericalWorkingVolumeType::RadialAxisLength_type& SphericalWorkingVolumeType::
    RadialAxisLength () const
    {
      return this->RadialAxisLength_.get ();
    }

    SphericalWorkingVolumeType::RadialAxisLength_type& SphericalWorkingVolumeType::
    RadialAxisLength ()
    {
      return this->RadialAxisLength_.get ();
    }

    void SphericalWorkingVolumeType::
    RadialAxisLength (const RadialAxisLength_type& x)
    {
      this->RadialAxisLength_.set (x);
    }

    void SphericalWorkingVolumeType::
    RadialAxisLength (::std::unique_ptr< RadialAxisLength_type > x)
    {
      this->RadialAxisLength_.set (std::move (x));
    }

    const SphericalWorkingVolumeType::MinAzimuthalAxisAngle_type& SphericalWorkingVolumeType::
    MinAzimuthalAxisAngle () const
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    SphericalWorkingVolumeType::MinAzimuthalAxisAngle_type& SphericalWorkingVolumeType::
    MinAzimuthalAxisAngle ()
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    void SphericalWorkingVolumeType::
    MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x)
    {
      this->MinAzimuthalAxisAngle_.set (x);
    }

    void SphericalWorkingVolumeType::
    MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > x)
    {
      this->MinAzimuthalAxisAngle_.set (std::move (x));
    }

    const SphericalWorkingVolumeType::MaxAzimuthalAxisAngle_type& SphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle () const
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    SphericalWorkingVolumeType::MaxAzimuthalAxisAngle_type& SphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle ()
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    void SphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x)
    {
      this->MaxAzimuthalAxisAngle_.set (x);
    }

    void SphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > x)
    {
      this->MaxAzimuthalAxisAngle_.set (std::move (x));
    }

    const SphericalWorkingVolumeType::MinPolarAxisAngle_type& SphericalWorkingVolumeType::
    MinPolarAxisAngle () const
    {
      return this->MinPolarAxisAngle_.get ();
    }

    SphericalWorkingVolumeType::MinPolarAxisAngle_type& SphericalWorkingVolumeType::
    MinPolarAxisAngle ()
    {
      return this->MinPolarAxisAngle_.get ();
    }

    void SphericalWorkingVolumeType::
    MinPolarAxisAngle (const MinPolarAxisAngle_type& x)
    {
      this->MinPolarAxisAngle_.set (x);
    }

    void SphericalWorkingVolumeType::
    MinPolarAxisAngle (::std::unique_ptr< MinPolarAxisAngle_type > x)
    {
      this->MinPolarAxisAngle_.set (std::move (x));
    }

    const SphericalWorkingVolumeType::MaxPolarAxisAngle_type& SphericalWorkingVolumeType::
    MaxPolarAxisAngle () const
    {
      return this->MaxPolarAxisAngle_.get ();
    }

    SphericalWorkingVolumeType::MaxPolarAxisAngle_type& SphericalWorkingVolumeType::
    MaxPolarAxisAngle ()
    {
      return this->MaxPolarAxisAngle_.get ();
    }

    void SphericalWorkingVolumeType::
    MaxPolarAxisAngle (const MaxPolarAxisAngle_type& x)
    {
      this->MaxPolarAxisAngle_.set (x);
    }

    void SphericalWorkingVolumeType::
    MaxPolarAxisAngle (::std::unique_ptr< MaxPolarAxisAngle_type > x)
    {
      this->MaxPolarAxisAngle_.set (std::move (x));
    }


    // CylindricalWorkingVolumeType
    //

    const CylindricalWorkingVolumeType::RadialAxisLength_type& CylindricalWorkingVolumeType::
    RadialAxisLength () const
    {
      return this->RadialAxisLength_.get ();
    }

    CylindricalWorkingVolumeType::RadialAxisLength_type& CylindricalWorkingVolumeType::
    RadialAxisLength ()
    {
      return this->RadialAxisLength_.get ();
    }

    void CylindricalWorkingVolumeType::
    RadialAxisLength (const RadialAxisLength_type& x)
    {
      this->RadialAxisLength_.set (x);
    }

    void CylindricalWorkingVolumeType::
    RadialAxisLength (::std::unique_ptr< RadialAxisLength_type > x)
    {
      this->RadialAxisLength_.set (std::move (x));
    }

    const CylindricalWorkingVolumeType::MinAzimuthalAxisAngle_type& CylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle () const
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    CylindricalWorkingVolumeType::MinAzimuthalAxisAngle_type& CylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle ()
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    void CylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x)
    {
      this->MinAzimuthalAxisAngle_.set (x);
    }

    void CylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > x)
    {
      this->MinAzimuthalAxisAngle_.set (std::move (x));
    }

    const CylindricalWorkingVolumeType::MaxAzimuthalAxisAngle_type& CylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle () const
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    CylindricalWorkingVolumeType::MaxAzimuthalAxisAngle_type& CylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle ()
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    void CylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x)
    {
      this->MaxAzimuthalAxisAngle_.set (x);
    }

    void CylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > x)
    {
      this->MaxAzimuthalAxisAngle_.set (std::move (x));
    }

    const CylindricalWorkingVolumeType::ZAxisLength_type& CylindricalWorkingVolumeType::
    ZAxisLength () const
    {
      return this->ZAxisLength_.get ();
    }

    CylindricalWorkingVolumeType::ZAxisLength_type& CylindricalWorkingVolumeType::
    ZAxisLength ()
    {
      return this->ZAxisLength_.get ();
    }

    void CylindricalWorkingVolumeType::
    ZAxisLength (const ZAxisLength_type& x)
    {
      this->ZAxisLength_.set (x);
    }

    void CylindricalWorkingVolumeType::
    ZAxisLength (::std::unique_ptr< ZAxisLength_type > x)
    {
      this->ZAxisLength_.set (std::move (x));
    }


    // UserDefinedWorkingVolumeType
    //

    const UserDefinedWorkingVolumeType::FirstAxis_type& UserDefinedWorkingVolumeType::
    FirstAxis () const
    {
      return this->FirstAxis_.get ();
    }

    UserDefinedWorkingVolumeType::FirstAxis_type& UserDefinedWorkingVolumeType::
    FirstAxis ()
    {
      return this->FirstAxis_.get ();
    }

    void UserDefinedWorkingVolumeType::
    FirstAxis (const FirstAxis_type& x)
    {
      this->FirstAxis_.set (x);
    }

    void UserDefinedWorkingVolumeType::
    FirstAxis (::std::unique_ptr< FirstAxis_type > x)
    {
      this->FirstAxis_.set (std::move (x));
    }

    const UserDefinedWorkingVolumeType::SecondAxis_type& UserDefinedWorkingVolumeType::
    SecondAxis () const
    {
      return this->SecondAxis_.get ();
    }

    UserDefinedWorkingVolumeType::SecondAxis_type& UserDefinedWorkingVolumeType::
    SecondAxis ()
    {
      return this->SecondAxis_.get ();
    }

    void UserDefinedWorkingVolumeType::
    SecondAxis (const SecondAxis_type& x)
    {
      this->SecondAxis_.set (x);
    }

    void UserDefinedWorkingVolumeType::
    SecondAxis (::std::unique_ptr< SecondAxis_type > x)
    {
      this->SecondAxis_.set (std::move (x));
    }

    const UserDefinedWorkingVolumeType::ThirdAxis_type& UserDefinedWorkingVolumeType::
    ThirdAxis () const
    {
      return this->ThirdAxis_.get ();
    }

    UserDefinedWorkingVolumeType::ThirdAxis_type& UserDefinedWorkingVolumeType::
    ThirdAxis ()
    {
      return this->ThirdAxis_.get ();
    }

    void UserDefinedWorkingVolumeType::
    ThirdAxis (const ThirdAxis_type& x)
    {
      this->ThirdAxis_.set (x);
    }

    void UserDefinedWorkingVolumeType::
    ThirdAxis (::std::unique_ptr< ThirdAxis_type > x)
    {
      this->ThirdAxis_.set (std::move (x));
    }


    // LinearOrRotaryAxisType
    //

    const LinearOrRotaryAxisType::Axis_type& LinearOrRotaryAxisType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    LinearOrRotaryAxisType::Axis_type& LinearOrRotaryAxisType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void LinearOrRotaryAxisType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void LinearOrRotaryAxisType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }


    // UserDefinedAxisType
    //

    const UserDefinedAxisType::Attributes_optional& UserDefinedAxisType::
    Attributes () const
    {
      return this->Attributes_;
    }

    UserDefinedAxisType::Attributes_optional& UserDefinedAxisType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void UserDefinedAxisType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void UserDefinedAxisType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void UserDefinedAxisType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const UserDefinedAxisType::AxisName_type& UserDefinedAxisType::
    AxisName () const
    {
      return this->AxisName_.get ();
    }

    UserDefinedAxisType::AxisName_type& UserDefinedAxisType::
    AxisName ()
    {
      return this->AxisName_.get ();
    }

    void UserDefinedAxisType::
    AxisName (const AxisName_type& x)
    {
      this->AxisName_.set (x);
    }

    void UserDefinedAxisType::
    AxisName (::std::unique_ptr< AxisName_type > x)
    {
      this->AxisName_.set (std::move (x));
    }


    // EffectiveWorkingVolumeBaseType
    //


    // EffectiveCylindricalWorkingVolumeType
    //

    const EffectiveCylindricalWorkingVolumeType::MinRadius_type& EffectiveCylindricalWorkingVolumeType::
    MinRadius () const
    {
      return this->MinRadius_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MinRadius_type& EffectiveCylindricalWorkingVolumeType::
    MinRadius ()
    {
      return this->MinRadius_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinRadius (const MinRadius_type& x)
    {
      this->MinRadius_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinRadius (::std::unique_ptr< MinRadius_type > x)
    {
      this->MinRadius_.set (std::move (x));
    }

    const EffectiveCylindricalWorkingVolumeType::MaxRadius_type& EffectiveCylindricalWorkingVolumeType::
    MaxRadius () const
    {
      return this->MaxRadius_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MaxRadius_type& EffectiveCylindricalWorkingVolumeType::
    MaxRadius ()
    {
      return this->MaxRadius_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxRadius (const MaxRadius_type& x)
    {
      this->MaxRadius_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxRadius (::std::unique_ptr< MaxRadius_type > x)
    {
      this->MaxRadius_.set (std::move (x));
    }

    const EffectiveCylindricalWorkingVolumeType::MinAzimuthalAxisAngle_type& EffectiveCylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle () const
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MinAzimuthalAxisAngle_type& EffectiveCylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle ()
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x)
    {
      this->MinAzimuthalAxisAngle_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > x)
    {
      this->MinAzimuthalAxisAngle_.set (std::move (x));
    }

    const EffectiveCylindricalWorkingVolumeType::MaxAzimuthalAxisAngle_type& EffectiveCylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle () const
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MaxAzimuthalAxisAngle_type& EffectiveCylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle ()
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x)
    {
      this->MaxAzimuthalAxisAngle_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > x)
    {
      this->MaxAzimuthalAxisAngle_.set (std::move (x));
    }

    const EffectiveCylindricalWorkingVolumeType::MinZAxis_type& EffectiveCylindricalWorkingVolumeType::
    MinZAxis () const
    {
      return this->MinZAxis_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MinZAxis_type& EffectiveCylindricalWorkingVolumeType::
    MinZAxis ()
    {
      return this->MinZAxis_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinZAxis (const MinZAxis_type& x)
    {
      this->MinZAxis_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MinZAxis (::std::unique_ptr< MinZAxis_type > x)
    {
      this->MinZAxis_.set (std::move (x));
    }

    const EffectiveCylindricalWorkingVolumeType::MaxZAxis_type& EffectiveCylindricalWorkingVolumeType::
    MaxZAxis () const
    {
      return this->MaxZAxis_.get ();
    }

    EffectiveCylindricalWorkingVolumeType::MaxZAxis_type& EffectiveCylindricalWorkingVolumeType::
    MaxZAxis ()
    {
      return this->MaxZAxis_.get ();
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxZAxis (const MaxZAxis_type& x)
    {
      this->MaxZAxis_.set (x);
    }

    void EffectiveCylindricalWorkingVolumeType::
    MaxZAxis (::std::unique_ptr< MaxZAxis_type > x)
    {
      this->MaxZAxis_.set (std::move (x));
    }


    // EffectiveSphericalWorkingVolumeType
    //

    const EffectiveSphericalWorkingVolumeType::MinRadialAxis_type& EffectiveSphericalWorkingVolumeType::
    MinRadialAxis () const
    {
      return this->MinRadialAxis_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MinRadialAxis_type& EffectiveSphericalWorkingVolumeType::
    MinRadialAxis ()
    {
      return this->MinRadialAxis_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MinRadialAxis (const MinRadialAxis_type& x)
    {
      this->MinRadialAxis_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MinRadialAxis (::std::unique_ptr< MinRadialAxis_type > x)
    {
      this->MinRadialAxis_.set (std::move (x));
    }

    const EffectiveSphericalWorkingVolumeType::MaxRadialAxis_type& EffectiveSphericalWorkingVolumeType::
    MaxRadialAxis () const
    {
      return this->MaxRadialAxis_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MaxRadialAxis_type& EffectiveSphericalWorkingVolumeType::
    MaxRadialAxis ()
    {
      return this->MaxRadialAxis_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxRadialAxis (const MaxRadialAxis_type& x)
    {
      this->MaxRadialAxis_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxRadialAxis (::std::unique_ptr< MaxRadialAxis_type > x)
    {
      this->MaxRadialAxis_.set (std::move (x));
    }

    const EffectiveSphericalWorkingVolumeType::MinAzimuthalAxisAngle_type& EffectiveSphericalWorkingVolumeType::
    MinAzimuthalAxisAngle () const
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MinAzimuthalAxisAngle_type& EffectiveSphericalWorkingVolumeType::
    MinAzimuthalAxisAngle ()
    {
      return this->MinAzimuthalAxisAngle_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x)
    {
      this->MinAzimuthalAxisAngle_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > x)
    {
      this->MinAzimuthalAxisAngle_.set (std::move (x));
    }

    const EffectiveSphericalWorkingVolumeType::MaxAzimuthalAxisAngle_type& EffectiveSphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle () const
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MaxAzimuthalAxisAngle_type& EffectiveSphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle ()
    {
      return this->MaxAzimuthalAxisAngle_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x)
    {
      this->MaxAzimuthalAxisAngle_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > x)
    {
      this->MaxAzimuthalAxisAngle_.set (std::move (x));
    }

    const EffectiveSphericalWorkingVolumeType::MinPolarAxis_type& EffectiveSphericalWorkingVolumeType::
    MinPolarAxis () const
    {
      return this->MinPolarAxis_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MinPolarAxis_type& EffectiveSphericalWorkingVolumeType::
    MinPolarAxis ()
    {
      return this->MinPolarAxis_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MinPolarAxis (const MinPolarAxis_type& x)
    {
      this->MinPolarAxis_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MinPolarAxis (::std::unique_ptr< MinPolarAxis_type > x)
    {
      this->MinPolarAxis_.set (std::move (x));
    }

    const EffectiveSphericalWorkingVolumeType::MaxPolarAxis_type& EffectiveSphericalWorkingVolumeType::
    MaxPolarAxis () const
    {
      return this->MaxPolarAxis_.get ();
    }

    EffectiveSphericalWorkingVolumeType::MaxPolarAxis_type& EffectiveSphericalWorkingVolumeType::
    MaxPolarAxis ()
    {
      return this->MaxPolarAxis_.get ();
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxPolarAxis (const MaxPolarAxis_type& x)
    {
      this->MaxPolarAxis_.set (x);
    }

    void EffectiveSphericalWorkingVolumeType::
    MaxPolarAxis (::std::unique_ptr< MaxPolarAxis_type > x)
    {
      this->MaxPolarAxis_.set (std::move (x));
    }


    // EffectiveCartesianWorkingVolumeType
    //

    const EffectiveCartesianWorkingVolumeType::MinPoint_type& EffectiveCartesianWorkingVolumeType::
    MinPoint () const
    {
      return this->MinPoint_.get ();
    }

    EffectiveCartesianWorkingVolumeType::MinPoint_type& EffectiveCartesianWorkingVolumeType::
    MinPoint ()
    {
      return this->MinPoint_.get ();
    }

    void EffectiveCartesianWorkingVolumeType::
    MinPoint (const MinPoint_type& x)
    {
      this->MinPoint_.set (x);
    }

    void EffectiveCartesianWorkingVolumeType::
    MinPoint (::std::unique_ptr< MinPoint_type > x)
    {
      this->MinPoint_.set (std::move (x));
    }

    const EffectiveCartesianWorkingVolumeType::MaxPoint_type& EffectiveCartesianWorkingVolumeType::
    MaxPoint () const
    {
      return this->MaxPoint_.get ();
    }

    EffectiveCartesianWorkingVolumeType::MaxPoint_type& EffectiveCartesianWorkingVolumeType::
    MaxPoint ()
    {
      return this->MaxPoint_.get ();
    }

    void EffectiveCartesianWorkingVolumeType::
    MaxPoint (const MaxPoint_type& x)
    {
      this->MaxPoint_.set (x);
    }

    void EffectiveCartesianWorkingVolumeType::
    MaxPoint (::std::unique_ptr< MaxPoint_type > x)
    {
      this->MaxPoint_.set (std::move (x));
    }


    // EffectiveClosedShellSetWorkingVolumeType
    //

    const EffectiveClosedShellSetWorkingVolumeType::WorkingClosedShellSet_type& EffectiveClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet () const
    {
      return this->WorkingClosedShellSet_.get ();
    }

    EffectiveClosedShellSetWorkingVolumeType::WorkingClosedShellSet_type& EffectiveClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet ()
    {
      return this->WorkingClosedShellSet_.get ();
    }

    void EffectiveClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet (const WorkingClosedShellSet_type& x)
    {
      this->WorkingClosedShellSet_.set (x);
    }

    void EffectiveClosedShellSetWorkingVolumeType::
    WorkingClosedShellSet (::std::unique_ptr< WorkingClosedShellSet_type > x)
    {
      this->WorkingClosedShellSet_.set (std::move (x));
    }


    // EffectiveUserDefinedWorkingVolumeType
    //

    const EffectiveUserDefinedWorkingVolumeType::UserDefinedWorkingVolumeId_type& EffectiveUserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeId () const
    {
      return this->UserDefinedWorkingVolumeId_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::UserDefinedWorkingVolumeId_type& EffectiveUserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeId ()
    {
      return this->UserDefinedWorkingVolumeId_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeId (const UserDefinedWorkingVolumeId_type& x)
    {
      this->UserDefinedWorkingVolumeId_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeId (::std::unique_ptr< UserDefinedWorkingVolumeId_type > x)
    {
      this->UserDefinedWorkingVolumeId_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MinFirstAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinFirstAxis () const
    {
      return this->MinFirstAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MinFirstAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinFirstAxis ()
    {
      return this->MinFirstAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinFirstAxis (const MinFirstAxis_type& x)
    {
      this->MinFirstAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinFirstAxis (::std::unique_ptr< MinFirstAxis_type > x)
    {
      this->MinFirstAxis_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MaxFirstAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxFirstAxis () const
    {
      return this->MaxFirstAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MaxFirstAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxFirstAxis ()
    {
      return this->MaxFirstAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxFirstAxis (const MaxFirstAxis_type& x)
    {
      this->MaxFirstAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxFirstAxis (::std::unique_ptr< MaxFirstAxis_type > x)
    {
      this->MaxFirstAxis_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MinSecondAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinSecondAxis () const
    {
      return this->MinSecondAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MinSecondAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinSecondAxis ()
    {
      return this->MinSecondAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinSecondAxis (const MinSecondAxis_type& x)
    {
      this->MinSecondAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinSecondAxis (::std::unique_ptr< MinSecondAxis_type > x)
    {
      this->MinSecondAxis_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MaxSecondAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxSecondAxis () const
    {
      return this->MaxSecondAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MaxSecondAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxSecondAxis ()
    {
      return this->MaxSecondAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxSecondAxis (const MaxSecondAxis_type& x)
    {
      this->MaxSecondAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxSecondAxis (::std::unique_ptr< MaxSecondAxis_type > x)
    {
      this->MaxSecondAxis_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MinThirdAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinThirdAxis () const
    {
      return this->MinThirdAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MinThirdAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MinThirdAxis ()
    {
      return this->MinThirdAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinThirdAxis (const MinThirdAxis_type& x)
    {
      this->MinThirdAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MinThirdAxis (::std::unique_ptr< MinThirdAxis_type > x)
    {
      this->MinThirdAxis_.set (std::move (x));
    }

    const EffectiveUserDefinedWorkingVolumeType::MaxThirdAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxThirdAxis () const
    {
      return this->MaxThirdAxis_.get ();
    }

    EffectiveUserDefinedWorkingVolumeType::MaxThirdAxis_type& EffectiveUserDefinedWorkingVolumeType::
    MaxThirdAxis ()
    {
      return this->MaxThirdAxis_.get ();
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxThirdAxis (const MaxThirdAxis_type& x)
    {
      this->MaxThirdAxis_.set (x);
    }

    void EffectiveUserDefinedWorkingVolumeType::
    MaxThirdAxis (::std::unique_ptr< MaxThirdAxis_type > x)
    {
      this->MaxThirdAxis_.set (std::move (x));
    }


    // UserAxisBaseType
    //


    // LinearAxisType
    //

    const LinearAxisType::MinLinearAxis_type& LinearAxisType::
    MinLinearAxis () const
    {
      return this->MinLinearAxis_.get ();
    }

    LinearAxisType::MinLinearAxis_type& LinearAxisType::
    MinLinearAxis ()
    {
      return this->MinLinearAxis_.get ();
    }

    void LinearAxisType::
    MinLinearAxis (const MinLinearAxis_type& x)
    {
      this->MinLinearAxis_.set (x);
    }

    void LinearAxisType::
    MinLinearAxis (::std::unique_ptr< MinLinearAxis_type > x)
    {
      this->MinLinearAxis_.set (std::move (x));
    }

    const LinearAxisType::MaxLinearAxis_type& LinearAxisType::
    MaxLinearAxis () const
    {
      return this->MaxLinearAxis_.get ();
    }

    LinearAxisType::MaxLinearAxis_type& LinearAxisType::
    MaxLinearAxis ()
    {
      return this->MaxLinearAxis_.get ();
    }

    void LinearAxisType::
    MaxLinearAxis (const MaxLinearAxis_type& x)
    {
      this->MaxLinearAxis_.set (x);
    }

    void LinearAxisType::
    MaxLinearAxis (::std::unique_ptr< MaxLinearAxis_type > x)
    {
      this->MaxLinearAxis_.set (std::move (x));
    }


    // RotaryAxisType
    //

    const RotaryAxisType::MinRotaryAxis_type& RotaryAxisType::
    MinRotaryAxis () const
    {
      return this->MinRotaryAxis_.get ();
    }

    RotaryAxisType::MinRotaryAxis_type& RotaryAxisType::
    MinRotaryAxis ()
    {
      return this->MinRotaryAxis_.get ();
    }

    void RotaryAxisType::
    MinRotaryAxis (const MinRotaryAxis_type& x)
    {
      this->MinRotaryAxis_.set (x);
    }

    void RotaryAxisType::
    MinRotaryAxis (::std::unique_ptr< MinRotaryAxis_type > x)
    {
      this->MinRotaryAxis_.set (std::move (x));
    }

    const RotaryAxisType::MaxRotaryAxis_type& RotaryAxisType::
    MaxRotaryAxis () const
    {
      return this->MaxRotaryAxis_.get ();
    }

    RotaryAxisType::MaxRotaryAxis_type& RotaryAxisType::
    MaxRotaryAxis ()
    {
      return this->MaxRotaryAxis_.get ();
    }

    void RotaryAxisType::
    MaxRotaryAxis (const MaxRotaryAxis_type& x)
    {
      this->MaxRotaryAxis_.set (x);
    }

    void RotaryAxisType::
    MaxRotaryAxis (::std::unique_ptr< MaxRotaryAxis_type > x)
    {
      this->MaxRotaryAxis_.set (std::move (x));
    }


    // ResolutionBaseType
    //


    // LinearResolutionType
    //

    const LinearResolutionType::LinearValue_type& LinearResolutionType::
    LinearValue () const
    {
      return this->LinearValue_.get ();
    }

    LinearResolutionType::LinearValue_type& LinearResolutionType::
    LinearValue ()
    {
      return this->LinearValue_.get ();
    }

    void LinearResolutionType::
    LinearValue (const LinearValue_type& x)
    {
      this->LinearValue_.set (x);
    }

    void LinearResolutionType::
    LinearValue (::std::unique_ptr< LinearValue_type > x)
    {
      this->LinearValue_.set (std::move (x));
    }


    // CartesianResolutionType
    //

    const CartesianResolutionType::CombinedCartesianResolution_optional& CartesianResolutionType::
    CombinedCartesianResolution () const
    {
      return this->CombinedCartesianResolution_;
    }

    CartesianResolutionType::CombinedCartesianResolution_optional& CartesianResolutionType::
    CombinedCartesianResolution ()
    {
      return this->CombinedCartesianResolution_;
    }

    void CartesianResolutionType::
    CombinedCartesianResolution (const CombinedCartesianResolution_type& x)
    {
      this->CombinedCartesianResolution_.set (x);
    }

    void CartesianResolutionType::
    CombinedCartesianResolution (const CombinedCartesianResolution_optional& x)
    {
      this->CombinedCartesianResolution_ = x;
    }

    void CartesianResolutionType::
    CombinedCartesianResolution (::std::unique_ptr< CombinedCartesianResolution_type > x)
    {
      this->CombinedCartesianResolution_.set (std::move (x));
    }

    const CartesianResolutionType::XYZResolution_optional& CartesianResolutionType::
    XYZResolution () const
    {
      return this->XYZResolution_;
    }

    CartesianResolutionType::XYZResolution_optional& CartesianResolutionType::
    XYZResolution ()
    {
      return this->XYZResolution_;
    }

    void CartesianResolutionType::
    XYZResolution (const XYZResolution_type& x)
    {
      this->XYZResolution_.set (x);
    }

    void CartesianResolutionType::
    XYZResolution (const XYZResolution_optional& x)
    {
      this->XYZResolution_ = x;
    }

    void CartesianResolutionType::
    XYZResolution (::std::unique_ptr< XYZResolution_type > x)
    {
      this->XYZResolution_.set (std::move (x));
    }


    // XYZResolutionType
    //

    const XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution () const
    {
      return this->XResolution_.get ();
    }

    XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution ()
    {
      return this->XResolution_.get ();
    }

    void XYZResolutionType::
    XResolution (const XResolution_type& x)
    {
      this->XResolution_.set (x);
    }

    void XYZResolutionType::
    XResolution (::std::unique_ptr< XResolution_type > x)
    {
      this->XResolution_.set (std::move (x));
    }

    const XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution () const
    {
      return this->YResolution_.get ();
    }

    XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution ()
    {
      return this->YResolution_.get ();
    }

    void XYZResolutionType::
    YResolution (const YResolution_type& x)
    {
      this->YResolution_.set (x);
    }

    void XYZResolutionType::
    YResolution (::std::unique_ptr< YResolution_type > x)
    {
      this->YResolution_.set (std::move (x));
    }

    const XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution () const
    {
      return this->ZResolution_.get ();
    }

    XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution ()
    {
      return this->ZResolution_.get ();
    }

    void XYZResolutionType::
    ZResolution (const ZResolution_type& x)
    {
      this->ZResolution_.set (x);
    }

    void XYZResolutionType::
    ZResolution (::std::unique_ptr< ZResolution_type > x)
    {
      this->ZResolution_.set (std::move (x));
    }


    // RAPZResolutionType
    //

    const RAPZResolutionType::RadialResolution_type& RAPZResolutionType::
    RadialResolution () const
    {
      return this->RadialResolution_.get ();
    }

    RAPZResolutionType::RadialResolution_type& RAPZResolutionType::
    RadialResolution ()
    {
      return this->RadialResolution_.get ();
    }

    void RAPZResolutionType::
    RadialResolution (const RadialResolution_type& x)
    {
      this->RadialResolution_.set (x);
    }

    void RAPZResolutionType::
    RadialResolution (::std::unique_ptr< RadialResolution_type > x)
    {
      this->RadialResolution_.set (std::move (x));
    }

    const RAPZResolutionType::AzimuthalAngleResolution_type& RAPZResolutionType::
    AzimuthalAngleResolution () const
    {
      return this->AzimuthalAngleResolution_.get ();
    }

    RAPZResolutionType::AzimuthalAngleResolution_type& RAPZResolutionType::
    AzimuthalAngleResolution ()
    {
      return this->AzimuthalAngleResolution_.get ();
    }

    void RAPZResolutionType::
    AzimuthalAngleResolution (const AzimuthalAngleResolution_type& x)
    {
      this->AzimuthalAngleResolution_.set (x);
    }

    void RAPZResolutionType::
    AzimuthalAngleResolution (::std::unique_ptr< AzimuthalAngleResolution_type > x)
    {
      this->AzimuthalAngleResolution_.set (std::move (x));
    }

    const RAPZResolutionType::PolarAngleResolution_type& RAPZResolutionType::
    PolarAngleResolution () const
    {
      return this->PolarAngleResolution_.get ();
    }

    RAPZResolutionType::PolarAngleResolution_type& RAPZResolutionType::
    PolarAngleResolution ()
    {
      return this->PolarAngleResolution_.get ();
    }

    void RAPZResolutionType::
    PolarAngleResolution (const PolarAngleResolution_type& x)
    {
      this->PolarAngleResolution_.set (x);
    }

    void RAPZResolutionType::
    PolarAngleResolution (::std::unique_ptr< PolarAngleResolution_type > x)
    {
      this->PolarAngleResolution_.set (std::move (x));
    }


    // SphericalResolutionType
    //

    const SphericalResolutionType::CombinedSphericalResolution_optional& SphericalResolutionType::
    CombinedSphericalResolution () const
    {
      return this->CombinedSphericalResolution_;
    }

    SphericalResolutionType::CombinedSphericalResolution_optional& SphericalResolutionType::
    CombinedSphericalResolution ()
    {
      return this->CombinedSphericalResolution_;
    }

    void SphericalResolutionType::
    CombinedSphericalResolution (const CombinedSphericalResolution_type& x)
    {
      this->CombinedSphericalResolution_.set (x);
    }

    void SphericalResolutionType::
    CombinedSphericalResolution (const CombinedSphericalResolution_optional& x)
    {
      this->CombinedSphericalResolution_ = x;
    }

    void SphericalResolutionType::
    CombinedSphericalResolution (::std::unique_ptr< CombinedSphericalResolution_type > x)
    {
      this->CombinedSphericalResolution_.set (std::move (x));
    }

    const SphericalResolutionType::RAPZResolution_optional& SphericalResolutionType::
    RAPZResolution () const
    {
      return this->RAPZResolution_;
    }

    SphericalResolutionType::RAPZResolution_optional& SphericalResolutionType::
    RAPZResolution ()
    {
      return this->RAPZResolution_;
    }

    void SphericalResolutionType::
    RAPZResolution (const RAPZResolution_type& x)
    {
      this->RAPZResolution_.set (x);
    }

    void SphericalResolutionType::
    RAPZResolution (const RAPZResolution_optional& x)
    {
      this->RAPZResolution_ = x;
    }

    void SphericalResolutionType::
    RAPZResolution (::std::unique_ptr< RAPZResolution_type > x)
    {
      this->RAPZResolution_.set (std::move (x));
    }

    const SphericalResolutionType::RAPResolution_optional& SphericalResolutionType::
    RAPResolution () const
    {
      return this->RAPResolution_;
    }

    SphericalResolutionType::RAPResolution_optional& SphericalResolutionType::
    RAPResolution ()
    {
      return this->RAPResolution_;
    }

    void SphericalResolutionType::
    RAPResolution (const RAPResolution_type& x)
    {
      this->RAPResolution_.set (x);
    }

    void SphericalResolutionType::
    RAPResolution (const RAPResolution_optional& x)
    {
      this->RAPResolution_ = x;
    }

    void SphericalResolutionType::
    RAPResolution (::std::unique_ptr< RAPResolution_type > x)
    {
      this->RAPResolution_.set (std::move (x));
    }


    // CombinedSphericalResolutionType
    //

    const CombinedSphericalResolutionType::CombinedRadialResolution_type& CombinedSphericalResolutionType::
    CombinedRadialResolution () const
    {
      return this->CombinedRadialResolution_.get ();
    }

    CombinedSphericalResolutionType::CombinedRadialResolution_type& CombinedSphericalResolutionType::
    CombinedRadialResolution ()
    {
      return this->CombinedRadialResolution_.get ();
    }

    void CombinedSphericalResolutionType::
    CombinedRadialResolution (const CombinedRadialResolution_type& x)
    {
      this->CombinedRadialResolution_.set (x);
    }

    void CombinedSphericalResolutionType::
    CombinedRadialResolution (::std::unique_ptr< CombinedRadialResolution_type > x)
    {
      this->CombinedRadialResolution_.set (std::move (x));
    }

    const CombinedSphericalResolutionType::CombinedAzimuthalResolution_type& CombinedSphericalResolutionType::
    CombinedAzimuthalResolution () const
    {
      return this->CombinedAzimuthalResolution_.get ();
    }

    CombinedSphericalResolutionType::CombinedAzimuthalResolution_type& CombinedSphericalResolutionType::
    CombinedAzimuthalResolution ()
    {
      return this->CombinedAzimuthalResolution_.get ();
    }

    void CombinedSphericalResolutionType::
    CombinedAzimuthalResolution (const CombinedAzimuthalResolution_type& x)
    {
      this->CombinedAzimuthalResolution_.set (x);
    }

    void CombinedSphericalResolutionType::
    CombinedAzimuthalResolution (::std::unique_ptr< CombinedAzimuthalResolution_type > x)
    {
      this->CombinedAzimuthalResolution_.set (std::move (x));
    }

    const CombinedSphericalResolutionType::CombinedPolarResolution_type& CombinedSphericalResolutionType::
    CombinedPolarResolution () const
    {
      return this->CombinedPolarResolution_.get ();
    }

    CombinedSphericalResolutionType::CombinedPolarResolution_type& CombinedSphericalResolutionType::
    CombinedPolarResolution ()
    {
      return this->CombinedPolarResolution_.get ();
    }

    void CombinedSphericalResolutionType::
    CombinedPolarResolution (const CombinedPolarResolution_type& x)
    {
      this->CombinedPolarResolution_.set (x);
    }

    void CombinedSphericalResolutionType::
    CombinedPolarResolution (::std::unique_ptr< CombinedPolarResolution_type > x)
    {
      this->CombinedPolarResolution_.set (std::move (x));
    }


    // UserDefinedResolutionType
    //

    const UserDefinedResolutionType::CombinedUserDefinedResolution_optional& UserDefinedResolutionType::
    CombinedUserDefinedResolution () const
    {
      return this->CombinedUserDefinedResolution_;
    }

    UserDefinedResolutionType::CombinedUserDefinedResolution_optional& UserDefinedResolutionType::
    CombinedUserDefinedResolution ()
    {
      return this->CombinedUserDefinedResolution_;
    }

    void UserDefinedResolutionType::
    CombinedUserDefinedResolution (const CombinedUserDefinedResolution_type& x)
    {
      this->CombinedUserDefinedResolution_.set (x);
    }

    void UserDefinedResolutionType::
    CombinedUserDefinedResolution (const CombinedUserDefinedResolution_optional& x)
    {
      this->CombinedUserDefinedResolution_ = x;
    }

    void UserDefinedResolutionType::
    CombinedUserDefinedResolution (::std::unique_ptr< CombinedUserDefinedResolution_type > x)
    {
      this->CombinedUserDefinedResolution_.set (std::move (x));
    }

    const UserDefinedResolutionType::ABCResolution_type& UserDefinedResolutionType::
    ABCResolution () const
    {
      return this->ABCResolution_.get ();
    }

    UserDefinedResolutionType::ABCResolution_type& UserDefinedResolutionType::
    ABCResolution ()
    {
      return this->ABCResolution_.get ();
    }

    void UserDefinedResolutionType::
    ABCResolution (const ABCResolution_type& x)
    {
      this->ABCResolution_.set (x);
    }

    void UserDefinedResolutionType::
    ABCResolution (::std::unique_ptr< ABCResolution_type > x)
    {
      this->ABCResolution_.set (std::move (x));
    }


    // ABCResolutionType
    //

    const ABCResolutionType::AAxisResolution_type& ABCResolutionType::
    AAxisResolution () const
    {
      return this->AAxisResolution_.get ();
    }

    ABCResolutionType::AAxisResolution_type& ABCResolutionType::
    AAxisResolution ()
    {
      return this->AAxisResolution_.get ();
    }

    void ABCResolutionType::
    AAxisResolution (const AAxisResolution_type& x)
    {
      this->AAxisResolution_.set (x);
    }

    void ABCResolutionType::
    AAxisResolution (::std::unique_ptr< AAxisResolution_type > x)
    {
      this->AAxisResolution_.set (std::move (x));
    }

    const ABCResolutionType::BAxisResolution_type& ABCResolutionType::
    BAxisResolution () const
    {
      return this->BAxisResolution_.get ();
    }

    ABCResolutionType::BAxisResolution_type& ABCResolutionType::
    BAxisResolution ()
    {
      return this->BAxisResolution_.get ();
    }

    void ABCResolutionType::
    BAxisResolution (const BAxisResolution_type& x)
    {
      this->BAxisResolution_.set (x);
    }

    void ABCResolutionType::
    BAxisResolution (::std::unique_ptr< BAxisResolution_type > x)
    {
      this->BAxisResolution_.set (std::move (x));
    }

    const ABCResolutionType::CAxisResolution_type& ABCResolutionType::
    CAxisResolution () const
    {
      return this->CAxisResolution_.get ();
    }

    ABCResolutionType::CAxisResolution_type& ABCResolutionType::
    CAxisResolution ()
    {
      return this->CAxisResolution_.get ();
    }

    void ABCResolutionType::
    CAxisResolution (const CAxisResolution_type& x)
    {
      this->CAxisResolution_.set (x);
    }

    void ABCResolutionType::
    CAxisResolution (::std::unique_ptr< CAxisResolution_type > x)
    {
      this->CAxisResolution_.set (std::move (x));
    }


    // CombinedUserDefinedResolutionType
    //

    const CombinedUserDefinedResolutionType::ACombinedResolution_type& CombinedUserDefinedResolutionType::
    ACombinedResolution () const
    {
      return this->ACombinedResolution_.get ();
    }

    CombinedUserDefinedResolutionType::ACombinedResolution_type& CombinedUserDefinedResolutionType::
    ACombinedResolution ()
    {
      return this->ACombinedResolution_.get ();
    }

    void CombinedUserDefinedResolutionType::
    ACombinedResolution (const ACombinedResolution_type& x)
    {
      this->ACombinedResolution_.set (x);
    }

    void CombinedUserDefinedResolutionType::
    ACombinedResolution (::std::unique_ptr< ACombinedResolution_type > x)
    {
      this->ACombinedResolution_.set (std::move (x));
    }

    const CombinedUserDefinedResolutionType::BCombinedResolution_type& CombinedUserDefinedResolutionType::
    BCombinedResolution () const
    {
      return this->BCombinedResolution_.get ();
    }

    CombinedUserDefinedResolutionType::BCombinedResolution_type& CombinedUserDefinedResolutionType::
    BCombinedResolution ()
    {
      return this->BCombinedResolution_.get ();
    }

    void CombinedUserDefinedResolutionType::
    BCombinedResolution (const BCombinedResolution_type& x)
    {
      this->BCombinedResolution_.set (x);
    }

    void CombinedUserDefinedResolutionType::
    BCombinedResolution (::std::unique_ptr< BCombinedResolution_type > x)
    {
      this->BCombinedResolution_.set (std::move (x));
    }

    const CombinedUserDefinedResolutionType::CCombinedResolution_type& CombinedUserDefinedResolutionType::
    CCombinedResolution () const
    {
      return this->CCombinedResolution_.get ();
    }

    CombinedUserDefinedResolutionType::CCombinedResolution_type& CombinedUserDefinedResolutionType::
    CCombinedResolution ()
    {
      return this->CCombinedResolution_.get ();
    }

    void CombinedUserDefinedResolutionType::
    CCombinedResolution (const CCombinedResolution_type& x)
    {
      this->CCombinedResolution_.set (x);
    }

    void CombinedUserDefinedResolutionType::
    CCombinedResolution (::std::unique_ptr< CCombinedResolution_type > x)
    {
      this->CCombinedResolution_.set (std::move (x));
    }


    // CalibrationMasterType
    //

    const CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber () const
    {
      return this->SerialNumber_.get ();
    }

    CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber ()
    {
      return this->SerialNumber_.get ();
    }

    void CalibrationMasterType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void CalibrationMasterType::
    SerialNumber (::std::unique_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (std::move (x));
    }

    const CalibrationMasterType::Description_optional& CalibrationMasterType::
    Description () const
    {
      return this->Description_;
    }

    CalibrationMasterType::Description_optional& CalibrationMasterType::
    Description ()
    {
      return this->Description_;
    }

    void CalibrationMasterType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void CalibrationMasterType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void CalibrationMasterType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // CalibrationType
    //

    const CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster () const
    {
      return this->CalibrationMaster_;
    }

    CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster ()
    {
      return this->CalibrationMaster_;
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_type& x)
    {
      this->CalibrationMaster_.set (x);
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_optional& x)
    {
      this->CalibrationMaster_ = x;
    }

    void CalibrationType::
    CalibrationMaster (::std::unique_ptr< CalibrationMaster_type > x)
    {
      this->CalibrationMaster_.set (std::move (x));
    }

    const CalibrationType::Temperatures_optional& CalibrationType::
    Temperatures () const
    {
      return this->Temperatures_;
    }

    CalibrationType::Temperatures_optional& CalibrationType::
    Temperatures ()
    {
      return this->Temperatures_;
    }

    void CalibrationType::
    Temperatures (const Temperatures_type& x)
    {
      this->Temperatures_.set (x);
    }

    void CalibrationType::
    Temperatures (const Temperatures_optional& x)
    {
      this->Temperatures_ = x;
    }

    void CalibrationType::
    Temperatures (::std::unique_ptr< Temperatures_type > x)
    {
      this->Temperatures_.set (std::move (x));
    }

    const CalibrationType::CalibrationDate_optional& CalibrationType::
    CalibrationDate () const
    {
      return this->CalibrationDate_;
    }

    CalibrationType::CalibrationDate_optional& CalibrationType::
    CalibrationDate ()
    {
      return this->CalibrationDate_;
    }

    void CalibrationType::
    CalibrationDate (const CalibrationDate_type& x)
    {
      this->CalibrationDate_.set (x);
    }

    void CalibrationType::
    CalibrationDate (const CalibrationDate_optional& x)
    {
      this->CalibrationDate_ = x;
    }

    void CalibrationType::
    CalibrationDate (::std::unique_ptr< CalibrationDate_type > x)
    {
      this->CalibrationDate_.set (std::move (x));
    }

    const CalibrationType::ExpirationDate_type& CalibrationType::
    ExpirationDate () const
    {
      return this->ExpirationDate_.get ();
    }

    CalibrationType::ExpirationDate_type& CalibrationType::
    ExpirationDate ()
    {
      return this->ExpirationDate_.get ();
    }

    void CalibrationType::
    ExpirationDate (const ExpirationDate_type& x)
    {
      this->ExpirationDate_.set (x);
    }

    void CalibrationType::
    ExpirationDate (::std::unique_ptr< ExpirationDate_type > x)
    {
      this->ExpirationDate_.set (std::move (x));
    }


    // CalibrationsType
    //

    const CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration () const
    {
      return this->Calibration_;
    }

    CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration ()
    {
      return this->Calibration_;
    }

    void CalibrationsType::
    Calibration (const Calibration_sequence& s)
    {
      this->Calibration_ = s;
    }

    const CalibrationsType::n_type& CalibrationsType::
    n () const
    {
      return this->n_.get ();
    }

    CalibrationsType::n_type& CalibrationsType::
    n ()
    {
      return this->n_.get ();
    }

    void CalibrationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CalibrationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // QualificationsType
    //

    const QualificationsType::Qualification_sequence& QualificationsType::
    Qualification () const
    {
      return this->Qualification_;
    }

    QualificationsType::Qualification_sequence& QualificationsType::
    Qualification ()
    {
      return this->Qualification_;
    }

    void QualificationsType::
    Qualification (const Qualification_sequence& s)
    {
      this->Qualification_ = s;
    }

    const QualificationsType::n_type& QualificationsType::
    n () const
    {
      return this->n_.get ();
    }

    QualificationsType::n_type& QualificationsType::
    n ()
    {
      return this->n_.get ();
    }

    void QualificationsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void QualificationsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // QualificationType
    //

    const QualificationType::Attributes_optional& QualificationType::
    Attributes () const
    {
      return this->Attributes_;
    }

    QualificationType::Attributes_optional& QualificationType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void QualificationType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void QualificationType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void QualificationType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const QualificationType::Description_type& QualificationType::
    Description () const
    {
      return this->Description_.get ();
    }

    QualificationType::Description_type& QualificationType::
    Description ()
    {
      return this->Description_.get ();
    }

    void QualificationType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void QualificationType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // TemperaturesType
    //

    const TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature () const
    {
      return this->Temperature_;
    }

    TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature ()
    {
      return this->Temperature_;
    }

    void TemperaturesType::
    Temperature (const Temperature_sequence& s)
    {
      this->Temperature_ = s;
    }

    const TemperaturesType::n_type& TemperaturesType::
    n () const
    {
      return this->n_.get ();
    }

    TemperaturesType::n_type& TemperaturesType::
    n ()
    {
      return this->n_.get ();
    }

    void TemperaturesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TemperaturesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TemperatureType
    //

    const TemperatureType::Attributes_optional& TemperatureType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TemperatureType::Attributes_optional& TemperatureType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TemperatureType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TemperatureType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TemperatureType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const TemperatureType::Temperature_type& TemperatureType::
    Temperature () const
    {
      return this->Temperature_.get ();
    }

    TemperatureType::Temperature_type& TemperatureType::
    Temperature ()
    {
      return this->Temperature_.get ();
    }

    void TemperatureType::
    Temperature (const Temperature_type& x)
    {
      this->Temperature_.set (x);
    }

    void TemperatureType::
    Temperature (::std::unique_ptr< Temperature_type > x)
    {
      this->Temperature_.set (std::move (x));
    }

    const TemperatureType::TimeStamp_optional& TemperatureType::
    TimeStamp () const
    {
      return this->TimeStamp_;
    }

    TemperatureType::TimeStamp_optional& TemperatureType::
    TimeStamp ()
    {
      return this->TimeStamp_;
    }

    void TemperatureType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void TemperatureType::
    TimeStamp (const TimeStamp_optional& x)
    {
      this->TimeStamp_ = x;
    }

    void TemperatureType::
    TimeStamp (::std::unique_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (std::move (x));
    }


    // LinearVariableDifferentialTransformerEnumType
    //

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_LinearVariableDifferentialTransformerEnumType_literals_[v])
    {
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const LinearVariableDifferentialTransformerEnumType& v,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    LinearVariableDifferentialTransformerEnumType& LinearVariableDifferentialTransformerEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_LinearVariableDifferentialTransformerEnumType_literals_[v]);

      return *this;
    }


    // LinearVariableDifferentialTransformerSensorType
    //

    const LinearVariableDifferentialTransformerSensorType::TypeOfLinearVariableDifferentialTransformer_optional& LinearVariableDifferentialTransformerSensorType::
    TypeOfLinearVariableDifferentialTransformer () const
    {
      return this->TypeOfLinearVariableDifferentialTransformer_;
    }

    LinearVariableDifferentialTransformerSensorType::TypeOfLinearVariableDifferentialTransformer_optional& LinearVariableDifferentialTransformerSensorType::
    TypeOfLinearVariableDifferentialTransformer ()
    {
      return this->TypeOfLinearVariableDifferentialTransformer_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    TypeOfLinearVariableDifferentialTransformer (const TypeOfLinearVariableDifferentialTransformer_type& x)
    {
      this->TypeOfLinearVariableDifferentialTransformer_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    TypeOfLinearVariableDifferentialTransformer (const TypeOfLinearVariableDifferentialTransformer_optional& x)
    {
      this->TypeOfLinearVariableDifferentialTransformer_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    TypeOfLinearVariableDifferentialTransformer (::std::unique_ptr< TypeOfLinearVariableDifferentialTransformer_type > x)
    {
      this->TypeOfLinearVariableDifferentialTransformer_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::MinMeasuringDistance_optional& LinearVariableDifferentialTransformerSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    LinearVariableDifferentialTransformerSensorType::MinMeasuringDistance_optional& LinearVariableDifferentialTransformerSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::MaxMeasuringDistance_optional& LinearVariableDifferentialTransformerSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    LinearVariableDifferentialTransformerSensorType::MaxMeasuringDistance_optional& LinearVariableDifferentialTransformerSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::TemperatureStability_optional& LinearVariableDifferentialTransformerSensorType::
    TemperatureStability () const
    {
      return this->TemperatureStability_;
    }

    LinearVariableDifferentialTransformerSensorType::TemperatureStability_optional& LinearVariableDifferentialTransformerSensorType::
    TemperatureStability ()
    {
      return this->TemperatureStability_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    TemperatureStability (const TemperatureStability_type& x)
    {
      this->TemperatureStability_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    TemperatureStability (const TemperatureStability_optional& x)
    {
      this->TemperatureStability_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    TemperatureStability (::std::unique_ptr< TemperatureStability_type > x)
    {
      this->TemperatureStability_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::ExcitationFrequency_optional& LinearVariableDifferentialTransformerSensorType::
    ExcitationFrequency () const
    {
      return this->ExcitationFrequency_;
    }

    LinearVariableDifferentialTransformerSensorType::ExcitationFrequency_optional& LinearVariableDifferentialTransformerSensorType::
    ExcitationFrequency ()
    {
      return this->ExcitationFrequency_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationFrequency (const ExcitationFrequency_type& x)
    {
      this->ExcitationFrequency_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationFrequency (const ExcitationFrequency_optional& x)
    {
      this->ExcitationFrequency_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationFrequency (::std::unique_ptr< ExcitationFrequency_type > x)
    {
      this->ExcitationFrequency_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::ExcitationAmplitude_optional& LinearVariableDifferentialTransformerSensorType::
    ExcitationAmplitude () const
    {
      return this->ExcitationAmplitude_;
    }

    LinearVariableDifferentialTransformerSensorType::ExcitationAmplitude_optional& LinearVariableDifferentialTransformerSensorType::
    ExcitationAmplitude ()
    {
      return this->ExcitationAmplitude_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationAmplitude (const ExcitationAmplitude_type& x)
    {
      this->ExcitationAmplitude_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationAmplitude (const ExcitationAmplitude_optional& x)
    {
      this->ExcitationAmplitude_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ExcitationAmplitude (::std::unique_ptr< ExcitationAmplitude_type > x)
    {
      this->ExcitationAmplitude_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::Diameter_optional& LinearVariableDifferentialTransformerSensorType::
    Diameter () const
    {
      return this->Diameter_;
    }

    LinearVariableDifferentialTransformerSensorType::Diameter_optional& LinearVariableDifferentialTransformerSensorType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::ShockTolerance_optional& LinearVariableDifferentialTransformerSensorType::
    ShockTolerance () const
    {
      return this->ShockTolerance_;
    }

    LinearVariableDifferentialTransformerSensorType::ShockTolerance_optional& LinearVariableDifferentialTransformerSensorType::
    ShockTolerance ()
    {
      return this->ShockTolerance_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ShockTolerance (const ShockTolerance_type& x)
    {
      this->ShockTolerance_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    ShockTolerance (const ShockTolerance_optional& x)
    {
      this->ShockTolerance_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ShockTolerance (::std::unique_ptr< ShockTolerance_type > x)
    {
      this->ShockTolerance_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::VibrationTolerance_optional& LinearVariableDifferentialTransformerSensorType::
    VibrationTolerance () const
    {
      return this->VibrationTolerance_;
    }

    LinearVariableDifferentialTransformerSensorType::VibrationTolerance_optional& LinearVariableDifferentialTransformerSensorType::
    VibrationTolerance ()
    {
      return this->VibrationTolerance_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    VibrationTolerance (const VibrationTolerance_type& x)
    {
      this->VibrationTolerance_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    VibrationTolerance (const VibrationTolerance_optional& x)
    {
      this->VibrationTolerance_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > x)
    {
      this->VibrationTolerance_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::HousingMaterial_optional& LinearVariableDifferentialTransformerSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    LinearVariableDifferentialTransformerSensorType::HousingMaterial_optional& LinearVariableDifferentialTransformerSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const LinearVariableDifferentialTransformerSensorType::ElectronicDescription_optional& LinearVariableDifferentialTransformerSensorType::
    ElectronicDescription () const
    {
      return this->ElectronicDescription_;
    }

    LinearVariableDifferentialTransformerSensorType::ElectronicDescription_optional& LinearVariableDifferentialTransformerSensorType::
    ElectronicDescription ()
    {
      return this->ElectronicDescription_;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ElectronicDescription (const ElectronicDescription_type& x)
    {
      this->ElectronicDescription_.set (x);
    }

    void LinearVariableDifferentialTransformerSensorType::
    ElectronicDescription (const ElectronicDescription_optional& x)
    {
      this->ElectronicDescription_ = x;
    }

    void LinearVariableDifferentialTransformerSensorType::
    ElectronicDescription (::std::unique_ptr< ElectronicDescription_type > x)
    {
      this->ElectronicDescription_.set (std::move (x));
    }


    // CapacitiveSensorType
    //

    const CapacitiveSensorType::MinOperatingVoltage_optional& CapacitiveSensorType::
    MinOperatingVoltage () const
    {
      return this->MinOperatingVoltage_;
    }

    CapacitiveSensorType::MinOperatingVoltage_optional& CapacitiveSensorType::
    MinOperatingVoltage ()
    {
      return this->MinOperatingVoltage_;
    }

    void CapacitiveSensorType::
    MinOperatingVoltage (const MinOperatingVoltage_type& x)
    {
      this->MinOperatingVoltage_.set (x);
    }

    void CapacitiveSensorType::
    MinOperatingVoltage (const MinOperatingVoltage_optional& x)
    {
      this->MinOperatingVoltage_ = x;
    }

    void CapacitiveSensorType::
    MinOperatingVoltage (::std::unique_ptr< MinOperatingVoltage_type > x)
    {
      this->MinOperatingVoltage_.set (std::move (x));
    }

    const CapacitiveSensorType::MaxOperatingVoltage_optional& CapacitiveSensorType::
    MaxOperatingVoltage () const
    {
      return this->MaxOperatingVoltage_;
    }

    CapacitiveSensorType::MaxOperatingVoltage_optional& CapacitiveSensorType::
    MaxOperatingVoltage ()
    {
      return this->MaxOperatingVoltage_;
    }

    void CapacitiveSensorType::
    MaxOperatingVoltage (const MaxOperatingVoltage_type& x)
    {
      this->MaxOperatingVoltage_.set (x);
    }

    void CapacitiveSensorType::
    MaxOperatingVoltage (const MaxOperatingVoltage_optional& x)
    {
      this->MaxOperatingVoltage_ = x;
    }

    void CapacitiveSensorType::
    MaxOperatingVoltage (::std::unique_ptr< MaxOperatingVoltage_type > x)
    {
      this->MaxOperatingVoltage_.set (std::move (x));
    }

    const CapacitiveSensorType::MinMeasuringDistance_optional& CapacitiveSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    CapacitiveSensorType::MinMeasuringDistance_optional& CapacitiveSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void CapacitiveSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void CapacitiveSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void CapacitiveSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const CapacitiveSensorType::MaxMeasuringDistance_optional& CapacitiveSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    CapacitiveSensorType::MaxMeasuringDistance_optional& CapacitiveSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void CapacitiveSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void CapacitiveSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void CapacitiveSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const CapacitiveSensorType::TemperatureStability_optional& CapacitiveSensorType::
    TemperatureStability () const
    {
      return this->TemperatureStability_;
    }

    CapacitiveSensorType::TemperatureStability_optional& CapacitiveSensorType::
    TemperatureStability ()
    {
      return this->TemperatureStability_;
    }

    void CapacitiveSensorType::
    TemperatureStability (const TemperatureStability_type& x)
    {
      this->TemperatureStability_.set (x);
    }

    void CapacitiveSensorType::
    TemperatureStability (const TemperatureStability_optional& x)
    {
      this->TemperatureStability_ = x;
    }

    void CapacitiveSensorType::
    TemperatureStability (::std::unique_ptr< TemperatureStability_type > x)
    {
      this->TemperatureStability_.set (std::move (x));
    }

    const CapacitiveSensorType::MinimumTargetDiameter_optional& CapacitiveSensorType::
    MinimumTargetDiameter () const
    {
      return this->MinimumTargetDiameter_;
    }

    CapacitiveSensorType::MinimumTargetDiameter_optional& CapacitiveSensorType::
    MinimumTargetDiameter ()
    {
      return this->MinimumTargetDiameter_;
    }

    void CapacitiveSensorType::
    MinimumTargetDiameter (const MinimumTargetDiameter_type& x)
    {
      this->MinimumTargetDiameter_.set (x);
    }

    void CapacitiveSensorType::
    MinimumTargetDiameter (const MinimumTargetDiameter_optional& x)
    {
      this->MinimumTargetDiameter_ = x;
    }

    void CapacitiveSensorType::
    MinimumTargetDiameter (::std::unique_ptr< MinimumTargetDiameter_type > x)
    {
      this->MinimumTargetDiameter_.set (std::move (x));
    }

    const CapacitiveSensorType::HousingMaterial_optional& CapacitiveSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    CapacitiveSensorType::HousingMaterial_optional& CapacitiveSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void CapacitiveSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void CapacitiveSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void CapacitiveSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const CapacitiveSensorType::Mounting_optional& CapacitiveSensorType::
    Mounting () const
    {
      return this->Mounting_;
    }

    CapacitiveSensorType::Mounting_optional& CapacitiveSensorType::
    Mounting ()
    {
      return this->Mounting_;
    }

    void CapacitiveSensorType::
    Mounting (const Mounting_type& x)
    {
      this->Mounting_.set (x);
    }

    void CapacitiveSensorType::
    Mounting (const Mounting_optional& x)
    {
      this->Mounting_ = x;
    }

    void CapacitiveSensorType::
    Mounting (::std::unique_ptr< Mounting_type > x)
    {
      this->Mounting_.set (std::move (x));
    }


    // EddyCurrentSensorType
    //

    const EddyCurrentSensorType::MaxPressureFront_optional& EddyCurrentSensorType::
    MaxPressureFront () const
    {
      return this->MaxPressureFront_;
    }

    EddyCurrentSensorType::MaxPressureFront_optional& EddyCurrentSensorType::
    MaxPressureFront ()
    {
      return this->MaxPressureFront_;
    }

    void EddyCurrentSensorType::
    MaxPressureFront (const MaxPressureFront_type& x)
    {
      this->MaxPressureFront_.set (x);
    }

    void EddyCurrentSensorType::
    MaxPressureFront (const MaxPressureFront_optional& x)
    {
      this->MaxPressureFront_ = x;
    }

    void EddyCurrentSensorType::
    MaxPressureFront (::std::unique_ptr< MaxPressureFront_type > x)
    {
      this->MaxPressureFront_.set (std::move (x));
    }

    const EddyCurrentSensorType::MaxPressureSide_optional& EddyCurrentSensorType::
    MaxPressureSide () const
    {
      return this->MaxPressureSide_;
    }

    EddyCurrentSensorType::MaxPressureSide_optional& EddyCurrentSensorType::
    MaxPressureSide ()
    {
      return this->MaxPressureSide_;
    }

    void EddyCurrentSensorType::
    MaxPressureSide (const MaxPressureSide_type& x)
    {
      this->MaxPressureSide_.set (x);
    }

    void EddyCurrentSensorType::
    MaxPressureSide (const MaxPressureSide_optional& x)
    {
      this->MaxPressureSide_ = x;
    }

    void EddyCurrentSensorType::
    MaxPressureSide (::std::unique_ptr< MaxPressureSide_type > x)
    {
      this->MaxPressureSide_.set (std::move (x));
    }

    const EddyCurrentSensorType::MinMeasuringDistance_optional& EddyCurrentSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    EddyCurrentSensorType::MinMeasuringDistance_optional& EddyCurrentSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void EddyCurrentSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void EddyCurrentSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void EddyCurrentSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const EddyCurrentSensorType::MaxMeasuringDistance_optional& EddyCurrentSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    EddyCurrentSensorType::MaxMeasuringDistance_optional& EddyCurrentSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void EddyCurrentSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void EddyCurrentSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void EddyCurrentSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const EddyCurrentSensorType::TemperatureStability_optional& EddyCurrentSensorType::
    TemperatureStability () const
    {
      return this->TemperatureStability_;
    }

    EddyCurrentSensorType::TemperatureStability_optional& EddyCurrentSensorType::
    TemperatureStability ()
    {
      return this->TemperatureStability_;
    }

    void EddyCurrentSensorType::
    TemperatureStability (const TemperatureStability_type& x)
    {
      this->TemperatureStability_.set (x);
    }

    void EddyCurrentSensorType::
    TemperatureStability (const TemperatureStability_optional& x)
    {
      this->TemperatureStability_ = x;
    }

    void EddyCurrentSensorType::
    TemperatureStability (::std::unique_ptr< TemperatureStability_type > x)
    {
      this->TemperatureStability_.set (std::move (x));
    }

    const EddyCurrentSensorType::OffsetDistance_optional& EddyCurrentSensorType::
    OffsetDistance () const
    {
      return this->OffsetDistance_;
    }

    EddyCurrentSensorType::OffsetDistance_optional& EddyCurrentSensorType::
    OffsetDistance ()
    {
      return this->OffsetDistance_;
    }

    void EddyCurrentSensorType::
    OffsetDistance (const OffsetDistance_type& x)
    {
      this->OffsetDistance_.set (x);
    }

    void EddyCurrentSensorType::
    OffsetDistance (const OffsetDistance_optional& x)
    {
      this->OffsetDistance_ = x;
    }

    void EddyCurrentSensorType::
    OffsetDistance (::std::unique_ptr< OffsetDistance_type > x)
    {
      this->OffsetDistance_.set (std::move (x));
    }

    const EddyCurrentSensorType::FrequencyResponse_optional& EddyCurrentSensorType::
    FrequencyResponse () const
    {
      return this->FrequencyResponse_;
    }

    EddyCurrentSensorType::FrequencyResponse_optional& EddyCurrentSensorType::
    FrequencyResponse ()
    {
      return this->FrequencyResponse_;
    }

    void EddyCurrentSensorType::
    FrequencyResponse (const FrequencyResponse_type& x)
    {
      this->FrequencyResponse_.set (x);
    }

    void EddyCurrentSensorType::
    FrequencyResponse (const FrequencyResponse_optional& x)
    {
      this->FrequencyResponse_ = x;
    }

    void EddyCurrentSensorType::
    FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > x)
    {
      this->FrequencyResponse_.set (std::move (x));
    }

    const EddyCurrentSensorType::MinPowerSupplyVoltage_optional& EddyCurrentSensorType::
    MinPowerSupplyVoltage () const
    {
      return this->MinPowerSupplyVoltage_;
    }

    EddyCurrentSensorType::MinPowerSupplyVoltage_optional& EddyCurrentSensorType::
    MinPowerSupplyVoltage ()
    {
      return this->MinPowerSupplyVoltage_;
    }

    void EddyCurrentSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x)
    {
      this->MinPowerSupplyVoltage_.set (x);
    }

    void EddyCurrentSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x)
    {
      this->MinPowerSupplyVoltage_ = x;
    }

    void EddyCurrentSensorType::
    MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > x)
    {
      this->MinPowerSupplyVoltage_.set (std::move (x));
    }

    const EddyCurrentSensorType::MaxPowerSupplyVoltage_optional& EddyCurrentSensorType::
    MaxPowerSupplyVoltage () const
    {
      return this->MaxPowerSupplyVoltage_;
    }

    EddyCurrentSensorType::MaxPowerSupplyVoltage_optional& EddyCurrentSensorType::
    MaxPowerSupplyVoltage ()
    {
      return this->MaxPowerSupplyVoltage_;
    }

    void EddyCurrentSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x)
    {
      this->MaxPowerSupplyVoltage_.set (x);
    }

    void EddyCurrentSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x)
    {
      this->MaxPowerSupplyVoltage_ = x;
    }

    void EddyCurrentSensorType::
    MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > x)
    {
      this->MaxPowerSupplyVoltage_.set (std::move (x));
    }

    const EddyCurrentSensorType::HousingMaterial_optional& EddyCurrentSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    EddyCurrentSensorType::HousingMaterial_optional& EddyCurrentSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void EddyCurrentSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void EddyCurrentSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void EddyCurrentSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const EddyCurrentSensorType::MeasurementObjectMaterial_optional& EddyCurrentSensorType::
    MeasurementObjectMaterial () const
    {
      return this->MeasurementObjectMaterial_;
    }

    EddyCurrentSensorType::MeasurementObjectMaterial_optional& EddyCurrentSensorType::
    MeasurementObjectMaterial ()
    {
      return this->MeasurementObjectMaterial_;
    }

    void EddyCurrentSensorType::
    MeasurementObjectMaterial (const MeasurementObjectMaterial_type& x)
    {
      this->MeasurementObjectMaterial_.set (x);
    }

    void EddyCurrentSensorType::
    MeasurementObjectMaterial (const MeasurementObjectMaterial_optional& x)
    {
      this->MeasurementObjectMaterial_ = x;
    }

    void EddyCurrentSensorType::
    MeasurementObjectMaterial (::std::unique_ptr< MeasurementObjectMaterial_type > x)
    {
      this->MeasurementObjectMaterial_.set (std::move (x));
    }


    // ConfocalChromaticSensorType
    //

    const ConfocalChromaticSensorType::SpotDiameter_optional& ConfocalChromaticSensorType::
    SpotDiameter () const
    {
      return this->SpotDiameter_;
    }

    ConfocalChromaticSensorType::SpotDiameter_optional& ConfocalChromaticSensorType::
    SpotDiameter ()
    {
      return this->SpotDiameter_;
    }

    void ConfocalChromaticSensorType::
    SpotDiameter (const SpotDiameter_type& x)
    {
      this->SpotDiameter_.set (x);
    }

    void ConfocalChromaticSensorType::
    SpotDiameter (const SpotDiameter_optional& x)
    {
      this->SpotDiameter_ = x;
    }

    void ConfocalChromaticSensorType::
    SpotDiameter (::std::unique_ptr< SpotDiameter_type > x)
    {
      this->SpotDiameter_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::MinMeasuringDistance_optional& ConfocalChromaticSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    ConfocalChromaticSensorType::MinMeasuringDistance_optional& ConfocalChromaticSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void ConfocalChromaticSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void ConfocalChromaticSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void ConfocalChromaticSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::MaxMeasuringDistance_optional& ConfocalChromaticSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    ConfocalChromaticSensorType::MaxMeasuringDistance_optional& ConfocalChromaticSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void ConfocalChromaticSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void ConfocalChromaticSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void ConfocalChromaticSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::MultiPeakMeasurement_optional& ConfocalChromaticSensorType::
    MultiPeakMeasurement () const
    {
      return this->MultiPeakMeasurement_;
    }

    ConfocalChromaticSensorType::MultiPeakMeasurement_optional& ConfocalChromaticSensorType::
    MultiPeakMeasurement ()
    {
      return this->MultiPeakMeasurement_;
    }

    void ConfocalChromaticSensorType::
    MultiPeakMeasurement (const MultiPeakMeasurement_type& x)
    {
      this->MultiPeakMeasurement_.set (x);
    }

    void ConfocalChromaticSensorType::
    MultiPeakMeasurement (const MultiPeakMeasurement_optional& x)
    {
      this->MultiPeakMeasurement_ = x;
    }

    const ConfocalChromaticSensorType::LightSource_optional& ConfocalChromaticSensorType::
    LightSource () const
    {
      return this->LightSource_;
    }

    ConfocalChromaticSensorType::LightSource_optional& ConfocalChromaticSensorType::
    LightSource ()
    {
      return this->LightSource_;
    }

    void ConfocalChromaticSensorType::
    LightSource (const LightSource_type& x)
    {
      this->LightSource_.set (x);
    }

    void ConfocalChromaticSensorType::
    LightSource (const LightSource_optional& x)
    {
      this->LightSource_ = x;
    }

    void ConfocalChromaticSensorType::
    LightSource (::std::unique_ptr< LightSource_type > x)
    {
      this->LightSource_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::MaxTilt_optional& ConfocalChromaticSensorType::
    MaxTilt () const
    {
      return this->MaxTilt_;
    }

    ConfocalChromaticSensorType::MaxTilt_optional& ConfocalChromaticSensorType::
    MaxTilt ()
    {
      return this->MaxTilt_;
    }

    void ConfocalChromaticSensorType::
    MaxTilt (const MaxTilt_type& x)
    {
      this->MaxTilt_.set (x);
    }

    void ConfocalChromaticSensorType::
    MaxTilt (const MaxTilt_optional& x)
    {
      this->MaxTilt_ = x;
    }

    void ConfocalChromaticSensorType::
    MaxTilt (::std::unique_ptr< MaxTilt_type > x)
    {
      this->MaxTilt_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::HousingMaterial_optional& ConfocalChromaticSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    ConfocalChromaticSensorType::HousingMaterial_optional& ConfocalChromaticSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void ConfocalChromaticSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void ConfocalChromaticSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void ConfocalChromaticSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::OpticalFiberCableLength_optional& ConfocalChromaticSensorType::
    OpticalFiberCableLength () const
    {
      return this->OpticalFiberCableLength_;
    }

    ConfocalChromaticSensorType::OpticalFiberCableLength_optional& ConfocalChromaticSensorType::
    OpticalFiberCableLength ()
    {
      return this->OpticalFiberCableLength_;
    }

    void ConfocalChromaticSensorType::
    OpticalFiberCableLength (const OpticalFiberCableLength_type& x)
    {
      this->OpticalFiberCableLength_.set (x);
    }

    void ConfocalChromaticSensorType::
    OpticalFiberCableLength (const OpticalFiberCableLength_optional& x)
    {
      this->OpticalFiberCableLength_ = x;
    }

    void ConfocalChromaticSensorType::
    OpticalFiberCableLength (::std::unique_ptr< OpticalFiberCableLength_type > x)
    {
      this->OpticalFiberCableLength_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::ShockTolerance_optional& ConfocalChromaticSensorType::
    ShockTolerance () const
    {
      return this->ShockTolerance_;
    }

    ConfocalChromaticSensorType::ShockTolerance_optional& ConfocalChromaticSensorType::
    ShockTolerance ()
    {
      return this->ShockTolerance_;
    }

    void ConfocalChromaticSensorType::
    ShockTolerance (const ShockTolerance_type& x)
    {
      this->ShockTolerance_.set (x);
    }

    void ConfocalChromaticSensorType::
    ShockTolerance (const ShockTolerance_optional& x)
    {
      this->ShockTolerance_ = x;
    }

    void ConfocalChromaticSensorType::
    ShockTolerance (::std::unique_ptr< ShockTolerance_type > x)
    {
      this->ShockTolerance_.set (std::move (x));
    }

    const ConfocalChromaticSensorType::VibrationTolerance_optional& ConfocalChromaticSensorType::
    VibrationTolerance () const
    {
      return this->VibrationTolerance_;
    }

    ConfocalChromaticSensorType::VibrationTolerance_optional& ConfocalChromaticSensorType::
    VibrationTolerance ()
    {
      return this->VibrationTolerance_;
    }

    void ConfocalChromaticSensorType::
    VibrationTolerance (const VibrationTolerance_type& x)
    {
      this->VibrationTolerance_.set (x);
    }

    void ConfocalChromaticSensorType::
    VibrationTolerance (const VibrationTolerance_optional& x)
    {
      this->VibrationTolerance_ = x;
    }

    void ConfocalChromaticSensorType::
    VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > x)
    {
      this->VibrationTolerance_.set (std::move (x));
    }


    // DrawWireSensorType
    //

    const DrawWireSensorType::MinMeasuringDistance_optional& DrawWireSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    DrawWireSensorType::MinMeasuringDistance_optional& DrawWireSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void DrawWireSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void DrawWireSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void DrawWireSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const DrawWireSensorType::MaxMeasuringDistance_optional& DrawWireSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    DrawWireSensorType::MaxMeasuringDistance_optional& DrawWireSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void DrawWireSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void DrawWireSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void DrawWireSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const DrawWireSensorType::MaxWireExtensionForce_optional& DrawWireSensorType::
    MaxWireExtensionForce () const
    {
      return this->MaxWireExtensionForce_;
    }

    DrawWireSensorType::MaxWireExtensionForce_optional& DrawWireSensorType::
    MaxWireExtensionForce ()
    {
      return this->MaxWireExtensionForce_;
    }

    void DrawWireSensorType::
    MaxWireExtensionForce (const MaxWireExtensionForce_type& x)
    {
      this->MaxWireExtensionForce_.set (x);
    }

    void DrawWireSensorType::
    MaxWireExtensionForce (const MaxWireExtensionForce_optional& x)
    {
      this->MaxWireExtensionForce_ = x;
    }

    void DrawWireSensorType::
    MaxWireExtensionForce (::std::unique_ptr< MaxWireExtensionForce_type > x)
    {
      this->MaxWireExtensionForce_.set (std::move (x));
    }

    const DrawWireSensorType::MinWireRetractionForce_optional& DrawWireSensorType::
    MinWireRetractionForce () const
    {
      return this->MinWireRetractionForce_;
    }

    DrawWireSensorType::MinWireRetractionForce_optional& DrawWireSensorType::
    MinWireRetractionForce ()
    {
      return this->MinWireRetractionForce_;
    }

    void DrawWireSensorType::
    MinWireRetractionForce (const MinWireRetractionForce_type& x)
    {
      this->MinWireRetractionForce_.set (x);
    }

    void DrawWireSensorType::
    MinWireRetractionForce (const MinWireRetractionForce_optional& x)
    {
      this->MinWireRetractionForce_ = x;
    }

    void DrawWireSensorType::
    MinWireRetractionForce (::std::unique_ptr< MinWireRetractionForce_type > x)
    {
      this->MinWireRetractionForce_.set (std::move (x));
    }

    const DrawWireSensorType::MaxWireAcceleration_optional& DrawWireSensorType::
    MaxWireAcceleration () const
    {
      return this->MaxWireAcceleration_;
    }

    DrawWireSensorType::MaxWireAcceleration_optional& DrawWireSensorType::
    MaxWireAcceleration ()
    {
      return this->MaxWireAcceleration_;
    }

    void DrawWireSensorType::
    MaxWireAcceleration (const MaxWireAcceleration_type& x)
    {
      this->MaxWireAcceleration_.set (x);
    }

    void DrawWireSensorType::
    MaxWireAcceleration (const MaxWireAcceleration_optional& x)
    {
      this->MaxWireAcceleration_ = x;
    }

    void DrawWireSensorType::
    MaxWireAcceleration (::std::unique_ptr< MaxWireAcceleration_type > x)
    {
      this->MaxWireAcceleration_.set (std::move (x));
    }


    // MagnetoInductiveSensorType
    //

    const MagnetoInductiveSensorType::MinMeasuringDistance_optional& MagnetoInductiveSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    MagnetoInductiveSensorType::MinMeasuringDistance_optional& MagnetoInductiveSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void MagnetoInductiveSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void MagnetoInductiveSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void MagnetoInductiveSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::MaxMeasuringDistance_optional& MagnetoInductiveSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    MagnetoInductiveSensorType::MaxMeasuringDistance_optional& MagnetoInductiveSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void MagnetoInductiveSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void MagnetoInductiveSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void MagnetoInductiveSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::FrequencyResponse_optional& MagnetoInductiveSensorType::
    FrequencyResponse () const
    {
      return this->FrequencyResponse_;
    }

    MagnetoInductiveSensorType::FrequencyResponse_optional& MagnetoInductiveSensorType::
    FrequencyResponse ()
    {
      return this->FrequencyResponse_;
    }

    void MagnetoInductiveSensorType::
    FrequencyResponse (const FrequencyResponse_type& x)
    {
      this->FrequencyResponse_.set (x);
    }

    void MagnetoInductiveSensorType::
    FrequencyResponse (const FrequencyResponse_optional& x)
    {
      this->FrequencyResponse_ = x;
    }

    void MagnetoInductiveSensorType::
    FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > x)
    {
      this->FrequencyResponse_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::OffsetDistance_optional& MagnetoInductiveSensorType::
    OffsetDistance () const
    {
      return this->OffsetDistance_;
    }

    MagnetoInductiveSensorType::OffsetDistance_optional& MagnetoInductiveSensorType::
    OffsetDistance ()
    {
      return this->OffsetDistance_;
    }

    void MagnetoInductiveSensorType::
    OffsetDistance (const OffsetDistance_type& x)
    {
      this->OffsetDistance_.set (x);
    }

    void MagnetoInductiveSensorType::
    OffsetDistance (const OffsetDistance_optional& x)
    {
      this->OffsetDistance_ = x;
    }

    void MagnetoInductiveSensorType::
    OffsetDistance (::std::unique_ptr< OffsetDistance_type > x)
    {
      this->OffsetDistance_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::MaxPressure_optional& MagnetoInductiveSensorType::
    MaxPressure () const
    {
      return this->MaxPressure_;
    }

    MagnetoInductiveSensorType::MaxPressure_optional& MagnetoInductiveSensorType::
    MaxPressure ()
    {
      return this->MaxPressure_;
    }

    void MagnetoInductiveSensorType::
    MaxPressure (const MaxPressure_type& x)
    {
      this->MaxPressure_.set (x);
    }

    void MagnetoInductiveSensorType::
    MaxPressure (const MaxPressure_optional& x)
    {
      this->MaxPressure_ = x;
    }

    void MagnetoInductiveSensorType::
    MaxPressure (::std::unique_ptr< MaxPressure_type > x)
    {
      this->MaxPressure_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::ShockTolerance_optional& MagnetoInductiveSensorType::
    ShockTolerance () const
    {
      return this->ShockTolerance_;
    }

    MagnetoInductiveSensorType::ShockTolerance_optional& MagnetoInductiveSensorType::
    ShockTolerance ()
    {
      return this->ShockTolerance_;
    }

    void MagnetoInductiveSensorType::
    ShockTolerance (const ShockTolerance_type& x)
    {
      this->ShockTolerance_.set (x);
    }

    void MagnetoInductiveSensorType::
    ShockTolerance (const ShockTolerance_optional& x)
    {
      this->ShockTolerance_ = x;
    }

    void MagnetoInductiveSensorType::
    ShockTolerance (::std::unique_ptr< ShockTolerance_type > x)
    {
      this->ShockTolerance_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::VibrationTolerance_optional& MagnetoInductiveSensorType::
    VibrationTolerance () const
    {
      return this->VibrationTolerance_;
    }

    MagnetoInductiveSensorType::VibrationTolerance_optional& MagnetoInductiveSensorType::
    VibrationTolerance ()
    {
      return this->VibrationTolerance_;
    }

    void MagnetoInductiveSensorType::
    VibrationTolerance (const VibrationTolerance_type& x)
    {
      this->VibrationTolerance_.set (x);
    }

    void MagnetoInductiveSensorType::
    VibrationTolerance (const VibrationTolerance_optional& x)
    {
      this->VibrationTolerance_ = x;
    }

    void MagnetoInductiveSensorType::
    VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > x)
    {
      this->VibrationTolerance_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::HousingMaterial_optional& MagnetoInductiveSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    MagnetoInductiveSensorType::HousingMaterial_optional& MagnetoInductiveSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void MagnetoInductiveSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void MagnetoInductiveSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void MagnetoInductiveSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::MaxCurrentConsumption_optional& MagnetoInductiveSensorType::
    MaxCurrentConsumption () const
    {
      return this->MaxCurrentConsumption_;
    }

    MagnetoInductiveSensorType::MaxCurrentConsumption_optional& MagnetoInductiveSensorType::
    MaxCurrentConsumption ()
    {
      return this->MaxCurrentConsumption_;
    }

    void MagnetoInductiveSensorType::
    MaxCurrentConsumption (const MaxCurrentConsumption_type& x)
    {
      this->MaxCurrentConsumption_.set (x);
    }

    void MagnetoInductiveSensorType::
    MaxCurrentConsumption (const MaxCurrentConsumption_optional& x)
    {
      this->MaxCurrentConsumption_ = x;
    }

    void MagnetoInductiveSensorType::
    MaxCurrentConsumption (::std::unique_ptr< MaxCurrentConsumption_type > x)
    {
      this->MaxCurrentConsumption_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::MinPowerSupplyVoltage_optional& MagnetoInductiveSensorType::
    MinPowerSupplyVoltage () const
    {
      return this->MinPowerSupplyVoltage_;
    }

    MagnetoInductiveSensorType::MinPowerSupplyVoltage_optional& MagnetoInductiveSensorType::
    MinPowerSupplyVoltage ()
    {
      return this->MinPowerSupplyVoltage_;
    }

    void MagnetoInductiveSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x)
    {
      this->MinPowerSupplyVoltage_.set (x);
    }

    void MagnetoInductiveSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x)
    {
      this->MinPowerSupplyVoltage_ = x;
    }

    void MagnetoInductiveSensorType::
    MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > x)
    {
      this->MinPowerSupplyVoltage_.set (std::move (x));
    }

    const MagnetoInductiveSensorType::MaxPowerSupplyVoltage_optional& MagnetoInductiveSensorType::
    MaxPowerSupplyVoltage () const
    {
      return this->MaxPowerSupplyVoltage_;
    }

    MagnetoInductiveSensorType::MaxPowerSupplyVoltage_optional& MagnetoInductiveSensorType::
    MaxPowerSupplyVoltage ()
    {
      return this->MaxPowerSupplyVoltage_;
    }

    void MagnetoInductiveSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x)
    {
      this->MaxPowerSupplyVoltage_.set (x);
    }

    void MagnetoInductiveSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x)
    {
      this->MaxPowerSupplyVoltage_ = x;
    }

    void MagnetoInductiveSensorType::
    MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > x)
    {
      this->MaxPowerSupplyVoltage_.set (std::move (x));
    }


    // DifferentialVariableReluctanceTransducerSensorType
    //

    const DifferentialVariableReluctanceTransducerSensorType::MinMeasuringDistance_optional& DifferentialVariableReluctanceTransducerSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    DifferentialVariableReluctanceTransducerSensorType::MinMeasuringDistance_optional& DifferentialVariableReluctanceTransducerSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const DifferentialVariableReluctanceTransducerSensorType::MaxMeasuringDistance_optional& DifferentialVariableReluctanceTransducerSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    DifferentialVariableReluctanceTransducerSensorType::MaxMeasuringDistance_optional& DifferentialVariableReluctanceTransducerSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const DifferentialVariableReluctanceTransducerSensorType::Hysteresis_optional& DifferentialVariableReluctanceTransducerSensorType::
    Hysteresis () const
    {
      return this->Hysteresis_;
    }

    DifferentialVariableReluctanceTransducerSensorType::Hysteresis_optional& DifferentialVariableReluctanceTransducerSensorType::
    Hysteresis ()
    {
      return this->Hysteresis_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    Hysteresis (const Hysteresis_type& x)
    {
      this->Hysteresis_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    Hysteresis (const Hysteresis_optional& x)
    {
      this->Hysteresis_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    Hysteresis (::std::unique_ptr< Hysteresis_type > x)
    {
      this->Hysteresis_.set (std::move (x));
    }

    const DifferentialVariableReluctanceTransducerSensorType::FrequencyResponse_optional& DifferentialVariableReluctanceTransducerSensorType::
    FrequencyResponse () const
    {
      return this->FrequencyResponse_;
    }

    DifferentialVariableReluctanceTransducerSensorType::FrequencyResponse_optional& DifferentialVariableReluctanceTransducerSensorType::
    FrequencyResponse ()
    {
      return this->FrequencyResponse_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    FrequencyResponse (const FrequencyResponse_type& x)
    {
      this->FrequencyResponse_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    FrequencyResponse (const FrequencyResponse_optional& x)
    {
      this->FrequencyResponse_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > x)
    {
      this->FrequencyResponse_.set (std::move (x));
    }

    const DifferentialVariableReluctanceTransducerSensorType::TemperatureStability_optional& DifferentialVariableReluctanceTransducerSensorType::
    TemperatureStability () const
    {
      return this->TemperatureStability_;
    }

    DifferentialVariableReluctanceTransducerSensorType::TemperatureStability_optional& DifferentialVariableReluctanceTransducerSensorType::
    TemperatureStability ()
    {
      return this->TemperatureStability_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    TemperatureStability (const TemperatureStability_type& x)
    {
      this->TemperatureStability_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    TemperatureStability (const TemperatureStability_optional& x)
    {
      this->TemperatureStability_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    TemperatureStability (::std::unique_ptr< TemperatureStability_type > x)
    {
      this->TemperatureStability_.set (std::move (x));
    }

    const DifferentialVariableReluctanceTransducerSensorType::HousingMaterial_optional& DifferentialVariableReluctanceTransducerSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    DifferentialVariableReluctanceTransducerSensorType::HousingMaterial_optional& DifferentialVariableReluctanceTransducerSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }


    // LaserTriangulationSensorType
    //

    const LaserTriangulationSensorType::AverageSpotDiameter_optional& LaserTriangulationSensorType::
    AverageSpotDiameter () const
    {
      return this->AverageSpotDiameter_;
    }

    LaserTriangulationSensorType::AverageSpotDiameter_optional& LaserTriangulationSensorType::
    AverageSpotDiameter ()
    {
      return this->AverageSpotDiameter_;
    }

    void LaserTriangulationSensorType::
    AverageSpotDiameter (const AverageSpotDiameter_type& x)
    {
      this->AverageSpotDiameter_.set (x);
    }

    void LaserTriangulationSensorType::
    AverageSpotDiameter (const AverageSpotDiameter_optional& x)
    {
      this->AverageSpotDiameter_ = x;
    }

    void LaserTriangulationSensorType::
    AverageSpotDiameter (::std::unique_ptr< AverageSpotDiameter_type > x)
    {
      this->AverageSpotDiameter_.set (std::move (x));
    }

    const LaserTriangulationSensorType::LaserSafetyClass_optional& LaserTriangulationSensorType::
    LaserSafetyClass () const
    {
      return this->LaserSafetyClass_;
    }

    LaserTriangulationSensorType::LaserSafetyClass_optional& LaserTriangulationSensorType::
    LaserSafetyClass ()
    {
      return this->LaserSafetyClass_;
    }

    void LaserTriangulationSensorType::
    LaserSafetyClass (const LaserSafetyClass_type& x)
    {
      this->LaserSafetyClass_.set (x);
    }

    void LaserTriangulationSensorType::
    LaserSafetyClass (const LaserSafetyClass_optional& x)
    {
      this->LaserSafetyClass_ = x;
    }

    void LaserTriangulationSensorType::
    LaserSafetyClass (::std::unique_ptr< LaserSafetyClass_type > x)
    {
      this->LaserSafetyClass_.set (std::move (x));
    }

    const LaserTriangulationSensorType::MaxMeasurementFrequency_optional& LaserTriangulationSensorType::
    MaxMeasurementFrequency () const
    {
      return this->MaxMeasurementFrequency_;
    }

    LaserTriangulationSensorType::MaxMeasurementFrequency_optional& LaserTriangulationSensorType::
    MaxMeasurementFrequency ()
    {
      return this->MaxMeasurementFrequency_;
    }

    void LaserTriangulationSensorType::
    MaxMeasurementFrequency (const MaxMeasurementFrequency_type& x)
    {
      this->MaxMeasurementFrequency_.set (x);
    }

    void LaserTriangulationSensorType::
    MaxMeasurementFrequency (const MaxMeasurementFrequency_optional& x)
    {
      this->MaxMeasurementFrequency_ = x;
    }

    void LaserTriangulationSensorType::
    MaxMeasurementFrequency (::std::unique_ptr< MaxMeasurementFrequency_type > x)
    {
      this->MaxMeasurementFrequency_.set (std::move (x));
    }

    const LaserTriangulationSensorType::MinMeasuringDistance_optional& LaserTriangulationSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    LaserTriangulationSensorType::MinMeasuringDistance_optional& LaserTriangulationSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void LaserTriangulationSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void LaserTriangulationSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void LaserTriangulationSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const LaserTriangulationSensorType::MaxMeasuringDistance_optional& LaserTriangulationSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    LaserTriangulationSensorType::MaxMeasuringDistance_optional& LaserTriangulationSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void LaserTriangulationSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void LaserTriangulationSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void LaserTriangulationSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const LaserTriangulationSensorType::HousingMaterial_optional& LaserTriangulationSensorType::
    HousingMaterial () const
    {
      return this->HousingMaterial_;
    }

    LaserTriangulationSensorType::HousingMaterial_optional& LaserTriangulationSensorType::
    HousingMaterial ()
    {
      return this->HousingMaterial_;
    }

    void LaserTriangulationSensorType::
    HousingMaterial (const HousingMaterial_type& x)
    {
      this->HousingMaterial_.set (x);
    }

    void LaserTriangulationSensorType::
    HousingMaterial (const HousingMaterial_optional& x)
    {
      this->HousingMaterial_ = x;
    }

    void LaserTriangulationSensorType::
    HousingMaterial (::std::unique_ptr< HousingMaterial_type > x)
    {
      this->HousingMaterial_.set (std::move (x));
    }

    const LaserTriangulationSensorType::PermissibleAmbientLight_optional& LaserTriangulationSensorType::
    PermissibleAmbientLight () const
    {
      return this->PermissibleAmbientLight_;
    }

    LaserTriangulationSensorType::PermissibleAmbientLight_optional& LaserTriangulationSensorType::
    PermissibleAmbientLight ()
    {
      return this->PermissibleAmbientLight_;
    }

    void LaserTriangulationSensorType::
    PermissibleAmbientLight (const PermissibleAmbientLight_type& x)
    {
      this->PermissibleAmbientLight_.set (x);
    }

    void LaserTriangulationSensorType::
    PermissibleAmbientLight (const PermissibleAmbientLight_optional& x)
    {
      this->PermissibleAmbientLight_ = x;
    }

    void LaserTriangulationSensorType::
    PermissibleAmbientLight (::std::unique_ptr< PermissibleAmbientLight_type > x)
    {
      this->PermissibleAmbientLight_.set (std::move (x));
    }

    const LaserTriangulationSensorType::ShockTolerance_optional& LaserTriangulationSensorType::
    ShockTolerance () const
    {
      return this->ShockTolerance_;
    }

    LaserTriangulationSensorType::ShockTolerance_optional& LaserTriangulationSensorType::
    ShockTolerance ()
    {
      return this->ShockTolerance_;
    }

    void LaserTriangulationSensorType::
    ShockTolerance (const ShockTolerance_type& x)
    {
      this->ShockTolerance_.set (x);
    }

    void LaserTriangulationSensorType::
    ShockTolerance (const ShockTolerance_optional& x)
    {
      this->ShockTolerance_ = x;
    }

    void LaserTriangulationSensorType::
    ShockTolerance (::std::unique_ptr< ShockTolerance_type > x)
    {
      this->ShockTolerance_.set (std::move (x));
    }

    const LaserTriangulationSensorType::VibrationTolerance_optional& LaserTriangulationSensorType::
    VibrationTolerance () const
    {
      return this->VibrationTolerance_;
    }

    LaserTriangulationSensorType::VibrationTolerance_optional& LaserTriangulationSensorType::
    VibrationTolerance ()
    {
      return this->VibrationTolerance_;
    }

    void LaserTriangulationSensorType::
    VibrationTolerance (const VibrationTolerance_type& x)
    {
      this->VibrationTolerance_.set (x);
    }

    void LaserTriangulationSensorType::
    VibrationTolerance (const VibrationTolerance_optional& x)
    {
      this->VibrationTolerance_ = x;
    }

    void LaserTriangulationSensorType::
    VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > x)
    {
      this->VibrationTolerance_.set (std::move (x));
    }

    const LaserTriangulationSensorType::OutputPower_optional& LaserTriangulationSensorType::
    OutputPower () const
    {
      return this->OutputPower_;
    }

    LaserTriangulationSensorType::OutputPower_optional& LaserTriangulationSensorType::
    OutputPower ()
    {
      return this->OutputPower_;
    }

    void LaserTriangulationSensorType::
    OutputPower (const OutputPower_type& x)
    {
      this->OutputPower_.set (x);
    }

    void LaserTriangulationSensorType::
    OutputPower (const OutputPower_optional& x)
    {
      this->OutputPower_ = x;
    }

    void LaserTriangulationSensorType::
    OutputPower (::std::unique_ptr< OutputPower_type > x)
    {
      this->OutputPower_.set (std::move (x));
    }

    const LaserTriangulationSensorType::Laser_optional& LaserTriangulationSensorType::
    Laser () const
    {
      return this->Laser_;
    }

    LaserTriangulationSensorType::Laser_optional& LaserTriangulationSensorType::
    Laser ()
    {
      return this->Laser_;
    }

    void LaserTriangulationSensorType::
    Laser (const Laser_type& x)
    {
      this->Laser_.set (x);
    }

    void LaserTriangulationSensorType::
    Laser (const Laser_optional& x)
    {
      this->Laser_ = x;
    }

    void LaserTriangulationSensorType::
    Laser (::std::unique_ptr< Laser_type > x)
    {
      this->Laser_.set (std::move (x));
    }


    // StructuredLightSensorType
    //

    const StructuredLightSensorType::OutputFileFormat_optional& StructuredLightSensorType::
    OutputFileFormat () const
    {
      return this->OutputFileFormat_;
    }

    StructuredLightSensorType::OutputFileFormat_optional& StructuredLightSensorType::
    OutputFileFormat ()
    {
      return this->OutputFileFormat_;
    }

    void StructuredLightSensorType::
    OutputFileFormat (const OutputFileFormat_type& x)
    {
      this->OutputFileFormat_.set (x);
    }

    void StructuredLightSensorType::
    OutputFileFormat (const OutputFileFormat_optional& x)
    {
      this->OutputFileFormat_ = x;
    }

    void StructuredLightSensorType::
    OutputFileFormat (::std::unique_ptr< OutputFileFormat_type > x)
    {
      this->OutputFileFormat_.set (std::move (x));
    }

    const StructuredLightSensorType::MeasurementFieldSize_optional& StructuredLightSensorType::
    MeasurementFieldSize () const
    {
      return this->MeasurementFieldSize_;
    }

    StructuredLightSensorType::MeasurementFieldSize_optional& StructuredLightSensorType::
    MeasurementFieldSize ()
    {
      return this->MeasurementFieldSize_;
    }

    void StructuredLightSensorType::
    MeasurementFieldSize (const MeasurementFieldSize_type& x)
    {
      this->MeasurementFieldSize_.set (x);
    }

    void StructuredLightSensorType::
    MeasurementFieldSize (const MeasurementFieldSize_optional& x)
    {
      this->MeasurementFieldSize_ = x;
    }

    void StructuredLightSensorType::
    MeasurementFieldSize (::std::unique_ptr< MeasurementFieldSize_type > x)
    {
      this->MeasurementFieldSize_.set (std::move (x));
    }

    const StructuredLightSensorType::NumberOfCameraPixels_optional& StructuredLightSensorType::
    NumberOfCameraPixels () const
    {
      return this->NumberOfCameraPixels_;
    }

    StructuredLightSensorType::NumberOfCameraPixels_optional& StructuredLightSensorType::
    NumberOfCameraPixels ()
    {
      return this->NumberOfCameraPixels_;
    }

    void StructuredLightSensorType::
    NumberOfCameraPixels (const NumberOfCameraPixels_type& x)
    {
      this->NumberOfCameraPixels_.set (x);
    }

    void StructuredLightSensorType::
    NumberOfCameraPixels (const NumberOfCameraPixels_optional& x)
    {
      this->NumberOfCameraPixels_ = x;
    }

    const StructuredLightSensorType::LightSource_optional& StructuredLightSensorType::
    LightSource () const
    {
      return this->LightSource_;
    }

    StructuredLightSensorType::LightSource_optional& StructuredLightSensorType::
    LightSource ()
    {
      return this->LightSource_;
    }

    void StructuredLightSensorType::
    LightSource (const LightSource_type& x)
    {
      this->LightSource_.set (x);
    }

    void StructuredLightSensorType::
    LightSource (const LightSource_optional& x)
    {
      this->LightSource_ = x;
    }

    void StructuredLightSensorType::
    LightSource (::std::unique_ptr< LightSource_type > x)
    {
      this->LightSource_.set (std::move (x));
    }

    const StructuredLightSensorType::MeasurementRate_optional& StructuredLightSensorType::
    MeasurementRate () const
    {
      return this->MeasurementRate_;
    }

    StructuredLightSensorType::MeasurementRate_optional& StructuredLightSensorType::
    MeasurementRate ()
    {
      return this->MeasurementRate_;
    }

    void StructuredLightSensorType::
    MeasurementRate (const MeasurementRate_type& x)
    {
      this->MeasurementRate_.set (x);
    }

    void StructuredLightSensorType::
    MeasurementRate (const MeasurementRate_optional& x)
    {
      this->MeasurementRate_ = x;
    }

    void StructuredLightSensorType::
    MeasurementRate (::std::unique_ptr< MeasurementRate_type > x)
    {
      this->MeasurementRate_.set (std::move (x));
    }

    const StructuredLightSensorType::WorkingVolume_optional& StructuredLightSensorType::
    WorkingVolume () const
    {
      return this->WorkingVolume_;
    }

    StructuredLightSensorType::WorkingVolume_optional& StructuredLightSensorType::
    WorkingVolume ()
    {
      return this->WorkingVolume_;
    }

    void StructuredLightSensorType::
    WorkingVolume (const WorkingVolume_type& x)
    {
      this->WorkingVolume_.set (x);
    }

    void StructuredLightSensorType::
    WorkingVolume (const WorkingVolume_optional& x)
    {
      this->WorkingVolume_ = x;
    }

    void StructuredLightSensorType::
    WorkingVolume (::std::unique_ptr< WorkingVolume_type > x)
    {
      this->WorkingVolume_.set (std::move (x));
    }

    const StructuredLightSensorType::StandOffDistance_optional& StructuredLightSensorType::
    StandOffDistance () const
    {
      return this->StandOffDistance_;
    }

    StructuredLightSensorType::StandOffDistance_optional& StructuredLightSensorType::
    StandOffDistance ()
    {
      return this->StandOffDistance_;
    }

    void StructuredLightSensorType::
    StandOffDistance (const StandOffDistance_type& x)
    {
      this->StandOffDistance_.set (x);
    }

    void StructuredLightSensorType::
    StandOffDistance (const StandOffDistance_optional& x)
    {
      this->StandOffDistance_ = x;
    }

    void StructuredLightSensorType::
    StandOffDistance (::std::unique_ptr< StandOffDistance_type > x)
    {
      this->StandOffDistance_.set (std::move (x));
    }

    const StructuredLightSensorType::MaxPermissibleProbingError_optional& StructuredLightSensorType::
    MaxPermissibleProbingError () const
    {
      return this->MaxPermissibleProbingError_;
    }

    StructuredLightSensorType::MaxPermissibleProbingError_optional& StructuredLightSensorType::
    MaxPermissibleProbingError ()
    {
      return this->MaxPermissibleProbingError_;
    }

    void StructuredLightSensorType::
    MaxPermissibleProbingError (const MaxPermissibleProbingError_type& x)
    {
      this->MaxPermissibleProbingError_.set (x);
    }

    void StructuredLightSensorType::
    MaxPermissibleProbingError (const MaxPermissibleProbingError_optional& x)
    {
      this->MaxPermissibleProbingError_ = x;
    }

    void StructuredLightSensorType::
    MaxPermissibleProbingError (::std::unique_ptr< MaxPermissibleProbingError_type > x)
    {
      this->MaxPermissibleProbingError_.set (std::move (x));
    }

    const StructuredLightSensorType::Laser_optional& StructuredLightSensorType::
    Laser () const
    {
      return this->Laser_;
    }

    StructuredLightSensorType::Laser_optional& StructuredLightSensorType::
    Laser ()
    {
      return this->Laser_;
    }

    void StructuredLightSensorType::
    Laser (const Laser_type& x)
    {
      this->Laser_.set (x);
    }

    void StructuredLightSensorType::
    Laser (const Laser_optional& x)
    {
      this->Laser_ = x;
    }

    void StructuredLightSensorType::
    Laser (::std::unique_ptr< Laser_type > x)
    {
      this->Laser_.set (std::move (x));
    }


    // UltrasonicSensorType
    //

    const UltrasonicSensorType::MinMeasuringDistance_optional& UltrasonicSensorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    UltrasonicSensorType::MinMeasuringDistance_optional& UltrasonicSensorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void UltrasonicSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void UltrasonicSensorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void UltrasonicSensorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const UltrasonicSensorType::MaxMeasuringDistance_optional& UltrasonicSensorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    UltrasonicSensorType::MaxMeasuringDistance_optional& UltrasonicSensorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void UltrasonicSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void UltrasonicSensorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void UltrasonicSensorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const UltrasonicSensorType::SamplingFrequency_optional& UltrasonicSensorType::
    SamplingFrequency () const
    {
      return this->SamplingFrequency_;
    }

    UltrasonicSensorType::SamplingFrequency_optional& UltrasonicSensorType::
    SamplingFrequency ()
    {
      return this->SamplingFrequency_;
    }

    void UltrasonicSensorType::
    SamplingFrequency (const SamplingFrequency_type& x)
    {
      this->SamplingFrequency_.set (x);
    }

    void UltrasonicSensorType::
    SamplingFrequency (const SamplingFrequency_optional& x)
    {
      this->SamplingFrequency_ = x;
    }

    void UltrasonicSensorType::
    SamplingFrequency (::std::unique_ptr< SamplingFrequency_type > x)
    {
      this->SamplingFrequency_.set (std::move (x));
    }

    const UltrasonicSensorType::AppliedFrequency_optional& UltrasonicSensorType::
    AppliedFrequency () const
    {
      return this->AppliedFrequency_;
    }

    UltrasonicSensorType::AppliedFrequency_optional& UltrasonicSensorType::
    AppliedFrequency ()
    {
      return this->AppliedFrequency_;
    }

    void UltrasonicSensorType::
    AppliedFrequency (const AppliedFrequency_type& x)
    {
      this->AppliedFrequency_.set (x);
    }

    void UltrasonicSensorType::
    AppliedFrequency (const AppliedFrequency_optional& x)
    {
      this->AppliedFrequency_ = x;
    }

    void UltrasonicSensorType::
    AppliedFrequency (::std::unique_ptr< AppliedFrequency_type > x)
    {
      this->AppliedFrequency_.set (std::move (x));
    }

    const UltrasonicSensorType::MaxResponseTime_optional& UltrasonicSensorType::
    MaxResponseTime () const
    {
      return this->MaxResponseTime_;
    }

    UltrasonicSensorType::MaxResponseTime_optional& UltrasonicSensorType::
    MaxResponseTime ()
    {
      return this->MaxResponseTime_;
    }

    void UltrasonicSensorType::
    MaxResponseTime (const MaxResponseTime_type& x)
    {
      this->MaxResponseTime_.set (x);
    }

    void UltrasonicSensorType::
    MaxResponseTime (const MaxResponseTime_optional& x)
    {
      this->MaxResponseTime_ = x;
    }

    void UltrasonicSensorType::
    MaxResponseTime (::std::unique_ptr< MaxResponseTime_type > x)
    {
      this->MaxResponseTime_.set (std::move (x));
    }

    const UltrasonicSensorType::ShockTolerance_optional& UltrasonicSensorType::
    ShockTolerance () const
    {
      return this->ShockTolerance_;
    }

    UltrasonicSensorType::ShockTolerance_optional& UltrasonicSensorType::
    ShockTolerance ()
    {
      return this->ShockTolerance_;
    }

    void UltrasonicSensorType::
    ShockTolerance (const ShockTolerance_type& x)
    {
      this->ShockTolerance_.set (x);
    }

    void UltrasonicSensorType::
    ShockTolerance (const ShockTolerance_optional& x)
    {
      this->ShockTolerance_ = x;
    }

    void UltrasonicSensorType::
    ShockTolerance (::std::unique_ptr< ShockTolerance_type > x)
    {
      this->ShockTolerance_.set (std::move (x));
    }

    const UltrasonicSensorType::VibrationTolerance_optional& UltrasonicSensorType::
    VibrationTolerance () const
    {
      return this->VibrationTolerance_;
    }

    UltrasonicSensorType::VibrationTolerance_optional& UltrasonicSensorType::
    VibrationTolerance ()
    {
      return this->VibrationTolerance_;
    }

    void UltrasonicSensorType::
    VibrationTolerance (const VibrationTolerance_type& x)
    {
      this->VibrationTolerance_.set (x);
    }

    void UltrasonicSensorType::
    VibrationTolerance (const VibrationTolerance_optional& x)
    {
      this->VibrationTolerance_ = x;
    }

    void UltrasonicSensorType::
    VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > x)
    {
      this->VibrationTolerance_.set (std::move (x));
    }

    const UltrasonicSensorType::MinPowerSupplyVoltage_optional& UltrasonicSensorType::
    MinPowerSupplyVoltage () const
    {
      return this->MinPowerSupplyVoltage_;
    }

    UltrasonicSensorType::MinPowerSupplyVoltage_optional& UltrasonicSensorType::
    MinPowerSupplyVoltage ()
    {
      return this->MinPowerSupplyVoltage_;
    }

    void UltrasonicSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x)
    {
      this->MinPowerSupplyVoltage_.set (x);
    }

    void UltrasonicSensorType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x)
    {
      this->MinPowerSupplyVoltage_ = x;
    }

    void UltrasonicSensorType::
    MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > x)
    {
      this->MinPowerSupplyVoltage_.set (std::move (x));
    }

    const UltrasonicSensorType::MaxPowerSupplyVoltage_optional& UltrasonicSensorType::
    MaxPowerSupplyVoltage () const
    {
      return this->MaxPowerSupplyVoltage_;
    }

    UltrasonicSensorType::MaxPowerSupplyVoltage_optional& UltrasonicSensorType::
    MaxPowerSupplyVoltage ()
    {
      return this->MaxPowerSupplyVoltage_;
    }

    void UltrasonicSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x)
    {
      this->MaxPowerSupplyVoltage_.set (x);
    }

    void UltrasonicSensorType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x)
    {
      this->MaxPowerSupplyVoltage_ = x;
    }

    void UltrasonicSensorType::
    MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > x)
    {
      this->MaxPowerSupplyVoltage_.set (std::move (x));
    }


    // TipEndGeometryEnumType
    //

    TipEndGeometryEnumType::
    TipEndGeometryEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_TipEndGeometryEnumType_literals_[v])
    {
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const TipEndGeometryEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    TipEndGeometryEnumType& TipEndGeometryEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_TipEndGeometryEnumType_literals_[v]);

      return *this;
    }


    // TipEndGeometryType
    //

    const TipEndGeometryType::TipEndGeometryEnum_optional& TipEndGeometryType::
    TipEndGeometryEnum () const
    {
      return this->TipEndGeometryEnum_;
    }

    TipEndGeometryType::TipEndGeometryEnum_optional& TipEndGeometryType::
    TipEndGeometryEnum ()
    {
      return this->TipEndGeometryEnum_;
    }

    void TipEndGeometryType::
    TipEndGeometryEnum (const TipEndGeometryEnum_type& x)
    {
      this->TipEndGeometryEnum_.set (x);
    }

    void TipEndGeometryType::
    TipEndGeometryEnum (const TipEndGeometryEnum_optional& x)
    {
      this->TipEndGeometryEnum_ = x;
    }

    void TipEndGeometryType::
    TipEndGeometryEnum (::std::unique_ptr< TipEndGeometryEnum_type > x)
    {
      this->TipEndGeometryEnum_.set (std::move (x));
    }

    const TipEndGeometryType::OtherTipEndGeometry_optional& TipEndGeometryType::
    OtherTipEndGeometry () const
    {
      return this->OtherTipEndGeometry_;
    }

    TipEndGeometryType::OtherTipEndGeometry_optional& TipEndGeometryType::
    OtherTipEndGeometry ()
    {
      return this->OtherTipEndGeometry_;
    }

    void TipEndGeometryType::
    OtherTipEndGeometry (const OtherTipEndGeometry_type& x)
    {
      this->OtherTipEndGeometry_.set (x);
    }

    void TipEndGeometryType::
    OtherTipEndGeometry (const OtherTipEndGeometry_optional& x)
    {
      this->OtherTipEndGeometry_ = x;
    }

    void TipEndGeometryType::
    OtherTipEndGeometry (::std::unique_ptr< OtherTipEndGeometry_type > x)
    {
      this->OtherTipEndGeometry_.set (std::move (x));
    }


    // TactileProbeSensorBaseType
    //


    // SimpleTactileProbeSensorType
    //

    const SimpleTactileProbeSensorType::Qualifications_optional& SimpleTactileProbeSensorType::
    Qualifications () const
    {
      return this->Qualifications_;
    }

    SimpleTactileProbeSensorType::Qualifications_optional& SimpleTactileProbeSensorType::
    Qualifications ()
    {
      return this->Qualifications_;
    }

    void SimpleTactileProbeSensorType::
    Qualifications (const Qualifications_type& x)
    {
      this->Qualifications_.set (x);
    }

    void SimpleTactileProbeSensorType::
    Qualifications (const Qualifications_optional& x)
    {
      this->Qualifications_ = x;
    }

    void SimpleTactileProbeSensorType::
    Qualifications (::std::unique_ptr< Qualifications_type > x)
    {
      this->Qualifications_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::Length_optional& SimpleTactileProbeSensorType::
    Length () const
    {
      return this->Length_;
    }

    SimpleTactileProbeSensorType::Length_optional& SimpleTactileProbeSensorType::
    Length ()
    {
      return this->Length_;
    }

    void SimpleTactileProbeSensorType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SimpleTactileProbeSensorType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SimpleTactileProbeSensorType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::TipEndGeometry_optional& SimpleTactileProbeSensorType::
    TipEndGeometry () const
    {
      return this->TipEndGeometry_;
    }

    SimpleTactileProbeSensorType::TipEndGeometry_optional& SimpleTactileProbeSensorType::
    TipEndGeometry ()
    {
      return this->TipEndGeometry_;
    }

    void SimpleTactileProbeSensorType::
    TipEndGeometry (const TipEndGeometry_type& x)
    {
      this->TipEndGeometry_.set (x);
    }

    void SimpleTactileProbeSensorType::
    TipEndGeometry (const TipEndGeometry_optional& x)
    {
      this->TipEndGeometry_ = x;
    }

    void SimpleTactileProbeSensorType::
    TipEndGeometry (::std::unique_ptr< TipEndGeometry_type > x)
    {
      this->TipEndGeometry_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::TipEndDiameter_optional& SimpleTactileProbeSensorType::
    TipEndDiameter () const
    {
      return this->TipEndDiameter_;
    }

    SimpleTactileProbeSensorType::TipEndDiameter_optional& SimpleTactileProbeSensorType::
    TipEndDiameter ()
    {
      return this->TipEndDiameter_;
    }

    void SimpleTactileProbeSensorType::
    TipEndDiameter (const TipEndDiameter_type& x)
    {
      this->TipEndDiameter_.set (x);
    }

    void SimpleTactileProbeSensorType::
    TipEndDiameter (const TipEndDiameter_optional& x)
    {
      this->TipEndDiameter_ = x;
    }

    void SimpleTactileProbeSensorType::
    TipEndDiameter (::std::unique_ptr< TipEndDiameter_type > x)
    {
      this->TipEndDiameter_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::TipEndMaterial_optional& SimpleTactileProbeSensorType::
    TipEndMaterial () const
    {
      return this->TipEndMaterial_;
    }

    SimpleTactileProbeSensorType::TipEndMaterial_optional& SimpleTactileProbeSensorType::
    TipEndMaterial ()
    {
      return this->TipEndMaterial_;
    }

    void SimpleTactileProbeSensorType::
    TipEndMaterial (const TipEndMaterial_type& x)
    {
      this->TipEndMaterial_.set (x);
    }

    void SimpleTactileProbeSensorType::
    TipEndMaterial (const TipEndMaterial_optional& x)
    {
      this->TipEndMaterial_ = x;
    }

    void SimpleTactileProbeSensorType::
    TipEndMaterial (::std::unique_ptr< TipEndMaterial_type > x)
    {
      this->TipEndMaterial_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::StemMaterial_optional& SimpleTactileProbeSensorType::
    StemMaterial () const
    {
      return this->StemMaterial_;
    }

    SimpleTactileProbeSensorType::StemMaterial_optional& SimpleTactileProbeSensorType::
    StemMaterial ()
    {
      return this->StemMaterial_;
    }

    void SimpleTactileProbeSensorType::
    StemMaterial (const StemMaterial_type& x)
    {
      this->StemMaterial_.set (x);
    }

    void SimpleTactileProbeSensorType::
    StemMaterial (const StemMaterial_optional& x)
    {
      this->StemMaterial_ = x;
    }

    void SimpleTactileProbeSensorType::
    StemMaterial (::std::unique_ptr< StemMaterial_type > x)
    {
      this->StemMaterial_.set (std::move (x));
    }

    const SimpleTactileProbeSensorType::StemDiameter_optional& SimpleTactileProbeSensorType::
    StemDiameter () const
    {
      return this->StemDiameter_;
    }

    SimpleTactileProbeSensorType::StemDiameter_optional& SimpleTactileProbeSensorType::
    StemDiameter ()
    {
      return this->StemDiameter_;
    }

    void SimpleTactileProbeSensorType::
    StemDiameter (const StemDiameter_type& x)
    {
      this->StemDiameter_.set (x);
    }

    void SimpleTactileProbeSensorType::
    StemDiameter (const StemDiameter_optional& x)
    {
      this->StemDiameter_ = x;
    }

    void SimpleTactileProbeSensorType::
    StemDiameter (::std::unique_ptr< StemDiameter_type > x)
    {
      this->StemDiameter_.set (std::move (x));
    }


    // ComplexTactileProbeSensorType
    //

    const ComplexTactileProbeSensorType::LocatedTips_type& ComplexTactileProbeSensorType::
    LocatedTips () const
    {
      return this->LocatedTips_.get ();
    }

    ComplexTactileProbeSensorType::LocatedTips_type& ComplexTactileProbeSensorType::
    LocatedTips ()
    {
      return this->LocatedTips_.get ();
    }

    void ComplexTactileProbeSensorType::
    LocatedTips (const LocatedTips_type& x)
    {
      this->LocatedTips_.set (x);
    }

    void ComplexTactileProbeSensorType::
    LocatedTips (::std::unique_ptr< LocatedTips_type > x)
    {
      this->LocatedTips_.set (std::move (x));
    }


    // LocatedTipsType
    //

    const LocatedTipsType::LocatedTip_sequence& LocatedTipsType::
    LocatedTip () const
    {
      return this->LocatedTip_;
    }

    LocatedTipsType::LocatedTip_sequence& LocatedTipsType::
    LocatedTip ()
    {
      return this->LocatedTip_;
    }

    void LocatedTipsType::
    LocatedTip (const LocatedTip_sequence& s)
    {
      this->LocatedTip_ = s;
    }

    const LocatedTipsType::n_type& LocatedTipsType::
    n () const
    {
      return this->n_.get ();
    }

    LocatedTipsType::n_type& LocatedTipsType::
    n ()
    {
      return this->n_.get ();
    }

    void LocatedTipsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LocatedTipsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ProbeTipType
    //

    const ProbeTipType::TipEndGeometry_optional& ProbeTipType::
    TipEndGeometry () const
    {
      return this->TipEndGeometry_;
    }

    ProbeTipType::TipEndGeometry_optional& ProbeTipType::
    TipEndGeometry ()
    {
      return this->TipEndGeometry_;
    }

    void ProbeTipType::
    TipEndGeometry (const TipEndGeometry_type& x)
    {
      this->TipEndGeometry_.set (x);
    }

    void ProbeTipType::
    TipEndGeometry (const TipEndGeometry_optional& x)
    {
      this->TipEndGeometry_ = x;
    }

    void ProbeTipType::
    TipEndGeometry (::std::unique_ptr< TipEndGeometry_type > x)
    {
      this->TipEndGeometry_.set (std::move (x));
    }

    const ProbeTipType::TipEndDiameter_optional& ProbeTipType::
    TipEndDiameter () const
    {
      return this->TipEndDiameter_;
    }

    ProbeTipType::TipEndDiameter_optional& ProbeTipType::
    TipEndDiameter ()
    {
      return this->TipEndDiameter_;
    }

    void ProbeTipType::
    TipEndDiameter (const TipEndDiameter_type& x)
    {
      this->TipEndDiameter_.set (x);
    }

    void ProbeTipType::
    TipEndDiameter (const TipEndDiameter_optional& x)
    {
      this->TipEndDiameter_ = x;
    }

    void ProbeTipType::
    TipEndDiameter (::std::unique_ptr< TipEndDiameter_type > x)
    {
      this->TipEndDiameter_.set (std::move (x));
    }

    const ProbeTipType::TipEndMaterial_optional& ProbeTipType::
    TipEndMaterial () const
    {
      return this->TipEndMaterial_;
    }

    ProbeTipType::TipEndMaterial_optional& ProbeTipType::
    TipEndMaterial ()
    {
      return this->TipEndMaterial_;
    }

    void ProbeTipType::
    TipEndMaterial (const TipEndMaterial_type& x)
    {
      this->TipEndMaterial_.set (x);
    }

    void ProbeTipType::
    TipEndMaterial (const TipEndMaterial_optional& x)
    {
      this->TipEndMaterial_ = x;
    }

    void ProbeTipType::
    TipEndMaterial (::std::unique_ptr< TipEndMaterial_type > x)
    {
      this->TipEndMaterial_.set (std::move (x));
    }

    const ProbeTipType::StemMaterial_optional& ProbeTipType::
    StemMaterial () const
    {
      return this->StemMaterial_;
    }

    ProbeTipType::StemMaterial_optional& ProbeTipType::
    StemMaterial ()
    {
      return this->StemMaterial_;
    }

    void ProbeTipType::
    StemMaterial (const StemMaterial_type& x)
    {
      this->StemMaterial_.set (x);
    }

    void ProbeTipType::
    StemMaterial (const StemMaterial_optional& x)
    {
      this->StemMaterial_ = x;
    }

    void ProbeTipType::
    StemMaterial (::std::unique_ptr< StemMaterial_type > x)
    {
      this->StemMaterial_.set (std::move (x));
    }

    const ProbeTipType::StemDiameter_optional& ProbeTipType::
    StemDiameter () const
    {
      return this->StemDiameter_;
    }

    ProbeTipType::StemDiameter_optional& ProbeTipType::
    StemDiameter ()
    {
      return this->StemDiameter_;
    }

    void ProbeTipType::
    StemDiameter (const StemDiameter_type& x)
    {
      this->StemDiameter_.set (x);
    }

    void ProbeTipType::
    StemDiameter (const StemDiameter_optional& x)
    {
      this->StemDiameter_ = x;
    }

    void ProbeTipType::
    StemDiameter (::std::unique_ptr< StemDiameter_type > x)
    {
      this->StemDiameter_.set (std::move (x));
    }


    // LocatedTipType
    //

    const LocatedTipType::ProbeTip_type& LocatedTipType::
    ProbeTip () const
    {
      return this->ProbeTip_.get ();
    }

    LocatedTipType::ProbeTip_type& LocatedTipType::
    ProbeTip ()
    {
      return this->ProbeTip_.get ();
    }

    void LocatedTipType::
    ProbeTip (const ProbeTip_type& x)
    {
      this->ProbeTip_.set (x);
    }

    void LocatedTipType::
    ProbeTip (::std::unique_ptr< ProbeTip_type > x)
    {
      this->ProbeTip_.set (std::move (x));
    }

    const LocatedTipType::TipEndLocation_type& LocatedTipType::
    TipEndLocation () const
    {
      return this->TipEndLocation_.get ();
    }

    LocatedTipType::TipEndLocation_type& LocatedTipType::
    TipEndLocation ()
    {
      return this->TipEndLocation_.get ();
    }

    void LocatedTipType::
    TipEndLocation (const TipEndLocation_type& x)
    {
      this->TipEndLocation_.set (x);
    }

    void LocatedTipType::
    TipEndLocation (::std::unique_ptr< TipEndLocation_type > x)
    {
      this->TipEndLocation_.set (std::move (x));
    }


    // ChargeCoupledDeviceCameraSensorType
    //

    const ChargeCoupledDeviceCameraSensorType::NumberOfPixels_optional& ChargeCoupledDeviceCameraSensorType::
    NumberOfPixels () const
    {
      return this->NumberOfPixels_;
    }

    ChargeCoupledDeviceCameraSensorType::NumberOfPixels_optional& ChargeCoupledDeviceCameraSensorType::
    NumberOfPixels ()
    {
      return this->NumberOfPixels_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    NumberOfPixels (const NumberOfPixels_type& x)
    {
      this->NumberOfPixels_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    NumberOfPixels (const NumberOfPixels_optional& x)
    {
      this->NumberOfPixels_ = x;
    }

    const ChargeCoupledDeviceCameraSensorType::MaxReadoutFrequency_optional& ChargeCoupledDeviceCameraSensorType::
    MaxReadoutFrequency () const
    {
      return this->MaxReadoutFrequency_;
    }

    ChargeCoupledDeviceCameraSensorType::MaxReadoutFrequency_optional& ChargeCoupledDeviceCameraSensorType::
    MaxReadoutFrequency ()
    {
      return this->MaxReadoutFrequency_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadoutFrequency (const MaxReadoutFrequency_type& x)
    {
      this->MaxReadoutFrequency_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadoutFrequency (const MaxReadoutFrequency_optional& x)
    {
      this->MaxReadoutFrequency_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadoutFrequency (::std::unique_ptr< MaxReadoutFrequency_type > x)
    {
      this->MaxReadoutFrequency_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::HorizontalFieldOfView_optional& ChargeCoupledDeviceCameraSensorType::
    HorizontalFieldOfView () const
    {
      return this->HorizontalFieldOfView_;
    }

    ChargeCoupledDeviceCameraSensorType::HorizontalFieldOfView_optional& ChargeCoupledDeviceCameraSensorType::
    HorizontalFieldOfView ()
    {
      return this->HorizontalFieldOfView_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    HorizontalFieldOfView (const HorizontalFieldOfView_type& x)
    {
      this->HorizontalFieldOfView_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    HorizontalFieldOfView (const HorizontalFieldOfView_optional& x)
    {
      this->HorizontalFieldOfView_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    HorizontalFieldOfView (::std::unique_ptr< HorizontalFieldOfView_type > x)
    {
      this->HorizontalFieldOfView_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::VerticalFieldOfView_optional& ChargeCoupledDeviceCameraSensorType::
    VerticalFieldOfView () const
    {
      return this->VerticalFieldOfView_;
    }

    ChargeCoupledDeviceCameraSensorType::VerticalFieldOfView_optional& ChargeCoupledDeviceCameraSensorType::
    VerticalFieldOfView ()
    {
      return this->VerticalFieldOfView_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    VerticalFieldOfView (const VerticalFieldOfView_type& x)
    {
      this->VerticalFieldOfView_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    VerticalFieldOfView (const VerticalFieldOfView_optional& x)
    {
      this->VerticalFieldOfView_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    VerticalFieldOfView (::std::unique_ptr< VerticalFieldOfView_type > x)
    {
      this->VerticalFieldOfView_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::MaxReadNoise_optional& ChargeCoupledDeviceCameraSensorType::
    MaxReadNoise () const
    {
      return this->MaxReadNoise_;
    }

    ChargeCoupledDeviceCameraSensorType::MaxReadNoise_optional& ChargeCoupledDeviceCameraSensorType::
    MaxReadNoise ()
    {
      return this->MaxReadNoise_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadNoise (const MaxReadNoise_type& x)
    {
      this->MaxReadNoise_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadNoise (const MaxReadNoise_optional& x)
    {
      this->MaxReadNoise_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxReadNoise (::std::unique_ptr< MaxReadNoise_type > x)
    {
      this->MaxReadNoise_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::MaxFrameRate_optional& ChargeCoupledDeviceCameraSensorType::
    MaxFrameRate () const
    {
      return this->MaxFrameRate_;
    }

    ChargeCoupledDeviceCameraSensorType::MaxFrameRate_optional& ChargeCoupledDeviceCameraSensorType::
    MaxFrameRate ()
    {
      return this->MaxFrameRate_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxFrameRate (const MaxFrameRate_type& x)
    {
      this->MaxFrameRate_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxFrameRate (const MaxFrameRate_optional& x)
    {
      this->MaxFrameRate_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxFrameRate (::std::unique_ptr< MaxFrameRate_type > x)
    {
      this->MaxFrameRate_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::PixelSize_optional& ChargeCoupledDeviceCameraSensorType::
    PixelSize () const
    {
      return this->PixelSize_;
    }

    ChargeCoupledDeviceCameraSensorType::PixelSize_optional& ChargeCoupledDeviceCameraSensorType::
    PixelSize ()
    {
      return this->PixelSize_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    PixelSize (const PixelSize_type& x)
    {
      this->PixelSize_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    PixelSize (const PixelSize_optional& x)
    {
      this->PixelSize_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    PixelSize (::std::unique_ptr< PixelSize_type > x)
    {
      this->PixelSize_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::SustainedDataRate_optional& ChargeCoupledDeviceCameraSensorType::
    SustainedDataRate () const
    {
      return this->SustainedDataRate_;
    }

    ChargeCoupledDeviceCameraSensorType::SustainedDataRate_optional& ChargeCoupledDeviceCameraSensorType::
    SustainedDataRate ()
    {
      return this->SustainedDataRate_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    SustainedDataRate (const SustainedDataRate_type& x)
    {
      this->SustainedDataRate_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    SustainedDataRate (const SustainedDataRate_optional& x)
    {
      this->SustainedDataRate_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    SustainedDataRate (::std::unique_ptr< SustainedDataRate_type > x)
    {
      this->SustainedDataRate_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::DarkCurrent_optional& ChargeCoupledDeviceCameraSensorType::
    DarkCurrent () const
    {
      return this->DarkCurrent_;
    }

    ChargeCoupledDeviceCameraSensorType::DarkCurrent_optional& ChargeCoupledDeviceCameraSensorType::
    DarkCurrent ()
    {
      return this->DarkCurrent_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    DarkCurrent (const DarkCurrent_type& x)
    {
      this->DarkCurrent_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    DarkCurrent (const DarkCurrent_optional& x)
    {
      this->DarkCurrent_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    DarkCurrent (::std::unique_ptr< DarkCurrent_type > x)
    {
      this->DarkCurrent_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::MaxPixelClockSpeed_optional& ChargeCoupledDeviceCameraSensorType::
    MaxPixelClockSpeed () const
    {
      return this->MaxPixelClockSpeed_;
    }

    ChargeCoupledDeviceCameraSensorType::MaxPixelClockSpeed_optional& ChargeCoupledDeviceCameraSensorType::
    MaxPixelClockSpeed ()
    {
      return this->MaxPixelClockSpeed_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxPixelClockSpeed (const MaxPixelClockSpeed_type& x)
    {
      this->MaxPixelClockSpeed_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxPixelClockSpeed (const MaxPixelClockSpeed_optional& x)
    {
      this->MaxPixelClockSpeed_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxPixelClockSpeed (::std::unique_ptr< MaxPixelClockSpeed_type > x)
    {
      this->MaxPixelClockSpeed_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::Linearity_optional& ChargeCoupledDeviceCameraSensorType::
    Linearity () const
    {
      return this->Linearity_;
    }

    ChargeCoupledDeviceCameraSensorType::Linearity_optional& ChargeCoupledDeviceCameraSensorType::
    Linearity ()
    {
      return this->Linearity_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    Linearity (const Linearity_type& x)
    {
      this->Linearity_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    Linearity (const Linearity_optional& x)
    {
      this->Linearity_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    Linearity (::std::unique_ptr< Linearity_type > x)
    {
      this->Linearity_.set (std::move (x));
    }

    const ChargeCoupledDeviceCameraSensorType::MaxOutputVoltage_optional& ChargeCoupledDeviceCameraSensorType::
    MaxOutputVoltage () const
    {
      return this->MaxOutputVoltage_;
    }

    ChargeCoupledDeviceCameraSensorType::MaxOutputVoltage_optional& ChargeCoupledDeviceCameraSensorType::
    MaxOutputVoltage ()
    {
      return this->MaxOutputVoltage_;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxOutputVoltage (const MaxOutputVoltage_type& x)
    {
      this->MaxOutputVoltage_.set (x);
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxOutputVoltage (const MaxOutputVoltage_optional& x)
    {
      this->MaxOutputVoltage_ = x;
    }

    void ChargeCoupledDeviceCameraSensorType::
    MaxOutputVoltage (::std::unique_ptr< MaxOutputVoltage_type > x)
    {
      this->MaxOutputVoltage_.set (std::move (x));
    }


    // CMMType
    //


    // CartesianCMMType
    //

    const CartesianCMMType::HomeLocation_optional& CartesianCMMType::
    HomeLocation () const
    {
      return this->HomeLocation_;
    }

    CartesianCMMType::HomeLocation_optional& CartesianCMMType::
    HomeLocation ()
    {
      return this->HomeLocation_;
    }

    void CartesianCMMType::
    HomeLocation (const HomeLocation_type& x)
    {
      this->HomeLocation_.set (x);
    }

    void CartesianCMMType::
    HomeLocation (const HomeLocation_optional& x)
    {
      this->HomeLocation_ = x;
    }

    void CartesianCMMType::
    HomeLocation (::std::unique_ptr< HomeLocation_type > x)
    {
      this->HomeLocation_.set (std::move (x));
    }

    const CartesianCMMType::CMMGeometry_optional& CartesianCMMType::
    CMMGeometry () const
    {
      return this->CMMGeometry_;
    }

    CartesianCMMType::CMMGeometry_optional& CartesianCMMType::
    CMMGeometry ()
    {
      return this->CMMGeometry_;
    }

    void CartesianCMMType::
    CMMGeometry (const CMMGeometry_type& x)
    {
      this->CMMGeometry_.set (x);
    }

    void CartesianCMMType::
    CMMGeometry (const CMMGeometry_optional& x)
    {
      this->CMMGeometry_ = x;
    }

    void CartesianCMMType::
    CMMGeometry (::std::unique_ptr< CMMGeometry_type > x)
    {
      this->CMMGeometry_.set (std::move (x));
    }

    const CartesianCMMType::CMMAxisDirections_optional& CartesianCMMType::
    CMMAxisDirections () const
    {
      return this->CMMAxisDirections_;
    }

    CartesianCMMType::CMMAxisDirections_optional& CartesianCMMType::
    CMMAxisDirections ()
    {
      return this->CMMAxisDirections_;
    }

    void CartesianCMMType::
    CMMAxisDirections (const CMMAxisDirections_type& x)
    {
      this->CMMAxisDirections_.set (x);
    }

    void CartesianCMMType::
    CMMAxisDirections (const CMMAxisDirections_optional& x)
    {
      this->CMMAxisDirections_ = x;
    }

    void CartesianCMMType::
    CMMAxisDirections (::std::unique_ptr< CMMAxisDirections_type > x)
    {
      this->CMMAxisDirections_.set (std::move (x));
    }

    const CartesianCMMType::Scales_optional& CartesianCMMType::
    Scales () const
    {
      return this->Scales_;
    }

    CartesianCMMType::Scales_optional& CartesianCMMType::
    Scales ()
    {
      return this->Scales_;
    }

    void CartesianCMMType::
    Scales (const Scales_type& x)
    {
      this->Scales_.set (x);
    }

    void CartesianCMMType::
    Scales (const Scales_optional& x)
    {
      this->Scales_ = x;
    }

    void CartesianCMMType::
    Scales (::std::unique_ptr< Scales_type > x)
    {
      this->Scales_.set (std::move (x));
    }

    const CartesianCMMType::MaxWorkpieceHeight_optional& CartesianCMMType::
    MaxWorkpieceHeight () const
    {
      return this->MaxWorkpieceHeight_;
    }

    CartesianCMMType::MaxWorkpieceHeight_optional& CartesianCMMType::
    MaxWorkpieceHeight ()
    {
      return this->MaxWorkpieceHeight_;
    }

    void CartesianCMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    void CartesianCMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x)
    {
      this->MaxWorkpieceHeight_ = x;
    }

    void CartesianCMMType::
    MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > x)
    {
      this->MaxWorkpieceHeight_.set (std::move (x));
    }

    const CartesianCMMType::MaxWorkpieceMass_optional& CartesianCMMType::
    MaxWorkpieceMass () const
    {
      return this->MaxWorkpieceMass_;
    }

    CartesianCMMType::MaxWorkpieceMass_optional& CartesianCMMType::
    MaxWorkpieceMass ()
    {
      return this->MaxWorkpieceMass_;
    }

    void CartesianCMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_type& x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    void CartesianCMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_optional& x)
    {
      this->MaxWorkpieceMass_ = x;
    }

    void CartesianCMMType::
    MaxWorkpieceMass (::std::unique_ptr< MaxWorkpieceMass_type > x)
    {
      this->MaxWorkpieceMass_.set (std::move (x));
    }

    const CartesianCMMType::JoystickSpeeds_optional& CartesianCMMType::
    JoystickSpeeds () const
    {
      return this->JoystickSpeeds_;
    }

    CartesianCMMType::JoystickSpeeds_optional& CartesianCMMType::
    JoystickSpeeds ()
    {
      return this->JoystickSpeeds_;
    }

    void CartesianCMMType::
    JoystickSpeeds (const JoystickSpeeds_type& x)
    {
      this->JoystickSpeeds_.set (x);
    }

    void CartesianCMMType::
    JoystickSpeeds (const JoystickSpeeds_optional& x)
    {
      this->JoystickSpeeds_ = x;
    }

    void CartesianCMMType::
    JoystickSpeeds (::std::unique_ptr< JoystickSpeeds_type > x)
    {
      this->JoystickSpeeds_.set (std::move (x));
    }

    const CartesianCMMType::CMMSpeeds_optional& CartesianCMMType::
    CMMSpeeds () const
    {
      return this->CMMSpeeds_;
    }

    CartesianCMMType::CMMSpeeds_optional& CartesianCMMType::
    CMMSpeeds ()
    {
      return this->CMMSpeeds_;
    }

    void CartesianCMMType::
    CMMSpeeds (const CMMSpeeds_type& x)
    {
      this->CMMSpeeds_.set (x);
    }

    void CartesianCMMType::
    CMMSpeeds (const CMMSpeeds_optional& x)
    {
      this->CMMSpeeds_ = x;
    }

    void CartesianCMMType::
    CMMSpeeds (::std::unique_ptr< CMMSpeeds_type > x)
    {
      this->CMMSpeeds_.set (std::move (x));
    }

    const CartesianCMMType::RotaryTable_optional& CartesianCMMType::
    RotaryTable () const
    {
      return this->RotaryTable_;
    }

    CartesianCMMType::RotaryTable_optional& CartesianCMMType::
    RotaryTable ()
    {
      return this->RotaryTable_;
    }

    void CartesianCMMType::
    RotaryTable (const RotaryTable_type& x)
    {
      this->RotaryTable_.set (x);
    }

    void CartesianCMMType::
    RotaryTable (const RotaryTable_optional& x)
    {
      this->RotaryTable_ = x;
    }

    void CartesianCMMType::
    RotaryTable (::std::unique_ptr< RotaryTable_type > x)
    {
      this->RotaryTable_.set (std::move (x));
    }

    const CartesianCMMType::Accuracies_optional& CartesianCMMType::
    Accuracies () const
    {
      return this->Accuracies_;
    }

    CartesianCMMType::Accuracies_optional& CartesianCMMType::
    Accuracies ()
    {
      return this->Accuracies_;
    }

    void CartesianCMMType::
    Accuracies (const Accuracies_type& x)
    {
      this->Accuracies_.set (x);
    }

    void CartesianCMMType::
    Accuracies (const Accuracies_optional& x)
    {
      this->Accuracies_ = x;
    }

    void CartesianCMMType::
    Accuracies (::std::unique_ptr< Accuracies_type > x)
    {
      this->Accuracies_.set (std::move (x));
    }

    const CartesianCMMType::ToolIds_optional& CartesianCMMType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CartesianCMMType::ToolIds_optional& CartesianCMMType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CartesianCMMType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CartesianCMMType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CartesianCMMType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }

    const CartesianCMMType::SensorIds_optional& CartesianCMMType::
    SensorIds () const
    {
      return this->SensorIds_;
    }

    CartesianCMMType::SensorIds_optional& CartesianCMMType::
    SensorIds ()
    {
      return this->SensorIds_;
    }

    void CartesianCMMType::
    SensorIds (const SensorIds_type& x)
    {
      this->SensorIds_.set (x);
    }

    void CartesianCMMType::
    SensorIds (const SensorIds_optional& x)
    {
      this->SensorIds_ = x;
    }

    void CartesianCMMType::
    SensorIds (::std::unique_ptr< SensorIds_type > x)
    {
      this->SensorIds_.set (std::move (x));
    }


    // MultipleCarriageCartesianCMMType
    //

    const MultipleCarriageCartesianCMMType::Carriages_type& MultipleCarriageCartesianCMMType::
    Carriages () const
    {
      return this->Carriages_.get ();
    }

    MultipleCarriageCartesianCMMType::Carriages_type& MultipleCarriageCartesianCMMType::
    Carriages ()
    {
      return this->Carriages_.get ();
    }

    void MultipleCarriageCartesianCMMType::
    Carriages (const Carriages_type& x)
    {
      this->Carriages_.set (x);
    }

    void MultipleCarriageCartesianCMMType::
    Carriages (::std::unique_ptr< Carriages_type > x)
    {
      this->Carriages_.set (std::move (x));
    }


    // LightPenCMMType
    //

    const LightPenCMMType::LightPenCMMChargeCoupledDeviceCameraSensor_optional& LightPenCMMType::
    LightPenCMMChargeCoupledDeviceCameraSensor () const
    {
      return this->LightPenCMMChargeCoupledDeviceCameraSensor_;
    }

    LightPenCMMType::LightPenCMMChargeCoupledDeviceCameraSensor_optional& LightPenCMMType::
    LightPenCMMChargeCoupledDeviceCameraSensor ()
    {
      return this->LightPenCMMChargeCoupledDeviceCameraSensor_;
    }

    void LightPenCMMType::
    LightPenCMMChargeCoupledDeviceCameraSensor (const LightPenCMMChargeCoupledDeviceCameraSensor_type& x)
    {
      this->LightPenCMMChargeCoupledDeviceCameraSensor_.set (x);
    }

    void LightPenCMMType::
    LightPenCMMChargeCoupledDeviceCameraSensor (const LightPenCMMChargeCoupledDeviceCameraSensor_optional& x)
    {
      this->LightPenCMMChargeCoupledDeviceCameraSensor_ = x;
    }

    void LightPenCMMType::
    LightPenCMMChargeCoupledDeviceCameraSensor (::std::unique_ptr< LightPenCMMChargeCoupledDeviceCameraSensor_type > x)
    {
      this->LightPenCMMChargeCoupledDeviceCameraSensor_.set (std::move (x));
    }

    const LightPenCMMType::LightSource_optional& LightPenCMMType::
    LightSource () const
    {
      return this->LightSource_;
    }

    LightPenCMMType::LightSource_optional& LightPenCMMType::
    LightSource ()
    {
      return this->LightSource_;
    }

    void LightPenCMMType::
    LightSource (const LightSource_type& x)
    {
      this->LightSource_.set (x);
    }

    void LightPenCMMType::
    LightSource (const LightSource_optional& x)
    {
      this->LightSource_ = x;
    }

    void LightPenCMMType::
    LightSource (::std::unique_ptr< LightSource_type > x)
    {
      this->LightSource_.set (std::move (x));
    }

    const LightPenCMMType::NominalVolumetricAccuracy_optional& LightPenCMMType::
    NominalVolumetricAccuracy () const
    {
      return this->NominalVolumetricAccuracy_;
    }

    LightPenCMMType::NominalVolumetricAccuracy_optional& LightPenCMMType::
    NominalVolumetricAccuracy ()
    {
      return this->NominalVolumetricAccuracy_;
    }

    void LightPenCMMType::
    NominalVolumetricAccuracy (const NominalVolumetricAccuracy_type& x)
    {
      this->NominalVolumetricAccuracy_.set (x);
    }

    void LightPenCMMType::
    NominalVolumetricAccuracy (const NominalVolumetricAccuracy_optional& x)
    {
      this->NominalVolumetricAccuracy_ = x;
    }

    void LightPenCMMType::
    NominalVolumetricAccuracy (::std::unique_ptr< NominalVolumetricAccuracy_type > x)
    {
      this->NominalVolumetricAccuracy_.set (std::move (x));
    }

    const LightPenCMMType::ActualVolumetricAccuracy_optional& LightPenCMMType::
    ActualVolumetricAccuracy () const
    {
      return this->ActualVolumetricAccuracy_;
    }

    LightPenCMMType::ActualVolumetricAccuracy_optional& LightPenCMMType::
    ActualVolumetricAccuracy ()
    {
      return this->ActualVolumetricAccuracy_;
    }

    void LightPenCMMType::
    ActualVolumetricAccuracy (const ActualVolumetricAccuracy_type& x)
    {
      this->ActualVolumetricAccuracy_.set (x);
    }

    void LightPenCMMType::
    ActualVolumetricAccuracy (const ActualVolumetricAccuracy_optional& x)
    {
      this->ActualVolumetricAccuracy_ = x;
    }

    void LightPenCMMType::
    ActualVolumetricAccuracy (::std::unique_ptr< ActualVolumetricAccuracy_type > x)
    {
      this->ActualVolumetricAccuracy_.set (std::move (x));
    }

    const LightPenCMMType::NominalSinglePointAccuracy_optional& LightPenCMMType::
    NominalSinglePointAccuracy () const
    {
      return this->NominalSinglePointAccuracy_;
    }

    LightPenCMMType::NominalSinglePointAccuracy_optional& LightPenCMMType::
    NominalSinglePointAccuracy ()
    {
      return this->NominalSinglePointAccuracy_;
    }

    void LightPenCMMType::
    NominalSinglePointAccuracy (const NominalSinglePointAccuracy_type& x)
    {
      this->NominalSinglePointAccuracy_.set (x);
    }

    void LightPenCMMType::
    NominalSinglePointAccuracy (const NominalSinglePointAccuracy_optional& x)
    {
      this->NominalSinglePointAccuracy_ = x;
    }

    void LightPenCMMType::
    NominalSinglePointAccuracy (::std::unique_ptr< NominalSinglePointAccuracy_type > x)
    {
      this->NominalSinglePointAccuracy_.set (std::move (x));
    }

    const LightPenCMMType::ActualSinglePointAccuracy_optional& LightPenCMMType::
    ActualSinglePointAccuracy () const
    {
      return this->ActualSinglePointAccuracy_;
    }

    LightPenCMMType::ActualSinglePointAccuracy_optional& LightPenCMMType::
    ActualSinglePointAccuracy ()
    {
      return this->ActualSinglePointAccuracy_;
    }

    void LightPenCMMType::
    ActualSinglePointAccuracy (const ActualSinglePointAccuracy_type& x)
    {
      this->ActualSinglePointAccuracy_.set (x);
    }

    void LightPenCMMType::
    ActualSinglePointAccuracy (const ActualSinglePointAccuracy_optional& x)
    {
      this->ActualSinglePointAccuracy_ = x;
    }

    void LightPenCMMType::
    ActualSinglePointAccuracy (::std::unique_ptr< ActualSinglePointAccuracy_type > x)
    {
      this->ActualSinglePointAccuracy_.set (std::move (x));
    }

    const LightPenCMMType::ScanningSpeed_optional& LightPenCMMType::
    ScanningSpeed () const
    {
      return this->ScanningSpeed_;
    }

    LightPenCMMType::ScanningSpeed_optional& LightPenCMMType::
    ScanningSpeed ()
    {
      return this->ScanningSpeed_;
    }

    void LightPenCMMType::
    ScanningSpeed (const ScanningSpeed_type& x)
    {
      this->ScanningSpeed_.set (x);
    }

    void LightPenCMMType::
    ScanningSpeed (const ScanningSpeed_optional& x)
    {
      this->ScanningSpeed_ = x;
    }

    void LightPenCMMType::
    ScanningSpeed (::std::unique_ptr< ScanningSpeed_type > x)
    {
      this->ScanningSpeed_.set (std::move (x));
    }

    const LightPenCMMType::LaserClass_optional& LightPenCMMType::
    LaserClass () const
    {
      return this->LaserClass_;
    }

    LightPenCMMType::LaserClass_optional& LightPenCMMType::
    LaserClass ()
    {
      return this->LaserClass_;
    }

    void LightPenCMMType::
    LaserClass (const LaserClass_type& x)
    {
      this->LaserClass_.set (x);
    }

    void LightPenCMMType::
    LaserClass (const LaserClass_optional& x)
    {
      this->LaserClass_ = x;
    }

    void LightPenCMMType::
    LaserClass (::std::unique_ptr< LaserClass_type > x)
    {
      this->LaserClass_.set (std::move (x));
    }


    // ParallelLinkCMMType
    //

    const ParallelLinkCMMType::CMMSpeeds_optional& ParallelLinkCMMType::
    CMMSpeeds () const
    {
      return this->CMMSpeeds_;
    }

    ParallelLinkCMMType::CMMSpeeds_optional& ParallelLinkCMMType::
    CMMSpeeds ()
    {
      return this->CMMSpeeds_;
    }

    void ParallelLinkCMMType::
    CMMSpeeds (const CMMSpeeds_type& x)
    {
      this->CMMSpeeds_.set (x);
    }

    void ParallelLinkCMMType::
    CMMSpeeds (const CMMSpeeds_optional& x)
    {
      this->CMMSpeeds_ = x;
    }

    void ParallelLinkCMMType::
    CMMSpeeds (::std::unique_ptr< CMMSpeeds_type > x)
    {
      this->CMMSpeeds_.set (std::move (x));
    }

    const ParallelLinkCMMType::AxesTravelDistance_optional& ParallelLinkCMMType::
    AxesTravelDistance () const
    {
      return this->AxesTravelDistance_;
    }

    ParallelLinkCMMType::AxesTravelDistance_optional& ParallelLinkCMMType::
    AxesTravelDistance ()
    {
      return this->AxesTravelDistance_;
    }

    void ParallelLinkCMMType::
    AxesTravelDistance (const AxesTravelDistance_type& x)
    {
      this->AxesTravelDistance_.set (x);
    }

    void ParallelLinkCMMType::
    AxesTravelDistance (const AxesTravelDistance_optional& x)
    {
      this->AxesTravelDistance_ = x;
    }

    void ParallelLinkCMMType::
    AxesTravelDistance (::std::unique_ptr< AxesTravelDistance_type > x)
    {
      this->AxesTravelDistance_.set (std::move (x));
    }

    const ParallelLinkCMMType::AxesRotationAngle_optional& ParallelLinkCMMType::
    AxesRotationAngle () const
    {
      return this->AxesRotationAngle_;
    }

    ParallelLinkCMMType::AxesRotationAngle_optional& ParallelLinkCMMType::
    AxesRotationAngle ()
    {
      return this->AxesRotationAngle_;
    }

    void ParallelLinkCMMType::
    AxesRotationAngle (const AxesRotationAngle_type& x)
    {
      this->AxesRotationAngle_.set (x);
    }

    void ParallelLinkCMMType::
    AxesRotationAngle (const AxesRotationAngle_optional& x)
    {
      this->AxesRotationAngle_ = x;
    }

    void ParallelLinkCMMType::
    AxesRotationAngle (::std::unique_ptr< AxesRotationAngle_type > x)
    {
      this->AxesRotationAngle_.set (std::move (x));
    }

    const ParallelLinkCMMType::AxisBacklash_optional& ParallelLinkCMMType::
    AxisBacklash () const
    {
      return this->AxisBacklash_;
    }

    ParallelLinkCMMType::AxisBacklash_optional& ParallelLinkCMMType::
    AxisBacklash ()
    {
      return this->AxisBacklash_;
    }

    void ParallelLinkCMMType::
    AxisBacklash (const AxisBacklash_type& x)
    {
      this->AxisBacklash_.set (x);
    }

    void ParallelLinkCMMType::
    AxisBacklash (const AxisBacklash_optional& x)
    {
      this->AxisBacklash_ = x;
    }

    void ParallelLinkCMMType::
    AxisBacklash (::std::unique_ptr< AxisBacklash_type > x)
    {
      this->AxisBacklash_.set (std::move (x));
    }

    const ParallelLinkCMMType::AxisRepeatability_optional& ParallelLinkCMMType::
    AxisRepeatability () const
    {
      return this->AxisRepeatability_;
    }

    ParallelLinkCMMType::AxisRepeatability_optional& ParallelLinkCMMType::
    AxisRepeatability ()
    {
      return this->AxisRepeatability_;
    }

    void ParallelLinkCMMType::
    AxisRepeatability (const AxisRepeatability_type& x)
    {
      this->AxisRepeatability_.set (x);
    }

    void ParallelLinkCMMType::
    AxisRepeatability (const AxisRepeatability_optional& x)
    {
      this->AxisRepeatability_ = x;
    }

    void ParallelLinkCMMType::
    AxisRepeatability (::std::unique_ptr< AxisRepeatability_type > x)
    {
      this->AxisRepeatability_.set (std::move (x));
    }

    const ParallelLinkCMMType::MaxLoad_optional& ParallelLinkCMMType::
    MaxLoad () const
    {
      return this->MaxLoad_;
    }

    ParallelLinkCMMType::MaxLoad_optional& ParallelLinkCMMType::
    MaxLoad ()
    {
      return this->MaxLoad_;
    }

    void ParallelLinkCMMType::
    MaxLoad (const MaxLoad_type& x)
    {
      this->MaxLoad_.set (x);
    }

    void ParallelLinkCMMType::
    MaxLoad (const MaxLoad_optional& x)
    {
      this->MaxLoad_ = x;
    }

    void ParallelLinkCMMType::
    MaxLoad (::std::unique_ptr< MaxLoad_type > x)
    {
      this->MaxLoad_.set (std::move (x));
    }

    const ParallelLinkCMMType::StageMaterial_optional& ParallelLinkCMMType::
    StageMaterial () const
    {
      return this->StageMaterial_;
    }

    ParallelLinkCMMType::StageMaterial_optional& ParallelLinkCMMType::
    StageMaterial ()
    {
      return this->StageMaterial_;
    }

    void ParallelLinkCMMType::
    StageMaterial (const StageMaterial_type& x)
    {
      this->StageMaterial_.set (x);
    }

    void ParallelLinkCMMType::
    StageMaterial (const StageMaterial_optional& x)
    {
      this->StageMaterial_ = x;
    }

    void ParallelLinkCMMType::
    StageMaterial (::std::unique_ptr< StageMaterial_type > x)
    {
      this->StageMaterial_.set (std::move (x));
    }

    const ParallelLinkCMMType::MaxHoldingForce_optional& ParallelLinkCMMType::
    MaxHoldingForce () const
    {
      return this->MaxHoldingForce_;
    }

    ParallelLinkCMMType::MaxHoldingForce_optional& ParallelLinkCMMType::
    MaxHoldingForce ()
    {
      return this->MaxHoldingForce_;
    }

    void ParallelLinkCMMType::
    MaxHoldingForce (const MaxHoldingForce_type& x)
    {
      this->MaxHoldingForce_.set (x);
    }

    void ParallelLinkCMMType::
    MaxHoldingForce (const MaxHoldingForce_optional& x)
    {
      this->MaxHoldingForce_ = x;
    }

    void ParallelLinkCMMType::
    MaxHoldingForce (::std::unique_ptr< MaxHoldingForce_type > x)
    {
      this->MaxHoldingForce_.set (std::move (x));
    }

    const ParallelLinkCMMType::MotorType_optional& ParallelLinkCMMType::
    MotorType () const
    {
      return this->MotorType_;
    }

    ParallelLinkCMMType::MotorType_optional& ParallelLinkCMMType::
    MotorType ()
    {
      return this->MotorType_;
    }

    void ParallelLinkCMMType::
    MotorType (const MotorType_type& x)
    {
      this->MotorType_.set (x);
    }

    void ParallelLinkCMMType::
    MotorType (const MotorType_optional& x)
    {
      this->MotorType_ = x;
    }

    void ParallelLinkCMMType::
    MotorType (::std::unique_ptr< MotorType_type > x)
    {
      this->MotorType_.set (std::move (x));
    }

    const ParallelLinkCMMType::LinksStiffness_optional& ParallelLinkCMMType::
    LinksStiffness () const
    {
      return this->LinksStiffness_;
    }

    ParallelLinkCMMType::LinksStiffness_optional& ParallelLinkCMMType::
    LinksStiffness ()
    {
      return this->LinksStiffness_;
    }

    void ParallelLinkCMMType::
    LinksStiffness (const LinksStiffness_type& x)
    {
      this->LinksStiffness_.set (x);
    }

    void ParallelLinkCMMType::
    LinksStiffness (const LinksStiffness_optional& x)
    {
      this->LinksStiffness_ = x;
    }

    void ParallelLinkCMMType::
    LinksStiffness (::std::unique_ptr< LinksStiffness_type > x)
    {
      this->LinksStiffness_.set (std::move (x));
    }

    const ParallelLinkCMMType::ToolIds_optional& ParallelLinkCMMType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    ParallelLinkCMMType::ToolIds_optional& ParallelLinkCMMType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void ParallelLinkCMMType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void ParallelLinkCMMType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void ParallelLinkCMMType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }


    // AACMMType
    //

    const AACMMType::HomeLocation_optional& AACMMType::
    HomeLocation () const
    {
      return this->HomeLocation_;
    }

    AACMMType::HomeLocation_optional& AACMMType::
    HomeLocation ()
    {
      return this->HomeLocation_;
    }

    void AACMMType::
    HomeLocation (const HomeLocation_type& x)
    {
      this->HomeLocation_.set (x);
    }

    void AACMMType::
    HomeLocation (const HomeLocation_optional& x)
    {
      this->HomeLocation_ = x;
    }

    void AACMMType::
    HomeLocation (::std::unique_ptr< HomeLocation_type > x)
    {
      this->HomeLocation_.set (std::move (x));
    }

    const AACMMType::NumberOfJoints_optional& AACMMType::
    NumberOfJoints () const
    {
      return this->NumberOfJoints_;
    }

    AACMMType::NumberOfJoints_optional& AACMMType::
    NumberOfJoints ()
    {
      return this->NumberOfJoints_;
    }

    void AACMMType::
    NumberOfJoints (const NumberOfJoints_type& x)
    {
      this->NumberOfJoints_.set (x);
    }

    void AACMMType::
    NumberOfJoints (const NumberOfJoints_optional& x)
    {
      this->NumberOfJoints_ = x;
    }

    const AACMMType::MinMeasuringDistance_optional& AACMMType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    AACMMType::MinMeasuringDistance_optional& AACMMType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void AACMMType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void AACMMType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void AACMMType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const AACMMType::MaxMeasuringDistance_optional& AACMMType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    AACMMType::MaxMeasuringDistance_optional& AACMMType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void AACMMType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void AACMMType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void AACMMType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const AACMMType::ProbeTipDiameter_optional& AACMMType::
    ProbeTipDiameter () const
    {
      return this->ProbeTipDiameter_;
    }

    AACMMType::ProbeTipDiameter_optional& AACMMType::
    ProbeTipDiameter ()
    {
      return this->ProbeTipDiameter_;
    }

    void AACMMType::
    ProbeTipDiameter (const ProbeTipDiameter_type& x)
    {
      this->ProbeTipDiameter_.set (x);
    }

    void AACMMType::
    ProbeTipDiameter (const ProbeTipDiameter_optional& x)
    {
      this->ProbeTipDiameter_ = x;
    }

    void AACMMType::
    ProbeTipDiameter (::std::unique_ptr< ProbeTipDiameter_type > x)
    {
      this->ProbeTipDiameter_.set (std::move (x));
    }

    const AACMMType::Accuracies_optional& AACMMType::
    Accuracies () const
    {
      return this->Accuracies_;
    }

    AACMMType::Accuracies_optional& AACMMType::
    Accuracies ()
    {
      return this->Accuracies_;
    }

    void AACMMType::
    Accuracies (const Accuracies_type& x)
    {
      this->Accuracies_.set (x);
    }

    void AACMMType::
    Accuracies (const Accuracies_optional& x)
    {
      this->Accuracies_ = x;
    }

    void AACMMType::
    Accuracies (::std::unique_ptr< Accuracies_type > x)
    {
      this->Accuracies_.set (std::move (x));
    }


    // CaliperType
    //

    const CaliperType::LinearResolution_optional& CaliperType::
    LinearResolution () const
    {
      return this->LinearResolution_;
    }

    CaliperType::LinearResolution_optional& CaliperType::
    LinearResolution ()
    {
      return this->LinearResolution_;
    }

    void CaliperType::
    LinearResolution (const LinearResolution_type& x)
    {
      this->LinearResolution_.set (x);
    }

    void CaliperType::
    LinearResolution (const LinearResolution_optional& x)
    {
      this->LinearResolution_ = x;
    }

    void CaliperType::
    LinearResolution (::std::unique_ptr< LinearResolution_type > x)
    {
      this->LinearResolution_.set (std::move (x));
    }

    const CaliperType::Accuracy_optional& CaliperType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    CaliperType::Accuracy_optional& CaliperType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void CaliperType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void CaliperType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void CaliperType::
    Accuracy (::std::unique_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (std::move (x));
    }

    const CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD () const
    {
      return this->CanMeasureInnerD_;
    }

    CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD ()
    {
      return this->CanMeasureInnerD_;
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_type& x)
    {
      this->CanMeasureInnerD_.set (x);
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_optional& x)
    {
      this->CanMeasureInnerD_ = x;
    }

    const CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD () const
    {
      return this->CanMeasureOuterD_;
    }

    CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD ()
    {
      return this->CanMeasureOuterD_;
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_type& x)
    {
      this->CanMeasureOuterD_.set (x);
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_optional& x)
    {
      this->CanMeasureOuterD_ = x;
    }

    const CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth () const
    {
      return this->CanMeasureDepth_;
    }

    CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth ()
    {
      return this->CanMeasureDepth_;
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_type& x)
    {
      this->CanMeasureDepth_.set (x);
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_optional& x)
    {
      this->CanMeasureDepth_ = x;
    }


    // CaliperDialType
    //


    // CaliperDigitalType
    //


    // MicrometerType
    //

    const MicrometerType::LinearResolution_optional& MicrometerType::
    LinearResolution () const
    {
      return this->LinearResolution_;
    }

    MicrometerType::LinearResolution_optional& MicrometerType::
    LinearResolution ()
    {
      return this->LinearResolution_;
    }

    void MicrometerType::
    LinearResolution (const LinearResolution_type& x)
    {
      this->LinearResolution_.set (x);
    }

    void MicrometerType::
    LinearResolution (const LinearResolution_optional& x)
    {
      this->LinearResolution_ = x;
    }

    void MicrometerType::
    LinearResolution (::std::unique_ptr< LinearResolution_type > x)
    {
      this->LinearResolution_.set (std::move (x));
    }

    const MicrometerType::Accuracy_optional& MicrometerType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    MicrometerType::Accuracy_optional& MicrometerType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void MicrometerType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void MicrometerType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void MicrometerType::
    Accuracy (::std::unique_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (std::move (x));
    }

    const MicrometerType::MeasuringForce_optional& MicrometerType::
    MeasuringForce () const
    {
      return this->MeasuringForce_;
    }

    MicrometerType::MeasuringForce_optional& MicrometerType::
    MeasuringForce ()
    {
      return this->MeasuringForce_;
    }

    void MicrometerType::
    MeasuringForce (const MeasuringForce_type& x)
    {
      this->MeasuringForce_.set (x);
    }

    void MicrometerType::
    MeasuringForce (const MeasuringForce_optional& x)
    {
      this->MeasuringForce_ = x;
    }

    void MicrometerType::
    MeasuringForce (::std::unique_ptr< MeasuringForce_type > x)
    {
      this->MeasuringForce_.set (std::move (x));
    }

    const MicrometerType::InternalExternal_optional& MicrometerType::
    InternalExternal () const
    {
      return this->InternalExternal_;
    }

    MicrometerType::InternalExternal_optional& MicrometerType::
    InternalExternal ()
    {
      return this->InternalExternal_;
    }

    void MicrometerType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void MicrometerType::
    InternalExternal (const InternalExternal_optional& x)
    {
      this->InternalExternal_ = x;
    }

    void MicrometerType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const MicrometerType::InternalExternal_type& MicrometerType::
    InternalExternal_default_value ()
    {
      return InternalExternal_default_value_;
    }


    // MicrometerAnalogType
    //


    // MicrometerDigitalType
    //


    // GageDeviceType
    //


    // SineBarType
    //

    const SineBarType::NominalBallCenterToBallCenterLength_optional& SineBarType::
    NominalBallCenterToBallCenterLength () const
    {
      return this->NominalBallCenterToBallCenterLength_;
    }

    SineBarType::NominalBallCenterToBallCenterLength_optional& SineBarType::
    NominalBallCenterToBallCenterLength ()
    {
      return this->NominalBallCenterToBallCenterLength_;
    }

    void SineBarType::
    NominalBallCenterToBallCenterLength (const NominalBallCenterToBallCenterLength_type& x)
    {
      this->NominalBallCenterToBallCenterLength_.set (x);
    }

    void SineBarType::
    NominalBallCenterToBallCenterLength (const NominalBallCenterToBallCenterLength_optional& x)
    {
      this->NominalBallCenterToBallCenterLength_ = x;
    }

    void SineBarType::
    NominalBallCenterToBallCenterLength (::std::unique_ptr< NominalBallCenterToBallCenterLength_type > x)
    {
      this->NominalBallCenterToBallCenterLength_.set (std::move (x));
    }

    const SineBarType::CylinderCenterToCylinderCenterAccuracy_optional& SineBarType::
    CylinderCenterToCylinderCenterAccuracy () const
    {
      return this->CylinderCenterToCylinderCenterAccuracy_;
    }

    SineBarType::CylinderCenterToCylinderCenterAccuracy_optional& SineBarType::
    CylinderCenterToCylinderCenterAccuracy ()
    {
      return this->CylinderCenterToCylinderCenterAccuracy_;
    }

    void SineBarType::
    CylinderCenterToCylinderCenterAccuracy (const CylinderCenterToCylinderCenterAccuracy_type& x)
    {
      this->CylinderCenterToCylinderCenterAccuracy_.set (x);
    }

    void SineBarType::
    CylinderCenterToCylinderCenterAccuracy (const CylinderCenterToCylinderCenterAccuracy_optional& x)
    {
      this->CylinderCenterToCylinderCenterAccuracy_ = x;
    }

    void SineBarType::
    CylinderCenterToCylinderCenterAccuracy (::std::unique_ptr< CylinderCenterToCylinderCenterAccuracy_type > x)
    {
      this->CylinderCenterToCylinderCenterAccuracy_.set (std::move (x));
    }

    const SineBarType::Parallelism_optional& SineBarType::
    Parallelism () const
    {
      return this->Parallelism_;
    }

    SineBarType::Parallelism_optional& SineBarType::
    Parallelism ()
    {
      return this->Parallelism_;
    }

    void SineBarType::
    Parallelism (const Parallelism_type& x)
    {
      this->Parallelism_.set (x);
    }

    void SineBarType::
    Parallelism (const Parallelism_optional& x)
    {
      this->Parallelism_ = x;
    }

    void SineBarType::
    Parallelism (::std::unique_ptr< Parallelism_type > x)
    {
      this->Parallelism_.set (std::move (x));
    }

    const SineBarType::OverallLength_optional& SineBarType::
    OverallLength () const
    {
      return this->OverallLength_;
    }

    SineBarType::OverallLength_optional& SineBarType::
    OverallLength ()
    {
      return this->OverallLength_;
    }

    void SineBarType::
    OverallLength (const OverallLength_type& x)
    {
      this->OverallLength_.set (x);
    }

    void SineBarType::
    OverallLength (const OverallLength_optional& x)
    {
      this->OverallLength_ = x;
    }

    void SineBarType::
    OverallLength (::std::unique_ptr< OverallLength_type > x)
    {
      this->OverallLength_.set (std::move (x));
    }

    const SineBarType::Material_optional& SineBarType::
    Material () const
    {
      return this->Material_;
    }

    SineBarType::Material_optional& SineBarType::
    Material ()
    {
      return this->Material_;
    }

    void SineBarType::
    Material (const Material_type& x)
    {
      this->Material_.set (x);
    }

    void SineBarType::
    Material (const Material_optional& x)
    {
      this->Material_ = x;
    }

    void SineBarType::
    Material (::std::unique_ptr< Material_type > x)
    {
      this->Material_.set (std::move (x));
    }

    const SineBarType::Magnetic_optional& SineBarType::
    Magnetic () const
    {
      return this->Magnetic_;
    }

    SineBarType::Magnetic_optional& SineBarType::
    Magnetic ()
    {
      return this->Magnetic_;
    }

    void SineBarType::
    Magnetic (const Magnetic_type& x)
    {
      this->Magnetic_.set (x);
    }

    void SineBarType::
    Magnetic (const Magnetic_optional& x)
    {
      this->Magnetic_ = x;
    }

    const SineBarType::Width_optional& SineBarType::
    Width () const
    {
      return this->Width_;
    }

    SineBarType::Width_optional& SineBarType::
    Width ()
    {
      return this->Width_;
    }

    void SineBarType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void SineBarType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void SineBarType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }


    // TheodoliteType
    //

    const TheodoliteType::LongitudinalTrackingSpeed_optional& TheodoliteType::
    LongitudinalTrackingSpeed () const
    {
      return this->LongitudinalTrackingSpeed_;
    }

    TheodoliteType::LongitudinalTrackingSpeed_optional& TheodoliteType::
    LongitudinalTrackingSpeed ()
    {
      return this->LongitudinalTrackingSpeed_;
    }

    void TheodoliteType::
    LongitudinalTrackingSpeed (const LongitudinalTrackingSpeed_type& x)
    {
      this->LongitudinalTrackingSpeed_.set (x);
    }

    void TheodoliteType::
    LongitudinalTrackingSpeed (const LongitudinalTrackingSpeed_optional& x)
    {
      this->LongitudinalTrackingSpeed_ = x;
    }

    void TheodoliteType::
    LongitudinalTrackingSpeed (::std::unique_ptr< LongitudinalTrackingSpeed_type > x)
    {
      this->LongitudinalTrackingSpeed_.set (std::move (x));
    }

    const TheodoliteType::LateralTrackingSpeed_optional& TheodoliteType::
    LateralTrackingSpeed () const
    {
      return this->LateralTrackingSpeed_;
    }

    TheodoliteType::LateralTrackingSpeed_optional& TheodoliteType::
    LateralTrackingSpeed ()
    {
      return this->LateralTrackingSpeed_;
    }

    void TheodoliteType::
    LateralTrackingSpeed (const LateralTrackingSpeed_type& x)
    {
      this->LateralTrackingSpeed_.set (x);
    }

    void TheodoliteType::
    LateralTrackingSpeed (const LateralTrackingSpeed_optional& x)
    {
      this->LateralTrackingSpeed_ = x;
    }

    void TheodoliteType::
    LateralTrackingSpeed (::std::unique_ptr< LateralTrackingSpeed_type > x)
    {
      this->LateralTrackingSpeed_.set (std::move (x));
    }

    const TheodoliteType::Magnification_optional& TheodoliteType::
    Magnification () const
    {
      return this->Magnification_;
    }

    TheodoliteType::Magnification_optional& TheodoliteType::
    Magnification ()
    {
      return this->Magnification_;
    }

    void TheodoliteType::
    Magnification (const Magnification_type& x)
    {
      this->Magnification_.set (x);
    }

    void TheodoliteType::
    Magnification (const Magnification_optional& x)
    {
      this->Magnification_ = x;
    }

    const TheodoliteType::FieldOfViewDiameter_optional& TheodoliteType::
    FieldOfViewDiameter () const
    {
      return this->FieldOfViewDiameter_;
    }

    TheodoliteType::FieldOfViewDiameter_optional& TheodoliteType::
    FieldOfViewDiameter ()
    {
      return this->FieldOfViewDiameter_;
    }

    void TheodoliteType::
    FieldOfViewDiameter (const FieldOfViewDiameter_type& x)
    {
      this->FieldOfViewDiameter_.set (x);
    }

    void TheodoliteType::
    FieldOfViewDiameter (const FieldOfViewDiameter_optional& x)
    {
      this->FieldOfViewDiameter_ = x;
    }

    void TheodoliteType::
    FieldOfViewDiameter (::std::unique_ptr< FieldOfViewDiameter_type > x)
    {
      this->FieldOfViewDiameter_.set (std::move (x));
    }

    const TheodoliteType::ApertureSize_optional& TheodoliteType::
    ApertureSize () const
    {
      return this->ApertureSize_;
    }

    TheodoliteType::ApertureSize_optional& TheodoliteType::
    ApertureSize ()
    {
      return this->ApertureSize_;
    }

    void TheodoliteType::
    ApertureSize (const ApertureSize_type& x)
    {
      this->ApertureSize_.set (x);
    }

    void TheodoliteType::
    ApertureSize (const ApertureSize_optional& x)
    {
      this->ApertureSize_ = x;
    }

    void TheodoliteType::
    ApertureSize (::std::unique_ptr< ApertureSize_type > x)
    {
      this->ApertureSize_.set (std::move (x));
    }

    const TheodoliteType::MaxFocusDistance_optional& TheodoliteType::
    MaxFocusDistance () const
    {
      return this->MaxFocusDistance_;
    }

    TheodoliteType::MaxFocusDistance_optional& TheodoliteType::
    MaxFocusDistance ()
    {
      return this->MaxFocusDistance_;
    }

    void TheodoliteType::
    MaxFocusDistance (const MaxFocusDistance_type& x)
    {
      this->MaxFocusDistance_.set (x);
    }

    void TheodoliteType::
    MaxFocusDistance (const MaxFocusDistance_optional& x)
    {
      this->MaxFocusDistance_ = x;
    }

    void TheodoliteType::
    MaxFocusDistance (::std::unique_ptr< MaxFocusDistance_type > x)
    {
      this->MaxFocusDistance_.set (std::move (x));
    }

    const TheodoliteType::AngularAccuracy_optional& TheodoliteType::
    AngularAccuracy () const
    {
      return this->AngularAccuracy_;
    }

    TheodoliteType::AngularAccuracy_optional& TheodoliteType::
    AngularAccuracy ()
    {
      return this->AngularAccuracy_;
    }

    void TheodoliteType::
    AngularAccuracy (const AngularAccuracy_type& x)
    {
      this->AngularAccuracy_.set (x);
    }

    void TheodoliteType::
    AngularAccuracy (const AngularAccuracy_optional& x)
    {
      this->AngularAccuracy_ = x;
    }

    void TheodoliteType::
    AngularAccuracy (::std::unique_ptr< AngularAccuracy_type > x)
    {
      this->AngularAccuracy_.set (std::move (x));
    }

    const TheodoliteType::MaxTiltCompensation_optional& TheodoliteType::
    MaxTiltCompensation () const
    {
      return this->MaxTiltCompensation_;
    }

    TheodoliteType::MaxTiltCompensation_optional& TheodoliteType::
    MaxTiltCompensation ()
    {
      return this->MaxTiltCompensation_;
    }

    void TheodoliteType::
    MaxTiltCompensation (const MaxTiltCompensation_type& x)
    {
      this->MaxTiltCompensation_.set (x);
    }

    void TheodoliteType::
    MaxTiltCompensation (const MaxTiltCompensation_optional& x)
    {
      this->MaxTiltCompensation_ = x;
    }

    void TheodoliteType::
    MaxTiltCompensation (::std::unique_ptr< MaxTiltCompensation_type > x)
    {
      this->MaxTiltCompensation_.set (std::move (x));
    }

    const TheodoliteType::ChargeCoupledDeviceCameraSensor_optional& TheodoliteType::
    ChargeCoupledDeviceCameraSensor () const
    {
      return this->ChargeCoupledDeviceCameraSensor_;
    }

    TheodoliteType::ChargeCoupledDeviceCameraSensor_optional& TheodoliteType::
    ChargeCoupledDeviceCameraSensor ()
    {
      return this->ChargeCoupledDeviceCameraSensor_;
    }

    void TheodoliteType::
    ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_type& x)
    {
      this->ChargeCoupledDeviceCameraSensor_.set (x);
    }

    void TheodoliteType::
    ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_optional& x)
    {
      this->ChargeCoupledDeviceCameraSensor_ = x;
    }

    void TheodoliteType::
    ChargeCoupledDeviceCameraSensor (::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > x)
    {
      this->ChargeCoupledDeviceCameraSensor_.set (std::move (x));
    }

    const TheodoliteType::MinFocusDistance_optional& TheodoliteType::
    MinFocusDistance () const
    {
      return this->MinFocusDistance_;
    }

    TheodoliteType::MinFocusDistance_optional& TheodoliteType::
    MinFocusDistance ()
    {
      return this->MinFocusDistance_;
    }

    void TheodoliteType::
    MinFocusDistance (const MinFocusDistance_type& x)
    {
      this->MinFocusDistance_.set (x);
    }

    void TheodoliteType::
    MinFocusDistance (const MinFocusDistance_optional& x)
    {
      this->MinFocusDistance_ = x;
    }

    void TheodoliteType::
    MinFocusDistance (::std::unique_ptr< MinFocusDistance_type > x)
    {
      this->MinFocusDistance_.set (std::move (x));
    }

    const TheodoliteType::EffectiveDiameterOfObjective_optional& TheodoliteType::
    EffectiveDiameterOfObjective () const
    {
      return this->EffectiveDiameterOfObjective_;
    }

    TheodoliteType::EffectiveDiameterOfObjective_optional& TheodoliteType::
    EffectiveDiameterOfObjective ()
    {
      return this->EffectiveDiameterOfObjective_;
    }

    void TheodoliteType::
    EffectiveDiameterOfObjective (const EffectiveDiameterOfObjective_type& x)
    {
      this->EffectiveDiameterOfObjective_.set (x);
    }

    void TheodoliteType::
    EffectiveDiameterOfObjective (const EffectiveDiameterOfObjective_optional& x)
    {
      this->EffectiveDiameterOfObjective_ = x;
    }

    void TheodoliteType::
    EffectiveDiameterOfObjective (::std::unique_ptr< EffectiveDiameterOfObjective_type > x)
    {
      this->EffectiveDiameterOfObjective_.set (std::move (x));
    }

    const TheodoliteType::StadiaBaseConstant_optional& TheodoliteType::
    StadiaBaseConstant () const
    {
      return this->StadiaBaseConstant_;
    }

    TheodoliteType::StadiaBaseConstant_optional& TheodoliteType::
    StadiaBaseConstant ()
    {
      return this->StadiaBaseConstant_;
    }

    void TheodoliteType::
    StadiaBaseConstant (const StadiaBaseConstant_type& x)
    {
      this->StadiaBaseConstant_.set (x);
    }

    void TheodoliteType::
    StadiaBaseConstant (const StadiaBaseConstant_optional& x)
    {
      this->StadiaBaseConstant_ = x;
    }

    void TheodoliteType::
    StadiaBaseConstant (::std::unique_ptr< StadiaBaseConstant_type > x)
    {
      this->StadiaBaseConstant_.set (std::move (x));
    }

    const TheodoliteType::StadiaRateConstant_optional& TheodoliteType::
    StadiaRateConstant () const
    {
      return this->StadiaRateConstant_;
    }

    TheodoliteType::StadiaRateConstant_optional& TheodoliteType::
    StadiaRateConstant ()
    {
      return this->StadiaRateConstant_;
    }

    void TheodoliteType::
    StadiaRateConstant (const StadiaRateConstant_type& x)
    {
      this->StadiaRateConstant_.set (x);
    }

    void TheodoliteType::
    StadiaRateConstant (const StadiaRateConstant_optional& x)
    {
      this->StadiaRateConstant_ = x;
    }

    void TheodoliteType::
    StadiaRateConstant (::std::unique_ptr< StadiaRateConstant_type > x)
    {
      this->StadiaRateConstant_.set (std::move (x));
    }

    const TheodoliteType::MinPowerSupplyVoltage_optional& TheodoliteType::
    MinPowerSupplyVoltage () const
    {
      return this->MinPowerSupplyVoltage_;
    }

    TheodoliteType::MinPowerSupplyVoltage_optional& TheodoliteType::
    MinPowerSupplyVoltage ()
    {
      return this->MinPowerSupplyVoltage_;
    }

    void TheodoliteType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x)
    {
      this->MinPowerSupplyVoltage_.set (x);
    }

    void TheodoliteType::
    MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x)
    {
      this->MinPowerSupplyVoltage_ = x;
    }

    void TheodoliteType::
    MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > x)
    {
      this->MinPowerSupplyVoltage_.set (std::move (x));
    }

    const TheodoliteType::MaxPowerSupplyVoltage_optional& TheodoliteType::
    MaxPowerSupplyVoltage () const
    {
      return this->MaxPowerSupplyVoltage_;
    }

    TheodoliteType::MaxPowerSupplyVoltage_optional& TheodoliteType::
    MaxPowerSupplyVoltage ()
    {
      return this->MaxPowerSupplyVoltage_;
    }

    void TheodoliteType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x)
    {
      this->MaxPowerSupplyVoltage_.set (x);
    }

    void TheodoliteType::
    MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x)
    {
      this->MaxPowerSupplyVoltage_ = x;
    }

    void TheodoliteType::
    MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > x)
    {
      this->MaxPowerSupplyVoltage_.set (std::move (x));
    }

    const TheodoliteType::Laser_optional& TheodoliteType::
    Laser () const
    {
      return this->Laser_;
    }

    TheodoliteType::Laser_optional& TheodoliteType::
    Laser ()
    {
      return this->Laser_;
    }

    void TheodoliteType::
    Laser (const Laser_type& x)
    {
      this->Laser_.set (x);
    }

    void TheodoliteType::
    Laser (const Laser_optional& x)
    {
      this->Laser_ = x;
    }

    void TheodoliteType::
    Laser (::std::unique_ptr< Laser_type > x)
    {
      this->Laser_.set (std::move (x));
    }


    // UniversalLengthMeasuringType
    //

    const UniversalLengthMeasuringType::MinMeasuringDistance_optional& UniversalLengthMeasuringType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    UniversalLengthMeasuringType::MinMeasuringDistance_optional& UniversalLengthMeasuringType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void UniversalLengthMeasuringType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void UniversalLengthMeasuringType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void UniversalLengthMeasuringType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::MaxMeasuringDistance_optional& UniversalLengthMeasuringType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    UniversalLengthMeasuringType::MaxMeasuringDistance_optional& UniversalLengthMeasuringType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void UniversalLengthMeasuringType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void UniversalLengthMeasuringType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void UniversalLengthMeasuringType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::MeasuringForce_optional& UniversalLengthMeasuringType::
    MeasuringForce () const
    {
      return this->MeasuringForce_;
    }

    UniversalLengthMeasuringType::MeasuringForce_optional& UniversalLengthMeasuringType::
    MeasuringForce ()
    {
      return this->MeasuringForce_;
    }

    void UniversalLengthMeasuringType::
    MeasuringForce (const MeasuringForce_type& x)
    {
      this->MeasuringForce_.set (x);
    }

    void UniversalLengthMeasuringType::
    MeasuringForce (const MeasuringForce_optional& x)
    {
      this->MeasuringForce_ = x;
    }

    void UniversalLengthMeasuringType::
    MeasuringForce (::std::unique_ptr< MeasuringForce_type > x)
    {
      this->MeasuringForce_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::Accuracy_optional& UniversalLengthMeasuringType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    UniversalLengthMeasuringType::Accuracy_optional& UniversalLengthMeasuringType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void UniversalLengthMeasuringType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void UniversalLengthMeasuringType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void UniversalLengthMeasuringType::
    Accuracy (::std::unique_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::Repeatability_optional& UniversalLengthMeasuringType::
    Repeatability () const
    {
      return this->Repeatability_;
    }

    UniversalLengthMeasuringType::Repeatability_optional& UniversalLengthMeasuringType::
    Repeatability ()
    {
      return this->Repeatability_;
    }

    void UniversalLengthMeasuringType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void UniversalLengthMeasuringType::
    Repeatability (const Repeatability_optional& x)
    {
      this->Repeatability_ = x;
    }

    void UniversalLengthMeasuringType::
    Repeatability (::std::unique_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::ToolIds_optional& UniversalLengthMeasuringType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    UniversalLengthMeasuringType::ToolIds_optional& UniversalLengthMeasuringType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void UniversalLengthMeasuringType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void UniversalLengthMeasuringType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void UniversalLengthMeasuringType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }

    const UniversalLengthMeasuringType::MaxWorkpieceWeight_optional& UniversalLengthMeasuringType::
    MaxWorkpieceWeight () const
    {
      return this->MaxWorkpieceWeight_;
    }

    UniversalLengthMeasuringType::MaxWorkpieceWeight_optional& UniversalLengthMeasuringType::
    MaxWorkpieceWeight ()
    {
      return this->MaxWorkpieceWeight_;
    }

    void UniversalLengthMeasuringType::
    MaxWorkpieceWeight (const MaxWorkpieceWeight_type& x)
    {
      this->MaxWorkpieceWeight_.set (x);
    }

    void UniversalLengthMeasuringType::
    MaxWorkpieceWeight (const MaxWorkpieceWeight_optional& x)
    {
      this->MaxWorkpieceWeight_ = x;
    }

    void UniversalLengthMeasuringType::
    MaxWorkpieceWeight (::std::unique_ptr< MaxWorkpieceWeight_type > x)
    {
      this->MaxWorkpieceWeight_.set (std::move (x));
    }


    // ComputedTomographyType
    //

    const ComputedTomographyType::SourceDescription_optional& ComputedTomographyType::
    SourceDescription () const
    {
      return this->SourceDescription_;
    }

    ComputedTomographyType::SourceDescription_optional& ComputedTomographyType::
    SourceDescription ()
    {
      return this->SourceDescription_;
    }

    void ComputedTomographyType::
    SourceDescription (const SourceDescription_type& x)
    {
      this->SourceDescription_.set (x);
    }

    void ComputedTomographyType::
    SourceDescription (const SourceDescription_optional& x)
    {
      this->SourceDescription_ = x;
    }

    void ComputedTomographyType::
    SourceDescription (::std::unique_ptr< SourceDescription_type > x)
    {
      this->SourceDescription_.set (std::move (x));
    }

    const ComputedTomographyType::SamplePenetratingMaterial_optional& ComputedTomographyType::
    SamplePenetratingMaterial () const
    {
      return this->SamplePenetratingMaterial_;
    }

    ComputedTomographyType::SamplePenetratingMaterial_optional& ComputedTomographyType::
    SamplePenetratingMaterial ()
    {
      return this->SamplePenetratingMaterial_;
    }

    void ComputedTomographyType::
    SamplePenetratingMaterial (const SamplePenetratingMaterial_type& x)
    {
      this->SamplePenetratingMaterial_.set (x);
    }

    void ComputedTomographyType::
    SamplePenetratingMaterial (const SamplePenetratingMaterial_optional& x)
    {
      this->SamplePenetratingMaterial_ = x;
    }

    void ComputedTomographyType::
    SamplePenetratingMaterial (::std::unique_ptr< SamplePenetratingMaterial_type > x)
    {
      this->SamplePenetratingMaterial_.set (std::move (x));
    }

    const ComputedTomographyType::SamplePenetratingMaterialLength_optional& ComputedTomographyType::
    SamplePenetratingMaterialLength () const
    {
      return this->SamplePenetratingMaterialLength_;
    }

    ComputedTomographyType::SamplePenetratingMaterialLength_optional& ComputedTomographyType::
    SamplePenetratingMaterialLength ()
    {
      return this->SamplePenetratingMaterialLength_;
    }

    void ComputedTomographyType::
    SamplePenetratingMaterialLength (const SamplePenetratingMaterialLength_type& x)
    {
      this->SamplePenetratingMaterialLength_.set (x);
    }

    void ComputedTomographyType::
    SamplePenetratingMaterialLength (const SamplePenetratingMaterialLength_optional& x)
    {
      this->SamplePenetratingMaterialLength_ = x;
    }

    void ComputedTomographyType::
    SamplePenetratingMaterialLength (::std::unique_ptr< SamplePenetratingMaterialLength_type > x)
    {
      this->SamplePenetratingMaterialLength_.set (std::move (x));
    }

    const ComputedTomographyType::FocalSpotSize_optional& ComputedTomographyType::
    FocalSpotSize () const
    {
      return this->FocalSpotSize_;
    }

    ComputedTomographyType::FocalSpotSize_optional& ComputedTomographyType::
    FocalSpotSize ()
    {
      return this->FocalSpotSize_;
    }

    void ComputedTomographyType::
    FocalSpotSize (const FocalSpotSize_type& x)
    {
      this->FocalSpotSize_.set (x);
    }

    void ComputedTomographyType::
    FocalSpotSize (const FocalSpotSize_optional& x)
    {
      this->FocalSpotSize_ = x;
    }

    void ComputedTomographyType::
    FocalSpotSize (::std::unique_ptr< FocalSpotSize_type > x)
    {
      this->FocalSpotSize_.set (std::move (x));
    }

    const ComputedTomographyType::MaxWorkpieceMass_optional& ComputedTomographyType::
    MaxWorkpieceMass () const
    {
      return this->MaxWorkpieceMass_;
    }

    ComputedTomographyType::MaxWorkpieceMass_optional& ComputedTomographyType::
    MaxWorkpieceMass ()
    {
      return this->MaxWorkpieceMass_;
    }

    void ComputedTomographyType::
    MaxWorkpieceMass (const MaxWorkpieceMass_type& x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    void ComputedTomographyType::
    MaxWorkpieceMass (const MaxWorkpieceMass_optional& x)
    {
      this->MaxWorkpieceMass_ = x;
    }

    void ComputedTomographyType::
    MaxWorkpieceMass (::std::unique_ptr< MaxWorkpieceMass_type > x)
    {
      this->MaxWorkpieceMass_.set (std::move (x));
    }

    const ComputedTomographyType::SafetyLevel_optional& ComputedTomographyType::
    SafetyLevel () const
    {
      return this->SafetyLevel_;
    }

    ComputedTomographyType::SafetyLevel_optional& ComputedTomographyType::
    SafetyLevel ()
    {
      return this->SafetyLevel_;
    }

    void ComputedTomographyType::
    SafetyLevel (const SafetyLevel_type& x)
    {
      this->SafetyLevel_.set (x);
    }

    void ComputedTomographyType::
    SafetyLevel (const SafetyLevel_optional& x)
    {
      this->SafetyLevel_ = x;
    }

    void ComputedTomographyType::
    SafetyLevel (::std::unique_ptr< SafetyLevel_type > x)
    {
      this->SafetyLevel_.set (std::move (x));
    }

    const ComputedTomographyType::CabinetDimensions_optional& ComputedTomographyType::
    CabinetDimensions () const
    {
      return this->CabinetDimensions_;
    }

    ComputedTomographyType::CabinetDimensions_optional& ComputedTomographyType::
    CabinetDimensions ()
    {
      return this->CabinetDimensions_;
    }

    void ComputedTomographyType::
    CabinetDimensions (const CabinetDimensions_type& x)
    {
      this->CabinetDimensions_.set (x);
    }

    void ComputedTomographyType::
    CabinetDimensions (const CabinetDimensions_optional& x)
    {
      this->CabinetDimensions_ = x;
    }

    void ComputedTomographyType::
    CabinetDimensions (::std::unique_ptr< CabinetDimensions_type > x)
    {
      this->CabinetDimensions_.set (std::move (x));
    }

    const ComputedTomographyType::MaxPower_optional& ComputedTomographyType::
    MaxPower () const
    {
      return this->MaxPower_;
    }

    ComputedTomographyType::MaxPower_optional& ComputedTomographyType::
    MaxPower ()
    {
      return this->MaxPower_;
    }

    void ComputedTomographyType::
    MaxPower (const MaxPower_type& x)
    {
      this->MaxPower_.set (x);
    }

    void ComputedTomographyType::
    MaxPower (const MaxPower_optional& x)
    {
      this->MaxPower_ = x;
    }

    void ComputedTomographyType::
    MaxPower (::std::unique_ptr< MaxPower_type > x)
    {
      this->MaxPower_.set (std::move (x));
    }

    const ComputedTomographyType::DetectorBitNumber_optional& ComputedTomographyType::
    DetectorBitNumber () const
    {
      return this->DetectorBitNumber_;
    }

    ComputedTomographyType::DetectorBitNumber_optional& ComputedTomographyType::
    DetectorBitNumber ()
    {
      return this->DetectorBitNumber_;
    }

    void ComputedTomographyType::
    DetectorBitNumber (const DetectorBitNumber_type& x)
    {
      this->DetectorBitNumber_.set (x);
    }

    void ComputedTomographyType::
    DetectorBitNumber (const DetectorBitNumber_optional& x)
    {
      this->DetectorBitNumber_ = x;
    }

    const ComputedTomographyType::DetectorPixelSize_optional& ComputedTomographyType::
    DetectorPixelSize () const
    {
      return this->DetectorPixelSize_;
    }

    ComputedTomographyType::DetectorPixelSize_optional& ComputedTomographyType::
    DetectorPixelSize ()
    {
      return this->DetectorPixelSize_;
    }

    void ComputedTomographyType::
    DetectorPixelSize (const DetectorPixelSize_type& x)
    {
      this->DetectorPixelSize_.set (x);
    }

    void ComputedTomographyType::
    DetectorPixelSize (const DetectorPixelSize_optional& x)
    {
      this->DetectorPixelSize_ = x;
    }

    void ComputedTomographyType::
    DetectorPixelSize (::std::unique_ptr< DetectorPixelSize_type > x)
    {
      this->DetectorPixelSize_.set (std::move (x));
    }

    const ComputedTomographyType::ActivePixelsNumber_optional& ComputedTomographyType::
    ActivePixelsNumber () const
    {
      return this->ActivePixelsNumber_;
    }

    ComputedTomographyType::ActivePixelsNumber_optional& ComputedTomographyType::
    ActivePixelsNumber ()
    {
      return this->ActivePixelsNumber_;
    }

    void ComputedTomographyType::
    ActivePixelsNumber (const ActivePixelsNumber_type& x)
    {
      this->ActivePixelsNumber_.set (x);
    }

    void ComputedTomographyType::
    ActivePixelsNumber (const ActivePixelsNumber_optional& x)
    {
      this->ActivePixelsNumber_ = x;
    }

    void ComputedTomographyType::
    ActivePixelsNumber (::std::unique_ptr< ActivePixelsNumber_type > x)
    {
      this->ActivePixelsNumber_.set (std::move (x));
    }

    const ComputedTomographyType::MaxKV_optional& ComputedTomographyType::
    MaxKV () const
    {
      return this->MaxKV_;
    }

    ComputedTomographyType::MaxKV_optional& ComputedTomographyType::
    MaxKV ()
    {
      return this->MaxKV_;
    }

    void ComputedTomographyType::
    MaxKV (const MaxKV_type& x)
    {
      this->MaxKV_.set (x);
    }

    void ComputedTomographyType::
    MaxKV (const MaxKV_optional& x)
    {
      this->MaxKV_ = x;
    }

    void ComputedTomographyType::
    MaxKV (::std::unique_ptr< MaxKV_type > x)
    {
      this->MaxKV_.set (std::move (x));
    }

    const ComputedTomographyType::MinOperatingCurrent_optional& ComputedTomographyType::
    MinOperatingCurrent () const
    {
      return this->MinOperatingCurrent_;
    }

    ComputedTomographyType::MinOperatingCurrent_optional& ComputedTomographyType::
    MinOperatingCurrent ()
    {
      return this->MinOperatingCurrent_;
    }

    void ComputedTomographyType::
    MinOperatingCurrent (const MinOperatingCurrent_type& x)
    {
      this->MinOperatingCurrent_.set (x);
    }

    void ComputedTomographyType::
    MinOperatingCurrent (const MinOperatingCurrent_optional& x)
    {
      this->MinOperatingCurrent_ = x;
    }

    void ComputedTomographyType::
    MinOperatingCurrent (::std::unique_ptr< MinOperatingCurrent_type > x)
    {
      this->MinOperatingCurrent_.set (std::move (x));
    }

    const ComputedTomographyType::MaxOperatingCurrent_optional& ComputedTomographyType::
    MaxOperatingCurrent () const
    {
      return this->MaxOperatingCurrent_;
    }

    ComputedTomographyType::MaxOperatingCurrent_optional& ComputedTomographyType::
    MaxOperatingCurrent ()
    {
      return this->MaxOperatingCurrent_;
    }

    void ComputedTomographyType::
    MaxOperatingCurrent (const MaxOperatingCurrent_type& x)
    {
      this->MaxOperatingCurrent_.set (x);
    }

    void ComputedTomographyType::
    MaxOperatingCurrent (const MaxOperatingCurrent_optional& x)
    {
      this->MaxOperatingCurrent_ = x;
    }

    void ComputedTomographyType::
    MaxOperatingCurrent (::std::unique_ptr< MaxOperatingCurrent_type > x)
    {
      this->MaxOperatingCurrent_.set (std::move (x));
    }

    const ComputedTomographyType::MaxFramePerSecond_optional& ComputedTomographyType::
    MaxFramePerSecond () const
    {
      return this->MaxFramePerSecond_;
    }

    ComputedTomographyType::MaxFramePerSecond_optional& ComputedTomographyType::
    MaxFramePerSecond ()
    {
      return this->MaxFramePerSecond_;
    }

    void ComputedTomographyType::
    MaxFramePerSecond (const MaxFramePerSecond_type& x)
    {
      this->MaxFramePerSecond_.set (x);
    }

    void ComputedTomographyType::
    MaxFramePerSecond (const MaxFramePerSecond_optional& x)
    {
      this->MaxFramePerSecond_ = x;
    }

    void ComputedTomographyType::
    MaxFramePerSecond (::std::unique_ptr< MaxFramePerSecond_type > x)
    {
      this->MaxFramePerSecond_.set (std::move (x));
    }

    const ComputedTomographyType::RotaryTable_optional& ComputedTomographyType::
    RotaryTable () const
    {
      return this->RotaryTable_;
    }

    ComputedTomographyType::RotaryTable_optional& ComputedTomographyType::
    RotaryTable ()
    {
      return this->RotaryTable_;
    }

    void ComputedTomographyType::
    RotaryTable (const RotaryTable_type& x)
    {
      this->RotaryTable_.set (x);
    }

    void ComputedTomographyType::
    RotaryTable (const RotaryTable_optional& x)
    {
      this->RotaryTable_ = x;
    }

    void ComputedTomographyType::
    RotaryTable (::std::unique_ptr< RotaryTable_type > x)
    {
      this->RotaryTable_.set (std::move (x));
    }

    const ComputedTomographyType::ToolIds_optional& ComputedTomographyType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    ComputedTomographyType::ToolIds_optional& ComputedTomographyType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void ComputedTomographyType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void ComputedTomographyType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void ComputedTomographyType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }


    // OpticalComparatorType
    //

    const OpticalComparatorType::Magnification_optional& OpticalComparatorType::
    Magnification () const
    {
      return this->Magnification_;
    }

    OpticalComparatorType::Magnification_optional& OpticalComparatorType::
    Magnification ()
    {
      return this->Magnification_;
    }

    void OpticalComparatorType::
    Magnification (const Magnification_type& x)
    {
      this->Magnification_.set (x);
    }

    void OpticalComparatorType::
    Magnification (const Magnification_optional& x)
    {
      this->Magnification_ = x;
    }

    const OpticalComparatorType::EffectiveScreenDiameter_optional& OpticalComparatorType::
    EffectiveScreenDiameter () const
    {
      return this->EffectiveScreenDiameter_;
    }

    OpticalComparatorType::EffectiveScreenDiameter_optional& OpticalComparatorType::
    EffectiveScreenDiameter ()
    {
      return this->EffectiveScreenDiameter_;
    }

    void OpticalComparatorType::
    EffectiveScreenDiameter (const EffectiveScreenDiameter_type& x)
    {
      this->EffectiveScreenDiameter_.set (x);
    }

    void OpticalComparatorType::
    EffectiveScreenDiameter (const EffectiveScreenDiameter_optional& x)
    {
      this->EffectiveScreenDiameter_ = x;
    }

    void OpticalComparatorType::
    EffectiveScreenDiameter (::std::unique_ptr< EffectiveScreenDiameter_type > x)
    {
      this->EffectiveScreenDiameter_.set (std::move (x));
    }

    const OpticalComparatorType::ScreenMaterial_optional& OpticalComparatorType::
    ScreenMaterial () const
    {
      return this->ScreenMaterial_;
    }

    OpticalComparatorType::ScreenMaterial_optional& OpticalComparatorType::
    ScreenMaterial ()
    {
      return this->ScreenMaterial_;
    }

    void OpticalComparatorType::
    ScreenMaterial (const ScreenMaterial_type& x)
    {
      this->ScreenMaterial_.set (x);
    }

    void OpticalComparatorType::
    ScreenMaterial (const ScreenMaterial_optional& x)
    {
      this->ScreenMaterial_ = x;
    }

    void OpticalComparatorType::
    ScreenMaterial (::std::unique_ptr< ScreenMaterial_type > x)
    {
      this->ScreenMaterial_.set (std::move (x));
    }

    const OpticalComparatorType::AngleResolution_optional& OpticalComparatorType::
    AngleResolution () const
    {
      return this->AngleResolution_;
    }

    OpticalComparatorType::AngleResolution_optional& OpticalComparatorType::
    AngleResolution ()
    {
      return this->AngleResolution_;
    }

    void OpticalComparatorType::
    AngleResolution (const AngleResolution_type& x)
    {
      this->AngleResolution_.set (x);
    }

    void OpticalComparatorType::
    AngleResolution (const AngleResolution_optional& x)
    {
      this->AngleResolution_ = x;
    }

    void OpticalComparatorType::
    AngleResolution (::std::unique_ptr< AngleResolution_type > x)
    {
      this->AngleResolution_.set (std::move (x));
    }

    const OpticalComparatorType::SurfaceIlluminationLightSource_optional& OpticalComparatorType::
    SurfaceIlluminationLightSource () const
    {
      return this->SurfaceIlluminationLightSource_;
    }

    OpticalComparatorType::SurfaceIlluminationLightSource_optional& OpticalComparatorType::
    SurfaceIlluminationLightSource ()
    {
      return this->SurfaceIlluminationLightSource_;
    }

    void OpticalComparatorType::
    SurfaceIlluminationLightSource (const SurfaceIlluminationLightSource_type& x)
    {
      this->SurfaceIlluminationLightSource_.set (x);
    }

    void OpticalComparatorType::
    SurfaceIlluminationLightSource (const SurfaceIlluminationLightSource_optional& x)
    {
      this->SurfaceIlluminationLightSource_ = x;
    }

    void OpticalComparatorType::
    SurfaceIlluminationLightSource (::std::unique_ptr< SurfaceIlluminationLightSource_type > x)
    {
      this->SurfaceIlluminationLightSource_.set (std::move (x));
    }

    const OpticalComparatorType::ContourIlluminationLightSource_optional& OpticalComparatorType::
    ContourIlluminationLightSource () const
    {
      return this->ContourIlluminationLightSource_;
    }

    OpticalComparatorType::ContourIlluminationLightSource_optional& OpticalComparatorType::
    ContourIlluminationLightSource ()
    {
      return this->ContourIlluminationLightSource_;
    }

    void OpticalComparatorType::
    ContourIlluminationLightSource (const ContourIlluminationLightSource_type& x)
    {
      this->ContourIlluminationLightSource_.set (x);
    }

    void OpticalComparatorType::
    ContourIlluminationLightSource (const ContourIlluminationLightSource_optional& x)
    {
      this->ContourIlluminationLightSource_ = x;
    }

    void OpticalComparatorType::
    ContourIlluminationLightSource (::std::unique_ptr< ContourIlluminationLightSource_type > x)
    {
      this->ContourIlluminationLightSource_.set (std::move (x));
    }

    const OpticalComparatorType::MaxWorkpieceHeight_optional& OpticalComparatorType::
    MaxWorkpieceHeight () const
    {
      return this->MaxWorkpieceHeight_;
    }

    OpticalComparatorType::MaxWorkpieceHeight_optional& OpticalComparatorType::
    MaxWorkpieceHeight ()
    {
      return this->MaxWorkpieceHeight_;
    }

    void OpticalComparatorType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    void OpticalComparatorType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x)
    {
      this->MaxWorkpieceHeight_ = x;
    }

    void OpticalComparatorType::
    MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > x)
    {
      this->MaxWorkpieceHeight_.set (std::move (x));
    }

    const OpticalComparatorType::WorkingDistance_optional& OpticalComparatorType::
    WorkingDistance () const
    {
      return this->WorkingDistance_;
    }

    OpticalComparatorType::WorkingDistance_optional& OpticalComparatorType::
    WorkingDistance ()
    {
      return this->WorkingDistance_;
    }

    void OpticalComparatorType::
    WorkingDistance (const WorkingDistance_type& x)
    {
      this->WorkingDistance_.set (x);
    }

    void OpticalComparatorType::
    WorkingDistance (const WorkingDistance_optional& x)
    {
      this->WorkingDistance_ = x;
    }

    void OpticalComparatorType::
    WorkingDistance (::std::unique_ptr< WorkingDistance_type > x)
    {
      this->WorkingDistance_.set (std::move (x));
    }

    const OpticalComparatorType::ToolIds_optional& OpticalComparatorType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    OpticalComparatorType::ToolIds_optional& OpticalComparatorType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void OpticalComparatorType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void OpticalComparatorType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void OpticalComparatorType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }


    // MicroscopeType
    //

    const MicroscopeType::IlluminationUnit_optional& MicroscopeType::
    IlluminationUnit () const
    {
      return this->IlluminationUnit_;
    }

    MicroscopeType::IlluminationUnit_optional& MicroscopeType::
    IlluminationUnit ()
    {
      return this->IlluminationUnit_;
    }

    void MicroscopeType::
    IlluminationUnit (const IlluminationUnit_type& x)
    {
      this->IlluminationUnit_.set (x);
    }

    void MicroscopeType::
    IlluminationUnit (const IlluminationUnit_optional& x)
    {
      this->IlluminationUnit_ = x;
    }

    void MicroscopeType::
    IlluminationUnit (::std::unique_ptr< IlluminationUnit_type > x)
    {
      this->IlluminationUnit_.set (std::move (x));
    }

    const MicroscopeType::TotalMagnification_optional& MicroscopeType::
    TotalMagnification () const
    {
      return this->TotalMagnification_;
    }

    MicroscopeType::TotalMagnification_optional& MicroscopeType::
    TotalMagnification ()
    {
      return this->TotalMagnification_;
    }

    void MicroscopeType::
    TotalMagnification (const TotalMagnification_type& x)
    {
      this->TotalMagnification_.set (x);
    }

    void MicroscopeType::
    TotalMagnification (const TotalMagnification_optional& x)
    {
      this->TotalMagnification_ = x;
    }

    const MicroscopeType::EyePieceMagnification_optional& MicroscopeType::
    EyePieceMagnification () const
    {
      return this->EyePieceMagnification_;
    }

    MicroscopeType::EyePieceMagnification_optional& MicroscopeType::
    EyePieceMagnification ()
    {
      return this->EyePieceMagnification_;
    }

    void MicroscopeType::
    EyePieceMagnification (const EyePieceMagnification_type& x)
    {
      this->EyePieceMagnification_.set (x);
    }

    void MicroscopeType::
    EyePieceMagnification (const EyePieceMagnification_optional& x)
    {
      this->EyePieceMagnification_ = x;
    }

    const MicroscopeType::ObjectiveMagnification_optional& MicroscopeType::
    ObjectiveMagnification () const
    {
      return this->ObjectiveMagnification_;
    }

    MicroscopeType::ObjectiveMagnification_optional& MicroscopeType::
    ObjectiveMagnification ()
    {
      return this->ObjectiveMagnification_;
    }

    void MicroscopeType::
    ObjectiveMagnification (const ObjectiveMagnification_type& x)
    {
      this->ObjectiveMagnification_.set (x);
    }

    void MicroscopeType::
    ObjectiveMagnification (const ObjectiveMagnification_optional& x)
    {
      this->ObjectiveMagnification_ = x;
    }

    const MicroscopeType::MaxWorkpieceHeight_optional& MicroscopeType::
    MaxWorkpieceHeight () const
    {
      return this->MaxWorkpieceHeight_;
    }

    MicroscopeType::MaxWorkpieceHeight_optional& MicroscopeType::
    MaxWorkpieceHeight ()
    {
      return this->MaxWorkpieceHeight_;
    }

    void MicroscopeType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    void MicroscopeType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x)
    {
      this->MaxWorkpieceHeight_ = x;
    }

    void MicroscopeType::
    MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > x)
    {
      this->MaxWorkpieceHeight_.set (std::move (x));
    }

    const MicroscopeType::MaxWorkpieceWeight_optional& MicroscopeType::
    MaxWorkpieceWeight () const
    {
      return this->MaxWorkpieceWeight_;
    }

    MicroscopeType::MaxWorkpieceWeight_optional& MicroscopeType::
    MaxWorkpieceWeight ()
    {
      return this->MaxWorkpieceWeight_;
    }

    void MicroscopeType::
    MaxWorkpieceWeight (const MaxWorkpieceWeight_type& x)
    {
      this->MaxWorkpieceWeight_.set (x);
    }

    void MicroscopeType::
    MaxWorkpieceWeight (const MaxWorkpieceWeight_optional& x)
    {
      this->MaxWorkpieceWeight_ = x;
    }

    void MicroscopeType::
    MaxWorkpieceWeight (::std::unique_ptr< MaxWorkpieceWeight_type > x)
    {
      this->MaxWorkpieceWeight_.set (std::move (x));
    }

    const MicroscopeType::Accuracy_optional& MicroscopeType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    MicroscopeType::Accuracy_optional& MicroscopeType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void MicroscopeType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void MicroscopeType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void MicroscopeType::
    Accuracy (::std::unique_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (std::move (x));
    }

    const MicroscopeType::StageSwivelingAngle_optional& MicroscopeType::
    StageSwivelingAngle () const
    {
      return this->StageSwivelingAngle_;
    }

    MicroscopeType::StageSwivelingAngle_optional& MicroscopeType::
    StageSwivelingAngle ()
    {
      return this->StageSwivelingAngle_;
    }

    void MicroscopeType::
    StageSwivelingAngle (const StageSwivelingAngle_type& x)
    {
      this->StageSwivelingAngle_.set (x);
    }

    void MicroscopeType::
    StageSwivelingAngle (const StageSwivelingAngle_optional& x)
    {
      this->StageSwivelingAngle_ = x;
    }

    void MicroscopeType::
    StageSwivelingAngle (::std::unique_ptr< StageSwivelingAngle_type > x)
    {
      this->StageSwivelingAngle_.set (std::move (x));
    }

    const MicroscopeType::ToolIds_optional& MicroscopeType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    MicroscopeType::ToolIds_optional& MicroscopeType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void MicroscopeType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void MicroscopeType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void MicroscopeType::
    ToolIds (::std::unique_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (std::move (x));
    }


    // AutocollimatorType
    //

    const AutocollimatorType::LightSource_optional& AutocollimatorType::
    LightSource () const
    {
      return this->LightSource_;
    }

    AutocollimatorType::LightSource_optional& AutocollimatorType::
    LightSource ()
    {
      return this->LightSource_;
    }

    void AutocollimatorType::
    LightSource (const LightSource_type& x)
    {
      this->LightSource_.set (x);
    }

    void AutocollimatorType::
    LightSource (const LightSource_optional& x)
    {
      this->LightSource_ = x;
    }

    void AutocollimatorType::
    LightSource (::std::unique_ptr< LightSource_type > x)
    {
      this->LightSource_.set (std::move (x));
    }

    const AutocollimatorType::MeasuringAccuracy_optional& AutocollimatorType::
    MeasuringAccuracy () const
    {
      return this->MeasuringAccuracy_;
    }

    AutocollimatorType::MeasuringAccuracy_optional& AutocollimatorType::
    MeasuringAccuracy ()
    {
      return this->MeasuringAccuracy_;
    }

    void AutocollimatorType::
    MeasuringAccuracy (const MeasuringAccuracy_type& x)
    {
      this->MeasuringAccuracy_.set (x);
    }

    void AutocollimatorType::
    MeasuringAccuracy (const MeasuringAccuracy_optional& x)
    {
      this->MeasuringAccuracy_ = x;
    }

    void AutocollimatorType::
    MeasuringAccuracy (::std::unique_ptr< MeasuringAccuracy_type > x)
    {
      this->MeasuringAccuracy_.set (std::move (x));
    }

    const AutocollimatorType::Magnification_optional& AutocollimatorType::
    Magnification () const
    {
      return this->Magnification_;
    }

    AutocollimatorType::Magnification_optional& AutocollimatorType::
    Magnification ()
    {
      return this->Magnification_;
    }

    void AutocollimatorType::
    Magnification (const Magnification_type& x)
    {
      this->Magnification_.set (x);
    }

    void AutocollimatorType::
    Magnification (const Magnification_optional& x)
    {
      this->Magnification_ = x;
    }

    const AutocollimatorType::ApertureSize_optional& AutocollimatorType::
    ApertureSize () const
    {
      return this->ApertureSize_;
    }

    AutocollimatorType::ApertureSize_optional& AutocollimatorType::
    ApertureSize ()
    {
      return this->ApertureSize_;
    }

    void AutocollimatorType::
    ApertureSize (const ApertureSize_type& x)
    {
      this->ApertureSize_.set (x);
    }

    void AutocollimatorType::
    ApertureSize (const ApertureSize_optional& x)
    {
      this->ApertureSize_ = x;
    }

    void AutocollimatorType::
    ApertureSize (::std::unique_ptr< ApertureSize_type > x)
    {
      this->ApertureSize_.set (std::move (x));
    }

    const AutocollimatorType::MinMeasuringDistance_optional& AutocollimatorType::
    MinMeasuringDistance () const
    {
      return this->MinMeasuringDistance_;
    }

    AutocollimatorType::MinMeasuringDistance_optional& AutocollimatorType::
    MinMeasuringDistance ()
    {
      return this->MinMeasuringDistance_;
    }

    void AutocollimatorType::
    MinMeasuringDistance (const MinMeasuringDistance_type& x)
    {
      this->MinMeasuringDistance_.set (x);
    }

    void AutocollimatorType::
    MinMeasuringDistance (const MinMeasuringDistance_optional& x)
    {
      this->MinMeasuringDistance_ = x;
    }

    void AutocollimatorType::
    MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > x)
    {
      this->MinMeasuringDistance_.set (std::move (x));
    }

    const AutocollimatorType::MaxMeasuringDistance_optional& AutocollimatorType::
    MaxMeasuringDistance () const
    {
      return this->MaxMeasuringDistance_;
    }

    AutocollimatorType::MaxMeasuringDistance_optional& AutocollimatorType::
    MaxMeasuringDistance ()
    {
      return this->MaxMeasuringDistance_;
    }

    void AutocollimatorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_type& x)
    {
      this->MaxMeasuringDistance_.set (x);
    }

    void AutocollimatorType::
    MaxMeasuringDistance (const MaxMeasuringDistance_optional& x)
    {
      this->MaxMeasuringDistance_ = x;
    }

    void AutocollimatorType::
    MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > x)
    {
      this->MaxMeasuringDistance_.set (std::move (x));
    }

    const AutocollimatorType::ObjectiveFocalLength_optional& AutocollimatorType::
    ObjectiveFocalLength () const
    {
      return this->ObjectiveFocalLength_;
    }

    AutocollimatorType::ObjectiveFocalLength_optional& AutocollimatorType::
    ObjectiveFocalLength ()
    {
      return this->ObjectiveFocalLength_;
    }

    void AutocollimatorType::
    ObjectiveFocalLength (const ObjectiveFocalLength_type& x)
    {
      this->ObjectiveFocalLength_.set (x);
    }

    void AutocollimatorType::
    ObjectiveFocalLength (const ObjectiveFocalLength_optional& x)
    {
      this->ObjectiveFocalLength_ = x;
    }

    void AutocollimatorType::
    ObjectiveFocalLength (::std::unique_ptr< ObjectiveFocalLength_type > x)
    {
      this->ObjectiveFocalLength_.set (std::move (x));
    }

    const AutocollimatorType::FieldOfView_optional& AutocollimatorType::
    FieldOfView () const
    {
      return this->FieldOfView_;
    }

    AutocollimatorType::FieldOfView_optional& AutocollimatorType::
    FieldOfView ()
    {
      return this->FieldOfView_;
    }

    void AutocollimatorType::
    FieldOfView (const FieldOfView_type& x)
    {
      this->FieldOfView_.set (x);
    }

    void AutocollimatorType::
    FieldOfView (const FieldOfView_optional& x)
    {
      this->FieldOfView_ = x;
    }

    void AutocollimatorType::
    FieldOfView (::std::unique_ptr< FieldOfView_type > x)
    {
      this->FieldOfView_.set (std::move (x));
    }


    // LaserTrackerType
    //

    const LaserTrackerType::MaximumAngularVelocity_optional& LaserTrackerType::
    MaximumAngularVelocity () const
    {
      return this->MaximumAngularVelocity_;
    }

    LaserTrackerType::MaximumAngularVelocity_optional& LaserTrackerType::
    MaximumAngularVelocity ()
    {
      return this->MaximumAngularVelocity_;
    }

    void LaserTrackerType::
    MaximumAngularVelocity (const MaximumAngularVelocity_type& x)
    {
      this->MaximumAngularVelocity_.set (x);
    }

    void LaserTrackerType::
    MaximumAngularVelocity (const MaximumAngularVelocity_optional& x)
    {
      this->MaximumAngularVelocity_ = x;
    }

    void LaserTrackerType::
    MaximumAngularVelocity (::std::unique_ptr< MaximumAngularVelocity_type > x)
    {
      this->MaximumAngularVelocity_.set (std::move (x));
    }

    const LaserTrackerType::DistanceAccuracy_optional& LaserTrackerType::
    DistanceAccuracy () const
    {
      return this->DistanceAccuracy_;
    }

    LaserTrackerType::DistanceAccuracy_optional& LaserTrackerType::
    DistanceAccuracy ()
    {
      return this->DistanceAccuracy_;
    }

    void LaserTrackerType::
    DistanceAccuracy (const DistanceAccuracy_type& x)
    {
      this->DistanceAccuracy_.set (x);
    }

    void LaserTrackerType::
    DistanceAccuracy (const DistanceAccuracy_optional& x)
    {
      this->DistanceAccuracy_ = x;
    }

    void LaserTrackerType::
    DistanceAccuracy (::std::unique_ptr< DistanceAccuracy_type > x)
    {
      this->DistanceAccuracy_.set (std::move (x));
    }

    const LaserTrackerType::AngularAccuracy_optional& LaserTrackerType::
    AngularAccuracy () const
    {
      return this->AngularAccuracy_;
    }

    LaserTrackerType::AngularAccuracy_optional& LaserTrackerType::
    AngularAccuracy ()
    {
      return this->AngularAccuracy_;
    }

    void LaserTrackerType::
    AngularAccuracy (const AngularAccuracy_type& x)
    {
      this->AngularAccuracy_.set (x);
    }

    void LaserTrackerType::
    AngularAccuracy (const AngularAccuracy_optional& x)
    {
      this->AngularAccuracy_ = x;
    }

    void LaserTrackerType::
    AngularAccuracy (::std::unique_ptr< AngularAccuracy_type > x)
    {
      this->AngularAccuracy_.set (std::move (x));
    }

    const LaserTrackerType::SamplingRate_optional& LaserTrackerType::
    SamplingRate () const
    {
      return this->SamplingRate_;
    }

    LaserTrackerType::SamplingRate_optional& LaserTrackerType::
    SamplingRate ()
    {
      return this->SamplingRate_;
    }

    void LaserTrackerType::
    SamplingRate (const SamplingRate_type& x)
    {
      this->SamplingRate_.set (x);
    }

    void LaserTrackerType::
    SamplingRate (const SamplingRate_optional& x)
    {
      this->SamplingRate_ = x;
    }

    void LaserTrackerType::
    SamplingRate (::std::unique_ptr< SamplingRate_type > x)
    {
      this->SamplingRate_.set (std::move (x));
    }

    const LaserTrackerType::TargetMirror_optional& LaserTrackerType::
    TargetMirror () const
    {
      return this->TargetMirror_;
    }

    LaserTrackerType::TargetMirror_optional& LaserTrackerType::
    TargetMirror ()
    {
      return this->TargetMirror_;
    }

    void LaserTrackerType::
    TargetMirror (const TargetMirror_type& x)
    {
      this->TargetMirror_.set (x);
    }

    void LaserTrackerType::
    TargetMirror (const TargetMirror_optional& x)
    {
      this->TargetMirror_ = x;
    }

    void LaserTrackerType::
    TargetMirror (::std::unique_ptr< TargetMirror_type > x)
    {
      this->TargetMirror_.set (std::move (x));
    }

    const LaserTrackerType::HeadMass_optional& LaserTrackerType::
    HeadMass () const
    {
      return this->HeadMass_;
    }

    LaserTrackerType::HeadMass_optional& LaserTrackerType::
    HeadMass ()
    {
      return this->HeadMass_;
    }

    void LaserTrackerType::
    HeadMass (const HeadMass_type& x)
    {
      this->HeadMass_.set (x);
    }

    void LaserTrackerType::
    HeadMass (const HeadMass_optional& x)
    {
      this->HeadMass_ = x;
    }

    void LaserTrackerType::
    HeadMass (::std::unique_ptr< HeadMass_type > x)
    {
      this->HeadMass_.set (std::move (x));
    }

    const LaserTrackerType::HeadSize_optional& LaserTrackerType::
    HeadSize () const
    {
      return this->HeadSize_;
    }

    LaserTrackerType::HeadSize_optional& LaserTrackerType::
    HeadSize ()
    {
      return this->HeadSize_;
    }

    void LaserTrackerType::
    HeadSize (const HeadSize_type& x)
    {
      this->HeadSize_.set (x);
    }

    void LaserTrackerType::
    HeadSize (const HeadSize_optional& x)
    {
      this->HeadSize_ = x;
    }

    void LaserTrackerType::
    HeadSize (::std::unique_ptr< HeadSize_type > x)
    {
      this->HeadSize_.set (std::move (x));
    }

    const LaserTrackerType::MaximumWorkingAmplitude_optional& LaserTrackerType::
    MaximumWorkingAmplitude () const
    {
      return this->MaximumWorkingAmplitude_;
    }

    LaserTrackerType::MaximumWorkingAmplitude_optional& LaserTrackerType::
    MaximumWorkingAmplitude ()
    {
      return this->MaximumWorkingAmplitude_;
    }

    void LaserTrackerType::
    MaximumWorkingAmplitude (const MaximumWorkingAmplitude_type& x)
    {
      this->MaximumWorkingAmplitude_.set (x);
    }

    void LaserTrackerType::
    MaximumWorkingAmplitude (const MaximumWorkingAmplitude_optional& x)
    {
      this->MaximumWorkingAmplitude_ = x;
    }

    void LaserTrackerType::
    MaximumWorkingAmplitude (::std::unique_ptr< MaximumWorkingAmplitude_type > x)
    {
      this->MaximumWorkingAmplitude_.set (std::move (x));
    }

    const LaserTrackerType::Laser_optional& LaserTrackerType::
    Laser () const
    {
      return this->Laser_;
    }

    LaserTrackerType::Laser_optional& LaserTrackerType::
    Laser ()
    {
      return this->Laser_;
    }

    void LaserTrackerType::
    Laser (const Laser_type& x)
    {
      this->Laser_.set (x);
    }

    void LaserTrackerType::
    Laser (const Laser_optional& x)
    {
      this->Laser_ = x;
    }

    void LaserTrackerType::
    Laser (::std::unique_ptr< Laser_type > x)
    {
      this->Laser_.set (std::move (x));
    }

    const LaserTrackerType::Repeatability_optional& LaserTrackerType::
    Repeatability () const
    {
      return this->Repeatability_;
    }

    LaserTrackerType::Repeatability_optional& LaserTrackerType::
    Repeatability ()
    {
      return this->Repeatability_;
    }

    void LaserTrackerType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void LaserTrackerType::
    Repeatability (const Repeatability_optional& x)
    {
      this->Repeatability_ = x;
    }

    void LaserTrackerType::
    Repeatability (::std::unique_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (std::move (x));
    }


    // LaserRadarType
    //

    const LaserRadarType::MeasurementLaser_optional& LaserRadarType::
    MeasurementLaser () const
    {
      return this->MeasurementLaser_;
    }

    LaserRadarType::MeasurementLaser_optional& LaserRadarType::
    MeasurementLaser ()
    {
      return this->MeasurementLaser_;
    }

    void LaserRadarType::
    MeasurementLaser (const MeasurementLaser_type& x)
    {
      this->MeasurementLaser_.set (x);
    }

    void LaserRadarType::
    MeasurementLaser (const MeasurementLaser_optional& x)
    {
      this->MeasurementLaser_ = x;
    }

    void LaserRadarType::
    MeasurementLaser (::std::unique_ptr< MeasurementLaser_type > x)
    {
      this->MeasurementLaser_.set (std::move (x));
    }

    const LaserRadarType::PointingLaser_optional& LaserRadarType::
    PointingLaser () const
    {
      return this->PointingLaser_;
    }

    LaserRadarType::PointingLaser_optional& LaserRadarType::
    PointingLaser ()
    {
      return this->PointingLaser_;
    }

    void LaserRadarType::
    PointingLaser (const PointingLaser_type& x)
    {
      this->PointingLaser_.set (x);
    }

    void LaserRadarType::
    PointingLaser (const PointingLaser_optional& x)
    {
      this->PointingLaser_ = x;
    }

    void LaserRadarType::
    PointingLaser (::std::unique_ptr< PointingLaser_type > x)
    {
      this->PointingLaser_.set (std::move (x));
    }

    const LaserRadarType::MaxPointsRate_optional& LaserRadarType::
    MaxPointsRate () const
    {
      return this->MaxPointsRate_;
    }

    LaserRadarType::MaxPointsRate_optional& LaserRadarType::
    MaxPointsRate ()
    {
      return this->MaxPointsRate_;
    }

    void LaserRadarType::
    MaxPointsRate (const MaxPointsRate_type& x)
    {
      this->MaxPointsRate_.set (x);
    }

    void LaserRadarType::
    MaxPointsRate (const MaxPointsRate_optional& x)
    {
      this->MaxPointsRate_ = x;
    }

    void LaserRadarType::
    MaxPointsRate (::std::unique_ptr< MaxPointsRate_type > x)
    {
      this->MaxPointsRate_.set (std::move (x));
    }

    const LaserRadarType::MaxMeasurementRange_optional& LaserRadarType::
    MaxMeasurementRange () const
    {
      return this->MaxMeasurementRange_;
    }

    LaserRadarType::MaxMeasurementRange_optional& LaserRadarType::
    MaxMeasurementRange ()
    {
      return this->MaxMeasurementRange_;
    }

    void LaserRadarType::
    MaxMeasurementRange (const MaxMeasurementRange_type& x)
    {
      this->MaxMeasurementRange_.set (x);
    }

    void LaserRadarType::
    MaxMeasurementRange (const MaxMeasurementRange_optional& x)
    {
      this->MaxMeasurementRange_ = x;
    }

    void LaserRadarType::
    MaxMeasurementRange (::std::unique_ptr< MaxMeasurementRange_type > x)
    {
      this->MaxMeasurementRange_.set (std::move (x));
    }

    const LaserRadarType::MinMeasurementRange_optional& LaserRadarType::
    MinMeasurementRange () const
    {
      return this->MinMeasurementRange_;
    }

    LaserRadarType::MinMeasurementRange_optional& LaserRadarType::
    MinMeasurementRange ()
    {
      return this->MinMeasurementRange_;
    }

    void LaserRadarType::
    MinMeasurementRange (const MinMeasurementRange_type& x)
    {
      this->MinMeasurementRange_.set (x);
    }

    void LaserRadarType::
    MinMeasurementRange (const MinMeasurementRange_optional& x)
    {
      this->MinMeasurementRange_ = x;
    }

    void LaserRadarType::
    MinMeasurementRange (::std::unique_ptr< MinMeasurementRange_type > x)
    {
      this->MinMeasurementRange_.set (std::move (x));
    }

    const LaserRadarType::ScanningSpeed_optional& LaserRadarType::
    ScanningSpeed () const
    {
      return this->ScanningSpeed_;
    }

    LaserRadarType::ScanningSpeed_optional& LaserRadarType::
    ScanningSpeed ()
    {
      return this->ScanningSpeed_;
    }

    void LaserRadarType::
    ScanningSpeed (const ScanningSpeed_type& x)
    {
      this->ScanningSpeed_.set (x);
    }

    void LaserRadarType::
    ScanningSpeed (const ScanningSpeed_optional& x)
    {
      this->ScanningSpeed_ = x;
    }

    void LaserRadarType::
    ScanningSpeed (::std::unique_ptr< ScanningSpeed_type > x)
    {
      this->ScanningSpeed_.set (std::move (x));
    }

    const LaserRadarType::DistanceAccuracy_optional& LaserRadarType::
    DistanceAccuracy () const
    {
      return this->DistanceAccuracy_;
    }

    LaserRadarType::DistanceAccuracy_optional& LaserRadarType::
    DistanceAccuracy ()
    {
      return this->DistanceAccuracy_;
    }

    void LaserRadarType::
    DistanceAccuracy (const DistanceAccuracy_type& x)
    {
      this->DistanceAccuracy_.set (x);
    }

    void LaserRadarType::
    DistanceAccuracy (const DistanceAccuracy_optional& x)
    {
      this->DistanceAccuracy_ = x;
    }

    void LaserRadarType::
    DistanceAccuracy (::std::unique_ptr< DistanceAccuracy_type > x)
    {
      this->DistanceAccuracy_.set (std::move (x));
    }

    const LaserRadarType::AzimuthAngularAccuracy_optional& LaserRadarType::
    AzimuthAngularAccuracy () const
    {
      return this->AzimuthAngularAccuracy_;
    }

    LaserRadarType::AzimuthAngularAccuracy_optional& LaserRadarType::
    AzimuthAngularAccuracy ()
    {
      return this->AzimuthAngularAccuracy_;
    }

    void LaserRadarType::
    AzimuthAngularAccuracy (const AzimuthAngularAccuracy_type& x)
    {
      this->AzimuthAngularAccuracy_.set (x);
    }

    void LaserRadarType::
    AzimuthAngularAccuracy (const AzimuthAngularAccuracy_optional& x)
    {
      this->AzimuthAngularAccuracy_ = x;
    }

    void LaserRadarType::
    AzimuthAngularAccuracy (::std::unique_ptr< AzimuthAngularAccuracy_type > x)
    {
      this->AzimuthAngularAccuracy_.set (std::move (x));
    }

    const LaserRadarType::ElevationAngularAccuracy_optional& LaserRadarType::
    ElevationAngularAccuracy () const
    {
      return this->ElevationAngularAccuracy_;
    }

    LaserRadarType::ElevationAngularAccuracy_optional& LaserRadarType::
    ElevationAngularAccuracy ()
    {
      return this->ElevationAngularAccuracy_;
    }

    void LaserRadarType::
    ElevationAngularAccuracy (const ElevationAngularAccuracy_type& x)
    {
      this->ElevationAngularAccuracy_.set (x);
    }

    void LaserRadarType::
    ElevationAngularAccuracy (const ElevationAngularAccuracy_optional& x)
    {
      this->ElevationAngularAccuracy_ = x;
    }

    void LaserRadarType::
    ElevationAngularAccuracy (::std::unique_ptr< ElevationAngularAccuracy_type > x)
    {
      this->ElevationAngularAccuracy_.set (std::move (x));
    }

    const LaserRadarType::RangeForVolumetricUncertainty_optional& LaserRadarType::
    RangeForVolumetricUncertainty () const
    {
      return this->RangeForVolumetricUncertainty_;
    }

    LaserRadarType::RangeForVolumetricUncertainty_optional& LaserRadarType::
    RangeForVolumetricUncertainty ()
    {
      return this->RangeForVolumetricUncertainty_;
    }

    void LaserRadarType::
    RangeForVolumetricUncertainty (const RangeForVolumetricUncertainty_type& x)
    {
      this->RangeForVolumetricUncertainty_.set (x);
    }

    void LaserRadarType::
    RangeForVolumetricUncertainty (const RangeForVolumetricUncertainty_optional& x)
    {
      this->RangeForVolumetricUncertainty_ = x;
    }

    void LaserRadarType::
    RangeForVolumetricUncertainty (::std::unique_ptr< RangeForVolumetricUncertainty_type > x)
    {
      this->RangeForVolumetricUncertainty_.set (std::move (x));
    }

    const LaserRadarType::VolumetricUncertainty_optional& LaserRadarType::
    VolumetricUncertainty () const
    {
      return this->VolumetricUncertainty_;
    }

    LaserRadarType::VolumetricUncertainty_optional& LaserRadarType::
    VolumetricUncertainty ()
    {
      return this->VolumetricUncertainty_;
    }

    void LaserRadarType::
    VolumetricUncertainty (const VolumetricUncertainty_type& x)
    {
      this->VolumetricUncertainty_.set (x);
    }

    void LaserRadarType::
    VolumetricUncertainty (const VolumetricUncertainty_optional& x)
    {
      this->VolumetricUncertainty_ = x;
    }

    void LaserRadarType::
    VolumetricUncertainty (::std::unique_ptr< VolumetricUncertainty_type > x)
    {
      this->VolumetricUncertainty_.set (std::move (x));
    }

    const LaserRadarType::MaxEnvironmentalAltitude_optional& LaserRadarType::
    MaxEnvironmentalAltitude () const
    {
      return this->MaxEnvironmentalAltitude_;
    }

    LaserRadarType::MaxEnvironmentalAltitude_optional& LaserRadarType::
    MaxEnvironmentalAltitude ()
    {
      return this->MaxEnvironmentalAltitude_;
    }

    void LaserRadarType::
    MaxEnvironmentalAltitude (const MaxEnvironmentalAltitude_type& x)
    {
      this->MaxEnvironmentalAltitude_.set (x);
    }

    void LaserRadarType::
    MaxEnvironmentalAltitude (const MaxEnvironmentalAltitude_optional& x)
    {
      this->MaxEnvironmentalAltitude_ = x;
    }

    void LaserRadarType::
    MaxEnvironmentalAltitude (::std::unique_ptr< MaxEnvironmentalAltitude_type > x)
    {
      this->MaxEnvironmentalAltitude_.set (std::move (x));
    }

    const LaserRadarType::MinEnvironmentalAltitude_optional& LaserRadarType::
    MinEnvironmentalAltitude () const
    {
      return this->MinEnvironmentalAltitude_;
    }

    LaserRadarType::MinEnvironmentalAltitude_optional& LaserRadarType::
    MinEnvironmentalAltitude ()
    {
      return this->MinEnvironmentalAltitude_;
    }

    void LaserRadarType::
    MinEnvironmentalAltitude (const MinEnvironmentalAltitude_type& x)
    {
      this->MinEnvironmentalAltitude_.set (x);
    }

    void LaserRadarType::
    MinEnvironmentalAltitude (const MinEnvironmentalAltitude_optional& x)
    {
      this->MinEnvironmentalAltitude_ = x;
    }

    void LaserRadarType::
    MinEnvironmentalAltitude (::std::unique_ptr< MinEnvironmentalAltitude_type > x)
    {
      this->MinEnvironmentalAltitude_.set (std::move (x));
    }

    const LaserRadarType::SurfacePointsSpeed_optional& LaserRadarType::
    SurfacePointsSpeed () const
    {
      return this->SurfacePointsSpeed_;
    }

    LaserRadarType::SurfacePointsSpeed_optional& LaserRadarType::
    SurfacePointsSpeed ()
    {
      return this->SurfacePointsSpeed_;
    }

    void LaserRadarType::
    SurfacePointsSpeed (const SurfacePointsSpeed_type& x)
    {
      this->SurfacePointsSpeed_.set (x);
    }

    void LaserRadarType::
    SurfacePointsSpeed (const SurfacePointsSpeed_optional& x)
    {
      this->SurfacePointsSpeed_ = x;
    }

    void LaserRadarType::
    SurfacePointsSpeed (::std::unique_ptr< SurfacePointsSpeed_type > x)
    {
      this->SurfacePointsSpeed_.set (std::move (x));
    }

    const LaserRadarType::ToolingBallSpeed_optional& LaserRadarType::
    ToolingBallSpeed () const
    {
      return this->ToolingBallSpeed_;
    }

    LaserRadarType::ToolingBallSpeed_optional& LaserRadarType::
    ToolingBallSpeed ()
    {
      return this->ToolingBallSpeed_;
    }

    void LaserRadarType::
    ToolingBallSpeed (const ToolingBallSpeed_type& x)
    {
      this->ToolingBallSpeed_.set (x);
    }

    void LaserRadarType::
    ToolingBallSpeed (const ToolingBallSpeed_optional& x)
    {
      this->ToolingBallSpeed_ = x;
    }

    void LaserRadarType::
    ToolingBallSpeed (::std::unique_ptr< ToolingBallSpeed_type > x)
    {
      this->ToolingBallSpeed_.set (std::move (x));
    }

    const LaserRadarType::FeatureSpeed_optional& LaserRadarType::
    FeatureSpeed () const
    {
      return this->FeatureSpeed_;
    }

    LaserRadarType::FeatureSpeed_optional& LaserRadarType::
    FeatureSpeed ()
    {
      return this->FeatureSpeed_;
    }

    void LaserRadarType::
    FeatureSpeed (const FeatureSpeed_type& x)
    {
      this->FeatureSpeed_.set (x);
    }

    void LaserRadarType::
    FeatureSpeed (const FeatureSpeed_optional& x)
    {
      this->FeatureSpeed_ = x;
    }

    void LaserRadarType::
    FeatureSpeed (::std::unique_ptr< FeatureSpeed_type > x)
    {
      this->FeatureSpeed_.set (std::move (x));
    }


    // StiffnessType
    //

    const StiffnessType::XStiffness_optional& StiffnessType::
    XStiffness () const
    {
      return this->XStiffness_;
    }

    StiffnessType::XStiffness_optional& StiffnessType::
    XStiffness ()
    {
      return this->XStiffness_;
    }

    void StiffnessType::
    XStiffness (const XStiffness_type& x)
    {
      this->XStiffness_.set (x);
    }

    void StiffnessType::
    XStiffness (const XStiffness_optional& x)
    {
      this->XStiffness_ = x;
    }

    void StiffnessType::
    XStiffness (::std::unique_ptr< XStiffness_type > x)
    {
      this->XStiffness_.set (std::move (x));
    }

    const StiffnessType::YStiffness_optional& StiffnessType::
    YStiffness () const
    {
      return this->YStiffness_;
    }

    StiffnessType::YStiffness_optional& StiffnessType::
    YStiffness ()
    {
      return this->YStiffness_;
    }

    void StiffnessType::
    YStiffness (const YStiffness_type& x)
    {
      this->YStiffness_.set (x);
    }

    void StiffnessType::
    YStiffness (const YStiffness_optional& x)
    {
      this->YStiffness_ = x;
    }

    void StiffnessType::
    YStiffness (::std::unique_ptr< YStiffness_type > x)
    {
      this->YStiffness_.set (std::move (x));
    }

    const StiffnessType::ZStiffness_optional& StiffnessType::
    ZStiffness () const
    {
      return this->ZStiffness_;
    }

    StiffnessType::ZStiffness_optional& StiffnessType::
    ZStiffness ()
    {
      return this->ZStiffness_;
    }

    void StiffnessType::
    ZStiffness (const ZStiffness_type& x)
    {
      this->ZStiffness_.set (x);
    }

    void StiffnessType::
    ZStiffness (const ZStiffness_optional& x)
    {
      this->ZStiffness_ = x;
    }

    void StiffnessType::
    ZStiffness (::std::unique_ptr< ZStiffness_type > x)
    {
      this->ZStiffness_.set (std::move (x));
    }


    // CMMDirectionEnumType
    //

    CMMDirectionEnumType::
    CMMDirectionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v])
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const CMMDirectionEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CMMDirectionEnumType& CMMDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v]);

      return *this;
    }


    // CartesianCMMGeometryType
    //

    const CartesianCMMGeometryType::CartesianCMMGeometryEnum_optional& CartesianCMMGeometryType::
    CartesianCMMGeometryEnum () const
    {
      return this->CartesianCMMGeometryEnum_;
    }

    CartesianCMMGeometryType::CartesianCMMGeometryEnum_optional& CartesianCMMGeometryType::
    CartesianCMMGeometryEnum ()
    {
      return this->CartesianCMMGeometryEnum_;
    }

    void CartesianCMMGeometryType::
    CartesianCMMGeometryEnum (const CartesianCMMGeometryEnum_type& x)
    {
      this->CartesianCMMGeometryEnum_.set (x);
    }

    void CartesianCMMGeometryType::
    CartesianCMMGeometryEnum (const CartesianCMMGeometryEnum_optional& x)
    {
      this->CartesianCMMGeometryEnum_ = x;
    }

    void CartesianCMMGeometryType::
    CartesianCMMGeometryEnum (::std::unique_ptr< CartesianCMMGeometryEnum_type > x)
    {
      this->CartesianCMMGeometryEnum_.set (std::move (x));
    }

    const CartesianCMMGeometryType::OtherCartesianCMMGeometry_optional& CartesianCMMGeometryType::
    OtherCartesianCMMGeometry () const
    {
      return this->OtherCartesianCMMGeometry_;
    }

    CartesianCMMGeometryType::OtherCartesianCMMGeometry_optional& CartesianCMMGeometryType::
    OtherCartesianCMMGeometry ()
    {
      return this->OtherCartesianCMMGeometry_;
    }

    void CartesianCMMGeometryType::
    OtherCartesianCMMGeometry (const OtherCartesianCMMGeometry_type& x)
    {
      this->OtherCartesianCMMGeometry_.set (x);
    }

    void CartesianCMMGeometryType::
    OtherCartesianCMMGeometry (const OtherCartesianCMMGeometry_optional& x)
    {
      this->OtherCartesianCMMGeometry_ = x;
    }

    void CartesianCMMGeometryType::
    OtherCartesianCMMGeometry (::std::unique_ptr< OtherCartesianCMMGeometry_type > x)
    {
      this->OtherCartesianCMMGeometry_.set (std::move (x));
    }


    // CartesianCMMGeometryEnumType
    //

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CartesianCMMGeometryEnumType_literals_[v])
    {
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const CartesianCMMGeometryEnumType& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CartesianCMMGeometryEnumType& CartesianCMMGeometryEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CartesianCMMGeometryEnumType_literals_[v]);

      return *this;
    }


    // CMMAxisDirectionsBaseType
    //


    // CartesianCMMAxisDirectionsType
    //

    const CartesianCMMAxisDirectionsType::XAxisDirection_type& CartesianCMMAxisDirectionsType::
    XAxisDirection () const
    {
      return this->XAxisDirection_.get ();
    }

    CartesianCMMAxisDirectionsType::XAxisDirection_type& CartesianCMMAxisDirectionsType::
    XAxisDirection ()
    {
      return this->XAxisDirection_.get ();
    }

    void CartesianCMMAxisDirectionsType::
    XAxisDirection (const XAxisDirection_type& x)
    {
      this->XAxisDirection_.set (x);
    }

    void CartesianCMMAxisDirectionsType::
    XAxisDirection (::std::unique_ptr< XAxisDirection_type > x)
    {
      this->XAxisDirection_.set (std::move (x));
    }

    const CartesianCMMAxisDirectionsType::YAxisDirection_type& CartesianCMMAxisDirectionsType::
    YAxisDirection () const
    {
      return this->YAxisDirection_.get ();
    }

    CartesianCMMAxisDirectionsType::YAxisDirection_type& CartesianCMMAxisDirectionsType::
    YAxisDirection ()
    {
      return this->YAxisDirection_.get ();
    }

    void CartesianCMMAxisDirectionsType::
    YAxisDirection (const YAxisDirection_type& x)
    {
      this->YAxisDirection_.set (x);
    }

    void CartesianCMMAxisDirectionsType::
    YAxisDirection (::std::unique_ptr< YAxisDirection_type > x)
    {
      this->YAxisDirection_.set (std::move (x));
    }

    const CartesianCMMAxisDirectionsType::ZAxisDirection_type& CartesianCMMAxisDirectionsType::
    ZAxisDirection () const
    {
      return this->ZAxisDirection_.get ();
    }

    CartesianCMMAxisDirectionsType::ZAxisDirection_type& CartesianCMMAxisDirectionsType::
    ZAxisDirection ()
    {
      return this->ZAxisDirection_.get ();
    }

    void CartesianCMMAxisDirectionsType::
    ZAxisDirection (const ZAxisDirection_type& x)
    {
      this->ZAxisDirection_.set (x);
    }

    void CartesianCMMAxisDirectionsType::
    ZAxisDirection (::std::unique_ptr< ZAxisDirection_type > x)
    {
      this->ZAxisDirection_.set (std::move (x));
    }


    // XYZLinearSpecificationType
    //

    const XYZLinearSpecificationType::X_optional& XYZLinearSpecificationType::
    X () const
    {
      return this->X_;
    }

    XYZLinearSpecificationType::X_optional& XYZLinearSpecificationType::
    X ()
    {
      return this->X_;
    }

    void XYZLinearSpecificationType::
    X (const X_type& x)
    {
      this->X_.set (x);
    }

    void XYZLinearSpecificationType::
    X (const X_optional& x)
    {
      this->X_ = x;
    }

    void XYZLinearSpecificationType::
    X (::std::unique_ptr< X_type > x)
    {
      this->X_.set (std::move (x));
    }

    const XYZLinearSpecificationType::Y_optional& XYZLinearSpecificationType::
    Y () const
    {
      return this->Y_;
    }

    XYZLinearSpecificationType::Y_optional& XYZLinearSpecificationType::
    Y ()
    {
      return this->Y_;
    }

    void XYZLinearSpecificationType::
    Y (const Y_type& x)
    {
      this->Y_.set (x);
    }

    void XYZLinearSpecificationType::
    Y (const Y_optional& x)
    {
      this->Y_ = x;
    }

    void XYZLinearSpecificationType::
    Y (::std::unique_ptr< Y_type > x)
    {
      this->Y_.set (std::move (x));
    }

    const XYZLinearSpecificationType::Z_optional& XYZLinearSpecificationType::
    Z () const
    {
      return this->Z_;
    }

    XYZLinearSpecificationType::Z_optional& XYZLinearSpecificationType::
    Z ()
    {
      return this->Z_;
    }

    void XYZLinearSpecificationType::
    Z (const Z_type& x)
    {
      this->Z_.set (x);
    }

    void XYZLinearSpecificationType::
    Z (const Z_optional& x)
    {
      this->Z_ = x;
    }

    void XYZLinearSpecificationType::
    Z (::std::unique_ptr< Z_type > x)
    {
      this->Z_.set (std::move (x));
    }


    // TargetMirrorEnumType
    //

    TargetMirrorEnumType::
    TargetMirrorEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_TargetMirrorEnumType_literals_[v])
    {
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const TargetMirrorEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    TargetMirrorEnumType& TargetMirrorEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_TargetMirrorEnumType_literals_[v]);

      return *this;
    }


    // MeasurementDeviceScalesBaseType
    //


    // CartesianMeasurementDeviceScalesType
    //

    const CartesianMeasurementDeviceScalesType::XScale_type& CartesianMeasurementDeviceScalesType::
    XScale () const
    {
      return this->XScale_.get ();
    }

    CartesianMeasurementDeviceScalesType::XScale_type& CartesianMeasurementDeviceScalesType::
    XScale ()
    {
      return this->XScale_.get ();
    }

    void CartesianMeasurementDeviceScalesType::
    XScale (const XScale_type& x)
    {
      this->XScale_.set (x);
    }

    void CartesianMeasurementDeviceScalesType::
    XScale (::std::unique_ptr< XScale_type > x)
    {
      this->XScale_.set (std::move (x));
    }

    const CartesianMeasurementDeviceScalesType::YScale_type& CartesianMeasurementDeviceScalesType::
    YScale () const
    {
      return this->YScale_.get ();
    }

    CartesianMeasurementDeviceScalesType::YScale_type& CartesianMeasurementDeviceScalesType::
    YScale ()
    {
      return this->YScale_.get ();
    }

    void CartesianMeasurementDeviceScalesType::
    YScale (const YScale_type& x)
    {
      this->YScale_.set (x);
    }

    void CartesianMeasurementDeviceScalesType::
    YScale (::std::unique_ptr< YScale_type > x)
    {
      this->YScale_.set (std::move (x));
    }

    const CartesianMeasurementDeviceScalesType::ZScale_type& CartesianMeasurementDeviceScalesType::
    ZScale () const
    {
      return this->ZScale_.get ();
    }

    CartesianMeasurementDeviceScalesType::ZScale_type& CartesianMeasurementDeviceScalesType::
    ZScale ()
    {
      return this->ZScale_.get ();
    }

    void CartesianMeasurementDeviceScalesType::
    ZScale (const ZScale_type& x)
    {
      this->ZScale_.set (x);
    }

    void CartesianMeasurementDeviceScalesType::
    ZScale (::std::unique_ptr< ZScale_type > x)
    {
      this->ZScale_.set (std::move (x));
    }


    // MeasurementDeviceScaleType
    //

    const MeasurementDeviceScaleType::ScaleMaterial_optional& MeasurementDeviceScaleType::
    ScaleMaterial () const
    {
      return this->ScaleMaterial_;
    }

    MeasurementDeviceScaleType::ScaleMaterial_optional& MeasurementDeviceScaleType::
    ScaleMaterial ()
    {
      return this->ScaleMaterial_;
    }

    void MeasurementDeviceScaleType::
    ScaleMaterial (const ScaleMaterial_type& x)
    {
      this->ScaleMaterial_.set (x);
    }

    void MeasurementDeviceScaleType::
    ScaleMaterial (const ScaleMaterial_optional& x)
    {
      this->ScaleMaterial_ = x;
    }

    void MeasurementDeviceScaleType::
    ScaleMaterial (::std::unique_ptr< ScaleMaterial_type > x)
    {
      this->ScaleMaterial_.set (std::move (x));
    }

    const MeasurementDeviceScaleType::ScaleCoefficientOfExpansion_optional& MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansion () const
    {
      return this->ScaleCoefficientOfExpansion_;
    }

    MeasurementDeviceScaleType::ScaleCoefficientOfExpansion_optional& MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansion ()
    {
      return this->ScaleCoefficientOfExpansion_;
    }

    void MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_type& x)
    {
      this->ScaleCoefficientOfExpansion_.set (x);
    }

    void MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_optional& x)
    {
      this->ScaleCoefficientOfExpansion_ = x;
    }

    const MeasurementDeviceScaleType::ScaleCoefficientOfExpansionUncertainty_optional& MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansionUncertainty () const
    {
      return this->ScaleCoefficientOfExpansionUncertainty_;
    }

    MeasurementDeviceScaleType::ScaleCoefficientOfExpansionUncertainty_optional& MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansionUncertainty ()
    {
      return this->ScaleCoefficientOfExpansionUncertainty_;
    }

    void MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_type& x)
    {
      this->ScaleCoefficientOfExpansionUncertainty_.set (x);
    }

    void MeasurementDeviceScaleType::
    ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_optional& x)
    {
      this->ScaleCoefficientOfExpansionUncertainty_ = x;
    }

    const MeasurementDeviceScaleType::TypeOfScale_optional& MeasurementDeviceScaleType::
    TypeOfScale () const
    {
      return this->TypeOfScale_;
    }

    MeasurementDeviceScaleType::TypeOfScale_optional& MeasurementDeviceScaleType::
    TypeOfScale ()
    {
      return this->TypeOfScale_;
    }

    void MeasurementDeviceScaleType::
    TypeOfScale (const TypeOfScale_type& x)
    {
      this->TypeOfScale_.set (x);
    }

    void MeasurementDeviceScaleType::
    TypeOfScale (const TypeOfScale_optional& x)
    {
      this->TypeOfScale_ = x;
    }

    void MeasurementDeviceScaleType::
    TypeOfScale (::std::unique_ptr< TypeOfScale_type > x)
    {
      this->TypeOfScale_.set (std::move (x));
    }

    const MeasurementDeviceScaleType::ScaleResolution_optional& MeasurementDeviceScaleType::
    ScaleResolution () const
    {
      return this->ScaleResolution_;
    }

    MeasurementDeviceScaleType::ScaleResolution_optional& MeasurementDeviceScaleType::
    ScaleResolution ()
    {
      return this->ScaleResolution_;
    }

    void MeasurementDeviceScaleType::
    ScaleResolution (const ScaleResolution_type& x)
    {
      this->ScaleResolution_.set (x);
    }

    void MeasurementDeviceScaleType::
    ScaleResolution (const ScaleResolution_optional& x)
    {
      this->ScaleResolution_ = x;
    }

    void MeasurementDeviceScaleType::
    ScaleResolution (::std::unique_ptr< ScaleResolution_type > x)
    {
      this->ScaleResolution_.set (std::move (x));
    }

    const MeasurementDeviceScaleType::ScaleReference_optional& MeasurementDeviceScaleType::
    ScaleReference () const
    {
      return this->ScaleReference_;
    }

    MeasurementDeviceScaleType::ScaleReference_optional& MeasurementDeviceScaleType::
    ScaleReference ()
    {
      return this->ScaleReference_;
    }

    void MeasurementDeviceScaleType::
    ScaleReference (const ScaleReference_type& x)
    {
      this->ScaleReference_.set (x);
    }

    void MeasurementDeviceScaleType::
    ScaleReference (const ScaleReference_optional& x)
    {
      this->ScaleReference_ = x;
    }

    void MeasurementDeviceScaleType::
    ScaleReference (::std::unique_ptr< ScaleReference_type > x)
    {
      this->ScaleReference_.set (std::move (x));
    }


    // ScaleReferenceEnumType
    //

    ScaleReferenceEnumType::
    ScaleReferenceEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ScaleReferenceEnumType_literals_[v])
    {
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const ScaleReferenceEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ScaleReferenceEnumType& ScaleReferenceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ScaleReferenceEnumType_literals_[v]);

      return *this;
    }


    // TypeOfScaleEnumType
    //

    TypeOfScaleEnumType::
    TypeOfScaleEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_TypeOfScaleEnumType_literals_[v])
    {
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const TypeOfScaleEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    TypeOfScaleEnumType& TypeOfScaleEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_TypeOfScaleEnumType_literals_[v]);

      return *this;
    }


    // TypeOfScaleType
    //

    const TypeOfScaleType::TypeOfScaleEnum_optional& TypeOfScaleType::
    TypeOfScaleEnum () const
    {
      return this->TypeOfScaleEnum_;
    }

    TypeOfScaleType::TypeOfScaleEnum_optional& TypeOfScaleType::
    TypeOfScaleEnum ()
    {
      return this->TypeOfScaleEnum_;
    }

    void TypeOfScaleType::
    TypeOfScaleEnum (const TypeOfScaleEnum_type& x)
    {
      this->TypeOfScaleEnum_.set (x);
    }

    void TypeOfScaleType::
    TypeOfScaleEnum (const TypeOfScaleEnum_optional& x)
    {
      this->TypeOfScaleEnum_ = x;
    }

    void TypeOfScaleType::
    TypeOfScaleEnum (::std::unique_ptr< TypeOfScaleEnum_type > x)
    {
      this->TypeOfScaleEnum_.set (std::move (x));
    }

    const TypeOfScaleType::OtherTypeOfScale_optional& TypeOfScaleType::
    OtherTypeOfScale () const
    {
      return this->OtherTypeOfScale_;
    }

    TypeOfScaleType::OtherTypeOfScale_optional& TypeOfScaleType::
    OtherTypeOfScale ()
    {
      return this->OtherTypeOfScale_;
    }

    void TypeOfScaleType::
    OtherTypeOfScale (const OtherTypeOfScale_type& x)
    {
      this->OtherTypeOfScale_.set (x);
    }

    void TypeOfScaleType::
    OtherTypeOfScale (const OtherTypeOfScale_optional& x)
    {
      this->OtherTypeOfScale_ = x;
    }

    void TypeOfScaleType::
    OtherTypeOfScale (::std::unique_ptr< OtherTypeOfScale_type > x)
    {
      this->OtherTypeOfScale_.set (std::move (x));
    }


    // CMMSpeedsBaseType
    //


    // CartesianCMMSpeedsType
    //

    const CartesianCMMSpeedsType::MaxXTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxXTraverseSpeed () const
    {
      return this->MaxXTraverseSpeed_;
    }

    CartesianCMMSpeedsType::MaxXTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxXTraverseSpeed ()
    {
      return this->MaxXTraverseSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_optional& x)
    {
      this->MaxXTraverseSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxXTraverseSpeed (::std::unique_ptr< MaxXTraverseSpeed_type > x)
    {
      this->MaxXTraverseSpeed_.set (std::move (x));
    }

    const CartesianCMMSpeedsType::MaxYTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxYTraverseSpeed () const
    {
      return this->MaxYTraverseSpeed_;
    }

    CartesianCMMSpeedsType::MaxYTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxYTraverseSpeed ()
    {
      return this->MaxYTraverseSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_optional& x)
    {
      this->MaxYTraverseSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxYTraverseSpeed (::std::unique_ptr< MaxYTraverseSpeed_type > x)
    {
      this->MaxYTraverseSpeed_.set (std::move (x));
    }

    const CartesianCMMSpeedsType::MaxZTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxZTraverseSpeed () const
    {
      return this->MaxZTraverseSpeed_;
    }

    CartesianCMMSpeedsType::MaxZTraverseSpeed_optional& CartesianCMMSpeedsType::
    MaxZTraverseSpeed ()
    {
      return this->MaxZTraverseSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_optional& x)
    {
      this->MaxZTraverseSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxZTraverseSpeed (::std::unique_ptr< MaxZTraverseSpeed_type > x)
    {
      this->MaxZTraverseSpeed_.set (std::move (x));
    }

    const CartesianCMMSpeedsType::MaxXProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxXProbingSpeed () const
    {
      return this->MaxXProbingSpeed_;
    }

    CartesianCMMSpeedsType::MaxXProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxXProbingSpeed ()
    {
      return this->MaxXProbingSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_type& x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_optional& x)
    {
      this->MaxXProbingSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxXProbingSpeed (::std::unique_ptr< MaxXProbingSpeed_type > x)
    {
      this->MaxXProbingSpeed_.set (std::move (x));
    }

    const CartesianCMMSpeedsType::MaxYProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxYProbingSpeed () const
    {
      return this->MaxYProbingSpeed_;
    }

    CartesianCMMSpeedsType::MaxYProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxYProbingSpeed ()
    {
      return this->MaxYProbingSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_type& x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_optional& x)
    {
      this->MaxYProbingSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxYProbingSpeed (::std::unique_ptr< MaxYProbingSpeed_type > x)
    {
      this->MaxYProbingSpeed_.set (std::move (x));
    }

    const CartesianCMMSpeedsType::MaxZProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxZProbingSpeed () const
    {
      return this->MaxZProbingSpeed_;
    }

    CartesianCMMSpeedsType::MaxZProbingSpeed_optional& CartesianCMMSpeedsType::
    MaxZProbingSpeed ()
    {
      return this->MaxZProbingSpeed_;
    }

    void CartesianCMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_type& x)
    {
      this->MaxZProbingSpeed_.set (x);
    }

    void CartesianCMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_optional& x)
    {
      this->MaxZProbingSpeed_ = x;
    }

    void CartesianCMMSpeedsType::
    MaxZProbingSpeed (::std::unique_ptr< MaxZProbingSpeed_type > x)
    {
      this->MaxZProbingSpeed_.set (std::move (x));
    }


    // ParallelLinkCMMSpeedsType
    //

    const ParallelLinkCMMSpeedsType::MaxXTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxXTraverseSpeed () const
    {
      return this->MaxXTraverseSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxXTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxXTraverseSpeed ()
    {
      return this->MaxXTraverseSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_optional& x)
    {
      this->MaxXTraverseSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXTraverseSpeed (::std::unique_ptr< MaxXTraverseSpeed_type > x)
    {
      this->MaxXTraverseSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxYTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxYTraverseSpeed () const
    {
      return this->MaxYTraverseSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxYTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxYTraverseSpeed ()
    {
      return this->MaxYTraverseSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_optional& x)
    {
      this->MaxYTraverseSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYTraverseSpeed (::std::unique_ptr< MaxYTraverseSpeed_type > x)
    {
      this->MaxYTraverseSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxZTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxZTraverseSpeed () const
    {
      return this->MaxZTraverseSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxZTraverseSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxZTraverseSpeed ()
    {
      return this->MaxZTraverseSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_optional& x)
    {
      this->MaxZTraverseSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZTraverseSpeed (::std::unique_ptr< MaxZTraverseSpeed_type > x)
    {
      this->MaxZTraverseSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxXProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxXProbingSpeed () const
    {
      return this->MaxXProbingSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxXProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxXProbingSpeed ()
    {
      return this->MaxXProbingSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_type& x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_optional& x)
    {
      this->MaxXProbingSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXProbingSpeed (::std::unique_ptr< MaxXProbingSpeed_type > x)
    {
      this->MaxXProbingSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxYProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxYProbingSpeed () const
    {
      return this->MaxYProbingSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxYProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxYProbingSpeed ()
    {
      return this->MaxYProbingSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_type& x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_optional& x)
    {
      this->MaxYProbingSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYProbingSpeed (::std::unique_ptr< MaxYProbingSpeed_type > x)
    {
      this->MaxYProbingSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxZProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxZProbingSpeed () const
    {
      return this->MaxZProbingSpeed_;
    }

    ParallelLinkCMMSpeedsType::MaxZProbingSpeed_optional& ParallelLinkCMMSpeedsType::
    MaxZProbingSpeed ()
    {
      return this->MaxZProbingSpeed_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_type& x)
    {
      this->MaxZProbingSpeed_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_optional& x)
    {
      this->MaxZProbingSpeed_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZProbingSpeed (::std::unique_ptr< MaxZProbingSpeed_type > x)
    {
      this->MaxZProbingSpeed_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxXRotation_optional& ParallelLinkCMMSpeedsType::
    MaxXRotation () const
    {
      return this->MaxXRotation_;
    }

    ParallelLinkCMMSpeedsType::MaxXRotation_optional& ParallelLinkCMMSpeedsType::
    MaxXRotation ()
    {
      return this->MaxXRotation_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXRotation (const MaxXRotation_type& x)
    {
      this->MaxXRotation_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxXRotation (const MaxXRotation_optional& x)
    {
      this->MaxXRotation_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxXRotation (::std::unique_ptr< MaxXRotation_type > x)
    {
      this->MaxXRotation_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxYRotation_optional& ParallelLinkCMMSpeedsType::
    MaxYRotation () const
    {
      return this->MaxYRotation_;
    }

    ParallelLinkCMMSpeedsType::MaxYRotation_optional& ParallelLinkCMMSpeedsType::
    MaxYRotation ()
    {
      return this->MaxYRotation_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYRotation (const MaxYRotation_type& x)
    {
      this->MaxYRotation_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxYRotation (const MaxYRotation_optional& x)
    {
      this->MaxYRotation_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxYRotation (::std::unique_ptr< MaxYRotation_type > x)
    {
      this->MaxYRotation_.set (std::move (x));
    }

    const ParallelLinkCMMSpeedsType::MaxZRotation_optional& ParallelLinkCMMSpeedsType::
    MaxZRotation () const
    {
      return this->MaxZRotation_;
    }

    ParallelLinkCMMSpeedsType::MaxZRotation_optional& ParallelLinkCMMSpeedsType::
    MaxZRotation ()
    {
      return this->MaxZRotation_;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZRotation (const MaxZRotation_type& x)
    {
      this->MaxZRotation_.set (x);
    }

    void ParallelLinkCMMSpeedsType::
    MaxZRotation (const MaxZRotation_optional& x)
    {
      this->MaxZRotation_ = x;
    }

    void ParallelLinkCMMSpeedsType::
    MaxZRotation (::std::unique_ptr< MaxZRotation_type > x)
    {
      this->MaxZRotation_.set (std::move (x));
    }


    // FunctionDiscreteType
    //

    const FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues () const
    {
      return this->DomainValues_.get ();
    }

    FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues ()
    {
      return this->DomainValues_.get ();
    }

    void FunctionDiscreteType::
    DomainValues (const DomainValues_type& x)
    {
      this->DomainValues_.set (x);
    }

    void FunctionDiscreteType::
    DomainValues (::std::unique_ptr< DomainValues_type > x)
    {
      this->DomainValues_.set (std::move (x));
    }

    const FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues () const
    {
      return this->RangeValues_.get ();
    }

    FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues ()
    {
      return this->RangeValues_.get ();
    }

    void FunctionDiscreteType::
    RangeValues (const RangeValues_type& x)
    {
      this->RangeValues_.set (x);
    }

    void FunctionDiscreteType::
    RangeValues (::std::unique_ptr< RangeValues_type > x)
    {
      this->RangeValues_.set (std::move (x));
    }

    const FunctionDiscreteType::n_type& FunctionDiscreteType::
    n () const
    {
      return this->n_.get ();
    }

    FunctionDiscreteType::n_type& FunctionDiscreteType::
    n ()
    {
      return this->n_.get ();
    }

    void FunctionDiscreteType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FunctionDiscreteType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LengthFunctionDiscreteType
    //

    const LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (::std::unique_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (std::move (x));
    }

    const LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit () const
    {
      return this->RangeLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit ()
    {
      return this->RangeLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (const RangeLinearUnit_type& x)
    {
      this->RangeLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (::std::unique_ptr< RangeLinearUnit_type > x)
    {
      this->RangeLinearUnit_.set (std::move (x));
    }


    // AngleFunctionDiscreteType
    //

    const AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (::std::unique_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (std::move (x));
    }

    const AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit () const
    {
      return this->RangeAngularUnit_.get ();
    }

    AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit ()
    {
      return this->RangeAngularUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (const RangeAngularUnit_type& x)
    {
      this->RangeAngularUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (::std::unique_ptr< RangeAngularUnit_type > x)
    {
      this->RangeAngularUnit_.set (std::move (x));
    }


    // MeasurementDeviceAccuracyBaseType
    //

    const MeasurementDeviceAccuracyBaseType::EnvironmentalRange_type& MeasurementDeviceAccuracyBaseType::
    EnvironmentalRange () const
    {
      return this->EnvironmentalRange_.get ();
    }

    MeasurementDeviceAccuracyBaseType::EnvironmentalRange_type& MeasurementDeviceAccuracyBaseType::
    EnvironmentalRange ()
    {
      return this->EnvironmentalRange_.get ();
    }

    void MeasurementDeviceAccuracyBaseType::
    EnvironmentalRange (const EnvironmentalRange_type& x)
    {
      this->EnvironmentalRange_.set (x);
    }

    void MeasurementDeviceAccuracyBaseType::
    EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > x)
    {
      this->EnvironmentalRange_.set (std::move (x));
    }


    // NumericalLengthAccuracyType
    //

    const NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue () const
    {
      return this->AccuracyValue_.get ();
    }

    NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue ()
    {
      return this->AccuracyValue_.get ();
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (const AccuracyValue_type& x)
    {
      this->AccuracyValue_.set (x);
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (::std::unique_ptr< AccuracyValue_type > x)
    {
      this->AccuracyValue_.set (std::move (x));
    }


    // EnvironmentalRangeType
    //

    const EnvironmentalRangeType::Name_optional& EnvironmentalRangeType::
    Name () const
    {
      return this->Name_;
    }

    EnvironmentalRangeType::Name_optional& EnvironmentalRangeType::
    Name ()
    {
      return this->Name_;
    }

    void EnvironmentalRangeType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void EnvironmentalRangeType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void EnvironmentalRangeType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const EnvironmentalRangeType::Description_optional& EnvironmentalRangeType::
    Description () const
    {
      return this->Description_;
    }

    EnvironmentalRangeType::Description_optional& EnvironmentalRangeType::
    Description ()
    {
      return this->Description_;
    }

    void EnvironmentalRangeType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void EnvironmentalRangeType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void EnvironmentalRangeType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const EnvironmentalRangeType::MaxAmbientTemperature_optional& EnvironmentalRangeType::
    MaxAmbientTemperature () const
    {
      return this->MaxAmbientTemperature_;
    }

    EnvironmentalRangeType::MaxAmbientTemperature_optional& EnvironmentalRangeType::
    MaxAmbientTemperature ()
    {
      return this->MaxAmbientTemperature_;
    }

    void EnvironmentalRangeType::
    MaxAmbientTemperature (const MaxAmbientTemperature_type& x)
    {
      this->MaxAmbientTemperature_.set (x);
    }

    void EnvironmentalRangeType::
    MaxAmbientTemperature (const MaxAmbientTemperature_optional& x)
    {
      this->MaxAmbientTemperature_ = x;
    }

    void EnvironmentalRangeType::
    MaxAmbientTemperature (::std::unique_ptr< MaxAmbientTemperature_type > x)
    {
      this->MaxAmbientTemperature_.set (std::move (x));
    }

    const EnvironmentalRangeType::MinAmbientTemperature_optional& EnvironmentalRangeType::
    MinAmbientTemperature () const
    {
      return this->MinAmbientTemperature_;
    }

    EnvironmentalRangeType::MinAmbientTemperature_optional& EnvironmentalRangeType::
    MinAmbientTemperature ()
    {
      return this->MinAmbientTemperature_;
    }

    void EnvironmentalRangeType::
    MinAmbientTemperature (const MinAmbientTemperature_type& x)
    {
      this->MinAmbientTemperature_.set (x);
    }

    void EnvironmentalRangeType::
    MinAmbientTemperature (const MinAmbientTemperature_optional& x)
    {
      this->MinAmbientTemperature_ = x;
    }

    void EnvironmentalRangeType::
    MinAmbientTemperature (::std::unique_ptr< MinAmbientTemperature_type > x)
    {
      this->MinAmbientTemperature_.set (std::move (x));
    }

    const EnvironmentalRangeType::MaxAmbientAirPressure_optional& EnvironmentalRangeType::
    MaxAmbientAirPressure () const
    {
      return this->MaxAmbientAirPressure_;
    }

    EnvironmentalRangeType::MaxAmbientAirPressure_optional& EnvironmentalRangeType::
    MaxAmbientAirPressure ()
    {
      return this->MaxAmbientAirPressure_;
    }

    void EnvironmentalRangeType::
    MaxAmbientAirPressure (const MaxAmbientAirPressure_type& x)
    {
      this->MaxAmbientAirPressure_.set (x);
    }

    void EnvironmentalRangeType::
    MaxAmbientAirPressure (const MaxAmbientAirPressure_optional& x)
    {
      this->MaxAmbientAirPressure_ = x;
    }

    void EnvironmentalRangeType::
    MaxAmbientAirPressure (::std::unique_ptr< MaxAmbientAirPressure_type > x)
    {
      this->MaxAmbientAirPressure_.set (std::move (x));
    }

    const EnvironmentalRangeType::MinAmbientAirPressure_optional& EnvironmentalRangeType::
    MinAmbientAirPressure () const
    {
      return this->MinAmbientAirPressure_;
    }

    EnvironmentalRangeType::MinAmbientAirPressure_optional& EnvironmentalRangeType::
    MinAmbientAirPressure ()
    {
      return this->MinAmbientAirPressure_;
    }

    void EnvironmentalRangeType::
    MinAmbientAirPressure (const MinAmbientAirPressure_type& x)
    {
      this->MinAmbientAirPressure_.set (x);
    }

    void EnvironmentalRangeType::
    MinAmbientAirPressure (const MinAmbientAirPressure_optional& x)
    {
      this->MinAmbientAirPressure_ = x;
    }

    void EnvironmentalRangeType::
    MinAmbientAirPressure (::std::unique_ptr< MinAmbientAirPressure_type > x)
    {
      this->MinAmbientAirPressure_.set (std::move (x));
    }

    const EnvironmentalRangeType::MaxAmbientRelativeHumidity_optional& EnvironmentalRangeType::
    MaxAmbientRelativeHumidity () const
    {
      return this->MaxAmbientRelativeHumidity_;
    }

    EnvironmentalRangeType::MaxAmbientRelativeHumidity_optional& EnvironmentalRangeType::
    MaxAmbientRelativeHumidity ()
    {
      return this->MaxAmbientRelativeHumidity_;
    }

    void EnvironmentalRangeType::
    MaxAmbientRelativeHumidity (const MaxAmbientRelativeHumidity_type& x)
    {
      this->MaxAmbientRelativeHumidity_.set (x);
    }

    void EnvironmentalRangeType::
    MaxAmbientRelativeHumidity (const MaxAmbientRelativeHumidity_optional& x)
    {
      this->MaxAmbientRelativeHumidity_ = x;
    }

    void EnvironmentalRangeType::
    MaxAmbientRelativeHumidity (::std::unique_ptr< MaxAmbientRelativeHumidity_type > x)
    {
      this->MaxAmbientRelativeHumidity_.set (std::move (x));
    }

    const EnvironmentalRangeType::MinAmbientRelativeHumidity_optional& EnvironmentalRangeType::
    MinAmbientRelativeHumidity () const
    {
      return this->MinAmbientRelativeHumidity_;
    }

    EnvironmentalRangeType::MinAmbientRelativeHumidity_optional& EnvironmentalRangeType::
    MinAmbientRelativeHumidity ()
    {
      return this->MinAmbientRelativeHumidity_;
    }

    void EnvironmentalRangeType::
    MinAmbientRelativeHumidity (const MinAmbientRelativeHumidity_type& x)
    {
      this->MinAmbientRelativeHumidity_.set (x);
    }

    void EnvironmentalRangeType::
    MinAmbientRelativeHumidity (const MinAmbientRelativeHumidity_optional& x)
    {
      this->MinAmbientRelativeHumidity_ = x;
    }

    void EnvironmentalRangeType::
    MinAmbientRelativeHumidity (::std::unique_ptr< MinAmbientRelativeHumidity_type > x)
    {
      this->MinAmbientRelativeHumidity_.set (std::move (x));
    }

    const EnvironmentalRangeType::MaxVibration_optional& EnvironmentalRangeType::
    MaxVibration () const
    {
      return this->MaxVibration_;
    }

    EnvironmentalRangeType::MaxVibration_optional& EnvironmentalRangeType::
    MaxVibration ()
    {
      return this->MaxVibration_;
    }

    void EnvironmentalRangeType::
    MaxVibration (const MaxVibration_type& x)
    {
      this->MaxVibration_.set (x);
    }

    void EnvironmentalRangeType::
    MaxVibration (const MaxVibration_optional& x)
    {
      this->MaxVibration_ = x;
    }

    void EnvironmentalRangeType::
    MaxVibration (::std::unique_ptr< MaxVibration_type > x)
    {
      this->MaxVibration_.set (std::move (x));
    }

    const EnvironmentalRangeType::Attributes_optional& EnvironmentalRangeType::
    Attributes () const
    {
      return this->Attributes_;
    }

    EnvironmentalRangeType::Attributes_optional& EnvironmentalRangeType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void EnvironmentalRangeType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void EnvironmentalRangeType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void EnvironmentalRangeType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // CartesianCMMAccuracyType
    //

    const CartesianCMMAccuracyType::CartesianCMMAccuracyTest_type& CartesianCMMAccuracyType::
    CartesianCMMAccuracyTest () const
    {
      return this->CartesianCMMAccuracyTest_.get ();
    }

    CartesianCMMAccuracyType::CartesianCMMAccuracyTest_type& CartesianCMMAccuracyType::
    CartesianCMMAccuracyTest ()
    {
      return this->CartesianCMMAccuracyTest_.get ();
    }

    void CartesianCMMAccuracyType::
    CartesianCMMAccuracyTest (const CartesianCMMAccuracyTest_type& x)
    {
      this->CartesianCMMAccuracyTest_.set (x);
    }

    void CartesianCMMAccuracyType::
    CartesianCMMAccuracyTest (::std::unique_ptr< CartesianCMMAccuracyTest_type > x)
    {
      this->CartesianCMMAccuracyTest_.set (std::move (x));
    }

    const CartesianCMMAccuracyType::AccuracySource_type& CartesianCMMAccuracyType::
    AccuracySource () const
    {
      return this->AccuracySource_.get ();
    }

    CartesianCMMAccuracyType::AccuracySource_type& CartesianCMMAccuracyType::
    AccuracySource ()
    {
      return this->AccuracySource_.get ();
    }

    void CartesianCMMAccuracyType::
    AccuracySource (const AccuracySource_type& x)
    {
      this->AccuracySource_.set (x);
    }

    void CartesianCMMAccuracyType::
    AccuracySource (::std::unique_ptr< AccuracySource_type > x)
    {
      this->AccuracySource_.set (std::move (x));
    }


    // AACMMAccuracyType
    //

    const AACMMAccuracyType::AACMMAccuracyTest_type& AACMMAccuracyType::
    AACMMAccuracyTest () const
    {
      return this->AACMMAccuracyTest_.get ();
    }

    AACMMAccuracyType::AACMMAccuracyTest_type& AACMMAccuracyType::
    AACMMAccuracyTest ()
    {
      return this->AACMMAccuracyTest_.get ();
    }

    void AACMMAccuracyType::
    AACMMAccuracyTest (const AACMMAccuracyTest_type& x)
    {
      this->AACMMAccuracyTest_.set (x);
    }

    void AACMMAccuracyType::
    AACMMAccuracyTest (::std::unique_ptr< AACMMAccuracyTest_type > x)
    {
      this->AACMMAccuracyTest_.set (std::move (x));
    }

    const AACMMAccuracyType::AccuracySource_type& AACMMAccuracyType::
    AccuracySource () const
    {
      return this->AccuracySource_.get ();
    }

    AACMMAccuracyType::AccuracySource_type& AACMMAccuracyType::
    AccuracySource ()
    {
      return this->AccuracySource_.get ();
    }

    void AACMMAccuracyType::
    AccuracySource (const AccuracySource_type& x)
    {
      this->AccuracySource_.set (x);
    }

    void AACMMAccuracyType::
    AccuracySource (::std::unique_ptr< AccuracySource_type > x)
    {
      this->AccuracySource_.set (std::move (x));
    }


    // CartesianCMMAccuraciesType
    //

    const CartesianCMMAccuraciesType::CartesianCMMAccuracy_sequence& CartesianCMMAccuraciesType::
    CartesianCMMAccuracy () const
    {
      return this->CartesianCMMAccuracy_;
    }

    CartesianCMMAccuraciesType::CartesianCMMAccuracy_sequence& CartesianCMMAccuraciesType::
    CartesianCMMAccuracy ()
    {
      return this->CartesianCMMAccuracy_;
    }

    void CartesianCMMAccuraciesType::
    CartesianCMMAccuracy (const CartesianCMMAccuracy_sequence& s)
    {
      this->CartesianCMMAccuracy_ = s;
    }

    const CartesianCMMAccuraciesType::n_type& CartesianCMMAccuraciesType::
    n () const
    {
      return this->n_.get ();
    }

    CartesianCMMAccuraciesType::n_type& CartesianCMMAccuraciesType::
    n ()
    {
      return this->n_.get ();
    }

    void CartesianCMMAccuraciesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CartesianCMMAccuraciesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AACMMAccuraciesType
    //

    const AACMMAccuraciesType::AACMMAccuracy_sequence& AACMMAccuraciesType::
    AACMMAccuracy () const
    {
      return this->AACMMAccuracy_;
    }

    AACMMAccuraciesType::AACMMAccuracy_sequence& AACMMAccuraciesType::
    AACMMAccuracy ()
    {
      return this->AACMMAccuracy_;
    }

    void AACMMAccuraciesType::
    AACMMAccuracy (const AACMMAccuracy_sequence& s)
    {
      this->AACMMAccuracy_ = s;
    }

    const AACMMAccuraciesType::n_type& AACMMAccuraciesType::
    n () const
    {
      return this->n_.get ();
    }

    AACMMAccuraciesType::n_type& AACMMAccuraciesType::
    n ()
    {
      return this->n_.get ();
    }

    void AACMMAccuraciesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AACMMAccuraciesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AccuracySourceType
    //

    const AccuracySourceType::AccuracySourceEnum_optional& AccuracySourceType::
    AccuracySourceEnum () const
    {
      return this->AccuracySourceEnum_;
    }

    AccuracySourceType::AccuracySourceEnum_optional& AccuracySourceType::
    AccuracySourceEnum ()
    {
      return this->AccuracySourceEnum_;
    }

    void AccuracySourceType::
    AccuracySourceEnum (const AccuracySourceEnum_type& x)
    {
      this->AccuracySourceEnum_.set (x);
    }

    void AccuracySourceType::
    AccuracySourceEnum (const AccuracySourceEnum_optional& x)
    {
      this->AccuracySourceEnum_ = x;
    }

    void AccuracySourceType::
    AccuracySourceEnum (::std::unique_ptr< AccuracySourceEnum_type > x)
    {
      this->AccuracySourceEnum_.set (std::move (x));
    }

    const AccuracySourceType::OtherAccuracySource_optional& AccuracySourceType::
    OtherAccuracySource () const
    {
      return this->OtherAccuracySource_;
    }

    AccuracySourceType::OtherAccuracySource_optional& AccuracySourceType::
    OtherAccuracySource ()
    {
      return this->OtherAccuracySource_;
    }

    void AccuracySourceType::
    OtherAccuracySource (const OtherAccuracySource_type& x)
    {
      this->OtherAccuracySource_.set (x);
    }

    void AccuracySourceType::
    OtherAccuracySource (const OtherAccuracySource_optional& x)
    {
      this->OtherAccuracySource_ = x;
    }

    void AccuracySourceType::
    OtherAccuracySource (::std::unique_ptr< OtherAccuracySource_type > x)
    {
      this->OtherAccuracySource_.set (std::move (x));
    }


    // AccuracySourceEnumType
    //

    AccuracySourceEnumType::
    AccuracySourceEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AccuracySourceEnumType_literals_[v])
    {
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const AccuracySourceEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AccuracySourceEnumType& AccuracySourceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AccuracySourceEnumType_literals_[v]);

      return *this;
    }


    // CMMAccuracyTestBaseType
    //


    // FPSTestType
    //

    const FPSTestType::XLinearity_type& FPSTestType::
    XLinearity () const
    {
      return this->XLinearity_.get ();
    }

    FPSTestType::XLinearity_type& FPSTestType::
    XLinearity ()
    {
      return this->XLinearity_.get ();
    }

    void FPSTestType::
    XLinearity (const XLinearity_type& x)
    {
      this->XLinearity_.set (x);
    }

    void FPSTestType::
    XLinearity (::std::unique_ptr< XLinearity_type > x)
    {
      this->XLinearity_.set (std::move (x));
    }

    const FPSTestType::YLinearity_type& FPSTestType::
    YLinearity () const
    {
      return this->YLinearity_.get ();
    }

    FPSTestType::YLinearity_type& FPSTestType::
    YLinearity ()
    {
      return this->YLinearity_.get ();
    }

    void FPSTestType::
    YLinearity (const YLinearity_type& x)
    {
      this->YLinearity_.set (x);
    }

    void FPSTestType::
    YLinearity (::std::unique_ptr< YLinearity_type > x)
    {
      this->YLinearity_.set (std::move (x));
    }

    const FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity () const
    {
      return this->ZLinearity_.get ();
    }

    FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity ()
    {
      return this->ZLinearity_.get ();
    }

    void FPSTestType::
    ZLinearity (const ZLinearity_type& x)
    {
      this->ZLinearity_.set (x);
    }

    void FPSTestType::
    ZLinearity (::std::unique_ptr< ZLinearity_type > x)
    {
      this->ZLinearity_.set (std::move (x));
    }

    const FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll () const
    {
      return this->XAxisRoll_.get ();
    }

    FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll ()
    {
      return this->XAxisRoll_.get ();
    }

    void FPSTestType::
    XAxisRoll (const XAxisRoll_type& x)
    {
      this->XAxisRoll_.set (x);
    }

    void FPSTestType::
    XAxisRoll (::std::unique_ptr< XAxisRoll_type > x)
    {
      this->XAxisRoll_.set (std::move (x));
    }

    const FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch () const
    {
      return this->XAxisPitch_.get ();
    }

    FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch ()
    {
      return this->XAxisPitch_.get ();
    }

    void FPSTestType::
    XAxisPitch (const XAxisPitch_type& x)
    {
      this->XAxisPitch_.set (x);
    }

    void FPSTestType::
    XAxisPitch (::std::unique_ptr< XAxisPitch_type > x)
    {
      this->XAxisPitch_.set (std::move (x));
    }

    const FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw () const
    {
      return this->XAxisYaw_.get ();
    }

    FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw ()
    {
      return this->XAxisYaw_.get ();
    }

    void FPSTestType::
    XAxisYaw (const XAxisYaw_type& x)
    {
      this->XAxisYaw_.set (x);
    }

    void FPSTestType::
    XAxisYaw (::std::unique_ptr< XAxisYaw_type > x)
    {
      this->XAxisYaw_.set (std::move (x));
    }

    const FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll () const
    {
      return this->YAxisRoll_.get ();
    }

    FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll ()
    {
      return this->YAxisRoll_.get ();
    }

    void FPSTestType::
    YAxisRoll (const YAxisRoll_type& x)
    {
      this->YAxisRoll_.set (x);
    }

    void FPSTestType::
    YAxisRoll (::std::unique_ptr< YAxisRoll_type > x)
    {
      this->YAxisRoll_.set (std::move (x));
    }

    const FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch () const
    {
      return this->YAxisPitch_.get ();
    }

    FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch ()
    {
      return this->YAxisPitch_.get ();
    }

    void FPSTestType::
    YAxisPitch (const YAxisPitch_type& x)
    {
      this->YAxisPitch_.set (x);
    }

    void FPSTestType::
    YAxisPitch (::std::unique_ptr< YAxisPitch_type > x)
    {
      this->YAxisPitch_.set (std::move (x));
    }

    const FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw () const
    {
      return this->YAxisYaw_.get ();
    }

    FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw ()
    {
      return this->YAxisYaw_.get ();
    }

    void FPSTestType::
    YAxisYaw (const YAxisYaw_type& x)
    {
      this->YAxisYaw_.set (x);
    }

    void FPSTestType::
    YAxisYaw (::std::unique_ptr< YAxisYaw_type > x)
    {
      this->YAxisYaw_.set (std::move (x));
    }

    const FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll () const
    {
      return this->ZAxisRoll_.get ();
    }

    FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll ()
    {
      return this->ZAxisRoll_.get ();
    }

    void FPSTestType::
    ZAxisRoll (const ZAxisRoll_type& x)
    {
      this->ZAxisRoll_.set (x);
    }

    void FPSTestType::
    ZAxisRoll (::std::unique_ptr< ZAxisRoll_type > x)
    {
      this->ZAxisRoll_.set (std::move (x));
    }

    const FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch () const
    {
      return this->ZAxisPitch_.get ();
    }

    FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch ()
    {
      return this->ZAxisPitch_.get ();
    }

    void FPSTestType::
    ZAxisPitch (const ZAxisPitch_type& x)
    {
      this->ZAxisPitch_.set (x);
    }

    void FPSTestType::
    ZAxisPitch (::std::unique_ptr< ZAxisPitch_type > x)
    {
      this->ZAxisPitch_.set (std::move (x));
    }

    const FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw () const
    {
      return this->ZAxisYaw_.get ();
    }

    FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw ()
    {
      return this->ZAxisYaw_.get ();
    }

    void FPSTestType::
    ZAxisYaw (const ZAxisYaw_type& x)
    {
      this->ZAxisYaw_.set (x);
    }

    void FPSTestType::
    ZAxisYaw (::std::unique_ptr< ZAxisYaw_type > x)
    {
      this->ZAxisYaw_.set (std::move (x));
    }

    const FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY () const
    {
      return this->XAxisStraightnessY_.get ();
    }

    FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY ()
    {
      return this->XAxisStraightnessY_.get ();
    }

    void FPSTestType::
    XAxisStraightnessY (const XAxisStraightnessY_type& x)
    {
      this->XAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessY (::std::unique_ptr< XAxisStraightnessY_type > x)
    {
      this->XAxisStraightnessY_.set (std::move (x));
    }

    const FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ () const
    {
      return this->XAxisStraightnessZ_.get ();
    }

    FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ ()
    {
      return this->XAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    XAxisStraightnessZ (const XAxisStraightnessZ_type& x)
    {
      this->XAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessZ (::std::unique_ptr< XAxisStraightnessZ_type > x)
    {
      this->XAxisStraightnessZ_.set (std::move (x));
    }

    const FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX () const
    {
      return this->YAxisStraightnessX_.get ();
    }

    FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX ()
    {
      return this->YAxisStraightnessX_.get ();
    }

    void FPSTestType::
    YAxisStraightnessX (const YAxisStraightnessX_type& x)
    {
      this->YAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessX (::std::unique_ptr< YAxisStraightnessX_type > x)
    {
      this->YAxisStraightnessX_.set (std::move (x));
    }

    const FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ () const
    {
      return this->YAxisStraightnessZ_.get ();
    }

    FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ ()
    {
      return this->YAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    YAxisStraightnessZ (const YAxisStraightnessZ_type& x)
    {
      this->YAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessZ (::std::unique_ptr< YAxisStraightnessZ_type > x)
    {
      this->YAxisStraightnessZ_.set (std::move (x));
    }

    const FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX () const
    {
      return this->ZAxisStraightnessX_.get ();
    }

    FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX ()
    {
      return this->ZAxisStraightnessX_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessX (const ZAxisStraightnessX_type& x)
    {
      this->ZAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessX (::std::unique_ptr< ZAxisStraightnessX_type > x)
    {
      this->ZAxisStraightnessX_.set (std::move (x));
    }

    const FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY () const
    {
      return this->ZAxisStraightnessY_.get ();
    }

    FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY ()
    {
      return this->ZAxisStraightnessY_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessY (const ZAxisStraightnessY_type& x)
    {
      this->ZAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessY (::std::unique_ptr< ZAxisStraightnessY_type > x)
    {
      this->ZAxisStraightnessY_.set (std::move (x));
    }

    const FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness () const
    {
      return this->XYSquareness_.get ();
    }

    FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness ()
    {
      return this->XYSquareness_.get ();
    }

    void FPSTestType::
    XYSquareness (const XYSquareness_type& x)
    {
      this->XYSquareness_.set (x);
    }

    const FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness () const
    {
      return this->XZSquareness_.get ();
    }

    FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness ()
    {
      return this->XZSquareness_.get ();
    }

    void FPSTestType::
    XZSquareness (const XZSquareness_type& x)
    {
      this->XZSquareness_.set (x);
    }

    const FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness () const
    {
      return this->YZSquareness_.get ();
    }

    FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness ()
    {
      return this->YZSquareness_.get ();
    }

    void FPSTestType::
    YZSquareness (const YZSquareness_type& x)
    {
      this->YZSquareness_.set (x);
    }


    // CartesianCMMB89TestType
    //

    const CartesianCMMB89TestType::XLinearAccuracy_type& CartesianCMMB89TestType::
    XLinearAccuracy () const
    {
      return this->XLinearAccuracy_.get ();
    }

    CartesianCMMB89TestType::XLinearAccuracy_type& CartesianCMMB89TestType::
    XLinearAccuracy ()
    {
      return this->XLinearAccuracy_.get ();
    }

    void CartesianCMMB89TestType::
    XLinearAccuracy (const XLinearAccuracy_type& x)
    {
      this->XLinearAccuracy_.set (x);
    }

    void CartesianCMMB89TestType::
    XLinearAccuracy (::std::unique_ptr< XLinearAccuracy_type > x)
    {
      this->XLinearAccuracy_.set (std::move (x));
    }

    const CartesianCMMB89TestType::YLinearAccuracy_type& CartesianCMMB89TestType::
    YLinearAccuracy () const
    {
      return this->YLinearAccuracy_.get ();
    }

    CartesianCMMB89TestType::YLinearAccuracy_type& CartesianCMMB89TestType::
    YLinearAccuracy ()
    {
      return this->YLinearAccuracy_.get ();
    }

    void CartesianCMMB89TestType::
    YLinearAccuracy (const YLinearAccuracy_type& x)
    {
      this->YLinearAccuracy_.set (x);
    }

    void CartesianCMMB89TestType::
    YLinearAccuracy (::std::unique_ptr< YLinearAccuracy_type > x)
    {
      this->YLinearAccuracy_.set (std::move (x));
    }

    const CartesianCMMB89TestType::ZLinearAccuracy_type& CartesianCMMB89TestType::
    ZLinearAccuracy () const
    {
      return this->ZLinearAccuracy_.get ();
    }

    CartesianCMMB89TestType::ZLinearAccuracy_type& CartesianCMMB89TestType::
    ZLinearAccuracy ()
    {
      return this->ZLinearAccuracy_.get ();
    }

    void CartesianCMMB89TestType::
    ZLinearAccuracy (const ZLinearAccuracy_type& x)
    {
      this->ZLinearAccuracy_.set (x);
    }

    void CartesianCMMB89TestType::
    ZLinearAccuracy (::std::unique_ptr< ZLinearAccuracy_type > x)
    {
      this->ZLinearAccuracy_.set (std::move (x));
    }

    const CartesianCMMB89TestType::OffsetVolumetricPerformance_type& CartesianCMMB89TestType::
    OffsetVolumetricPerformance () const
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    CartesianCMMB89TestType::OffsetVolumetricPerformance_type& CartesianCMMB89TestType::
    OffsetVolumetricPerformance ()
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    void CartesianCMMB89TestType::
    OffsetVolumetricPerformance (const OffsetVolumetricPerformance_type& x)
    {
      this->OffsetVolumetricPerformance_.set (x);
    }

    void CartesianCMMB89TestType::
    OffsetVolumetricPerformance (::std::unique_ptr< OffsetVolumetricPerformance_type > x)
    {
      this->OffsetVolumetricPerformance_.set (std::move (x));
    }

    const CartesianCMMB89TestType::VolumetricPerformance_type& CartesianCMMB89TestType::
    VolumetricPerformance () const
    {
      return this->VolumetricPerformance_.get ();
    }

    CartesianCMMB89TestType::VolumetricPerformance_type& CartesianCMMB89TestType::
    VolumetricPerformance ()
    {
      return this->VolumetricPerformance_.get ();
    }

    void CartesianCMMB89TestType::
    VolumetricPerformance (const VolumetricPerformance_type& x)
    {
      this->VolumetricPerformance_.set (x);
    }

    void CartesianCMMB89TestType::
    VolumetricPerformance (::std::unique_ptr< VolumetricPerformance_type > x)
    {
      this->VolumetricPerformance_.set (std::move (x));
    }

    const CartesianCMMB89TestType::Repeatability_type& CartesianCMMB89TestType::
    Repeatability () const
    {
      return this->Repeatability_.get ();
    }

    CartesianCMMB89TestType::Repeatability_type& CartesianCMMB89TestType::
    Repeatability ()
    {
      return this->Repeatability_.get ();
    }

    void CartesianCMMB89TestType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void CartesianCMMB89TestType::
    Repeatability (::std::unique_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (std::move (x));
    }


    // AACMMB89TestType
    //

    const AACMMB89TestType::EffectiveDiameterPerformanceTest_optional& AACMMB89TestType::
    EffectiveDiameterPerformanceTest () const
    {
      return this->EffectiveDiameterPerformanceTest_;
    }

    AACMMB89TestType::EffectiveDiameterPerformanceTest_optional& AACMMB89TestType::
    EffectiveDiameterPerformanceTest ()
    {
      return this->EffectiveDiameterPerformanceTest_;
    }

    void AACMMB89TestType::
    EffectiveDiameterPerformanceTest (const EffectiveDiameterPerformanceTest_type& x)
    {
      this->EffectiveDiameterPerformanceTest_.set (x);
    }

    void AACMMB89TestType::
    EffectiveDiameterPerformanceTest (const EffectiveDiameterPerformanceTest_optional& x)
    {
      this->EffectiveDiameterPerformanceTest_ = x;
    }

    void AACMMB89TestType::
    EffectiveDiameterPerformanceTest (::std::unique_ptr< EffectiveDiameterPerformanceTest_type > x)
    {
      this->EffectiveDiameterPerformanceTest_.set (std::move (x));
    }

    const AACMMB89TestType::SinglePointArticulationPerformanceTest_optional& AACMMB89TestType::
    SinglePointArticulationPerformanceTest () const
    {
      return this->SinglePointArticulationPerformanceTest_;
    }

    AACMMB89TestType::SinglePointArticulationPerformanceTest_optional& AACMMB89TestType::
    SinglePointArticulationPerformanceTest ()
    {
      return this->SinglePointArticulationPerformanceTest_;
    }

    void AACMMB89TestType::
    SinglePointArticulationPerformanceTest (const SinglePointArticulationPerformanceTest_type& x)
    {
      this->SinglePointArticulationPerformanceTest_.set (x);
    }

    void AACMMB89TestType::
    SinglePointArticulationPerformanceTest (const SinglePointArticulationPerformanceTest_optional& x)
    {
      this->SinglePointArticulationPerformanceTest_ = x;
    }

    void AACMMB89TestType::
    SinglePointArticulationPerformanceTest (::std::unique_ptr< SinglePointArticulationPerformanceTest_type > x)
    {
      this->SinglePointArticulationPerformanceTest_.set (std::move (x));
    }

    const AACMMB89TestType::VolumetricPerformanceTest_optional& AACMMB89TestType::
    VolumetricPerformanceTest () const
    {
      return this->VolumetricPerformanceTest_;
    }

    AACMMB89TestType::VolumetricPerformanceTest_optional& AACMMB89TestType::
    VolumetricPerformanceTest ()
    {
      return this->VolumetricPerformanceTest_;
    }

    void AACMMB89TestType::
    VolumetricPerformanceTest (const VolumetricPerformanceTest_type& x)
    {
      this->VolumetricPerformanceTest_.set (x);
    }

    void AACMMB89TestType::
    VolumetricPerformanceTest (const VolumetricPerformanceTest_optional& x)
    {
      this->VolumetricPerformanceTest_ = x;
    }

    void AACMMB89TestType::
    VolumetricPerformanceTest (::std::unique_ptr< VolumetricPerformanceTest_type > x)
    {
      this->VolumetricPerformanceTest_.set (std::move (x));
    }


    // EffectiveDiameterPerformanceTestType
    //

    const EffectiveDiameterPerformanceTestType::AverageDiameter_type& EffectiveDiameterPerformanceTestType::
    AverageDiameter () const
    {
      return this->AverageDiameter_.get ();
    }

    EffectiveDiameterPerformanceTestType::AverageDiameter_type& EffectiveDiameterPerformanceTestType::
    AverageDiameter ()
    {
      return this->AverageDiameter_.get ();
    }

    void EffectiveDiameterPerformanceTestType::
    AverageDiameter (const AverageDiameter_type& x)
    {
      this->AverageDiameter_.set (x);
    }

    const EffectiveDiameterPerformanceTestType::StandardDeviation_type& EffectiveDiameterPerformanceTestType::
    StandardDeviation () const
    {
      return this->StandardDeviation_.get ();
    }

    EffectiveDiameterPerformanceTestType::StandardDeviation_type& EffectiveDiameterPerformanceTestType::
    StandardDeviation ()
    {
      return this->StandardDeviation_.get ();
    }

    void EffectiveDiameterPerformanceTestType::
    StandardDeviation (const StandardDeviation_type& x)
    {
      this->StandardDeviation_.set (x);
    }


    // SinglePointArticulationPerformanceTestType
    //

    const SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageNear_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageNear () const
    {
      return this->MaxDeviationFromAverageNear_.get ();
    }

    SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageNear_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageNear ()
    {
      return this->MaxDeviationFromAverageNear_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageNear (const MaxDeviationFromAverageNear_type& x)
    {
      this->MaxDeviationFromAverageNear_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageNear (::std::unique_ptr< MaxDeviationFromAverageNear_type > x)
    {
      this->MaxDeviationFromAverageNear_.set (std::move (x));
    }

    const SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageFar_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageFar () const
    {
      return this->MaxDeviationFromAverageFar_.get ();
    }

    SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageFar_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageFar ()
    {
      return this->MaxDeviationFromAverageFar_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageFar (const MaxDeviationFromAverageFar_type& x)
    {
      this->MaxDeviationFromAverageFar_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageFar (::std::unique_ptr< MaxDeviationFromAverageFar_type > x)
    {
      this->MaxDeviationFromAverageFar_.set (std::move (x));
    }

    const SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageMiddle_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageMiddle () const
    {
      return this->MaxDeviationFromAverageMiddle_.get ();
    }

    SinglePointArticulationPerformanceTestType::MaxDeviationFromAverageMiddle_type& SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageMiddle ()
    {
      return this->MaxDeviationFromAverageMiddle_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageMiddle (const MaxDeviationFromAverageMiddle_type& x)
    {
      this->MaxDeviationFromAverageMiddle_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    MaxDeviationFromAverageMiddle (::std::unique_ptr< MaxDeviationFromAverageMiddle_type > x)
    {
      this->MaxDeviationFromAverageMiddle_.set (std::move (x));
    }

    const SinglePointArticulationPerformanceTestType::TwiceStandardDeviationNear_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationNear () const
    {
      return this->TwiceStandardDeviationNear_.get ();
    }

    SinglePointArticulationPerformanceTestType::TwiceStandardDeviationNear_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationNear ()
    {
      return this->TwiceStandardDeviationNear_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationNear (const TwiceStandardDeviationNear_type& x)
    {
      this->TwiceStandardDeviationNear_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationNear (::std::unique_ptr< TwiceStandardDeviationNear_type > x)
    {
      this->TwiceStandardDeviationNear_.set (std::move (x));
    }

    const SinglePointArticulationPerformanceTestType::TwiceStandardDeviationFar_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationFar () const
    {
      return this->TwiceStandardDeviationFar_.get ();
    }

    SinglePointArticulationPerformanceTestType::TwiceStandardDeviationFar_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationFar ()
    {
      return this->TwiceStandardDeviationFar_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationFar (const TwiceStandardDeviationFar_type& x)
    {
      this->TwiceStandardDeviationFar_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationFar (::std::unique_ptr< TwiceStandardDeviationFar_type > x)
    {
      this->TwiceStandardDeviationFar_.set (std::move (x));
    }

    const SinglePointArticulationPerformanceTestType::TwiceStandardDeviationMiddle_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationMiddle () const
    {
      return this->TwiceStandardDeviationMiddle_.get ();
    }

    SinglePointArticulationPerformanceTestType::TwiceStandardDeviationMiddle_type& SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationMiddle ()
    {
      return this->TwiceStandardDeviationMiddle_.get ();
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationMiddle (const TwiceStandardDeviationMiddle_type& x)
    {
      this->TwiceStandardDeviationMiddle_.set (x);
    }

    void SinglePointArticulationPerformanceTestType::
    TwiceStandardDeviationMiddle (::std::unique_ptr< TwiceStandardDeviationMiddle_type > x)
    {
      this->TwiceStandardDeviationMiddle_.set (std::move (x));
    }


    // VolumetricPerformanceTestType
    //

    const VolumetricPerformanceTestType::DeviationsFromCalibration_type& VolumetricPerformanceTestType::
    DeviationsFromCalibration () const
    {
      return this->DeviationsFromCalibration_.get ();
    }

    VolumetricPerformanceTestType::DeviationsFromCalibration_type& VolumetricPerformanceTestType::
    DeviationsFromCalibration ()
    {
      return this->DeviationsFromCalibration_.get ();
    }

    void VolumetricPerformanceTestType::
    DeviationsFromCalibration (const DeviationsFromCalibration_type& x)
    {
      this->DeviationsFromCalibration_.set (x);
    }

    void VolumetricPerformanceTestType::
    DeviationsFromCalibration (::std::unique_ptr< DeviationsFromCalibration_type > x)
    {
      this->DeviationsFromCalibration_.set (std::move (x));
    }

    const VolumetricPerformanceTestType::TwiceStandardDeviation_type& VolumetricPerformanceTestType::
    TwiceStandardDeviation () const
    {
      return this->TwiceStandardDeviation_.get ();
    }

    VolumetricPerformanceTestType::TwiceStandardDeviation_type& VolumetricPerformanceTestType::
    TwiceStandardDeviation ()
    {
      return this->TwiceStandardDeviation_.get ();
    }

    void VolumetricPerformanceTestType::
    TwiceStandardDeviation (const TwiceStandardDeviation_type& x)
    {
      this->TwiceStandardDeviation_.set (x);
    }

    void VolumetricPerformanceTestType::
    TwiceStandardDeviation (::std::unique_ptr< TwiceStandardDeviation_type > x)
    {
      this->TwiceStandardDeviation_.set (std::move (x));
    }


    // TwentyLinearValuesType
    //

    const TwentyLinearValuesType::LinearValue_sequence& TwentyLinearValuesType::
    LinearValue () const
    {
      return this->LinearValue_;
    }

    TwentyLinearValuesType::LinearValue_sequence& TwentyLinearValuesType::
    LinearValue ()
    {
      return this->LinearValue_;
    }

    void TwentyLinearValuesType::
    LinearValue (const LinearValue_sequence& s)
    {
      this->LinearValue_ = s;
    }

    const TwentyLinearValuesType::n_type& TwentyLinearValuesType::
    n () const
    {
      return this->n_.get ();
    }

    TwentyLinearValuesType::n_type& TwentyLinearValuesType::
    n ()
    {
      return this->n_.get ();
    }

    void TwentyLinearValuesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TwentyLinearValuesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ISO10360TestType
    //

    const ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_;
    }

    ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_;
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_optional& x)
    {
      this->MaxErrorConstant_ = x;
    }

    void ISO10360TestType::
    MaxErrorConstant (::std::unique_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (std::move (x));
    }

    const ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError () const
    {
      return this->LinearError_;
    }

    ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError ()
    {
      return this->LinearError_;
    }

    void ISO10360TestType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void ISO10360TestType::
    LinearError (const LinearError_optional& x)
    {
      this->LinearError_ = x;
    }

    void ISO10360TestType::
    LinearError (::std::unique_ptr< LinearError_type > x)
    {
      this->LinearError_.set (std::move (x));
    }

    const ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError () const
    {
      return this->LesserError_;
    }

    ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError ()
    {
      return this->LesserError_;
    }

    void ISO10360TestType::
    LesserError (const LesserError_type& x)
    {
      this->LesserError_.set (x);
    }

    void ISO10360TestType::
    LesserError (const LesserError_optional& x)
    {
      this->LesserError_ = x;
    }

    void ISO10360TestType::
    LesserError (::std::unique_ptr< LesserError_type > x)
    {
      this->LesserError_.set (std::move (x));
    }


    // LinearErrorType
    //

    const LinearErrorType::BaseError_type& LinearErrorType::
    BaseError () const
    {
      return this->BaseError_.get ();
    }

    LinearErrorType::BaseError_type& LinearErrorType::
    BaseError ()
    {
      return this->BaseError_.get ();
    }

    void LinearErrorType::
    BaseError (const BaseError_type& x)
    {
      this->BaseError_.set (x);
    }

    void LinearErrorType::
    BaseError (::std::unique_ptr< BaseError_type > x)
    {
      this->BaseError_.set (std::move (x));
    }

    const LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate () const
    {
      return this->ErrorRate_.get ();
    }

    LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate ()
    {
      return this->ErrorRate_.get ();
    }

    void LinearErrorType::
    ErrorRate (const ErrorRate_type& x)
    {
      this->ErrorRate_.set (x);
    }


    // LesserErrorType
    //

    const LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_.get ();
    }

    LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_.get ();
    }

    void LesserErrorType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void LesserErrorType::
    MaxErrorConstant (::std::unique_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (std::move (x));
    }

    const LesserErrorType::LinearError_type& LesserErrorType::
    LinearError () const
    {
      return this->LinearError_.get ();
    }

    LesserErrorType::LinearError_type& LesserErrorType::
    LinearError ()
    {
      return this->LinearError_.get ();
    }

    void LesserErrorType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void LesserErrorType::
    LinearError (::std::unique_ptr< LinearError_type > x)
    {
      this->LinearError_.set (std::move (x));
    }


    // PointAccuracyTestType
    //

    const PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy () const
    {
      return this->Accuracy_.get ();
    }

    PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy ()
    {
      return this->Accuracy_.get ();
    }

    void PointAccuracyTestType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void PointAccuracyTestType::
    Accuracy (::std::unique_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (std::move (x));
    }


    // AngularErrorType
    //

    const AngularErrorType::BaseError_type& AngularErrorType::
    BaseError () const
    {
      return this->BaseError_.get ();
    }

    AngularErrorType::BaseError_type& AngularErrorType::
    BaseError ()
    {
      return this->BaseError_.get ();
    }

    void AngularErrorType::
    BaseError (const BaseError_type& x)
    {
      this->BaseError_.set (x);
    }

    void AngularErrorType::
    BaseError (::std::unique_ptr< BaseError_type > x)
    {
      this->BaseError_.set (std::move (x));
    }

    const AngularErrorType::ErrorRate_type& AngularErrorType::
    ErrorRate () const
    {
      return this->ErrorRate_.get ();
    }

    AngularErrorType::ErrorRate_type& AngularErrorType::
    ErrorRate ()
    {
      return this->ErrorRate_.get ();
    }

    void AngularErrorType::
    ErrorRate (const ErrorRate_type& x)
    {
      this->ErrorRate_.set (x);
    }


    // RotaryTableType
    //

    const RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM () const
    {
      return this->LocationOnCMM_.get ();
    }

    RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM ()
    {
      return this->LocationOnCMM_.get ();
    }

    void RotaryTableType::
    LocationOnCMM (const LocationOnCMM_type& x)
    {
      this->LocationOnCMM_.set (x);
    }

    void RotaryTableType::
    LocationOnCMM (::std::unique_ptr< LocationOnCMM_type > x)
    {
      this->LocationOnCMM_.set (std::move (x));
    }

    const RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection () const
    {
      return this->AxisDirection_.get ();
    }

    RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection ()
    {
      return this->AxisDirection_.get ();
    }

    void RotaryTableType::
    AxisDirection (const AxisDirection_type& x)
    {
      this->AxisDirection_.set (x);
    }

    void RotaryTableType::
    AxisDirection (::std::unique_ptr< AxisDirection_type > x)
    {
      this->AxisDirection_.set (std::move (x));
    }

    const RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection () const
    {
      return this->ZeroIndexDirection_.get ();
    }

    RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection ()
    {
      return this->ZeroIndexDirection_.get ();
    }

    void RotaryTableType::
    ZeroIndexDirection (const ZeroIndexDirection_type& x)
    {
      this->ZeroIndexDirection_.set (x);
    }

    void RotaryTableType::
    ZeroIndexDirection (::std::unique_ptr< ZeroIndexDirection_type > x)
    {
      this->ZeroIndexDirection_.set (std::move (x));
    }

    const RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius () const
    {
      return this->TableRadius_.get ();
    }

    RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius ()
    {
      return this->TableRadius_.get ();
    }

    void RotaryTableType::
    TableRadius (const TableRadius_type& x)
    {
      this->TableRadius_.set (x);
    }

    void RotaryTableType::
    TableRadius (::std::unique_ptr< TableRadius_type > x)
    {
      this->TableRadius_.set (std::move (x));
    }

    const RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors () const
    {
      return this->TableErrors_.get ();
    }

    RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors ()
    {
      return this->TableErrors_.get ();
    }

    void RotaryTableType::
    TableErrors (const TableErrors_type& x)
    {
      this->TableErrors_.set (x);
    }

    void RotaryTableType::
    TableErrors (::std::unique_ptr< TableErrors_type > x)
    {
      this->TableErrors_.set (std::move (x));
    }


    // TableErrorsType
    //

    const TableErrorsType::AxialError_type& TableErrorsType::
    AxialError () const
    {
      return this->AxialError_.get ();
    }

    TableErrorsType::AxialError_type& TableErrorsType::
    AxialError ()
    {
      return this->AxialError_.get ();
    }

    void TableErrorsType::
    AxialError (const AxialError_type& x)
    {
      this->AxialError_.set (x);
    }

    void TableErrorsType::
    AxialError (::std::unique_ptr< AxialError_type > x)
    {
      this->AxialError_.set (std::move (x));
    }

    const TableErrorsType::RadialError_type& TableErrorsType::
    RadialError () const
    {
      return this->RadialError_.get ();
    }

    TableErrorsType::RadialError_type& TableErrorsType::
    RadialError ()
    {
      return this->RadialError_.get ();
    }

    void TableErrorsType::
    RadialError (const RadialError_type& x)
    {
      this->RadialError_.set (x);
    }

    void TableErrorsType::
    RadialError (::std::unique_ptr< RadialError_type > x)
    {
      this->RadialError_.set (std::move (x));
    }

    const TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError () const
    {
      return this->TangentialError_.get ();
    }

    TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError ()
    {
      return this->TangentialError_.get ();
    }

    void TableErrorsType::
    TangentialError (const TangentialError_type& x)
    {
      this->TangentialError_.set (x);
    }

    void TableErrorsType::
    TangentialError (::std::unique_ptr< TangentialError_type > x)
    {
      this->TangentialError_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // MeasurementResourcesType
    //

    MeasurementResourcesType::
    MeasurementResourcesType ()
    : ::xml_schema::type (),
      Version_ (this),
      Fixtures_ (this),
      MeasurementRooms_ (this),
      MeasurementDevices_ (this),
      DetachableSensors_ (this),
      Tools_ (this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const MeasurementResourcesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      Fixtures_ (x.Fixtures_, f, this),
      MeasurementRooms_ (x.MeasurementRooms_, f, this),
      MeasurementDevices_ (x.MeasurementDevices_, f, this),
      DetachableSensors_ (x.DetachableSensors_, f, this),
      Tools_ (x.Tools_, f, this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      Fixtures_ (this),
      MeasurementRooms_ (this),
      MeasurementDevices_ (this),
      DetachableSensors_ (this),
      Tools_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementResourcesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Fixtures
        //
        if (n.name () == L"Fixtures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Fixtures_type > r (
            Fixtures_traits::create (i, f, this));

          if (!this->Fixtures_)
          {
            this->Fixtures_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementRooms
        //
        if (n.name () == L"MeasurementRooms" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementRooms_type > r (
            MeasurementRooms_traits::create (i, f, this));

          if (!this->MeasurementRooms_)
          {
            this->MeasurementRooms_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementDevices
        //
        if (n.name () == L"MeasurementDevices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDevices_type > r (
            MeasurementDevices_traits::create (i, f, this));

          if (!this->MeasurementDevices_)
          {
            this->MeasurementDevices_.set (::std::move (r));
            continue;
          }
        }

        // DetachableSensors
        //
        if (n.name () == L"DetachableSensors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DetachableSensors_type > r (
            DetachableSensors_traits::create (i, f, this));

          if (!this->DetachableSensors_)
          {
            this->DetachableSensors_.set (::std::move (r));
            continue;
          }
        }

        // Tools
        //
        if (n.name () == L"Tools" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Tools_type > r (
            Tools_traits::create (i, f, this));

          if (!this->Tools_)
          {
            this->Tools_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasurementResourcesType* MeasurementResourcesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementResourcesType (*this, f, c);
    }

    MeasurementResourcesType& MeasurementResourcesType::
    operator= (const MeasurementResourcesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->Fixtures_ = x.Fixtures_;
        this->MeasurementRooms_ = x.MeasurementRooms_;
        this->MeasurementDevices_ = x.MeasurementDevices_;
        this->DetachableSensors_ = x.DetachableSensors_;
        this->Tools_ = x.Tools_;
      }

      return *this;
    }

    MeasurementResourcesType::
    ~MeasurementResourcesType ()
    {
    }

    // MeasurementResourceBaseType
    //

    MeasurementResourceBaseType::
    MeasurementResourceBaseType ()
    : ::xml_schema::type (),
      Name_ (this),
      Description_ (this),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this),
      Mass_ (this),
      Size_ (this),
      LocationId_ (this),
      Location_ (this),
      Attributes_ (this),
      id_ (this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const Name_type& Name,
                                 const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Description_ (this),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this),
      Mass_ (this),
      Size_ (this),
      LocationId_ (this),
      Location_ (this),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const MeasurementResourceBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      Manufacturer_ (x.Manufacturer_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this),
      Mass_ (x.Mass_, f, this),
      Size_ (x.Size_, f, this),
      LocationId_ (x.LocationId_, f, this),
      Location_ (x.Location_, f, this),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Description_ (this),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this),
      Mass_ (this),
      Size_ (this),
      LocationId_ (this),
      Location_ (this),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementResourceBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // Manufacturer
        //
        if (n.name () == L"Manufacturer" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Manufacturer_type > r (
            Manufacturer_traits::create (i, f, this));

          if (!this->Manufacturer_)
          {
            this->Manufacturer_.set (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == L"ModelNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (::std::move (r));
            continue;
          }
        }

        // SerialNumber
        //
        if (n.name () == L"SerialNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!this->SerialNumber_)
          {
            this->SerialNumber_.set (::std::move (r));
            continue;
          }
        }

        // Mass
        //
        if (n.name () == L"Mass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Mass_type > r (
            Mass_traits::create (i, f, this));

          if (!this->Mass_)
          {
            this->Mass_.set (::std::move (r));
            continue;
          }
        }

        // Size
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Size",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Size_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Size_)
            {
              ::std::unique_ptr< Size_type > r (
                dynamic_cast< Size_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Size_.set (::std::move (r));
              continue;
            }
          }
        }

        // LocationId
        //
        if (n.name () == L"LocationId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocationId_type > r (
            LocationId_traits::create (i, f, this));

          if (!this->LocationId_)
          {
            this->LocationId_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    MeasurementResourceBaseType& MeasurementResourceBaseType::
    operator= (const MeasurementResourceBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->Manufacturer_ = x.Manufacturer_;
        this->ModelNumber_ = x.ModelNumber_;
        this->SerialNumber_ = x.SerialNumber_;
        this->Mass_ = x.Mass_;
        this->Size_ = x.Size_;
        this->LocationId_ = x.LocationId_;
        this->Location_ = x.Location_;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasurementResourceBaseType::
    ~MeasurementResourceBaseType ()
    {
    }

    // CarriageType
    //

    CarriageType::
    CarriageType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      ToolIds_ (this)
    {
    }

    CarriageType::
    CarriageType (const Name_type& Name,
                  const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      ToolIds_ (this)
    {
    }

    CarriageType::
    CarriageType (const CarriageType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    CarriageType::
    CarriageType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CarriageType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CarriageType* CarriageType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriageType (*this, f, c);
    }

    CarriageType& CarriageType::
    operator= (const CarriageType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    CarriageType::
    ~CarriageType ()
    {
    }

    // CarriagesType
    //

    CarriagesType::
    CarriagesType ()
    : ::xml_schema::type (),
      Carriage_ (this),
      n_ (this)
    {
    }

    CarriagesType::
    CarriagesType (const n_type& n)
    : ::xml_schema::type (),
      Carriage_ (this),
      n_ (n, this)
    {
    }

    CarriagesType::
    CarriagesType (const CarriagesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Carriage_ (x.Carriage_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CarriagesType::
    CarriagesType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Carriage_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CarriagesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Carriage
        //
        if (n.name () == L"Carriage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Carriage_type > r (
            Carriage_traits::create (i, f, this));

          this->Carriage_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CarriagesType* CarriagesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriagesType (*this, f, c);
    }

    CarriagesType& CarriagesType::
    operator= (const CarriagesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Carriage_ = x.Carriage_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CarriagesType::
    ~CarriagesType ()
    {
    }

    // FixturesType
    //

    FixturesType::
    FixturesType ()
    : ::xml_schema::type (),
      Fixture_ (this),
      n_ (this)
    {
    }

    FixturesType::
    FixturesType (const n_type& n)
    : ::xml_schema::type (),
      Fixture_ (this),
      n_ (n, this)
    {
    }

    FixturesType::
    FixturesType (const FixturesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Fixture_ (x.Fixture_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FixturesType::
    FixturesType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Fixture_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FixturesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Fixture
        //
        if (n.name () == L"Fixture" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Fixture_type > r (
            Fixture_traits::create (i, f, this));

          this->Fixture_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FixturesType* FixturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixturesType (*this, f, c);
    }

    FixturesType& FixturesType::
    operator= (const FixturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Fixture_ = x.Fixture_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FixturesType::
    ~FixturesType ()
    {
    }

    // MeasurementRoomType
    //

    MeasurementRoomType::
    MeasurementRoomType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      TemperatureRangeMin_ (this),
      TemperatureRangeMax_ (this),
      TemperatureControlMin_ (this),
      TemperatureControlMax_ (this),
      RelativeHumidityRangeMin_ (this),
      RelativeHumidityRangeMax_ (this),
      RelativeHumidityControlMin_ (this),
      RelativeHumidityControlMax_ (this)
    {
    }

    MeasurementRoomType::
    MeasurementRoomType (const Name_type& Name,
                         const id_type& id,
                         const TemperatureRangeMin_type& TemperatureRangeMin,
                         const TemperatureRangeMax_type& TemperatureRangeMax,
                         const TemperatureControlMin_type& TemperatureControlMin,
                         const TemperatureControlMax_type& TemperatureControlMax,
                         const RelativeHumidityRangeMin_type& RelativeHumidityRangeMin,
                         const RelativeHumidityRangeMax_type& RelativeHumidityRangeMax,
                         const RelativeHumidityControlMin_type& RelativeHumidityControlMin,
                         const RelativeHumidityControlMax_type& RelativeHumidityControlMax)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      TemperatureRangeMin_ (TemperatureRangeMin, this),
      TemperatureRangeMax_ (TemperatureRangeMax, this),
      TemperatureControlMin_ (TemperatureControlMin, this),
      TemperatureControlMax_ (TemperatureControlMax, this),
      RelativeHumidityRangeMin_ (RelativeHumidityRangeMin, this),
      RelativeHumidityRangeMax_ (RelativeHumidityRangeMax, this),
      RelativeHumidityControlMin_ (RelativeHumidityControlMin, this),
      RelativeHumidityControlMax_ (RelativeHumidityControlMax, this)
    {
    }

    MeasurementRoomType::
    MeasurementRoomType (const Name_type& Name,
                         const id_type& id,
                         ::std::unique_ptr< TemperatureRangeMin_type > TemperatureRangeMin,
                         ::std::unique_ptr< TemperatureRangeMax_type > TemperatureRangeMax,
                         ::std::unique_ptr< TemperatureControlMin_type > TemperatureControlMin,
                         ::std::unique_ptr< TemperatureControlMax_type > TemperatureControlMax,
                         ::std::unique_ptr< RelativeHumidityRangeMin_type > RelativeHumidityRangeMin,
                         ::std::unique_ptr< RelativeHumidityRangeMax_type > RelativeHumidityRangeMax,
                         ::std::unique_ptr< RelativeHumidityControlMin_type > RelativeHumidityControlMin,
                         ::std::unique_ptr< RelativeHumidityControlMax_type > RelativeHumidityControlMax)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      TemperatureRangeMin_ (std::move (TemperatureRangeMin), this),
      TemperatureRangeMax_ (std::move (TemperatureRangeMax), this),
      TemperatureControlMin_ (std::move (TemperatureControlMin), this),
      TemperatureControlMax_ (std::move (TemperatureControlMax), this),
      RelativeHumidityRangeMin_ (std::move (RelativeHumidityRangeMin), this),
      RelativeHumidityRangeMax_ (std::move (RelativeHumidityRangeMax), this),
      RelativeHumidityControlMin_ (std::move (RelativeHumidityControlMin), this),
      RelativeHumidityControlMax_ (std::move (RelativeHumidityControlMax), this)
    {
    }

    MeasurementRoomType::
    MeasurementRoomType (const MeasurementRoomType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      TemperatureRangeMin_ (x.TemperatureRangeMin_, f, this),
      TemperatureRangeMax_ (x.TemperatureRangeMax_, f, this),
      TemperatureControlMin_ (x.TemperatureControlMin_, f, this),
      TemperatureControlMax_ (x.TemperatureControlMax_, f, this),
      RelativeHumidityRangeMin_ (x.RelativeHumidityRangeMin_, f, this),
      RelativeHumidityRangeMax_ (x.RelativeHumidityRangeMax_, f, this),
      RelativeHumidityControlMin_ (x.RelativeHumidityControlMin_, f, this),
      RelativeHumidityControlMax_ (x.RelativeHumidityControlMax_, f, this)
    {
    }

    MeasurementRoomType::
    MeasurementRoomType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      TemperatureRangeMin_ (this),
      TemperatureRangeMax_ (this),
      TemperatureControlMin_ (this),
      TemperatureControlMax_ (this),
      RelativeHumidityRangeMin_ (this),
      RelativeHumidityRangeMax_ (this),
      RelativeHumidityControlMin_ (this),
      RelativeHumidityControlMax_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementRoomType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TemperatureRangeMin
        //
        if (n.name () == L"TemperatureRangeMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureRangeMin_type > r (
            TemperatureRangeMin_traits::create (i, f, this));

          if (!TemperatureRangeMin_.present ())
          {
            this->TemperatureRangeMin_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureRangeMax
        //
        if (n.name () == L"TemperatureRangeMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureRangeMax_type > r (
            TemperatureRangeMax_traits::create (i, f, this));

          if (!TemperatureRangeMax_.present ())
          {
            this->TemperatureRangeMax_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureControlMin
        //
        if (n.name () == L"TemperatureControlMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureControlMin_type > r (
            TemperatureControlMin_traits::create (i, f, this));

          if (!TemperatureControlMin_.present ())
          {
            this->TemperatureControlMin_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureControlMax
        //
        if (n.name () == L"TemperatureControlMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureControlMax_type > r (
            TemperatureControlMax_traits::create (i, f, this));

          if (!TemperatureControlMax_.present ())
          {
            this->TemperatureControlMax_.set (::std::move (r));
            continue;
          }
        }

        // RelativeHumidityRangeMin
        //
        if (n.name () == L"RelativeHumidityRangeMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeHumidityRangeMin_type > r (
            RelativeHumidityRangeMin_traits::create (i, f, this));

          if (!RelativeHumidityRangeMin_.present ())
          {
            this->RelativeHumidityRangeMin_.set (::std::move (r));
            continue;
          }
        }

        // RelativeHumidityRangeMax
        //
        if (n.name () == L"RelativeHumidityRangeMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeHumidityRangeMax_type > r (
            RelativeHumidityRangeMax_traits::create (i, f, this));

          if (!RelativeHumidityRangeMax_.present ())
          {
            this->RelativeHumidityRangeMax_.set (::std::move (r));
            continue;
          }
        }

        // RelativeHumidityControlMin
        //
        if (n.name () == L"RelativeHumidityControlMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeHumidityControlMin_type > r (
            RelativeHumidityControlMin_traits::create (i, f, this));

          if (!RelativeHumidityControlMin_.present ())
          {
            this->RelativeHumidityControlMin_.set (::std::move (r));
            continue;
          }
        }

        // RelativeHumidityControlMax
        //
        if (n.name () == L"RelativeHumidityControlMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeHumidityControlMax_type > r (
            RelativeHumidityControlMax_traits::create (i, f, this));

          if (!RelativeHumidityControlMax_.present ())
          {
            this->RelativeHumidityControlMax_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TemperatureRangeMin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TemperatureRangeMin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TemperatureRangeMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TemperatureRangeMax",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TemperatureControlMin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TemperatureControlMin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TemperatureControlMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TemperatureControlMax",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RelativeHumidityRangeMin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RelativeHumidityRangeMin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RelativeHumidityRangeMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RelativeHumidityRangeMax",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RelativeHumidityControlMin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RelativeHumidityControlMin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RelativeHumidityControlMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RelativeHumidityControlMax",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasurementRoomType* MeasurementRoomType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementRoomType (*this, f, c);
    }

    MeasurementRoomType& MeasurementRoomType::
    operator= (const MeasurementRoomType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->TemperatureRangeMin_ = x.TemperatureRangeMin_;
        this->TemperatureRangeMax_ = x.TemperatureRangeMax_;
        this->TemperatureControlMin_ = x.TemperatureControlMin_;
        this->TemperatureControlMax_ = x.TemperatureControlMax_;
        this->RelativeHumidityRangeMin_ = x.RelativeHumidityRangeMin_;
        this->RelativeHumidityRangeMax_ = x.RelativeHumidityRangeMax_;
        this->RelativeHumidityControlMin_ = x.RelativeHumidityControlMin_;
        this->RelativeHumidityControlMax_ = x.RelativeHumidityControlMax_;
      }

      return *this;
    }

    MeasurementRoomType::
    ~MeasurementRoomType ()
    {
    }

    // MeasurementRoomsType
    //

    MeasurementRoomsType::
    MeasurementRoomsType ()
    : ::xml_schema::type (),
      MeasurementRoom_ (this),
      n_ (this)
    {
    }

    MeasurementRoomsType::
    MeasurementRoomsType (const n_type& n)
    : ::xml_schema::type (),
      MeasurementRoom_ (this),
      n_ (n, this)
    {
    }

    MeasurementRoomsType::
    MeasurementRoomsType (const MeasurementRoomsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementRoom_ (x.MeasurementRoom_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MeasurementRoomsType::
    MeasurementRoomsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementRoom_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementRoomsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementRoom
        //
        if (n.name () == L"MeasurementRoom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementRoom_type > r (
            MeasurementRoom_traits::create (i, f, this));

          this->MeasurementRoom_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MeasurementRoomsType* MeasurementRoomsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementRoomsType (*this, f, c);
    }

    MeasurementRoomsType& MeasurementRoomsType::
    operator= (const MeasurementRoomsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurementRoom_ = x.MeasurementRoom_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MeasurementRoomsType::
    ~MeasurementRoomsType ()
    {
    }

    // FixtureType
    //

    FixtureType::
    FixtureType ()
    : ::xsd::qif30::MeasurementResourceBaseType ()
    {
    }

    FixtureType::
    FixtureType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id)
    {
    }

    FixtureType::
    FixtureType (const FixtureType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c)
    {
    }

    FixtureType::
    FixtureType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f, c)
    {
    }

    FixtureType* FixtureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixtureType (*this, f, c);
    }

    FixtureType::
    ~FixtureType ()
    {
    }

    // SensorType
    //

    SensorType::
    SensorType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      ProtectionClass_ (this),
      LinearityError_ (this),
      Repeatability_ (this),
      Sensitivity_ (this),
      Resolution_ (this),
      EnvironmentalRange_ (this)
    {
    }

    SensorType::
    SensorType (const Name_type& Name,
                const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      ProtectionClass_ (this),
      LinearityError_ (this),
      Repeatability_ (this),
      Sensitivity_ (this),
      Resolution_ (this),
      EnvironmentalRange_ (this)
    {
    }

    SensorType::
    SensorType (const SensorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      ProtectionClass_ (x.ProtectionClass_, f, this),
      LinearityError_ (x.LinearityError_, f, this),
      Repeatability_ (x.Repeatability_, f, this),
      Sensitivity_ (x.Sensitivity_, f, this),
      Resolution_ (x.Resolution_, f, this),
      EnvironmentalRange_ (x.EnvironmentalRange_, f, this)
    {
    }

    SensorType::
    SensorType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      ProtectionClass_ (this),
      LinearityError_ (this),
      Repeatability_ (this),
      Sensitivity_ (this),
      Resolution_ (this),
      EnvironmentalRange_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProtectionClass
        //
        if (n.name () == L"ProtectionClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProtectionClass_type > r (
            ProtectionClass_traits::create (i, f, this));

          if (!this->ProtectionClass_)
          {
            this->ProtectionClass_.set (::std::move (r));
            continue;
          }
        }

        // LinearityError
        //
        if (n.name () == L"LinearityError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearityError_type > r (
            LinearityError_traits::create (i, f, this));

          if (!this->LinearityError_)
          {
            this->LinearityError_.set (::std::move (r));
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == L"Repeatability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!this->Repeatability_)
          {
            this->Repeatability_.set (::std::move (r));
            continue;
          }
        }

        // Sensitivity
        //
        if (n.name () == L"Sensitivity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Sensitivity_)
          {
            this->Sensitivity_.set (Sensitivity_traits::create (i, f, this));
            continue;
          }
        }

        // Resolution
        //
        if (n.name () == L"Resolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (::std::move (r));
            continue;
          }
        }

        // EnvironmentalRange
        //
        if (n.name () == L"EnvironmentalRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EnvironmentalRange_type > r (
            EnvironmentalRange_traits::create (i, f, this));

          if (!this->EnvironmentalRange_)
          {
            this->EnvironmentalRange_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SensorType* SensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SensorType (*this, f, c);
    }

    SensorType& SensorType::
    operator= (const SensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->ProtectionClass_ = x.ProtectionClass_;
        this->LinearityError_ = x.LinearityError_;
        this->Repeatability_ = x.Repeatability_;
        this->Sensitivity_ = x.Sensitivity_;
        this->Resolution_ = x.Resolution_;
        this->EnvironmentalRange_ = x.EnvironmentalRange_;
      }

      return *this;
    }

    SensorType::
    ~SensorType ()
    {
    }

    // LaserType
    //

    LaserType::
    LaserType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      LaserSource_ (this),
      LaserWaveLength_ (this),
      LaserPower_ (this),
      LaserSafetyClass_ (this),
      LaserEffectiveLength_ (this),
      LaserSpotSize_ (this),
      LaserPowerSupply_ (this)
    {
    }

    LaserType::
    LaserType (const Name_type& Name,
               const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      LaserSource_ (this),
      LaserWaveLength_ (this),
      LaserPower_ (this),
      LaserSafetyClass_ (this),
      LaserEffectiveLength_ (this),
      LaserSpotSize_ (this),
      LaserPowerSupply_ (this)
    {
    }

    LaserType::
    LaserType (const LaserType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      LaserSource_ (x.LaserSource_, f, this),
      LaserWaveLength_ (x.LaserWaveLength_, f, this),
      LaserPower_ (x.LaserPower_, f, this),
      LaserSafetyClass_ (x.LaserSafetyClass_, f, this),
      LaserEffectiveLength_ (x.LaserEffectiveLength_, f, this),
      LaserSpotSize_ (x.LaserSpotSize_, f, this),
      LaserPowerSupply_ (x.LaserPowerSupply_, f, this)
    {
    }

    LaserType::
    LaserType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      LaserSource_ (this),
      LaserWaveLength_ (this),
      LaserPower_ (this),
      LaserSafetyClass_ (this),
      LaserEffectiveLength_ (this),
      LaserSpotSize_ (this),
      LaserPowerSupply_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LaserType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LaserSource
        //
        if (n.name () == L"LaserSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserSource_type > r (
            LaserSource_traits::create (i, f, this));

          if (!this->LaserSource_)
          {
            this->LaserSource_.set (::std::move (r));
            continue;
          }
        }

        // LaserWaveLength
        //
        if (n.name () == L"LaserWaveLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserWaveLength_type > r (
            LaserWaveLength_traits::create (i, f, this));

          if (!this->LaserWaveLength_)
          {
            this->LaserWaveLength_.set (::std::move (r));
            continue;
          }
        }

        // LaserPower
        //
        if (n.name () == L"LaserPower" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserPower_type > r (
            LaserPower_traits::create (i, f, this));

          if (!this->LaserPower_)
          {
            this->LaserPower_.set (::std::move (r));
            continue;
          }
        }

        // LaserSafetyClass
        //
        if (n.name () == L"LaserSafetyClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserSafetyClass_type > r (
            LaserSafetyClass_traits::create (i, f, this));

          if (!this->LaserSafetyClass_)
          {
            this->LaserSafetyClass_.set (::std::move (r));
            continue;
          }
        }

        // LaserEffectiveLength
        //
        if (n.name () == L"LaserEffectiveLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserEffectiveLength_type > r (
            LaserEffectiveLength_traits::create (i, f, this));

          if (!this->LaserEffectiveLength_)
          {
            this->LaserEffectiveLength_.set (::std::move (r));
            continue;
          }
        }

        // LaserSpotSize
        //
        if (n.name () == L"LaserSpotSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserSpotSize_type > r (
            LaserSpotSize_traits::create (i, f, this));

          if (!this->LaserSpotSize_)
          {
            this->LaserSpotSize_.set (::std::move (r));
            continue;
          }
        }

        // LaserPowerSupply
        //
        if (n.name () == L"LaserPowerSupply" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserPowerSupply_type > r (
            LaserPowerSupply_traits::create (i, f, this));

          if (!this->LaserPowerSupply_)
          {
            this->LaserPowerSupply_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LaserType* LaserType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserType (*this, f, c);
    }

    LaserType& LaserType::
    operator= (const LaserType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->LaserSource_ = x.LaserSource_;
        this->LaserWaveLength_ = x.LaserWaveLength_;
        this->LaserPower_ = x.LaserPower_;
        this->LaserSafetyClass_ = x.LaserSafetyClass_;
        this->LaserEffectiveLength_ = x.LaserEffectiveLength_;
        this->LaserSpotSize_ = x.LaserSpotSize_;
        this->LaserPowerSupply_ = x.LaserPowerSupply_;
      }

      return *this;
    }

    LaserType::
    ~LaserType ()
    {
    }

    // DetachableSensorBaseType
    //

    DetachableSensorBaseType::
    DetachableSensorBaseType ()
    : ::xsd::qif30::SensorType ()
    {
    }

    DetachableSensorBaseType::
    DetachableSensorBaseType (const Name_type& Name,
                              const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id)
    {
    }

    DetachableSensorBaseType::
    DetachableSensorBaseType (const DetachableSensorBaseType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c)
    {
    }

    DetachableSensorBaseType::
    DetachableSensorBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f, c)
    {
    }

    DetachableSensorBaseType::
    ~DetachableSensorBaseType ()
    {
    }

    // DetachableSensorsType
    //

    DetachableSensorsType::
    DetachableSensorsType ()
    : ::xml_schema::type (),
      DetachableSensor_ (this),
      n_ (this)
    {
    }

    DetachableSensorsType::
    DetachableSensorsType (const n_type& n)
    : ::xml_schema::type (),
      DetachableSensor_ (this),
      n_ (n, this)
    {
    }

    DetachableSensorsType::
    DetachableSensorsType (const DetachableSensorsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DetachableSensor_ (x.DetachableSensor_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DetachableSensorsType::
    DetachableSensorsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DetachableSensor_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DetachableSensorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DetachableSensor
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"DetachableSensor",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DetachableSensor_type > r (
              dynamic_cast< DetachableSensor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->DetachableSensor_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DetachableSensorsType* DetachableSensorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DetachableSensorsType (*this, f, c);
    }

    DetachableSensorsType& DetachableSensorsType::
    operator= (const DetachableSensorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DetachableSensor_ = x.DetachableSensor_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DetachableSensorsType::
    ~DetachableSensorsType ()
    {
    }

    // ToolsType
    //

    ToolsType::
    ToolsType ()
    : ::xml_schema::type (),
      Tool_ (this),
      n_ (this)
    {
    }

    ToolsType::
    ToolsType (const n_type& n)
    : ::xml_schema::type (),
      Tool_ (this),
      n_ (n, this)
    {
    }

    ToolsType::
    ToolsType (const ToolsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Tool_ (x.Tool_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ToolsType::
    ToolsType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Tool_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Tool
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Tool",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Tool_type > r (
              dynamic_cast< Tool_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Tool_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ToolsType* ToolsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolsType (*this, f, c);
    }

    ToolsType& ToolsType::
    operator= (const ToolsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Tool_ = x.Tool_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ToolsType::
    ~ToolsType ()
    {
    }

    // ToolBaseType
    //

    ToolBaseType::
    ToolBaseType ()
    : ::xsd::qif30::MeasurementResourceBaseType ()
    {
    }

    ToolBaseType::
    ToolBaseType (const Name_type& Name,
                  const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id)
    {
    }

    ToolBaseType::
    ToolBaseType (const ToolBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c)
    {
    }

    ToolBaseType::
    ToolBaseType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f, c)
    {
    }

    ToolBaseType::
    ~ToolBaseType ()
    {
    }

    // ToolWithIntegratedSensorBaseType
    //

    ToolWithIntegratedSensorBaseType::
    ToolWithIntegratedSensorBaseType ()
    : ::xsd::qif30::ToolBaseType ()
    {
    }

    ToolWithIntegratedSensorBaseType::
    ToolWithIntegratedSensorBaseType (const Name_type& Name,
                                      const id_type& id)
    : ::xsd::qif30::ToolBaseType (Name,
                                  id)
    {
    }

    ToolWithIntegratedSensorBaseType::
    ToolWithIntegratedSensorBaseType (const ToolWithIntegratedSensorBaseType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ToolBaseType (x, f, c)
    {
    }

    ToolWithIntegratedSensorBaseType::
    ToolWithIntegratedSensorBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ToolBaseType (e, f, c)
    {
    }

    ToolWithIntegratedSensorBaseType::
    ~ToolWithIntegratedSensorBaseType ()
    {
    }

    // ToolWithLVDTSensorType
    //

    ToolWithLVDTSensorType::
    ToolWithLVDTSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      LVDTSensor_ (this)
    {
    }

    ToolWithLVDTSensorType::
    ToolWithLVDTSensorType (const Name_type& Name,
                            const id_type& id,
                            const LVDTSensor_type& LVDTSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      LVDTSensor_ (LVDTSensor, this)
    {
    }

    ToolWithLVDTSensorType::
    ToolWithLVDTSensorType (const Name_type& Name,
                            const id_type& id,
                            ::std::unique_ptr< LVDTSensor_type > LVDTSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      LVDTSensor_ (std::move (LVDTSensor), this)
    {
    }

    ToolWithLVDTSensorType::
    ToolWithLVDTSensorType (const ToolWithLVDTSensorType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      LVDTSensor_ (x.LVDTSensor_, f, this)
    {
    }

    ToolWithLVDTSensorType::
    ToolWithLVDTSensorType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      LVDTSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithLVDTSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LVDTSensor
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"LVDTSensor",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< LVDTSensor_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!LVDTSensor_.present ())
            {
              ::std::unique_ptr< LVDTSensor_type > r (
                dynamic_cast< LVDTSensor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->LVDTSensor_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!LVDTSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LVDTSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithLVDTSensorType* ToolWithLVDTSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithLVDTSensorType (*this, f, c);
    }

    ToolWithLVDTSensorType& ToolWithLVDTSensorType::
    operator= (const ToolWithLVDTSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->LVDTSensor_ = x.LVDTSensor_;
      }

      return *this;
    }

    ToolWithLVDTSensorType::
    ~ToolWithLVDTSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithLVDTSensorType >
    _xsd_ToolWithLVDTSensorType_type_factory_init (
      L"ToolWithLVDTSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithCapacitiveSensorType
    //

    ToolWithCapacitiveSensorType::
    ToolWithCapacitiveSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      CapacitiveSensor_ (this)
    {
    }

    ToolWithCapacitiveSensorType::
    ToolWithCapacitiveSensorType (const Name_type& Name,
                                  const id_type& id,
                                  const CapacitiveSensor_type& CapacitiveSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      CapacitiveSensor_ (CapacitiveSensor, this)
    {
    }

    ToolWithCapacitiveSensorType::
    ToolWithCapacitiveSensorType (const Name_type& Name,
                                  const id_type& id,
                                  ::std::unique_ptr< CapacitiveSensor_type > CapacitiveSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      CapacitiveSensor_ (std::move (CapacitiveSensor), this)
    {
    }

    ToolWithCapacitiveSensorType::
    ToolWithCapacitiveSensorType (const ToolWithCapacitiveSensorType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      CapacitiveSensor_ (x.CapacitiveSensor_, f, this)
    {
    }

    ToolWithCapacitiveSensorType::
    ToolWithCapacitiveSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      CapacitiveSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithCapacitiveSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CapacitiveSensor
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CapacitiveSensor",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< CapacitiveSensor_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!CapacitiveSensor_.present ())
            {
              ::std::unique_ptr< CapacitiveSensor_type > r (
                dynamic_cast< CapacitiveSensor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CapacitiveSensor_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!CapacitiveSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CapacitiveSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithCapacitiveSensorType* ToolWithCapacitiveSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithCapacitiveSensorType (*this, f, c);
    }

    ToolWithCapacitiveSensorType& ToolWithCapacitiveSensorType::
    operator= (const ToolWithCapacitiveSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->CapacitiveSensor_ = x.CapacitiveSensor_;
      }

      return *this;
    }

    ToolWithCapacitiveSensorType::
    ~ToolWithCapacitiveSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithCapacitiveSensorType >
    _xsd_ToolWithCapacitiveSensorType_type_factory_init (
      L"ToolWithCapacitiveSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithEddyCurrentSensorType
    //

    ToolWithEddyCurrentSensorType::
    ToolWithEddyCurrentSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      EddyCurrentSensor_ (this)
    {
    }

    ToolWithEddyCurrentSensorType::
    ToolWithEddyCurrentSensorType (const Name_type& Name,
                                   const id_type& id,
                                   const EddyCurrentSensor_type& EddyCurrentSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      EddyCurrentSensor_ (EddyCurrentSensor, this)
    {
    }

    ToolWithEddyCurrentSensorType::
    ToolWithEddyCurrentSensorType (const Name_type& Name,
                                   const id_type& id,
                                   ::std::unique_ptr< EddyCurrentSensor_type > EddyCurrentSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      EddyCurrentSensor_ (std::move (EddyCurrentSensor), this)
    {
    }

    ToolWithEddyCurrentSensorType::
    ToolWithEddyCurrentSensorType (const ToolWithEddyCurrentSensorType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      EddyCurrentSensor_ (x.EddyCurrentSensor_, f, this)
    {
    }

    ToolWithEddyCurrentSensorType::
    ToolWithEddyCurrentSensorType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      EddyCurrentSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithEddyCurrentSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EddyCurrentSensor
        //
        if (n.name () == L"EddyCurrentSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EddyCurrentSensor_type > r (
            EddyCurrentSensor_traits::create (i, f, this));

          if (!EddyCurrentSensor_.present ())
          {
            this->EddyCurrentSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!EddyCurrentSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EddyCurrentSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithEddyCurrentSensorType* ToolWithEddyCurrentSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithEddyCurrentSensorType (*this, f, c);
    }

    ToolWithEddyCurrentSensorType& ToolWithEddyCurrentSensorType::
    operator= (const ToolWithEddyCurrentSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->EddyCurrentSensor_ = x.EddyCurrentSensor_;
      }

      return *this;
    }

    ToolWithEddyCurrentSensorType::
    ~ToolWithEddyCurrentSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithEddyCurrentSensorType >
    _xsd_ToolWithEddyCurrentSensorType_type_factory_init (
      L"ToolWithEddyCurrentSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithConfocalChromaticSensorType
    //

    ToolWithConfocalChromaticSensorType::
    ToolWithConfocalChromaticSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      ConfocalChromaticSensor_ (this)
    {
    }

    ToolWithConfocalChromaticSensorType::
    ToolWithConfocalChromaticSensorType (const Name_type& Name,
                                         const id_type& id,
                                         const ConfocalChromaticSensor_type& ConfocalChromaticSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ConfocalChromaticSensor_ (ConfocalChromaticSensor, this)
    {
    }

    ToolWithConfocalChromaticSensorType::
    ToolWithConfocalChromaticSensorType (const Name_type& Name,
                                         const id_type& id,
                                         ::std::unique_ptr< ConfocalChromaticSensor_type > ConfocalChromaticSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ConfocalChromaticSensor_ (std::move (ConfocalChromaticSensor), this)
    {
    }

    ToolWithConfocalChromaticSensorType::
    ToolWithConfocalChromaticSensorType (const ToolWithConfocalChromaticSensorType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      ConfocalChromaticSensor_ (x.ConfocalChromaticSensor_, f, this)
    {
    }

    ToolWithConfocalChromaticSensorType::
    ToolWithConfocalChromaticSensorType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      ConfocalChromaticSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithConfocalChromaticSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ConfocalChromaticSensor
        //
        if (n.name () == L"ConfocalChromaticSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ConfocalChromaticSensor_type > r (
            ConfocalChromaticSensor_traits::create (i, f, this));

          if (!ConfocalChromaticSensor_.present ())
          {
            this->ConfocalChromaticSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ConfocalChromaticSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ConfocalChromaticSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithConfocalChromaticSensorType* ToolWithConfocalChromaticSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithConfocalChromaticSensorType (*this, f, c);
    }

    ToolWithConfocalChromaticSensorType& ToolWithConfocalChromaticSensorType::
    operator= (const ToolWithConfocalChromaticSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->ConfocalChromaticSensor_ = x.ConfocalChromaticSensor_;
      }

      return *this;
    }

    ToolWithConfocalChromaticSensorType::
    ~ToolWithConfocalChromaticSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithConfocalChromaticSensorType >
    _xsd_ToolWithConfocalChromaticSensorType_type_factory_init (
      L"ToolWithConfocalChromaticSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithDrawWireSensorType
    //

    ToolWithDrawWireSensorType::
    ToolWithDrawWireSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      DrawWireSensor_ (this)
    {
    }

    ToolWithDrawWireSensorType::
    ToolWithDrawWireSensorType (const Name_type& Name,
                                const id_type& id,
                                const DrawWireSensor_type& DrawWireSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      DrawWireSensor_ (DrawWireSensor, this)
    {
    }

    ToolWithDrawWireSensorType::
    ToolWithDrawWireSensorType (const Name_type& Name,
                                const id_type& id,
                                ::std::unique_ptr< DrawWireSensor_type > DrawWireSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      DrawWireSensor_ (std::move (DrawWireSensor), this)
    {
    }

    ToolWithDrawWireSensorType::
    ToolWithDrawWireSensorType (const ToolWithDrawWireSensorType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      DrawWireSensor_ (x.DrawWireSensor_, f, this)
    {
    }

    ToolWithDrawWireSensorType::
    ToolWithDrawWireSensorType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      DrawWireSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithDrawWireSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DrawWireSensor
        //
        if (n.name () == L"DrawWireSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DrawWireSensor_type > r (
            DrawWireSensor_traits::create (i, f, this));

          if (!DrawWireSensor_.present ())
          {
            this->DrawWireSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DrawWireSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DrawWireSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithDrawWireSensorType* ToolWithDrawWireSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithDrawWireSensorType (*this, f, c);
    }

    ToolWithDrawWireSensorType& ToolWithDrawWireSensorType::
    operator= (const ToolWithDrawWireSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->DrawWireSensor_ = x.DrawWireSensor_;
      }

      return *this;
    }

    ToolWithDrawWireSensorType::
    ~ToolWithDrawWireSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithDrawWireSensorType >
    _xsd_ToolWithDrawWireSensorType_type_factory_init (
      L"ToolWithDrawWireSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithMagnetoInductiveSensorType
    //

    ToolWithMagnetoInductiveSensorType::
    ToolWithMagnetoInductiveSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      MagnetoInductiveSensor_ (this)
    {
    }

    ToolWithMagnetoInductiveSensorType::
    ToolWithMagnetoInductiveSensorType (const Name_type& Name,
                                        const id_type& id,
                                        const MagnetoInductiveSensor_type& MagnetoInductiveSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      MagnetoInductiveSensor_ (MagnetoInductiveSensor, this)
    {
    }

    ToolWithMagnetoInductiveSensorType::
    ToolWithMagnetoInductiveSensorType (const Name_type& Name,
                                        const id_type& id,
                                        ::std::unique_ptr< MagnetoInductiveSensor_type > MagnetoInductiveSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      MagnetoInductiveSensor_ (std::move (MagnetoInductiveSensor), this)
    {
    }

    ToolWithMagnetoInductiveSensorType::
    ToolWithMagnetoInductiveSensorType (const ToolWithMagnetoInductiveSensorType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      MagnetoInductiveSensor_ (x.MagnetoInductiveSensor_, f, this)
    {
    }

    ToolWithMagnetoInductiveSensorType::
    ToolWithMagnetoInductiveSensorType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      MagnetoInductiveSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithMagnetoInductiveSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MagnetoInductiveSensor
        //
        if (n.name () == L"MagnetoInductiveSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MagnetoInductiveSensor_type > r (
            MagnetoInductiveSensor_traits::create (i, f, this));

          if (!MagnetoInductiveSensor_.present ())
          {
            this->MagnetoInductiveSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MagnetoInductiveSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MagnetoInductiveSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithMagnetoInductiveSensorType* ToolWithMagnetoInductiveSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithMagnetoInductiveSensorType (*this, f, c);
    }

    ToolWithMagnetoInductiveSensorType& ToolWithMagnetoInductiveSensorType::
    operator= (const ToolWithMagnetoInductiveSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->MagnetoInductiveSensor_ = x.MagnetoInductiveSensor_;
      }

      return *this;
    }

    ToolWithMagnetoInductiveSensorType::
    ~ToolWithMagnetoInductiveSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithMagnetoInductiveSensorType >
    _xsd_ToolWithMagnetoInductiveSensorType_type_factory_init (
      L"ToolWithMagnetoInductiveSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithDVRTSensorType
    //

    ToolWithDVRTSensorType::
    ToolWithDVRTSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      DVRTSensor_ (this)
    {
    }

    ToolWithDVRTSensorType::
    ToolWithDVRTSensorType (const Name_type& Name,
                            const id_type& id,
                            const DVRTSensor_type& DVRTSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      DVRTSensor_ (DVRTSensor, this)
    {
    }

    ToolWithDVRTSensorType::
    ToolWithDVRTSensorType (const Name_type& Name,
                            const id_type& id,
                            ::std::unique_ptr< DVRTSensor_type > DVRTSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      DVRTSensor_ (std::move (DVRTSensor), this)
    {
    }

    ToolWithDVRTSensorType::
    ToolWithDVRTSensorType (const ToolWithDVRTSensorType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      DVRTSensor_ (x.DVRTSensor_, f, this)
    {
    }

    ToolWithDVRTSensorType::
    ToolWithDVRTSensorType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      DVRTSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithDVRTSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DVRTSensor
        //
        if (n.name () == L"DVRTSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DVRTSensor_type > r (
            DVRTSensor_traits::create (i, f, this));

          if (!DVRTSensor_.present ())
          {
            this->DVRTSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DVRTSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DVRTSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithDVRTSensorType* ToolWithDVRTSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithDVRTSensorType (*this, f, c);
    }

    ToolWithDVRTSensorType& ToolWithDVRTSensorType::
    operator= (const ToolWithDVRTSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->DVRTSensor_ = x.DVRTSensor_;
      }

      return *this;
    }

    ToolWithDVRTSensorType::
    ~ToolWithDVRTSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithDVRTSensorType >
    _xsd_ToolWithDVRTSensorType_type_factory_init (
      L"ToolWithDVRTSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithLaserTriangulationSensorType
    //

    ToolWithLaserTriangulationSensorType::
    ToolWithLaserTriangulationSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      LaserTriangulationSensor_ (this)
    {
    }

    ToolWithLaserTriangulationSensorType::
    ToolWithLaserTriangulationSensorType (const Name_type& Name,
                                          const id_type& id,
                                          const LaserTriangulationSensor_type& LaserTriangulationSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      LaserTriangulationSensor_ (LaserTriangulationSensor, this)
    {
    }

    ToolWithLaserTriangulationSensorType::
    ToolWithLaserTriangulationSensorType (const Name_type& Name,
                                          const id_type& id,
                                          ::std::unique_ptr< LaserTriangulationSensor_type > LaserTriangulationSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      LaserTriangulationSensor_ (std::move (LaserTriangulationSensor), this)
    {
    }

    ToolWithLaserTriangulationSensorType::
    ToolWithLaserTriangulationSensorType (const ToolWithLaserTriangulationSensorType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      LaserTriangulationSensor_ (x.LaserTriangulationSensor_, f, this)
    {
    }

    ToolWithLaserTriangulationSensorType::
    ToolWithLaserTriangulationSensorType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      LaserTriangulationSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithLaserTriangulationSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LaserTriangulationSensor
        //
        if (n.name () == L"LaserTriangulationSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserTriangulationSensor_type > r (
            LaserTriangulationSensor_traits::create (i, f, this));

          if (!LaserTriangulationSensor_.present ())
          {
            this->LaserTriangulationSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LaserTriangulationSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LaserTriangulationSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithLaserTriangulationSensorType* ToolWithLaserTriangulationSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithLaserTriangulationSensorType (*this, f, c);
    }

    ToolWithLaserTriangulationSensorType& ToolWithLaserTriangulationSensorType::
    operator= (const ToolWithLaserTriangulationSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->LaserTriangulationSensor_ = x.LaserTriangulationSensor_;
      }

      return *this;
    }

    ToolWithLaserTriangulationSensorType::
    ~ToolWithLaserTriangulationSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithLaserTriangulationSensorType >
    _xsd_ToolWithLaserTriangulationSensorType_type_factory_init (
      L"ToolWithLaserTriangulationSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithStructuredLightSensorType
    //

    ToolWithStructuredLightSensorType::
    ToolWithStructuredLightSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      StructuredLightSensor_ (this)
    {
    }

    ToolWithStructuredLightSensorType::
    ToolWithStructuredLightSensorType (const Name_type& Name,
                                       const id_type& id,
                                       const StructuredLightSensor_type& StructuredLightSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      StructuredLightSensor_ (StructuredLightSensor, this)
    {
    }

    ToolWithStructuredLightSensorType::
    ToolWithStructuredLightSensorType (const Name_type& Name,
                                       const id_type& id,
                                       ::std::unique_ptr< StructuredLightSensor_type > StructuredLightSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      StructuredLightSensor_ (std::move (StructuredLightSensor), this)
    {
    }

    ToolWithStructuredLightSensorType::
    ToolWithStructuredLightSensorType (const ToolWithStructuredLightSensorType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      StructuredLightSensor_ (x.StructuredLightSensor_, f, this)
    {
    }

    ToolWithStructuredLightSensorType::
    ToolWithStructuredLightSensorType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      StructuredLightSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithStructuredLightSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StructuredLightSensor
        //
        if (n.name () == L"StructuredLightSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StructuredLightSensor_type > r (
            StructuredLightSensor_traits::create (i, f, this));

          if (!StructuredLightSensor_.present ())
          {
            this->StructuredLightSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StructuredLightSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StructuredLightSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithStructuredLightSensorType* ToolWithStructuredLightSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithStructuredLightSensorType (*this, f, c);
    }

    ToolWithStructuredLightSensorType& ToolWithStructuredLightSensorType::
    operator= (const ToolWithStructuredLightSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->StructuredLightSensor_ = x.StructuredLightSensor_;
      }

      return *this;
    }

    ToolWithStructuredLightSensorType::
    ~ToolWithStructuredLightSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithStructuredLightSensorType >
    _xsd_ToolWithStructuredLightSensorType_type_factory_init (
      L"ToolWithStructuredLightSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithUltrasonicSensorType
    //

    ToolWithUltrasonicSensorType::
    ToolWithUltrasonicSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      UltrasonicSensor_ (this)
    {
    }

    ToolWithUltrasonicSensorType::
    ToolWithUltrasonicSensorType (const Name_type& Name,
                                  const id_type& id,
                                  const UltrasonicSensor_type& UltrasonicSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      UltrasonicSensor_ (UltrasonicSensor, this)
    {
    }

    ToolWithUltrasonicSensorType::
    ToolWithUltrasonicSensorType (const Name_type& Name,
                                  const id_type& id,
                                  ::std::unique_ptr< UltrasonicSensor_type > UltrasonicSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      UltrasonicSensor_ (std::move (UltrasonicSensor), this)
    {
    }

    ToolWithUltrasonicSensorType::
    ToolWithUltrasonicSensorType (const ToolWithUltrasonicSensorType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      UltrasonicSensor_ (x.UltrasonicSensor_, f, this)
    {
    }

    ToolWithUltrasonicSensorType::
    ToolWithUltrasonicSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      UltrasonicSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithUltrasonicSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UltrasonicSensor
        //
        if (n.name () == L"UltrasonicSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UltrasonicSensor_type > r (
            UltrasonicSensor_traits::create (i, f, this));

          if (!UltrasonicSensor_.present ())
          {
            this->UltrasonicSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UltrasonicSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UltrasonicSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithUltrasonicSensorType* ToolWithUltrasonicSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithUltrasonicSensorType (*this, f, c);
    }

    ToolWithUltrasonicSensorType& ToolWithUltrasonicSensorType::
    operator= (const ToolWithUltrasonicSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->UltrasonicSensor_ = x.UltrasonicSensor_;
      }

      return *this;
    }

    ToolWithUltrasonicSensorType::
    ~ToolWithUltrasonicSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithUltrasonicSensorType >
    _xsd_ToolWithUltrasonicSensorType_type_factory_init (
      L"ToolWithUltrasonicSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithSimpleTactileProbeSensorType
    //

    ToolWithSimpleTactileProbeSensorType::
    ToolWithSimpleTactileProbeSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      SimpleTactileProbeSensor_ (this)
    {
    }

    ToolWithSimpleTactileProbeSensorType::
    ToolWithSimpleTactileProbeSensorType (const Name_type& Name,
                                          const id_type& id,
                                          const SimpleTactileProbeSensor_type& SimpleTactileProbeSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      SimpleTactileProbeSensor_ (SimpleTactileProbeSensor, this)
    {
    }

    ToolWithSimpleTactileProbeSensorType::
    ToolWithSimpleTactileProbeSensorType (const Name_type& Name,
                                          const id_type& id,
                                          ::std::unique_ptr< SimpleTactileProbeSensor_type > SimpleTactileProbeSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      SimpleTactileProbeSensor_ (std::move (SimpleTactileProbeSensor), this)
    {
    }

    ToolWithSimpleTactileProbeSensorType::
    ToolWithSimpleTactileProbeSensorType (const ToolWithSimpleTactileProbeSensorType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      SimpleTactileProbeSensor_ (x.SimpleTactileProbeSensor_, f, this)
    {
    }

    ToolWithSimpleTactileProbeSensorType::
    ToolWithSimpleTactileProbeSensorType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      SimpleTactileProbeSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithSimpleTactileProbeSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SimpleTactileProbeSensor
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"SimpleTactileProbeSensor",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< SimpleTactileProbeSensor_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!SimpleTactileProbeSensor_.present ())
            {
              ::std::unique_ptr< SimpleTactileProbeSensor_type > r (
                dynamic_cast< SimpleTactileProbeSensor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->SimpleTactileProbeSensor_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!SimpleTactileProbeSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SimpleTactileProbeSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithSimpleTactileProbeSensorType* ToolWithSimpleTactileProbeSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithSimpleTactileProbeSensorType (*this, f, c);
    }

    ToolWithSimpleTactileProbeSensorType& ToolWithSimpleTactileProbeSensorType::
    operator= (const ToolWithSimpleTactileProbeSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->SimpleTactileProbeSensor_ = x.SimpleTactileProbeSensor_;
      }

      return *this;
    }

    ToolWithSimpleTactileProbeSensorType::
    ~ToolWithSimpleTactileProbeSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithSimpleTactileProbeSensorType >
    _xsd_ToolWithSimpleTactileProbeSensorType_type_factory_init (
      L"ToolWithSimpleTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithComplexTactileProbeSensorType
    //

    ToolWithComplexTactileProbeSensorType::
    ToolWithComplexTactileProbeSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      ComplexTactileProbeSensor_ (this)
    {
    }

    ToolWithComplexTactileProbeSensorType::
    ToolWithComplexTactileProbeSensorType (const Name_type& Name,
                                           const id_type& id,
                                           const ComplexTactileProbeSensor_type& ComplexTactileProbeSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ComplexTactileProbeSensor_ (ComplexTactileProbeSensor, this)
    {
    }

    ToolWithComplexTactileProbeSensorType::
    ToolWithComplexTactileProbeSensorType (const Name_type& Name,
                                           const id_type& id,
                                           ::std::unique_ptr< ComplexTactileProbeSensor_type > ComplexTactileProbeSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ComplexTactileProbeSensor_ (std::move (ComplexTactileProbeSensor), this)
    {
    }

    ToolWithComplexTactileProbeSensorType::
    ToolWithComplexTactileProbeSensorType (const ToolWithComplexTactileProbeSensorType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      ComplexTactileProbeSensor_ (x.ComplexTactileProbeSensor_, f, this)
    {
    }

    ToolWithComplexTactileProbeSensorType::
    ToolWithComplexTactileProbeSensorType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      ComplexTactileProbeSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithComplexTactileProbeSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ComplexTactileProbeSensor
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ComplexTactileProbeSensor",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< ComplexTactileProbeSensor_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ComplexTactileProbeSensor_.present ())
            {
              ::std::unique_ptr< ComplexTactileProbeSensor_type > r (
                dynamic_cast< ComplexTactileProbeSensor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ComplexTactileProbeSensor_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!ComplexTactileProbeSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ComplexTactileProbeSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithComplexTactileProbeSensorType* ToolWithComplexTactileProbeSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithComplexTactileProbeSensorType (*this, f, c);
    }

    ToolWithComplexTactileProbeSensorType& ToolWithComplexTactileProbeSensorType::
    operator= (const ToolWithComplexTactileProbeSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->ComplexTactileProbeSensor_ = x.ComplexTactileProbeSensor_;
      }

      return *this;
    }

    ToolWithComplexTactileProbeSensorType::
    ~ToolWithComplexTactileProbeSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithComplexTactileProbeSensorType >
    _xsd_ToolWithComplexTactileProbeSensorType_type_factory_init (
      L"ToolWithComplexTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithCCDCameraSensorType
    //

    ToolWithCCDCameraSensorType::
    ToolWithCCDCameraSensorType ()
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (),
      ChargeCoupledDeviceCameraSensor_ (this)
    {
    }

    ToolWithCCDCameraSensorType::
    ToolWithCCDCameraSensorType (const Name_type& Name,
                                 const id_type& id,
                                 const ChargeCoupledDeviceCameraSensor_type& ChargeCoupledDeviceCameraSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ChargeCoupledDeviceCameraSensor_ (ChargeCoupledDeviceCameraSensor, this)
    {
    }

    ToolWithCCDCameraSensorType::
    ToolWithCCDCameraSensorType (const Name_type& Name,
                                 const id_type& id,
                                 ::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > ChargeCoupledDeviceCameraSensor)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (Name,
                                                      id),
      ChargeCoupledDeviceCameraSensor_ (std::move (ChargeCoupledDeviceCameraSensor), this)
    {
    }

    ToolWithCCDCameraSensorType::
    ToolWithCCDCameraSensorType (const ToolWithCCDCameraSensorType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (x, f, c),
      ChargeCoupledDeviceCameraSensor_ (x.ChargeCoupledDeviceCameraSensor_, f, this)
    {
    }

    ToolWithCCDCameraSensorType::
    ToolWithCCDCameraSensorType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ToolWithIntegratedSensorBaseType (e, f | ::xml_schema::flags::base, c),
      ChargeCoupledDeviceCameraSensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithCCDCameraSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolWithIntegratedSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ChargeCoupledDeviceCameraSensor
        //
        if (n.name () == L"ChargeCoupledDeviceCameraSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > r (
            ChargeCoupledDeviceCameraSensor_traits::create (i, f, this));

          if (!ChargeCoupledDeviceCameraSensor_.present ())
          {
            this->ChargeCoupledDeviceCameraSensor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ChargeCoupledDeviceCameraSensor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ChargeCoupledDeviceCameraSensor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToolWithCCDCameraSensorType* ToolWithCCDCameraSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithCCDCameraSensorType (*this, f, c);
    }

    ToolWithCCDCameraSensorType& ToolWithCCDCameraSensorType::
    operator= (const ToolWithCCDCameraSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (*this) = x;
        this->ChargeCoupledDeviceCameraSensor_ = x.ChargeCoupledDeviceCameraSensor_;
      }

      return *this;
    }

    ToolWithCCDCameraSensorType::
    ~ToolWithCCDCameraSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithCCDCameraSensorType >
    _xsd_ToolWithCCDCameraSensorType_type_factory_init (
      L"ToolWithCCDCameraSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ToolWithDetachableSensorsType
    //

    ToolWithDetachableSensorsType::
    ToolWithDetachableSensorsType ()
    : ::xsd::qif30::ToolBaseType (),
      SensorIds_ (this)
    {
    }

    ToolWithDetachableSensorsType::
    ToolWithDetachableSensorsType (const Name_type& Name,
                                   const id_type& id)
    : ::xsd::qif30::ToolBaseType (Name,
                                  id),
      SensorIds_ (this)
    {
    }

    ToolWithDetachableSensorsType::
    ToolWithDetachableSensorsType (const ToolWithDetachableSensorsType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ToolBaseType (x, f, c),
      SensorIds_ (x.SensorIds_, f, this)
    {
    }

    ToolWithDetachableSensorsType::
    ToolWithDetachableSensorsType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ToolBaseType (e, f | ::xml_schema::flags::base, c),
      SensorIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolWithDetachableSensorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ToolBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SensorIds
        //
        if (n.name () == L"SensorIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SensorIds_type > r (
            SensorIds_traits::create (i, f, this));

          if (!this->SensorIds_)
          {
            this->SensorIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToolWithDetachableSensorsType* ToolWithDetachableSensorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolWithDetachableSensorsType (*this, f, c);
    }

    ToolWithDetachableSensorsType& ToolWithDetachableSensorsType::
    operator= (const ToolWithDetachableSensorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ToolBaseType& > (*this) = x;
        this->SensorIds_ = x.SensorIds_;
      }

      return *this;
    }

    ToolWithDetachableSensorsType::
    ~ToolWithDetachableSensorsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToolWithDetachableSensorsType >
    _xsd_ToolWithDetachableSensorsType_type_factory_init (
      L"ToolWithDetachableSensorsType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasurementDevicesType
    //

    MeasurementDevicesType::
    MeasurementDevicesType ()
    : ::xml_schema::type (),
      MeasurementDevice_ (this),
      n_ (this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const n_type& n)
    : ::xml_schema::type (),
      MeasurementDevice_ (this),
      n_ (n, this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const MeasurementDevicesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementDevice_ (x.MeasurementDevice_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementDevice_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementDevicesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDevice
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"MeasurementDevice",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< MeasurementDevice_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MeasurementDevice_type > r (
              dynamic_cast< MeasurementDevice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->MeasurementDevice_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MeasurementDevicesType* MeasurementDevicesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDevicesType (*this, f, c);
    }

    MeasurementDevicesType& MeasurementDevicesType::
    operator= (const MeasurementDevicesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurementDevice_ = x.MeasurementDevice_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MeasurementDevicesType::
    ~MeasurementDevicesType ()
    {
    }

    // MeasurementDeviceType
    //

    MeasurementDeviceType::
    MeasurementDeviceType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      Calibrations_ (this),
      EnvironmentalRange_ (this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      Calibrations_ (this),
      EnvironmentalRange_ (this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const MeasurementDeviceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      Calibrations_ (x.Calibrations_, f, this),
      EnvironmentalRange_ (x.EnvironmentalRange_, f, this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      Calibrations_ (this),
      EnvironmentalRange_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementDeviceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Calibrations
        //
        if (n.name () == L"Calibrations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Calibrations_type > r (
            Calibrations_traits::create (i, f, this));

          if (!this->Calibrations_)
          {
            this->Calibrations_.set (::std::move (r));
            continue;
          }
        }

        // EnvironmentalRange
        //
        if (n.name () == L"EnvironmentalRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EnvironmentalRange_type > r (
            EnvironmentalRange_traits::create (i, f, this));

          if (!this->EnvironmentalRange_)
          {
            this->EnvironmentalRange_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasurementDeviceType* MeasurementDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceType (*this, f, c);
    }

    MeasurementDeviceType& MeasurementDeviceType::
    operator= (const MeasurementDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->Calibrations_ = x.Calibrations_;
        this->EnvironmentalRange_ = x.EnvironmentalRange_;
      }

      return *this;
    }

    MeasurementDeviceType::
    ~MeasurementDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasurementDeviceType >
    _xsd_MeasurementDeviceType_type_factory_init (
      L"MeasurementDeviceType",
      L"http://qifstandards.org/xsd/qif3");

    // ManualMeasurementDeviceType
    //

    ManualMeasurementDeviceType::
    ManualMeasurementDeviceType ()
    : ::xsd::qif30::MeasurementDeviceType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this)
    {
    }

    ManualMeasurementDeviceType::
    ManualMeasurementDeviceType (const Name_type& Name,
                                 const id_type& id)
    : ::xsd::qif30::MeasurementDeviceType (Name,
                                           id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this)
    {
    }

    ManualMeasurementDeviceType::
    ManualMeasurementDeviceType (const ManualMeasurementDeviceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this)
    {
    }

    ManualMeasurementDeviceType::
    ManualMeasurementDeviceType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ManualMeasurementDeviceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ManualMeasurementDeviceType* ManualMeasurementDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManualMeasurementDeviceType (*this, f, c);
    }

    ManualMeasurementDeviceType& ManualMeasurementDeviceType::
    operator= (const ManualMeasurementDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
      }

      return *this;
    }

    ManualMeasurementDeviceType::
    ~ManualMeasurementDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ManualMeasurementDeviceType >
    _xsd_ManualMeasurementDeviceType_type_factory_init (
      L"ManualMeasurementDeviceType",
      L"http://qifstandards.org/xsd/qif3");

    // UniversalDeviceType
    //

    UniversalDeviceType::
    UniversalDeviceType ()
    : ::xsd::qif30::MeasurementDeviceType (),
      Resolution_ (this),
      WorkingVolume_ (this),
      EffectiveWorkingVolume_ (this),
      TemperatureCompensation_ (this)
    {
    }

    UniversalDeviceType::
    UniversalDeviceType (const Name_type& Name,
                         const id_type& id)
    : ::xsd::qif30::MeasurementDeviceType (Name,
                                           id),
      Resolution_ (this),
      WorkingVolume_ (this),
      EffectiveWorkingVolume_ (this),
      TemperatureCompensation_ (this)
    {
    }

    UniversalDeviceType::
    UniversalDeviceType (const UniversalDeviceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceType (x, f, c),
      Resolution_ (x.Resolution_, f, this),
      WorkingVolume_ (x.WorkingVolume_, f, this),
      EffectiveWorkingVolume_ (x.EffectiveWorkingVolume_, f, this),
      TemperatureCompensation_ (x.TemperatureCompensation_, f, this)
    {
    }

    UniversalDeviceType::
    UniversalDeviceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      Resolution_ (this),
      WorkingVolume_ (this),
      EffectiveWorkingVolume_ (this),
      TemperatureCompensation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void UniversalDeviceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Resolution
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Resolution",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Resolution_)
            {
              ::std::unique_ptr< Resolution_type > r (
                dynamic_cast< Resolution_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Resolution_.set (::std::move (r));
              continue;
            }
          }
        }

        // WorkingVolume
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"WorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->WorkingVolume_)
            {
              ::std::unique_ptr< WorkingVolume_type > r (
                dynamic_cast< WorkingVolume_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->WorkingVolume_.set (::std::move (r));
              continue;
            }
          }
        }

        // EffectiveWorkingVolume
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"EffectiveWorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EffectiveWorkingVolume_)
            {
              ::std::unique_ptr< EffectiveWorkingVolume_type > r (
                dynamic_cast< EffectiveWorkingVolume_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EffectiveWorkingVolume_.set (::std::move (r));
              continue;
            }
          }
        }

        // TemperatureCompensation
        //
        if (n.name () == L"TemperatureCompensation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureCompensation_type > r (
            TemperatureCompensation_traits::create (i, f, this));

          if (!this->TemperatureCompensation_)
          {
            this->TemperatureCompensation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UniversalDeviceType* UniversalDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UniversalDeviceType (*this, f, c);
    }

    UniversalDeviceType& UniversalDeviceType::
    operator= (const UniversalDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceType& > (*this) = x;
        this->Resolution_ = x.Resolution_;
        this->WorkingVolume_ = x.WorkingVolume_;
        this->EffectiveWorkingVolume_ = x.EffectiveWorkingVolume_;
        this->TemperatureCompensation_ = x.TemperatureCompensation_;
      }

      return *this;
    }

    UniversalDeviceType::
    ~UniversalDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UniversalDeviceType >
    _xsd_UniversalDeviceType_type_factory_init (
      L"UniversalDeviceType",
      L"http://qifstandards.org/xsd/qif3");

    // TemperatureCompensationEnumType
    //

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_TemperatureCompensationEnumType_convert ();
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_TemperatureCompensationEnumType_convert ();
    }

    TemperatureCompensationEnumType::
    TemperatureCompensationEnumType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_TemperatureCompensationEnumType_convert ();
    }

    TemperatureCompensationEnumType* TemperatureCompensationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureCompensationEnumType (*this, f, c);
    }

    TemperatureCompensationEnumType::value TemperatureCompensationEnumType::
    _xsd_TemperatureCompensationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_TemperatureCompensationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TemperatureCompensationEnumType_indexes_,
                        _xsd_TemperatureCompensationEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_TemperatureCompensationEnumType_indexes_ + 4 || _xsd_TemperatureCompensationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const TemperatureCompensationEnumType::
    _xsd_TemperatureCompensationEnumType_literals_[4] =
    {
      L"NONE",
      L"DEVICE_ONLY",
      L"DEVICE_AND_PART_SAME",
      L"DEVICE_AND_PART_SEPARATE"
    };

    const TemperatureCompensationEnumType::value TemperatureCompensationEnumType::
    _xsd_TemperatureCompensationEnumType_indexes_[4] =
    {
      ::xsd::qif30::TemperatureCompensationEnumType::DEVICE_AND_PART_SAME,
      ::xsd::qif30::TemperatureCompensationEnumType::DEVICE_AND_PART_SEPARATE,
      ::xsd::qif30::TemperatureCompensationEnumType::DEVICE_ONLY,
      ::xsd::qif30::TemperatureCompensationEnumType::NONE
    };

    // TemperatureCompensationType
    //

    TemperatureCompensationType::
    TemperatureCompensationType ()
    : ::xml_schema::type (),
      TemperatureCompensationEnum_ (this),
      OtherTemperatureCompensation_ (this)
    {
    }

    TemperatureCompensationType::
    TemperatureCompensationType (const TemperatureCompensationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TemperatureCompensationEnum_ (x.TemperatureCompensationEnum_, f, this),
      OtherTemperatureCompensation_ (x.OtherTemperatureCompensation_, f, this)
    {
    }

    TemperatureCompensationType::
    TemperatureCompensationType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TemperatureCompensationEnum_ (this),
      OtherTemperatureCompensation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureCompensationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TemperatureCompensationEnum
        //
        if (n.name () == L"TemperatureCompensationEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureCompensationEnum_type > r (
            TemperatureCompensationEnum_traits::create (i, f, this));

          if (!this->TemperatureCompensationEnum_)
          {
            this->TemperatureCompensationEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherTemperatureCompensation
        //
        if (n.name () == L"OtherTemperatureCompensation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherTemperatureCompensation_type > r (
            OtherTemperatureCompensation_traits::create (i, f, this));

          if (!this->OtherTemperatureCompensation_)
          {
            this->OtherTemperatureCompensation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TemperatureCompensationType* TemperatureCompensationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureCompensationType (*this, f, c);
    }

    TemperatureCompensationType& TemperatureCompensationType::
    operator= (const TemperatureCompensationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TemperatureCompensationEnum_ = x.TemperatureCompensationEnum_;
        this->OtherTemperatureCompensation_ = x.OtherTemperatureCompensation_;
      }

      return *this;
    }

    TemperatureCompensationType::
    ~TemperatureCompensationType ()
    {
    }

    // WorkingVolumeBaseType
    //

    WorkingVolumeBaseType::
    WorkingVolumeBaseType ()
    : ::xml_schema::type ()
    {
    }

    WorkingVolumeBaseType::
    WorkingVolumeBaseType (const WorkingVolumeBaseType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    WorkingVolumeBaseType::
    WorkingVolumeBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    WorkingVolumeBaseType::
    WorkingVolumeBaseType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    WorkingVolumeBaseType::
    WorkingVolumeBaseType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    WorkingVolumeBaseType::
    ~WorkingVolumeBaseType ()
    {
    }

    // ClosedShellSetWorkingVolumeType
    //

    ClosedShellSetWorkingVolumeType::
    ClosedShellSetWorkingVolumeType ()
    : ::xsd::qif30::WorkingVolumeBaseType (),
      WorkingClosedShellSet_ (this)
    {
    }

    ClosedShellSetWorkingVolumeType::
    ClosedShellSetWorkingVolumeType (const WorkingClosedShellSet_type& WorkingClosedShellSet)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      WorkingClosedShellSet_ (WorkingClosedShellSet, this)
    {
    }

    ClosedShellSetWorkingVolumeType::
    ClosedShellSetWorkingVolumeType (::std::unique_ptr< WorkingClosedShellSet_type > WorkingClosedShellSet)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      WorkingClosedShellSet_ (std::move (WorkingClosedShellSet), this)
    {
    }

    ClosedShellSetWorkingVolumeType::
    ClosedShellSetWorkingVolumeType (const ClosedShellSetWorkingVolumeType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (x, f, c),
      WorkingClosedShellSet_ (x.WorkingClosedShellSet_, f, this)
    {
    }

    ClosedShellSetWorkingVolumeType::
    ClosedShellSetWorkingVolumeType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      WorkingClosedShellSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ClosedShellSetWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WorkingClosedShellSet
        //
        if (n.name () == L"WorkingClosedShellSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkingClosedShellSet_type > r (
            WorkingClosedShellSet_traits::create (i, f, this));

          if (!WorkingClosedShellSet_.present ())
          {
            this->WorkingClosedShellSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!WorkingClosedShellSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"WorkingClosedShellSet",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ClosedShellSetWorkingVolumeType* ClosedShellSetWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ClosedShellSetWorkingVolumeType (*this, f, c);
    }

    ClosedShellSetWorkingVolumeType& ClosedShellSetWorkingVolumeType::
    operator= (const ClosedShellSetWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkingVolumeBaseType& > (*this) = x;
        this->WorkingClosedShellSet_ = x.WorkingClosedShellSet_;
      }

      return *this;
    }

    ClosedShellSetWorkingVolumeType::
    ~ClosedShellSetWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ClosedShellSetWorkingVolumeType >
    _xsd_ClosedShellSetWorkingVolumeType_type_factory_init (
      L"ClosedShellSetWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // ClosedShellSetType
    //

    ClosedShellSetType::
    ClosedShellSetType ()
    : ::xml_schema::type (),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this)
    {
    }

    ClosedShellSetType::
    ClosedShellSetType (const ShellSet_type& ShellSet)
    : ::xml_schema::type (),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (ShellSet, this)
    {
    }

    ClosedShellSetType::
    ClosedShellSetType (::std::unique_ptr< ShellSet_type > ShellSet)
    : ::xml_schema::type (),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (std::move (ShellSet), this)
    {
    }

    ClosedShellSetType::
    ClosedShellSetType (const ClosedShellSetType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSet_ (x.PointSet_, f, this),
      Curve12Set_ (x.Curve12Set_, f, this),
      Curve13Set_ (x.Curve13Set_, f, this),
      SurfaceSet_ (x.SurfaceSet_, f, this),
      CurveMeshSet_ (x.CurveMeshSet_, f, this),
      SurfaceMeshSet_ (x.SurfaceMeshSet_, f, this),
      VertexSet_ (x.VertexSet_, f, this),
      EdgeSet_ (x.EdgeSet_, f, this),
      LoopSet_ (x.LoopSet_, f, this),
      FaceSet_ (x.FaceSet_, f, this),
      ShellSet_ (x.ShellSet_, f, this)
    {
    }

    ClosedShellSetType::
    ClosedShellSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ClosedShellSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSet
        //
        if (n.name () == L"PointSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSet_type > r (
            PointSet_traits::create (i, f, this));

          if (!this->PointSet_)
          {
            this->PointSet_.set (::std::move (r));
            continue;
          }
        }

        // Curve12Set
        //
        if (n.name () == L"Curve12Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve12Set_type > r (
            Curve12Set_traits::create (i, f, this));

          if (!this->Curve12Set_)
          {
            this->Curve12Set_.set (::std::move (r));
            continue;
          }
        }

        // Curve13Set
        //
        if (n.name () == L"Curve13Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve13Set_type > r (
            Curve13Set_traits::create (i, f, this));

          if (!this->Curve13Set_)
          {
            this->Curve13Set_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceSet
        //
        if (n.name () == L"SurfaceSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceSet_type > r (
            SurfaceSet_traits::create (i, f, this));

          if (!this->SurfaceSet_)
          {
            this->SurfaceSet_.set (::std::move (r));
            continue;
          }
        }

        // CurveMeshSet
        //
        if (n.name () == L"CurveMeshSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveMeshSet_type > r (
            CurveMeshSet_traits::create (i, f, this));

          if (!this->CurveMeshSet_)
          {
            this->CurveMeshSet_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceMeshSet
        //
        if (n.name () == L"SurfaceMeshSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceMeshSet_type > r (
            SurfaceMeshSet_traits::create (i, f, this));

          if (!this->SurfaceMeshSet_)
          {
            this->SurfaceMeshSet_.set (::std::move (r));
            continue;
          }
        }

        // VertexSet
        //
        if (n.name () == L"VertexSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexSet_type > r (
            VertexSet_traits::create (i, f, this));

          if (!this->VertexSet_)
          {
            this->VertexSet_.set (::std::move (r));
            continue;
          }
        }

        // EdgeSet
        //
        if (n.name () == L"EdgeSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeSet_type > r (
            EdgeSet_traits::create (i, f, this));

          if (!this->EdgeSet_)
          {
            this->EdgeSet_.set (::std::move (r));
            continue;
          }
        }

        // LoopSet
        //
        if (n.name () == L"LoopSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LoopSet_type > r (
            LoopSet_traits::create (i, f, this));

          if (!this->LoopSet_)
          {
            this->LoopSet_.set (::std::move (r));
            continue;
          }
        }

        // FaceSet
        //
        if (n.name () == L"FaceSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FaceSet_type > r (
            FaceSet_traits::create (i, f, this));

          if (!this->FaceSet_)
          {
            this->FaceSet_.set (::std::move (r));
            continue;
          }
        }

        // ShellSet
        //
        if (n.name () == L"ShellSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShellSet_type > r (
            ShellSet_traits::create (i, f, this));

          if (!ShellSet_.present ())
          {
            this->ShellSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ShellSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ShellSet",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ClosedShellSetType* ClosedShellSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ClosedShellSetType (*this, f, c);
    }

    ClosedShellSetType& ClosedShellSetType::
    operator= (const ClosedShellSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSet_ = x.PointSet_;
        this->Curve12Set_ = x.Curve12Set_;
        this->Curve13Set_ = x.Curve13Set_;
        this->SurfaceSet_ = x.SurfaceSet_;
        this->CurveMeshSet_ = x.CurveMeshSet_;
        this->SurfaceMeshSet_ = x.SurfaceMeshSet_;
        this->VertexSet_ = x.VertexSet_;
        this->EdgeSet_ = x.EdgeSet_;
        this->LoopSet_ = x.LoopSet_;
        this->FaceSet_ = x.FaceSet_;
        this->ShellSet_ = x.ShellSet_;
      }

      return *this;
    }

    ClosedShellSetType::
    ~ClosedShellSetType ()
    {
    }

    // CartesianWorkingVolumeType
    //

    CartesianWorkingVolumeType::
    CartesianWorkingVolumeType ()
    : ::xsd::qif30::WorkingVolumeBaseType (),
      XAxisLength_ (this),
      YAxisLength_ (this),
      ZAxisLength_ (this)
    {
    }

    CartesianWorkingVolumeType::
    CartesianWorkingVolumeType (const CartesianWorkingVolumeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (x, f, c),
      XAxisLength_ (x.XAxisLength_, f, this),
      YAxisLength_ (x.YAxisLength_, f, this),
      ZAxisLength_ (x.ZAxisLength_, f, this)
    {
    }

    CartesianWorkingVolumeType::
    CartesianWorkingVolumeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      XAxisLength_ (this),
      YAxisLength_ (this),
      ZAxisLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XAxisLength
        //
        if (n.name () == L"XAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisLength_type > r (
            XAxisLength_traits::create (i, f, this));

          if (!this->XAxisLength_)
          {
            this->XAxisLength_.set (::std::move (r));
            continue;
          }
        }

        // YAxisLength
        //
        if (n.name () == L"YAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisLength_type > r (
            YAxisLength_traits::create (i, f, this));

          if (!this->YAxisLength_)
          {
            this->YAxisLength_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisLength
        //
        if (n.name () == L"ZAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisLength_type > r (
            ZAxisLength_traits::create (i, f, this));

          if (!this->ZAxisLength_)
          {
            this->ZAxisLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CartesianWorkingVolumeType* CartesianWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianWorkingVolumeType (*this, f, c);
    }

    CartesianWorkingVolumeType& CartesianWorkingVolumeType::
    operator= (const CartesianWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkingVolumeBaseType& > (*this) = x;
        this->XAxisLength_ = x.XAxisLength_;
        this->YAxisLength_ = x.YAxisLength_;
        this->ZAxisLength_ = x.ZAxisLength_;
      }

      return *this;
    }

    CartesianWorkingVolumeType::
    ~CartesianWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianWorkingVolumeType >
    _xsd_CartesianWorkingVolumeType_type_factory_init (
      L"CartesianWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalWorkingVolumeType
    //

    SphericalWorkingVolumeType::
    SphericalWorkingVolumeType ()
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinPolarAxisAngle_ (this),
      MaxPolarAxisAngle_ (this)
    {
    }

    SphericalWorkingVolumeType::
    SphericalWorkingVolumeType (const RadialAxisLength_type& RadialAxisLength,
                                const MinAzimuthalAxisAngle_type& MinAzimuthalAxisAngle,
                                const MaxAzimuthalAxisAngle_type& MaxAzimuthalAxisAngle,
                                const MinPolarAxisAngle_type& MinPolarAxisAngle,
                                const MaxPolarAxisAngle_type& MaxPolarAxisAngle)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (RadialAxisLength, this),
      MinAzimuthalAxisAngle_ (MinAzimuthalAxisAngle, this),
      MaxAzimuthalAxisAngle_ (MaxAzimuthalAxisAngle, this),
      MinPolarAxisAngle_ (MinPolarAxisAngle, this),
      MaxPolarAxisAngle_ (MaxPolarAxisAngle, this)
    {
    }

    SphericalWorkingVolumeType::
    SphericalWorkingVolumeType (::std::unique_ptr< RadialAxisLength_type > RadialAxisLength,
                                ::std::unique_ptr< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle,
                                ::std::unique_ptr< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle,
                                ::std::unique_ptr< MinPolarAxisAngle_type > MinPolarAxisAngle,
                                ::std::unique_ptr< MaxPolarAxisAngle_type > MaxPolarAxisAngle)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (std::move (RadialAxisLength), this),
      MinAzimuthalAxisAngle_ (std::move (MinAzimuthalAxisAngle), this),
      MaxAzimuthalAxisAngle_ (std::move (MaxAzimuthalAxisAngle), this),
      MinPolarAxisAngle_ (std::move (MinPolarAxisAngle), this),
      MaxPolarAxisAngle_ (std::move (MaxPolarAxisAngle), this)
    {
    }

    SphericalWorkingVolumeType::
    SphericalWorkingVolumeType (const SphericalWorkingVolumeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (x, f, c),
      RadialAxisLength_ (x.RadialAxisLength_, f, this),
      MinAzimuthalAxisAngle_ (x.MinAzimuthalAxisAngle_, f, this),
      MaxAzimuthalAxisAngle_ (x.MaxAzimuthalAxisAngle_, f, this),
      MinPolarAxisAngle_ (x.MinPolarAxisAngle_, f, this),
      MaxPolarAxisAngle_ (x.MaxPolarAxisAngle_, f, this)
    {
    }

    SphericalWorkingVolumeType::
    SphericalWorkingVolumeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      RadialAxisLength_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinPolarAxisAngle_ (this),
      MaxPolarAxisAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RadialAxisLength
        //
        if (n.name () == L"RadialAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadialAxisLength_type > r (
            RadialAxisLength_traits::create (i, f, this));

          if (!RadialAxisLength_.present ())
          {
            this->RadialAxisLength_.set (::std::move (r));
            continue;
          }
        }

        // MinAzimuthalAxisAngle
        //
        if (n.name () == L"MinAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAzimuthalAxisAngle_type > r (
            MinAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MinAzimuthalAxisAngle_.present ())
          {
            this->MinAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MaxAzimuthalAxisAngle
        //
        if (n.name () == L"MaxAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAzimuthalAxisAngle_type > r (
            MaxAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MaxAzimuthalAxisAngle_.present ())
          {
            this->MaxAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MinPolarAxisAngle
        //
        if (n.name () == L"MinPolarAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPolarAxisAngle_type > r (
            MinPolarAxisAngle_traits::create (i, f, this));

          if (!MinPolarAxisAngle_.present ())
          {
            this->MinPolarAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MaxPolarAxisAngle
        //
        if (n.name () == L"MaxPolarAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPolarAxisAngle_type > r (
            MaxPolarAxisAngle_traits::create (i, f, this));

          if (!MaxPolarAxisAngle_.present ())
          {
            this->MaxPolarAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RadialAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RadialAxisLength",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinPolarAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinPolarAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxPolarAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxPolarAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalWorkingVolumeType* SphericalWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalWorkingVolumeType (*this, f, c);
    }

    SphericalWorkingVolumeType& SphericalWorkingVolumeType::
    operator= (const SphericalWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkingVolumeBaseType& > (*this) = x;
        this->RadialAxisLength_ = x.RadialAxisLength_;
        this->MinAzimuthalAxisAngle_ = x.MinAzimuthalAxisAngle_;
        this->MaxAzimuthalAxisAngle_ = x.MaxAzimuthalAxisAngle_;
        this->MinPolarAxisAngle_ = x.MinPolarAxisAngle_;
        this->MaxPolarAxisAngle_ = x.MaxPolarAxisAngle_;
      }

      return *this;
    }

    SphericalWorkingVolumeType::
    ~SphericalWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalWorkingVolumeType >
    _xsd_SphericalWorkingVolumeType_type_factory_init (
      L"SphericalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalWorkingVolumeType
    //

    CylindricalWorkingVolumeType::
    CylindricalWorkingVolumeType ()
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      ZAxisLength_ (this)
    {
    }

    CylindricalWorkingVolumeType::
    CylindricalWorkingVolumeType (const RadialAxisLength_type& RadialAxisLength,
                                  const MinAzimuthalAxisAngle_type& MinAzimuthalAxisAngle,
                                  const MaxAzimuthalAxisAngle_type& MaxAzimuthalAxisAngle,
                                  const ZAxisLength_type& ZAxisLength)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (RadialAxisLength, this),
      MinAzimuthalAxisAngle_ (MinAzimuthalAxisAngle, this),
      MaxAzimuthalAxisAngle_ (MaxAzimuthalAxisAngle, this),
      ZAxisLength_ (ZAxisLength, this)
    {
    }

    CylindricalWorkingVolumeType::
    CylindricalWorkingVolumeType (::std::unique_ptr< RadialAxisLength_type > RadialAxisLength,
                                  ::std::unique_ptr< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle,
                                  ::std::unique_ptr< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle,
                                  ::std::unique_ptr< ZAxisLength_type > ZAxisLength)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      RadialAxisLength_ (std::move (RadialAxisLength), this),
      MinAzimuthalAxisAngle_ (std::move (MinAzimuthalAxisAngle), this),
      MaxAzimuthalAxisAngle_ (std::move (MaxAzimuthalAxisAngle), this),
      ZAxisLength_ (std::move (ZAxisLength), this)
    {
    }

    CylindricalWorkingVolumeType::
    CylindricalWorkingVolumeType (const CylindricalWorkingVolumeType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (x, f, c),
      RadialAxisLength_ (x.RadialAxisLength_, f, this),
      MinAzimuthalAxisAngle_ (x.MinAzimuthalAxisAngle_, f, this),
      MaxAzimuthalAxisAngle_ (x.MaxAzimuthalAxisAngle_, f, this),
      ZAxisLength_ (x.ZAxisLength_, f, this)
    {
    }

    CylindricalWorkingVolumeType::
    CylindricalWorkingVolumeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      RadialAxisLength_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      ZAxisLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RadialAxisLength
        //
        if (n.name () == L"RadialAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadialAxisLength_type > r (
            RadialAxisLength_traits::create (i, f, this));

          if (!RadialAxisLength_.present ())
          {
            this->RadialAxisLength_.set (::std::move (r));
            continue;
          }
        }

        // MinAzimuthalAxisAngle
        //
        if (n.name () == L"MinAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAzimuthalAxisAngle_type > r (
            MinAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MinAzimuthalAxisAngle_.present ())
          {
            this->MinAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MaxAzimuthalAxisAngle
        //
        if (n.name () == L"MaxAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAzimuthalAxisAngle_type > r (
            MaxAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MaxAzimuthalAxisAngle_.present ())
          {
            this->MaxAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisLength
        //
        if (n.name () == L"ZAxisLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisLength_type > r (
            ZAxisLength_traits::create (i, f, this));

          if (!ZAxisLength_.present ())
          {
            this->ZAxisLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RadialAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RadialAxisLength",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisLength",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalWorkingVolumeType* CylindricalWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalWorkingVolumeType (*this, f, c);
    }

    CylindricalWorkingVolumeType& CylindricalWorkingVolumeType::
    operator= (const CylindricalWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkingVolumeBaseType& > (*this) = x;
        this->RadialAxisLength_ = x.RadialAxisLength_;
        this->MinAzimuthalAxisAngle_ = x.MinAzimuthalAxisAngle_;
        this->MaxAzimuthalAxisAngle_ = x.MaxAzimuthalAxisAngle_;
        this->ZAxisLength_ = x.ZAxisLength_;
      }

      return *this;
    }

    CylindricalWorkingVolumeType::
    ~CylindricalWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricalWorkingVolumeType >
    _xsd_CylindricalWorkingVolumeType_type_factory_init (
      L"CylindricalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDefinedWorkingVolumeType
    //

    UserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeType ()
    : ::xsd::qif30::WorkingVolumeBaseType (),
      FirstAxis_ (this),
      SecondAxis_ (this),
      ThirdAxis_ (this)
    {
    }

    UserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeType (const FirstAxis_type& FirstAxis,
                                  const SecondAxis_type& SecondAxis,
                                  const ThirdAxis_type& ThirdAxis)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      FirstAxis_ (FirstAxis, this),
      SecondAxis_ (SecondAxis, this),
      ThirdAxis_ (ThirdAxis, this)
    {
    }

    UserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeType (::std::unique_ptr< FirstAxis_type > FirstAxis,
                                  ::std::unique_ptr< SecondAxis_type > SecondAxis,
                                  ::std::unique_ptr< ThirdAxis_type > ThirdAxis)
    : ::xsd::qif30::WorkingVolumeBaseType (),
      FirstAxis_ (std::move (FirstAxis), this),
      SecondAxis_ (std::move (SecondAxis), this),
      ThirdAxis_ (std::move (ThirdAxis), this)
    {
    }

    UserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeType (const UserDefinedWorkingVolumeType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (x, f, c),
      FirstAxis_ (x.FirstAxis_, f, this),
      SecondAxis_ (x.SecondAxis_, f, this),
      ThirdAxis_ (x.ThirdAxis_, f, this)
    {
    }

    UserDefinedWorkingVolumeType::
    UserDefinedWorkingVolumeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::WorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      FirstAxis_ (this),
      SecondAxis_ (this),
      ThirdAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FirstAxis
        //
        if (n.name () == L"FirstAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstAxis_type > r (
            FirstAxis_traits::create (i, f, this));

          if (!FirstAxis_.present ())
          {
            this->FirstAxis_.set (::std::move (r));
            continue;
          }
        }

        // SecondAxis
        //
        if (n.name () == L"SecondAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondAxis_type > r (
            SecondAxis_traits::create (i, f, this));

          if (!SecondAxis_.present ())
          {
            this->SecondAxis_.set (::std::move (r));
            continue;
          }
        }

        // ThirdAxis
        //
        if (n.name () == L"ThirdAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThirdAxis_type > r (
            ThirdAxis_traits::create (i, f, this));

          if (!ThirdAxis_.present ())
          {
            this->ThirdAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FirstAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SecondAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThirdAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThirdAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UserDefinedWorkingVolumeType* UserDefinedWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedWorkingVolumeType (*this, f, c);
    }

    UserDefinedWorkingVolumeType& UserDefinedWorkingVolumeType::
    operator= (const UserDefinedWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkingVolumeBaseType& > (*this) = x;
        this->FirstAxis_ = x.FirstAxis_;
        this->SecondAxis_ = x.SecondAxis_;
        this->ThirdAxis_ = x.ThirdAxis_;
      }

      return *this;
    }

    UserDefinedWorkingVolumeType::
    ~UserDefinedWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedWorkingVolumeType >
    _xsd_UserDefinedWorkingVolumeType_type_factory_init (
      L"UserDefinedWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // LinearOrRotaryAxisType
    //

    LinearOrRotaryAxisType::
    LinearOrRotaryAxisType ()
    : ::xml_schema::type (),
      Axis_ (this)
    {
    }

    LinearOrRotaryAxisType::
    LinearOrRotaryAxisType (const Axis_type& Axis)
    : ::xml_schema::type (),
      Axis_ (Axis, this)
    {
    }

    LinearOrRotaryAxisType::
    LinearOrRotaryAxisType (::std::unique_ptr< Axis_type > Axis)
    : ::xml_schema::type (),
      Axis_ (std::move (Axis), this)
    {
    }

    LinearOrRotaryAxisType::
    LinearOrRotaryAxisType (const LinearOrRotaryAxisType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Axis_ (x.Axis_, f, this)
    {
    }

    LinearOrRotaryAxisType::
    LinearOrRotaryAxisType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Axis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearOrRotaryAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Axis",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Axis_.present ())
            {
              ::std::unique_ptr< Axis_type > r (
                dynamic_cast< Axis_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Axis_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearOrRotaryAxisType* LinearOrRotaryAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearOrRotaryAxisType (*this, f, c);
    }

    LinearOrRotaryAxisType& LinearOrRotaryAxisType::
    operator= (const LinearOrRotaryAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Axis_ = x.Axis_;
      }

      return *this;
    }

    LinearOrRotaryAxisType::
    ~LinearOrRotaryAxisType ()
    {
    }

    // UserDefinedAxisType
    //

    UserDefinedAxisType::
    UserDefinedAxisType ()
    : ::xsd::qif30::LinearOrRotaryAxisType (),
      Attributes_ (this),
      AxisName_ (this)
    {
    }

    UserDefinedAxisType::
    UserDefinedAxisType (const Axis_type& Axis,
                         const AxisName_type& AxisName)
    : ::xsd::qif30::LinearOrRotaryAxisType (Axis),
      Attributes_ (this),
      AxisName_ (AxisName, this)
    {
    }

    UserDefinedAxisType::
    UserDefinedAxisType (::std::unique_ptr< Axis_type > Axis,
                         const AxisName_type& AxisName)
    : ::xsd::qif30::LinearOrRotaryAxisType (std::move (Axis)),
      Attributes_ (this),
      AxisName_ (AxisName, this)
    {
    }

    UserDefinedAxisType::
    UserDefinedAxisType (const UserDefinedAxisType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::LinearOrRotaryAxisType (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      AxisName_ (x.AxisName_, f, this)
    {
    }

    UserDefinedAxisType::
    UserDefinedAxisType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::LinearOrRotaryAxisType (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      AxisName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LinearOrRotaryAxisType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // AxisName
        //
        if (n.name () == L"AxisName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisName_type > r (
            AxisName_traits::create (i, f, this));

          if (!AxisName_.present ())
          {
            this->AxisName_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AxisName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UserDefinedAxisType* UserDefinedAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedAxisType (*this, f, c);
    }

    UserDefinedAxisType& UserDefinedAxisType::
    operator= (const UserDefinedAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LinearOrRotaryAxisType& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->AxisName_ = x.AxisName_;
      }

      return *this;
    }

    UserDefinedAxisType::
    ~UserDefinedAxisType ()
    {
    }

    // EffectiveWorkingVolumeBaseType
    //

    EffectiveWorkingVolumeBaseType::
    EffectiveWorkingVolumeBaseType ()
    : ::xml_schema::type ()
    {
    }

    EffectiveWorkingVolumeBaseType::
    EffectiveWorkingVolumeBaseType (const EffectiveWorkingVolumeBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    EffectiveWorkingVolumeBaseType::
    EffectiveWorkingVolumeBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    EffectiveWorkingVolumeBaseType::
    EffectiveWorkingVolumeBaseType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    EffectiveWorkingVolumeBaseType::
    EffectiveWorkingVolumeBaseType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    EffectiveWorkingVolumeBaseType::
    ~EffectiveWorkingVolumeBaseType ()
    {
    }

    // EffectiveCylindricalWorkingVolumeType
    //

    EffectiveCylindricalWorkingVolumeType::
    EffectiveCylindricalWorkingVolumeType ()
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadius_ (this),
      MaxRadius_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinZAxis_ (this),
      MaxZAxis_ (this)
    {
    }

    EffectiveCylindricalWorkingVolumeType::
    EffectiveCylindricalWorkingVolumeType (const MinRadius_type& MinRadius,
                                           const MaxRadius_type& MaxRadius,
                                           const MinAzimuthalAxisAngle_type& MinAzimuthalAxisAngle,
                                           const MaxAzimuthalAxisAngle_type& MaxAzimuthalAxisAngle,
                                           const MinZAxis_type& MinZAxis,
                                           const MaxZAxis_type& MaxZAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadius_ (MinRadius, this),
      MaxRadius_ (MaxRadius, this),
      MinAzimuthalAxisAngle_ (MinAzimuthalAxisAngle, this),
      MaxAzimuthalAxisAngle_ (MaxAzimuthalAxisAngle, this),
      MinZAxis_ (MinZAxis, this),
      MaxZAxis_ (MaxZAxis, this)
    {
    }

    EffectiveCylindricalWorkingVolumeType::
    EffectiveCylindricalWorkingVolumeType (::std::unique_ptr< MinRadius_type > MinRadius,
                                           ::std::unique_ptr< MaxRadius_type > MaxRadius,
                                           ::std::unique_ptr< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle,
                                           ::std::unique_ptr< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle,
                                           ::std::unique_ptr< MinZAxis_type > MinZAxis,
                                           ::std::unique_ptr< MaxZAxis_type > MaxZAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadius_ (std::move (MinRadius), this),
      MaxRadius_ (std::move (MaxRadius), this),
      MinAzimuthalAxisAngle_ (std::move (MinAzimuthalAxisAngle), this),
      MaxAzimuthalAxisAngle_ (std::move (MaxAzimuthalAxisAngle), this),
      MinZAxis_ (std::move (MinZAxis), this),
      MaxZAxis_ (std::move (MaxZAxis), this)
    {
    }

    EffectiveCylindricalWorkingVolumeType::
    EffectiveCylindricalWorkingVolumeType (const EffectiveCylindricalWorkingVolumeType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (x, f, c),
      MinRadius_ (x.MinRadius_, f, this),
      MaxRadius_ (x.MaxRadius_, f, this),
      MinAzimuthalAxisAngle_ (x.MinAzimuthalAxisAngle_, f, this),
      MaxAzimuthalAxisAngle_ (x.MaxAzimuthalAxisAngle_, f, this),
      MinZAxis_ (x.MinZAxis_, f, this),
      MaxZAxis_ (x.MaxZAxis_, f, this)
    {
    }

    EffectiveCylindricalWorkingVolumeType::
    EffectiveCylindricalWorkingVolumeType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      MinRadius_ (this),
      MaxRadius_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinZAxis_ (this),
      MaxZAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveCylindricalWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinRadius
        //
        if (n.name () == L"MinRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinRadius_type > r (
            MinRadius_traits::create (i, f, this));

          if (!MinRadius_.present ())
          {
            this->MinRadius_.set (::std::move (r));
            continue;
          }
        }

        // MaxRadius
        //
        if (n.name () == L"MaxRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxRadius_type > r (
            MaxRadius_traits::create (i, f, this));

          if (!MaxRadius_.present ())
          {
            this->MaxRadius_.set (::std::move (r));
            continue;
          }
        }

        // MinAzimuthalAxisAngle
        //
        if (n.name () == L"MinAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAzimuthalAxisAngle_type > r (
            MinAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MinAzimuthalAxisAngle_.present ())
          {
            this->MinAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MaxAzimuthalAxisAngle
        //
        if (n.name () == L"MaxAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAzimuthalAxisAngle_type > r (
            MaxAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MaxAzimuthalAxisAngle_.present ())
          {
            this->MaxAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MinZAxis
        //
        if (n.name () == L"MinZAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinZAxis_type > r (
            MinZAxis_traits::create (i, f, this));

          if (!MinZAxis_.present ())
          {
            this->MinZAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxZAxis
        //
        if (n.name () == L"MaxZAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZAxis_type > r (
            MaxZAxis_traits::create (i, f, this));

          if (!MaxZAxis_.present ())
          {
            this->MaxZAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MinRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinZAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinZAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxZAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxZAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveCylindricalWorkingVolumeType* EffectiveCylindricalWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveCylindricalWorkingVolumeType (*this, f, c);
    }

    EffectiveCylindricalWorkingVolumeType& EffectiveCylindricalWorkingVolumeType::
    operator= (const EffectiveCylindricalWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (*this) = x;
        this->MinRadius_ = x.MinRadius_;
        this->MaxRadius_ = x.MaxRadius_;
        this->MinAzimuthalAxisAngle_ = x.MinAzimuthalAxisAngle_;
        this->MaxAzimuthalAxisAngle_ = x.MaxAzimuthalAxisAngle_;
        this->MinZAxis_ = x.MinZAxis_;
        this->MaxZAxis_ = x.MaxZAxis_;
      }

      return *this;
    }

    EffectiveCylindricalWorkingVolumeType::
    ~EffectiveCylindricalWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EffectiveCylindricalWorkingVolumeType >
    _xsd_EffectiveCylindricalWorkingVolumeType_type_factory_init (
      L"EffectiveCylindricalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // EffectiveSphericalWorkingVolumeType
    //

    EffectiveSphericalWorkingVolumeType::
    EffectiveSphericalWorkingVolumeType ()
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadialAxis_ (this),
      MaxRadialAxis_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinPolarAxis_ (this),
      MaxPolarAxis_ (this)
    {
    }

    EffectiveSphericalWorkingVolumeType::
    EffectiveSphericalWorkingVolumeType (const MinRadialAxis_type& MinRadialAxis,
                                         const MaxRadialAxis_type& MaxRadialAxis,
                                         const MinAzimuthalAxisAngle_type& MinAzimuthalAxisAngle,
                                         const MaxAzimuthalAxisAngle_type& MaxAzimuthalAxisAngle,
                                         const MinPolarAxis_type& MinPolarAxis,
                                         const MaxPolarAxis_type& MaxPolarAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadialAxis_ (MinRadialAxis, this),
      MaxRadialAxis_ (MaxRadialAxis, this),
      MinAzimuthalAxisAngle_ (MinAzimuthalAxisAngle, this),
      MaxAzimuthalAxisAngle_ (MaxAzimuthalAxisAngle, this),
      MinPolarAxis_ (MinPolarAxis, this),
      MaxPolarAxis_ (MaxPolarAxis, this)
    {
    }

    EffectiveSphericalWorkingVolumeType::
    EffectiveSphericalWorkingVolumeType (::std::unique_ptr< MinRadialAxis_type > MinRadialAxis,
                                         ::std::unique_ptr< MaxRadialAxis_type > MaxRadialAxis,
                                         ::std::unique_ptr< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle,
                                         ::std::unique_ptr< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle,
                                         ::std::unique_ptr< MinPolarAxis_type > MinPolarAxis,
                                         ::std::unique_ptr< MaxPolarAxis_type > MaxPolarAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinRadialAxis_ (std::move (MinRadialAxis), this),
      MaxRadialAxis_ (std::move (MaxRadialAxis), this),
      MinAzimuthalAxisAngle_ (std::move (MinAzimuthalAxisAngle), this),
      MaxAzimuthalAxisAngle_ (std::move (MaxAzimuthalAxisAngle), this),
      MinPolarAxis_ (std::move (MinPolarAxis), this),
      MaxPolarAxis_ (std::move (MaxPolarAxis), this)
    {
    }

    EffectiveSphericalWorkingVolumeType::
    EffectiveSphericalWorkingVolumeType (const EffectiveSphericalWorkingVolumeType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (x, f, c),
      MinRadialAxis_ (x.MinRadialAxis_, f, this),
      MaxRadialAxis_ (x.MaxRadialAxis_, f, this),
      MinAzimuthalAxisAngle_ (x.MinAzimuthalAxisAngle_, f, this),
      MaxAzimuthalAxisAngle_ (x.MaxAzimuthalAxisAngle_, f, this),
      MinPolarAxis_ (x.MinPolarAxis_, f, this),
      MaxPolarAxis_ (x.MaxPolarAxis_, f, this)
    {
    }

    EffectiveSphericalWorkingVolumeType::
    EffectiveSphericalWorkingVolumeType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      MinRadialAxis_ (this),
      MaxRadialAxis_ (this),
      MinAzimuthalAxisAngle_ (this),
      MaxAzimuthalAxisAngle_ (this),
      MinPolarAxis_ (this),
      MaxPolarAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveSphericalWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinRadialAxis
        //
        if (n.name () == L"MinRadialAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinRadialAxis_type > r (
            MinRadialAxis_traits::create (i, f, this));

          if (!MinRadialAxis_.present ())
          {
            this->MinRadialAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxRadialAxis
        //
        if (n.name () == L"MaxRadialAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxRadialAxis_type > r (
            MaxRadialAxis_traits::create (i, f, this));

          if (!MaxRadialAxis_.present ())
          {
            this->MaxRadialAxis_.set (::std::move (r));
            continue;
          }
        }

        // MinAzimuthalAxisAngle
        //
        if (n.name () == L"MinAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAzimuthalAxisAngle_type > r (
            MinAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MinAzimuthalAxisAngle_.present ())
          {
            this->MinAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MaxAzimuthalAxisAngle
        //
        if (n.name () == L"MaxAzimuthalAxisAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAzimuthalAxisAngle_type > r (
            MaxAzimuthalAxisAngle_traits::create (i, f, this));

          if (!MaxAzimuthalAxisAngle_.present ())
          {
            this->MaxAzimuthalAxisAngle_.set (::std::move (r));
            continue;
          }
        }

        // MinPolarAxis
        //
        if (n.name () == L"MinPolarAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPolarAxis_type > r (
            MinPolarAxis_traits::create (i, f, this));

          if (!MinPolarAxis_.present ())
          {
            this->MinPolarAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxPolarAxis
        //
        if (n.name () == L"MaxPolarAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPolarAxis_type > r (
            MaxPolarAxis_traits::create (i, f, this));

          if (!MaxPolarAxis_.present ())
          {
            this->MaxPolarAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MinRadialAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinRadialAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxRadialAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxRadialAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxAzimuthalAxisAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxAzimuthalAxisAngle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinPolarAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinPolarAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxPolarAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxPolarAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveSphericalWorkingVolumeType* EffectiveSphericalWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveSphericalWorkingVolumeType (*this, f, c);
    }

    EffectiveSphericalWorkingVolumeType& EffectiveSphericalWorkingVolumeType::
    operator= (const EffectiveSphericalWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (*this) = x;
        this->MinRadialAxis_ = x.MinRadialAxis_;
        this->MaxRadialAxis_ = x.MaxRadialAxis_;
        this->MinAzimuthalAxisAngle_ = x.MinAzimuthalAxisAngle_;
        this->MaxAzimuthalAxisAngle_ = x.MaxAzimuthalAxisAngle_;
        this->MinPolarAxis_ = x.MinPolarAxis_;
        this->MaxPolarAxis_ = x.MaxPolarAxis_;
      }

      return *this;
    }

    EffectiveSphericalWorkingVolumeType::
    ~EffectiveSphericalWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EffectiveSphericalWorkingVolumeType >
    _xsd_EffectiveSphericalWorkingVolumeType_type_factory_init (
      L"EffectiveSphericalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // EffectiveCartesianWorkingVolumeType
    //

    EffectiveCartesianWorkingVolumeType::
    EffectiveCartesianWorkingVolumeType ()
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinPoint_ (this),
      MaxPoint_ (this)
    {
    }

    EffectiveCartesianWorkingVolumeType::
    EffectiveCartesianWorkingVolumeType (const MinPoint_type& MinPoint,
                                         const MaxPoint_type& MaxPoint)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinPoint_ (MinPoint, this),
      MaxPoint_ (MaxPoint, this)
    {
    }

    EffectiveCartesianWorkingVolumeType::
    EffectiveCartesianWorkingVolumeType (::std::unique_ptr< MinPoint_type > MinPoint,
                                         ::std::unique_ptr< MaxPoint_type > MaxPoint)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      MinPoint_ (std::move (MinPoint), this),
      MaxPoint_ (std::move (MaxPoint), this)
    {
    }

    EffectiveCartesianWorkingVolumeType::
    EffectiveCartesianWorkingVolumeType (const EffectiveCartesianWorkingVolumeType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (x, f, c),
      MinPoint_ (x.MinPoint_, f, this),
      MaxPoint_ (x.MaxPoint_, f, this)
    {
    }

    EffectiveCartesianWorkingVolumeType::
    EffectiveCartesianWorkingVolumeType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      MinPoint_ (this),
      MaxPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveCartesianWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinPoint
        //
        if (n.name () == L"MinPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPoint_type > r (
            MinPoint_traits::create (i, f, this));

          if (!MinPoint_.present ())
          {
            this->MinPoint_.set (::std::move (r));
            continue;
          }
        }

        // MaxPoint
        //
        if (n.name () == L"MaxPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPoint_type > r (
            MaxPoint_traits::create (i, f, this));

          if (!MaxPoint_.present ())
          {
            this->MaxPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MinPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveCartesianWorkingVolumeType* EffectiveCartesianWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveCartesianWorkingVolumeType (*this, f, c);
    }

    EffectiveCartesianWorkingVolumeType& EffectiveCartesianWorkingVolumeType::
    operator= (const EffectiveCartesianWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (*this) = x;
        this->MinPoint_ = x.MinPoint_;
        this->MaxPoint_ = x.MaxPoint_;
      }

      return *this;
    }

    EffectiveCartesianWorkingVolumeType::
    ~EffectiveCartesianWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EffectiveCartesianWorkingVolumeType >
    _xsd_EffectiveCartesianWorkingVolumeType_type_factory_init (
      L"EffectiveCartesianWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // EffectiveClosedShellSetWorkingVolumeType
    //

    EffectiveClosedShellSetWorkingVolumeType::
    EffectiveClosedShellSetWorkingVolumeType ()
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      WorkingClosedShellSet_ (this)
    {
    }

    EffectiveClosedShellSetWorkingVolumeType::
    EffectiveClosedShellSetWorkingVolumeType (const WorkingClosedShellSet_type& WorkingClosedShellSet)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      WorkingClosedShellSet_ (WorkingClosedShellSet, this)
    {
    }

    EffectiveClosedShellSetWorkingVolumeType::
    EffectiveClosedShellSetWorkingVolumeType (::std::unique_ptr< WorkingClosedShellSet_type > WorkingClosedShellSet)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      WorkingClosedShellSet_ (std::move (WorkingClosedShellSet), this)
    {
    }

    EffectiveClosedShellSetWorkingVolumeType::
    EffectiveClosedShellSetWorkingVolumeType (const EffectiveClosedShellSetWorkingVolumeType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (x, f, c),
      WorkingClosedShellSet_ (x.WorkingClosedShellSet_, f, this)
    {
    }

    EffectiveClosedShellSetWorkingVolumeType::
    EffectiveClosedShellSetWorkingVolumeType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      WorkingClosedShellSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveClosedShellSetWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WorkingClosedShellSet
        //
        if (n.name () == L"WorkingClosedShellSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkingClosedShellSet_type > r (
            WorkingClosedShellSet_traits::create (i, f, this));

          if (!WorkingClosedShellSet_.present ())
          {
            this->WorkingClosedShellSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!WorkingClosedShellSet_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"WorkingClosedShellSet",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveClosedShellSetWorkingVolumeType* EffectiveClosedShellSetWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveClosedShellSetWorkingVolumeType (*this, f, c);
    }

    EffectiveClosedShellSetWorkingVolumeType& EffectiveClosedShellSetWorkingVolumeType::
    operator= (const EffectiveClosedShellSetWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (*this) = x;
        this->WorkingClosedShellSet_ = x.WorkingClosedShellSet_;
      }

      return *this;
    }

    EffectiveClosedShellSetWorkingVolumeType::
    ~EffectiveClosedShellSetWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EffectiveClosedShellSetWorkingVolumeType >
    _xsd_EffectiveClosedShellSetWorkingVolumeType_type_factory_init (
      L"EffectiveClosedShellSetWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // EffectiveUserDefinedWorkingVolumeType
    //

    EffectiveUserDefinedWorkingVolumeType::
    EffectiveUserDefinedWorkingVolumeType ()
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      UserDefinedWorkingVolumeId_ (this),
      MinFirstAxis_ (this),
      MaxFirstAxis_ (this),
      MinSecondAxis_ (this),
      MaxSecondAxis_ (this),
      MinThirdAxis_ (this),
      MaxThirdAxis_ (this)
    {
    }

    EffectiveUserDefinedWorkingVolumeType::
    EffectiveUserDefinedWorkingVolumeType (const UserDefinedWorkingVolumeId_type& UserDefinedWorkingVolumeId,
                                           const MinFirstAxis_type& MinFirstAxis,
                                           const MaxFirstAxis_type& MaxFirstAxis,
                                           const MinSecondAxis_type& MinSecondAxis,
                                           const MaxSecondAxis_type& MaxSecondAxis,
                                           const MinThirdAxis_type& MinThirdAxis,
                                           const MaxThirdAxis_type& MaxThirdAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      UserDefinedWorkingVolumeId_ (UserDefinedWorkingVolumeId, this),
      MinFirstAxis_ (MinFirstAxis, this),
      MaxFirstAxis_ (MaxFirstAxis, this),
      MinSecondAxis_ (MinSecondAxis, this),
      MaxSecondAxis_ (MaxSecondAxis, this),
      MinThirdAxis_ (MinThirdAxis, this),
      MaxThirdAxis_ (MaxThirdAxis, this)
    {
    }

    EffectiveUserDefinedWorkingVolumeType::
    EffectiveUserDefinedWorkingVolumeType (::std::unique_ptr< UserDefinedWorkingVolumeId_type > UserDefinedWorkingVolumeId,
                                           ::std::unique_ptr< MinFirstAxis_type > MinFirstAxis,
                                           ::std::unique_ptr< MaxFirstAxis_type > MaxFirstAxis,
                                           ::std::unique_ptr< MinSecondAxis_type > MinSecondAxis,
                                           ::std::unique_ptr< MaxSecondAxis_type > MaxSecondAxis,
                                           ::std::unique_ptr< MinThirdAxis_type > MinThirdAxis,
                                           ::std::unique_ptr< MaxThirdAxis_type > MaxThirdAxis)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (),
      UserDefinedWorkingVolumeId_ (std::move (UserDefinedWorkingVolumeId), this),
      MinFirstAxis_ (std::move (MinFirstAxis), this),
      MaxFirstAxis_ (std::move (MaxFirstAxis), this),
      MinSecondAxis_ (std::move (MinSecondAxis), this),
      MaxSecondAxis_ (std::move (MaxSecondAxis), this),
      MinThirdAxis_ (std::move (MinThirdAxis), this),
      MaxThirdAxis_ (std::move (MaxThirdAxis), this)
    {
    }

    EffectiveUserDefinedWorkingVolumeType::
    EffectiveUserDefinedWorkingVolumeType (const EffectiveUserDefinedWorkingVolumeType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (x, f, c),
      UserDefinedWorkingVolumeId_ (x.UserDefinedWorkingVolumeId_, f, this),
      MinFirstAxis_ (x.MinFirstAxis_, f, this),
      MaxFirstAxis_ (x.MaxFirstAxis_, f, this),
      MinSecondAxis_ (x.MinSecondAxis_, f, this),
      MaxSecondAxis_ (x.MaxSecondAxis_, f, this),
      MinThirdAxis_ (x.MinThirdAxis_, f, this),
      MaxThirdAxis_ (x.MaxThirdAxis_, f, this)
    {
    }

    EffectiveUserDefinedWorkingVolumeType::
    EffectiveUserDefinedWorkingVolumeType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::EffectiveWorkingVolumeBaseType (e, f | ::xml_schema::flags::base, c),
      UserDefinedWorkingVolumeId_ (this),
      MinFirstAxis_ (this),
      MaxFirstAxis_ (this),
      MinSecondAxis_ (this),
      MaxSecondAxis_ (this),
      MinThirdAxis_ (this),
      MaxThirdAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveUserDefinedWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UserDefinedWorkingVolumeId
        //
        if (n.name () == L"UserDefinedWorkingVolumeId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedWorkingVolumeId_type > r (
            UserDefinedWorkingVolumeId_traits::create (i, f, this));

          if (!UserDefinedWorkingVolumeId_.present ())
          {
            this->UserDefinedWorkingVolumeId_.set (::std::move (r));
            continue;
          }
        }

        // MinFirstAxis
        //
        if (n.name () == L"MinFirstAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinFirstAxis_type > r (
            MinFirstAxis_traits::create (i, f, this));

          if (!MinFirstAxis_.present ())
          {
            this->MinFirstAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxFirstAxis
        //
        if (n.name () == L"MaxFirstAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFirstAxis_type > r (
            MaxFirstAxis_traits::create (i, f, this));

          if (!MaxFirstAxis_.present ())
          {
            this->MaxFirstAxis_.set (::std::move (r));
            continue;
          }
        }

        // MinSecondAxis
        //
        if (n.name () == L"MinSecondAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinSecondAxis_type > r (
            MinSecondAxis_traits::create (i, f, this));

          if (!MinSecondAxis_.present ())
          {
            this->MinSecondAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxSecondAxis
        //
        if (n.name () == L"MaxSecondAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxSecondAxis_type > r (
            MaxSecondAxis_traits::create (i, f, this));

          if (!MaxSecondAxis_.present ())
          {
            this->MaxSecondAxis_.set (::std::move (r));
            continue;
          }
        }

        // MinThirdAxis
        //
        if (n.name () == L"MinThirdAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinThirdAxis_type > r (
            MinThirdAxis_traits::create (i, f, this));

          if (!MinThirdAxis_.present ())
          {
            this->MinThirdAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxThirdAxis
        //
        if (n.name () == L"MaxThirdAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxThirdAxis_type > r (
            MaxThirdAxis_traits::create (i, f, this));

          if (!MaxThirdAxis_.present ())
          {
            this->MaxThirdAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UserDefinedWorkingVolumeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UserDefinedWorkingVolumeId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinFirstAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinFirstAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxFirstAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxFirstAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinSecondAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinSecondAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxSecondAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxSecondAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinThirdAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinThirdAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxThirdAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxThirdAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveUserDefinedWorkingVolumeType* EffectiveUserDefinedWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveUserDefinedWorkingVolumeType (*this, f, c);
    }

    EffectiveUserDefinedWorkingVolumeType& EffectiveUserDefinedWorkingVolumeType::
    operator= (const EffectiveUserDefinedWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (*this) = x;
        this->UserDefinedWorkingVolumeId_ = x.UserDefinedWorkingVolumeId_;
        this->MinFirstAxis_ = x.MinFirstAxis_;
        this->MaxFirstAxis_ = x.MaxFirstAxis_;
        this->MinSecondAxis_ = x.MinSecondAxis_;
        this->MaxSecondAxis_ = x.MaxSecondAxis_;
        this->MinThirdAxis_ = x.MinThirdAxis_;
        this->MaxThirdAxis_ = x.MaxThirdAxis_;
      }

      return *this;
    }

    EffectiveUserDefinedWorkingVolumeType::
    ~EffectiveUserDefinedWorkingVolumeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EffectiveUserDefinedWorkingVolumeType >
    _xsd_EffectiveUserDefinedWorkingVolumeType_type_factory_init (
      L"EffectiveUserDefinedWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");

    // UserAxisBaseType
    //

    UserAxisBaseType::
    UserAxisBaseType ()
    : ::xml_schema::type ()
    {
    }

    UserAxisBaseType::
    UserAxisBaseType (const UserAxisBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    UserAxisBaseType::
    UserAxisBaseType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    UserAxisBaseType::
    UserAxisBaseType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    UserAxisBaseType::
    UserAxisBaseType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    UserAxisBaseType::
    ~UserAxisBaseType ()
    {
    }

    // LinearAxisType
    //

    LinearAxisType::
    LinearAxisType ()
    : ::xsd::qif30::UserAxisBaseType (),
      MinLinearAxis_ (this),
      MaxLinearAxis_ (this)
    {
    }

    LinearAxisType::
    LinearAxisType (const MinLinearAxis_type& MinLinearAxis,
                    const MaxLinearAxis_type& MaxLinearAxis)
    : ::xsd::qif30::UserAxisBaseType (),
      MinLinearAxis_ (MinLinearAxis, this),
      MaxLinearAxis_ (MaxLinearAxis, this)
    {
    }

    LinearAxisType::
    LinearAxisType (::std::unique_ptr< MinLinearAxis_type > MinLinearAxis,
                    ::std::unique_ptr< MaxLinearAxis_type > MaxLinearAxis)
    : ::xsd::qif30::UserAxisBaseType (),
      MinLinearAxis_ (std::move (MinLinearAxis), this),
      MaxLinearAxis_ (std::move (MaxLinearAxis), this)
    {
    }

    LinearAxisType::
    LinearAxisType (const LinearAxisType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UserAxisBaseType (x, f, c),
      MinLinearAxis_ (x.MinLinearAxis_, f, this),
      MaxLinearAxis_ (x.MaxLinearAxis_, f, this)
    {
    }

    LinearAxisType::
    LinearAxisType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UserAxisBaseType (e, f | ::xml_schema::flags::base, c),
      MinLinearAxis_ (this),
      MaxLinearAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinLinearAxis
        //
        if (n.name () == L"MinLinearAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinLinearAxis_type > r (
            MinLinearAxis_traits::create (i, f, this));

          if (!MinLinearAxis_.present ())
          {
            this->MinLinearAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxLinearAxis
        //
        if (n.name () == L"MaxLinearAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxLinearAxis_type > r (
            MaxLinearAxis_traits::create (i, f, this));

          if (!MaxLinearAxis_.present ())
          {
            this->MaxLinearAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MinLinearAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinLinearAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxLinearAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxLinearAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearAxisType* LinearAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearAxisType (*this, f, c);
    }

    LinearAxisType& LinearAxisType::
    operator= (const LinearAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UserAxisBaseType& > (*this) = x;
        this->MinLinearAxis_ = x.MinLinearAxis_;
        this->MaxLinearAxis_ = x.MaxLinearAxis_;
      }

      return *this;
    }

    LinearAxisType::
    ~LinearAxisType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearAxisType >
    _xsd_LinearAxisType_type_factory_init (
      L"LinearAxisType",
      L"http://qifstandards.org/xsd/qif3");

    // RotaryAxisType
    //

    RotaryAxisType::
    RotaryAxisType ()
    : ::xsd::qif30::UserAxisBaseType (),
      MinRotaryAxis_ (this),
      MaxRotaryAxis_ (this)
    {
    }

    RotaryAxisType::
    RotaryAxisType (const MinRotaryAxis_type& MinRotaryAxis,
                    const MaxRotaryAxis_type& MaxRotaryAxis)
    : ::xsd::qif30::UserAxisBaseType (),
      MinRotaryAxis_ (MinRotaryAxis, this),
      MaxRotaryAxis_ (MaxRotaryAxis, this)
    {
    }

    RotaryAxisType::
    RotaryAxisType (::std::unique_ptr< MinRotaryAxis_type > MinRotaryAxis,
                    ::std::unique_ptr< MaxRotaryAxis_type > MaxRotaryAxis)
    : ::xsd::qif30::UserAxisBaseType (),
      MinRotaryAxis_ (std::move (MinRotaryAxis), this),
      MaxRotaryAxis_ (std::move (MaxRotaryAxis), this)
    {
    }

    RotaryAxisType::
    RotaryAxisType (const RotaryAxisType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UserAxisBaseType (x, f, c),
      MinRotaryAxis_ (x.MinRotaryAxis_, f, this),
      MaxRotaryAxis_ (x.MaxRotaryAxis_, f, this)
    {
    }

    RotaryAxisType::
    RotaryAxisType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UserAxisBaseType (e, f | ::xml_schema::flags::base, c),
      MinRotaryAxis_ (this),
      MaxRotaryAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RotaryAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinRotaryAxis
        //
        if (n.name () == L"MinRotaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinRotaryAxis_type > r (
            MinRotaryAxis_traits::create (i, f, this));

          if (!MinRotaryAxis_.present ())
          {
            this->MinRotaryAxis_.set (::std::move (r));
            continue;
          }
        }

        // MaxRotaryAxis
        //
        if (n.name () == L"MaxRotaryAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxRotaryAxis_type > r (
            MaxRotaryAxis_traits::create (i, f, this));

          if (!MaxRotaryAxis_.present ())
          {
            this->MaxRotaryAxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MinRotaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinRotaryAxis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxRotaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxRotaryAxis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RotaryAxisType* RotaryAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RotaryAxisType (*this, f, c);
    }

    RotaryAxisType& RotaryAxisType::
    operator= (const RotaryAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UserAxisBaseType& > (*this) = x;
        this->MinRotaryAxis_ = x.MinRotaryAxis_;
        this->MaxRotaryAxis_ = x.MaxRotaryAxis_;
      }

      return *this;
    }

    RotaryAxisType::
    ~RotaryAxisType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RotaryAxisType >
    _xsd_RotaryAxisType_type_factory_init (
      L"RotaryAxisType",
      L"http://qifstandards.org/xsd/qif3");

    // ResolutionBaseType
    //

    ResolutionBaseType::
    ResolutionBaseType ()
    : ::xml_schema::type ()
    {
    }

    ResolutionBaseType::
    ResolutionBaseType (const ResolutionBaseType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ResolutionBaseType::
    ResolutionBaseType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ResolutionBaseType::
    ResolutionBaseType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ResolutionBaseType::
    ResolutionBaseType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ResolutionBaseType::
    ~ResolutionBaseType ()
    {
    }

    // LinearResolutionType
    //

    LinearResolutionType::
    LinearResolutionType ()
    : ::xsd::qif30::ResolutionBaseType (),
      LinearValue_ (this)
    {
    }

    LinearResolutionType::
    LinearResolutionType (const LinearValue_type& LinearValue)
    : ::xsd::qif30::ResolutionBaseType (),
      LinearValue_ (LinearValue, this)
    {
    }

    LinearResolutionType::
    LinearResolutionType (::std::unique_ptr< LinearValue_type > LinearValue)
    : ::xsd::qif30::ResolutionBaseType (),
      LinearValue_ (std::move (LinearValue), this)
    {
    }

    LinearResolutionType::
    LinearResolutionType (const LinearResolutionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (x, f, c),
      LinearValue_ (x.LinearValue_, f, this)
    {
    }

    LinearResolutionType::
    LinearResolutionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (e, f | ::xml_schema::flags::base, c),
      LinearValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearValue
        //
        if (n.name () == L"LinearValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearValue_type > r (
            LinearValue_traits::create (i, f, this));

          if (!LinearValue_.present ())
          {
            this->LinearValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LinearValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LinearValue",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearResolutionType* LinearResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearResolutionType (*this, f, c);
    }

    LinearResolutionType& LinearResolutionType::
    operator= (const LinearResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ResolutionBaseType& > (*this) = x;
        this->LinearValue_ = x.LinearValue_;
      }

      return *this;
    }

    LinearResolutionType::
    ~LinearResolutionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearResolutionType >
    _xsd_LinearResolutionType_type_factory_init (
      L"LinearResolutionType",
      L"http://qifstandards.org/xsd/qif3");

    // CartesianResolutionType
    //

    CartesianResolutionType::
    CartesianResolutionType ()
    : ::xsd::qif30::ResolutionBaseType (),
      CombinedCartesianResolution_ (this),
      XYZResolution_ (this)
    {
    }

    CartesianResolutionType::
    CartesianResolutionType (const CartesianResolutionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (x, f, c),
      CombinedCartesianResolution_ (x.CombinedCartesianResolution_, f, this),
      XYZResolution_ (x.XYZResolution_, f, this)
    {
    }

    CartesianResolutionType::
    CartesianResolutionType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (e, f | ::xml_schema::flags::base, c),
      CombinedCartesianResolution_ (this),
      XYZResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CombinedCartesianResolution
        //
        if (n.name () == L"CombinedCartesianResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedCartesianResolution_type > r (
            CombinedCartesianResolution_traits::create (i, f, this));

          if (!this->CombinedCartesianResolution_)
          {
            this->CombinedCartesianResolution_.set (::std::move (r));
            continue;
          }
        }

        // XYZResolution
        //
        if (n.name () == L"XYZResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XYZResolution_type > r (
            XYZResolution_traits::create (i, f, this));

          if (!this->XYZResolution_)
          {
            this->XYZResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CartesianResolutionType* CartesianResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianResolutionType (*this, f, c);
    }

    CartesianResolutionType& CartesianResolutionType::
    operator= (const CartesianResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ResolutionBaseType& > (*this) = x;
        this->CombinedCartesianResolution_ = x.CombinedCartesianResolution_;
        this->XYZResolution_ = x.XYZResolution_;
      }

      return *this;
    }

    CartesianResolutionType::
    ~CartesianResolutionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianResolutionType >
    _xsd_CartesianResolutionType_type_factory_init (
      L"CartesianResolutionType",
      L"http://qifstandards.org/xsd/qif3");

    // XYZResolutionType
    //

    XYZResolutionType::
    XYZResolutionType ()
    : ::xml_schema::type (),
      XResolution_ (this),
      YResolution_ (this),
      ZResolution_ (this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const XResolution_type& XResolution,
                       const YResolution_type& YResolution,
                       const ZResolution_type& ZResolution)
    : ::xml_schema::type (),
      XResolution_ (XResolution, this),
      YResolution_ (YResolution, this),
      ZResolution_ (ZResolution, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (::std::unique_ptr< XResolution_type > XResolution,
                       ::std::unique_ptr< YResolution_type > YResolution,
                       ::std::unique_ptr< ZResolution_type > ZResolution)
    : ::xml_schema::type (),
      XResolution_ (std::move (XResolution), this),
      YResolution_ (std::move (YResolution), this),
      ZResolution_ (std::move (ZResolution), this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const XYZResolutionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XResolution_ (x.XResolution_, f, this),
      YResolution_ (x.YResolution_, f, this),
      ZResolution_ (x.ZResolution_, f, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XResolution_ (this),
      YResolution_ (this),
      ZResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void XYZResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XResolution
        //
        if (n.name () == L"XResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XResolution_type > r (
            XResolution_traits::create (i, f, this));

          if (!XResolution_.present ())
          {
            this->XResolution_.set (::std::move (r));
            continue;
          }
        }

        // YResolution
        //
        if (n.name () == L"YResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YResolution_type > r (
            YResolution_traits::create (i, f, this));

          if (!YResolution_.present ())
          {
            this->YResolution_.set (::std::move (r));
            continue;
          }
        }

        // ZResolution
        //
        if (n.name () == L"ZResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZResolution_type > r (
            ZResolution_traits::create (i, f, this));

          if (!ZResolution_.present ())
          {
            this->ZResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    XYZResolutionType* XYZResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class XYZResolutionType (*this, f, c);
    }

    XYZResolutionType& XYZResolutionType::
    operator= (const XYZResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XResolution_ = x.XResolution_;
        this->YResolution_ = x.YResolution_;
        this->ZResolution_ = x.ZResolution_;
      }

      return *this;
    }

    XYZResolutionType::
    ~XYZResolutionType ()
    {
    }

    // RAPZResolutionType
    //

    RAPZResolutionType::
    RAPZResolutionType ()
    : ::xml_schema::type (),
      RadialResolution_ (this),
      AzimuthalAngleResolution_ (this),
      PolarAngleResolution_ (this)
    {
    }

    RAPZResolutionType::
    RAPZResolutionType (const RadialResolution_type& RadialResolution,
                        const AzimuthalAngleResolution_type& AzimuthalAngleResolution,
                        const PolarAngleResolution_type& PolarAngleResolution)
    : ::xml_schema::type (),
      RadialResolution_ (RadialResolution, this),
      AzimuthalAngleResolution_ (AzimuthalAngleResolution, this),
      PolarAngleResolution_ (PolarAngleResolution, this)
    {
    }

    RAPZResolutionType::
    RAPZResolutionType (::std::unique_ptr< RadialResolution_type > RadialResolution,
                        ::std::unique_ptr< AzimuthalAngleResolution_type > AzimuthalAngleResolution,
                        ::std::unique_ptr< PolarAngleResolution_type > PolarAngleResolution)
    : ::xml_schema::type (),
      RadialResolution_ (std::move (RadialResolution), this),
      AzimuthalAngleResolution_ (std::move (AzimuthalAngleResolution), this),
      PolarAngleResolution_ (std::move (PolarAngleResolution), this)
    {
    }

    RAPZResolutionType::
    RAPZResolutionType (const RAPZResolutionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      RadialResolution_ (x.RadialResolution_, f, this),
      AzimuthalAngleResolution_ (x.AzimuthalAngleResolution_, f, this),
      PolarAngleResolution_ (x.PolarAngleResolution_, f, this)
    {
    }

    RAPZResolutionType::
    RAPZResolutionType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      RadialResolution_ (this),
      AzimuthalAngleResolution_ (this),
      PolarAngleResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RAPZResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RadialResolution
        //
        if (n.name () == L"RadialResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadialResolution_type > r (
            RadialResolution_traits::create (i, f, this));

          if (!RadialResolution_.present ())
          {
            this->RadialResolution_.set (::std::move (r));
            continue;
          }
        }

        // AzimuthalAngleResolution
        //
        if (n.name () == L"AzimuthalAngleResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AzimuthalAngleResolution_type > r (
            AzimuthalAngleResolution_traits::create (i, f, this));

          if (!AzimuthalAngleResolution_.present ())
          {
            this->AzimuthalAngleResolution_.set (::std::move (r));
            continue;
          }
        }

        // PolarAngleResolution
        //
        if (n.name () == L"PolarAngleResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PolarAngleResolution_type > r (
            PolarAngleResolution_traits::create (i, f, this));

          if (!PolarAngleResolution_.present ())
          {
            this->PolarAngleResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RadialResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RadialResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AzimuthalAngleResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AzimuthalAngleResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PolarAngleResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PolarAngleResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RAPZResolutionType* RAPZResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RAPZResolutionType (*this, f, c);
    }

    RAPZResolutionType& RAPZResolutionType::
    operator= (const RAPZResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->RadialResolution_ = x.RadialResolution_;
        this->AzimuthalAngleResolution_ = x.AzimuthalAngleResolution_;
        this->PolarAngleResolution_ = x.PolarAngleResolution_;
      }

      return *this;
    }

    RAPZResolutionType::
    ~RAPZResolutionType ()
    {
    }

    // SphericalResolutionType
    //

    SphericalResolutionType::
    SphericalResolutionType ()
    : ::xsd::qif30::ResolutionBaseType (),
      CombinedSphericalResolution_ (this),
      RAPZResolution_ (this),
      RAPResolution_ (this)
    {
    }

    SphericalResolutionType::
    SphericalResolutionType (const SphericalResolutionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (x, f, c),
      CombinedSphericalResolution_ (x.CombinedSphericalResolution_, f, this),
      RAPZResolution_ (x.RAPZResolution_, f, this),
      RAPResolution_ (x.RAPResolution_, f, this)
    {
    }

    SphericalResolutionType::
    SphericalResolutionType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (e, f | ::xml_schema::flags::base, c),
      CombinedSphericalResolution_ (this),
      RAPZResolution_ (this),
      RAPResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CombinedSphericalResolution
        //
        if (n.name () == L"CombinedSphericalResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedSphericalResolution_type > r (
            CombinedSphericalResolution_traits::create (i, f, this));

          if (!this->CombinedSphericalResolution_)
          {
            this->CombinedSphericalResolution_.set (::std::move (r));
            continue;
          }
        }

        // RAPZResolution
        //
        if (n.name () == L"RAPZResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RAPZResolution_type > r (
            RAPZResolution_traits::create (i, f, this));

          if (!this->RAPZResolution_)
          {
            this->RAPZResolution_.set (::std::move (r));
            continue;
          }
        }

        // RAPResolution
        //
        if (n.name () == L"RAPResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RAPResolution_type > r (
            RAPResolution_traits::create (i, f, this));

          if (!this->RAPResolution_)
          {
            this->RAPResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalResolutionType* SphericalResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalResolutionType (*this, f, c);
    }

    SphericalResolutionType& SphericalResolutionType::
    operator= (const SphericalResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ResolutionBaseType& > (*this) = x;
        this->CombinedSphericalResolution_ = x.CombinedSphericalResolution_;
        this->RAPZResolution_ = x.RAPZResolution_;
        this->RAPResolution_ = x.RAPResolution_;
      }

      return *this;
    }

    SphericalResolutionType::
    ~SphericalResolutionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalResolutionType >
    _xsd_SphericalResolutionType_type_factory_init (
      L"SphericalResolutionType",
      L"http://qifstandards.org/xsd/qif3");

    // CombinedSphericalResolutionType
    //

    CombinedSphericalResolutionType::
    CombinedSphericalResolutionType ()
    : ::xml_schema::type (),
      CombinedRadialResolution_ (this),
      CombinedAzimuthalResolution_ (this),
      CombinedPolarResolution_ (this)
    {
    }

    CombinedSphericalResolutionType::
    CombinedSphericalResolutionType (const CombinedRadialResolution_type& CombinedRadialResolution,
                                     const CombinedAzimuthalResolution_type& CombinedAzimuthalResolution,
                                     const CombinedPolarResolution_type& CombinedPolarResolution)
    : ::xml_schema::type (),
      CombinedRadialResolution_ (CombinedRadialResolution, this),
      CombinedAzimuthalResolution_ (CombinedAzimuthalResolution, this),
      CombinedPolarResolution_ (CombinedPolarResolution, this)
    {
    }

    CombinedSphericalResolutionType::
    CombinedSphericalResolutionType (::std::unique_ptr< CombinedRadialResolution_type > CombinedRadialResolution,
                                     ::std::unique_ptr< CombinedAzimuthalResolution_type > CombinedAzimuthalResolution,
                                     ::std::unique_ptr< CombinedPolarResolution_type > CombinedPolarResolution)
    : ::xml_schema::type (),
      CombinedRadialResolution_ (std::move (CombinedRadialResolution), this),
      CombinedAzimuthalResolution_ (std::move (CombinedAzimuthalResolution), this),
      CombinedPolarResolution_ (std::move (CombinedPolarResolution), this)
    {
    }

    CombinedSphericalResolutionType::
    CombinedSphericalResolutionType (const CombinedSphericalResolutionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CombinedRadialResolution_ (x.CombinedRadialResolution_, f, this),
      CombinedAzimuthalResolution_ (x.CombinedAzimuthalResolution_, f, this),
      CombinedPolarResolution_ (x.CombinedPolarResolution_, f, this)
    {
    }

    CombinedSphericalResolutionType::
    CombinedSphericalResolutionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CombinedRadialResolution_ (this),
      CombinedAzimuthalResolution_ (this),
      CombinedPolarResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CombinedSphericalResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CombinedRadialResolution
        //
        if (n.name () == L"CombinedRadialResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedRadialResolution_type > r (
            CombinedRadialResolution_traits::create (i, f, this));

          if (!CombinedRadialResolution_.present ())
          {
            this->CombinedRadialResolution_.set (::std::move (r));
            continue;
          }
        }

        // CombinedAzimuthalResolution
        //
        if (n.name () == L"CombinedAzimuthalResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedAzimuthalResolution_type > r (
            CombinedAzimuthalResolution_traits::create (i, f, this));

          if (!CombinedAzimuthalResolution_.present ())
          {
            this->CombinedAzimuthalResolution_.set (::std::move (r));
            continue;
          }
        }

        // CombinedPolarResolution
        //
        if (n.name () == L"CombinedPolarResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedPolarResolution_type > r (
            CombinedPolarResolution_traits::create (i, f, this));

          if (!CombinedPolarResolution_.present ())
          {
            this->CombinedPolarResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CombinedRadialResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CombinedRadialResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CombinedAzimuthalResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CombinedAzimuthalResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CombinedPolarResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CombinedPolarResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CombinedSphericalResolutionType* CombinedSphericalResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CombinedSphericalResolutionType (*this, f, c);
    }

    CombinedSphericalResolutionType& CombinedSphericalResolutionType::
    operator= (const CombinedSphericalResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CombinedRadialResolution_ = x.CombinedRadialResolution_;
        this->CombinedAzimuthalResolution_ = x.CombinedAzimuthalResolution_;
        this->CombinedPolarResolution_ = x.CombinedPolarResolution_;
      }

      return *this;
    }

    CombinedSphericalResolutionType::
    ~CombinedSphericalResolutionType ()
    {
    }

    // UserDefinedResolutionType
    //

    UserDefinedResolutionType::
    UserDefinedResolutionType ()
    : ::xsd::qif30::ResolutionBaseType (),
      CombinedUserDefinedResolution_ (this),
      ABCResolution_ (this)
    {
    }

    UserDefinedResolutionType::
    UserDefinedResolutionType (const ABCResolution_type& ABCResolution)
    : ::xsd::qif30::ResolutionBaseType (),
      CombinedUserDefinedResolution_ (this),
      ABCResolution_ (ABCResolution, this)
    {
    }

    UserDefinedResolutionType::
    UserDefinedResolutionType (::std::unique_ptr< ABCResolution_type > ABCResolution)
    : ::xsd::qif30::ResolutionBaseType (),
      CombinedUserDefinedResolution_ (this),
      ABCResolution_ (std::move (ABCResolution), this)
    {
    }

    UserDefinedResolutionType::
    UserDefinedResolutionType (const UserDefinedResolutionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (x, f, c),
      CombinedUserDefinedResolution_ (x.CombinedUserDefinedResolution_, f, this),
      ABCResolution_ (x.ABCResolution_, f, this)
    {
    }

    UserDefinedResolutionType::
    UserDefinedResolutionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ResolutionBaseType (e, f | ::xml_schema::flags::base, c),
      CombinedUserDefinedResolution_ (this),
      ABCResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CombinedUserDefinedResolution
        //
        if (n.name () == L"CombinedUserDefinedResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CombinedUserDefinedResolution_type > r (
            CombinedUserDefinedResolution_traits::create (i, f, this));

          if (!this->CombinedUserDefinedResolution_)
          {
            this->CombinedUserDefinedResolution_.set (::std::move (r));
            continue;
          }
        }

        // ABCResolution
        //
        if (n.name () == L"ABCResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ABCResolution_type > r (
            ABCResolution_traits::create (i, f, this));

          if (!ABCResolution_.present ())
          {
            this->ABCResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ABCResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ABCResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UserDefinedResolutionType* UserDefinedResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedResolutionType (*this, f, c);
    }

    UserDefinedResolutionType& UserDefinedResolutionType::
    operator= (const UserDefinedResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ResolutionBaseType& > (*this) = x;
        this->CombinedUserDefinedResolution_ = x.CombinedUserDefinedResolution_;
        this->ABCResolution_ = x.ABCResolution_;
      }

      return *this;
    }

    UserDefinedResolutionType::
    ~UserDefinedResolutionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UserDefinedResolutionType >
    _xsd_UserDefinedResolutionType_type_factory_init (
      L"UserDefinedResolutionType",
      L"http://qifstandards.org/xsd/qif3");

    // ABCResolutionType
    //

    ABCResolutionType::
    ABCResolutionType ()
    : ::xml_schema::type (),
      AAxisResolution_ (this),
      BAxisResolution_ (this),
      CAxisResolution_ (this)
    {
    }

    ABCResolutionType::
    ABCResolutionType (const AAxisResolution_type& AAxisResolution,
                       const BAxisResolution_type& BAxisResolution,
                       const CAxisResolution_type& CAxisResolution)
    : ::xml_schema::type (),
      AAxisResolution_ (AAxisResolution, this),
      BAxisResolution_ (BAxisResolution, this),
      CAxisResolution_ (CAxisResolution, this)
    {
    }

    ABCResolutionType::
    ABCResolutionType (::std::unique_ptr< AAxisResolution_type > AAxisResolution,
                       ::std::unique_ptr< BAxisResolution_type > BAxisResolution,
                       ::std::unique_ptr< CAxisResolution_type > CAxisResolution)
    : ::xml_schema::type (),
      AAxisResolution_ (std::move (AAxisResolution), this),
      BAxisResolution_ (std::move (BAxisResolution), this),
      CAxisResolution_ (std::move (CAxisResolution), this)
    {
    }

    ABCResolutionType::
    ABCResolutionType (const ABCResolutionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AAxisResolution_ (x.AAxisResolution_, f, this),
      BAxisResolution_ (x.BAxisResolution_, f, this),
      CAxisResolution_ (x.CAxisResolution_, f, this)
    {
    }

    ABCResolutionType::
    ABCResolutionType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AAxisResolution_ (this),
      BAxisResolution_ (this),
      CAxisResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ABCResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AAxisResolution
        //
        if (n.name () == L"AAxisResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AAxisResolution_type > r (
            AAxisResolution_traits::create (i, f, this));

          if (!AAxisResolution_.present ())
          {
            this->AAxisResolution_.set (::std::move (r));
            continue;
          }
        }

        // BAxisResolution
        //
        if (n.name () == L"BAxisResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BAxisResolution_type > r (
            BAxisResolution_traits::create (i, f, this));

          if (!BAxisResolution_.present ())
          {
            this->BAxisResolution_.set (::std::move (r));
            continue;
          }
        }

        // CAxisResolution
        //
        if (n.name () == L"CAxisResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CAxisResolution_type > r (
            CAxisResolution_traits::create (i, f, this));

          if (!CAxisResolution_.present ())
          {
            this->CAxisResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AAxisResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AAxisResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!BAxisResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BAxisResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CAxisResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CAxisResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ABCResolutionType* ABCResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ABCResolutionType (*this, f, c);
    }

    ABCResolutionType& ABCResolutionType::
    operator= (const ABCResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AAxisResolution_ = x.AAxisResolution_;
        this->BAxisResolution_ = x.BAxisResolution_;
        this->CAxisResolution_ = x.CAxisResolution_;
      }

      return *this;
    }

    ABCResolutionType::
    ~ABCResolutionType ()
    {
    }

    // CombinedUserDefinedResolutionType
    //

    CombinedUserDefinedResolutionType::
    CombinedUserDefinedResolutionType ()
    : ::xml_schema::type (),
      ACombinedResolution_ (this),
      BCombinedResolution_ (this),
      CCombinedResolution_ (this)
    {
    }

    CombinedUserDefinedResolutionType::
    CombinedUserDefinedResolutionType (const ACombinedResolution_type& ACombinedResolution,
                                       const BCombinedResolution_type& BCombinedResolution,
                                       const CCombinedResolution_type& CCombinedResolution)
    : ::xml_schema::type (),
      ACombinedResolution_ (ACombinedResolution, this),
      BCombinedResolution_ (BCombinedResolution, this),
      CCombinedResolution_ (CCombinedResolution, this)
    {
    }

    CombinedUserDefinedResolutionType::
    CombinedUserDefinedResolutionType (::std::unique_ptr< ACombinedResolution_type > ACombinedResolution,
                                       ::std::unique_ptr< BCombinedResolution_type > BCombinedResolution,
                                       ::std::unique_ptr< CCombinedResolution_type > CCombinedResolution)
    : ::xml_schema::type (),
      ACombinedResolution_ (std::move (ACombinedResolution), this),
      BCombinedResolution_ (std::move (BCombinedResolution), this),
      CCombinedResolution_ (std::move (CCombinedResolution), this)
    {
    }

    CombinedUserDefinedResolutionType::
    CombinedUserDefinedResolutionType (const CombinedUserDefinedResolutionType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ACombinedResolution_ (x.ACombinedResolution_, f, this),
      BCombinedResolution_ (x.BCombinedResolution_, f, this),
      CCombinedResolution_ (x.CCombinedResolution_, f, this)
    {
    }

    CombinedUserDefinedResolutionType::
    CombinedUserDefinedResolutionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ACombinedResolution_ (this),
      BCombinedResolution_ (this),
      CCombinedResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CombinedUserDefinedResolutionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ACombinedResolution
        //
        if (n.name () == L"ACombinedResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ACombinedResolution_type > r (
            ACombinedResolution_traits::create (i, f, this));

          if (!ACombinedResolution_.present ())
          {
            this->ACombinedResolution_.set (::std::move (r));
            continue;
          }
        }

        // BCombinedResolution
        //
        if (n.name () == L"BCombinedResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BCombinedResolution_type > r (
            BCombinedResolution_traits::create (i, f, this));

          if (!BCombinedResolution_.present ())
          {
            this->BCombinedResolution_.set (::std::move (r));
            continue;
          }
        }

        // CCombinedResolution
        //
        if (n.name () == L"CCombinedResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CCombinedResolution_type > r (
            CCombinedResolution_traits::create (i, f, this));

          if (!CCombinedResolution_.present ())
          {
            this->CCombinedResolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ACombinedResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ACombinedResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!BCombinedResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BCombinedResolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CCombinedResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CCombinedResolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CombinedUserDefinedResolutionType* CombinedUserDefinedResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CombinedUserDefinedResolutionType (*this, f, c);
    }

    CombinedUserDefinedResolutionType& CombinedUserDefinedResolutionType::
    operator= (const CombinedUserDefinedResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ACombinedResolution_ = x.ACombinedResolution_;
        this->BCombinedResolution_ = x.BCombinedResolution_;
        this->CCombinedResolution_ = x.CCombinedResolution_;
      }

      return *this;
    }

    CombinedUserDefinedResolutionType::
    ~CombinedUserDefinedResolutionType ()
    {
    }

    // CalibrationMasterType
    //

    CalibrationMasterType::
    CalibrationMasterType ()
    : ::xml_schema::type (),
      SerialNumber_ (this),
      Description_ (this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const SerialNumber_type& SerialNumber)
    : ::xml_schema::type (),
      SerialNumber_ (SerialNumber, this),
      Description_ (this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const CalibrationMasterType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SerialNumber_ (x.SerialNumber_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SerialNumber_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CalibrationMasterType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SerialNumber
        //
        if (n.name () == L"SerialNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!SerialNumber_.present ())
          {
            this->SerialNumber_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SerialNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SerialNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CalibrationMasterType* CalibrationMasterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationMasterType (*this, f, c);
    }

    CalibrationMasterType& CalibrationMasterType::
    operator= (const CalibrationMasterType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SerialNumber_ = x.SerialNumber_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    CalibrationMasterType::
    ~CalibrationMasterType ()
    {
    }

    // CalibrationType
    //

    CalibrationType::
    CalibrationType ()
    : ::xml_schema::type (),
      CalibrationMaster_ (this),
      Temperatures_ (this),
      CalibrationDate_ (this),
      ExpirationDate_ (this)
    {
    }

    CalibrationType::
    CalibrationType (const ExpirationDate_type& ExpirationDate)
    : ::xml_schema::type (),
      CalibrationMaster_ (this),
      Temperatures_ (this),
      CalibrationDate_ (this),
      ExpirationDate_ (ExpirationDate, this)
    {
    }

    CalibrationType::
    CalibrationType (const CalibrationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CalibrationMaster_ (x.CalibrationMaster_, f, this),
      Temperatures_ (x.Temperatures_, f, this),
      CalibrationDate_ (x.CalibrationDate_, f, this),
      ExpirationDate_ (x.ExpirationDate_, f, this)
    {
    }

    CalibrationType::
    CalibrationType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CalibrationMaster_ (this),
      Temperatures_ (this),
      CalibrationDate_ (this),
      ExpirationDate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CalibrationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CalibrationMaster
        //
        if (n.name () == L"CalibrationMaster" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CalibrationMaster_type > r (
            CalibrationMaster_traits::create (i, f, this));

          if (!this->CalibrationMaster_)
          {
            this->CalibrationMaster_.set (::std::move (r));
            continue;
          }
        }

        // Temperatures
        //
        if (n.name () == L"Temperatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Temperatures_type > r (
            Temperatures_traits::create (i, f, this));

          if (!this->Temperatures_)
          {
            this->Temperatures_.set (::std::move (r));
            continue;
          }
        }

        // CalibrationDate
        //
        if (n.name () == L"CalibrationDate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CalibrationDate_type > r (
            CalibrationDate_traits::create (i, f, this));

          if (!this->CalibrationDate_)
          {
            this->CalibrationDate_.set (::std::move (r));
            continue;
          }
        }

        // ExpirationDate
        //
        if (n.name () == L"ExpirationDate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExpirationDate_type > r (
            ExpirationDate_traits::create (i, f, this));

          if (!ExpirationDate_.present ())
          {
            this->ExpirationDate_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ExpirationDate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ExpirationDate",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CalibrationType* CalibrationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationType (*this, f, c);
    }

    CalibrationType& CalibrationType::
    operator= (const CalibrationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CalibrationMaster_ = x.CalibrationMaster_;
        this->Temperatures_ = x.Temperatures_;
        this->CalibrationDate_ = x.CalibrationDate_;
        this->ExpirationDate_ = x.ExpirationDate_;
      }

      return *this;
    }

    CalibrationType::
    ~CalibrationType ()
    {
    }

    // CalibrationsType
    //

    CalibrationsType::
    CalibrationsType ()
    : ::xml_schema::type (),
      Calibration_ (this),
      n_ (this)
    {
    }

    CalibrationsType::
    CalibrationsType (const n_type& n)
    : ::xml_schema::type (),
      Calibration_ (this),
      n_ (n, this)
    {
    }

    CalibrationsType::
    CalibrationsType (const CalibrationsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Calibration_ (x.Calibration_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CalibrationsType::
    CalibrationsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Calibration_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CalibrationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Calibration
        //
        if (n.name () == L"Calibration" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Calibration_type > r (
            Calibration_traits::create (i, f, this));

          this->Calibration_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CalibrationsType* CalibrationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationsType (*this, f, c);
    }

    CalibrationsType& CalibrationsType::
    operator= (const CalibrationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Calibration_ = x.Calibration_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CalibrationsType::
    ~CalibrationsType ()
    {
    }

    // QualificationsType
    //

    QualificationsType::
    QualificationsType ()
    : ::xml_schema::type (),
      Qualification_ (this),
      n_ (this)
    {
    }

    QualificationsType::
    QualificationsType (const n_type& n)
    : ::xml_schema::type (),
      Qualification_ (this),
      n_ (n, this)
    {
    }

    QualificationsType::
    QualificationsType (const QualificationsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Qualification_ (x.Qualification_, f, this),
      n_ (x.n_, f, this)
    {
    }

    QualificationsType::
    QualificationsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Qualification_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void QualificationsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Qualification
        //
        if (n.name () == L"Qualification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Qualification_type > r (
            Qualification_traits::create (i, f, this));

          this->Qualification_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    QualificationsType* QualificationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationsType (*this, f, c);
    }

    QualificationsType& QualificationsType::
    operator= (const QualificationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Qualification_ = x.Qualification_;
        this->n_ = x.n_;
      }

      return *this;
    }

    QualificationsType::
    ~QualificationsType ()
    {
    }

    // QualificationType
    //

    QualificationType::
    QualificationType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Description_ (this)
    {
    }

    QualificationType::
    QualificationType (const Description_type& Description)
    : ::xml_schema::type (),
      Attributes_ (this),
      Description_ (Description, this)
    {
    }

    QualificationType::
    QualificationType (const QualificationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    QualificationType::
    QualificationType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QualificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Description",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    QualificationType* QualificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationType (*this, f, c);
    }

    QualificationType& QualificationType::
    operator= (const QualificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    QualificationType::
    ~QualificationType ()
    {
    }

    // TemperaturesType
    //

    TemperaturesType::
    TemperaturesType ()
    : ::xml_schema::type (),
      Temperature_ (this),
      n_ (this)
    {
    }

    TemperaturesType::
    TemperaturesType (const n_type& n)
    : ::xml_schema::type (),
      Temperature_ (this),
      n_ (n, this)
    {
    }

    TemperaturesType::
    TemperaturesType (const TemperaturesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Temperature_ (x.Temperature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TemperaturesType::
    TemperaturesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Temperature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TemperaturesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Temperature
        //
        if (n.name () == L"Temperature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          this->Temperature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TemperaturesType* TemperaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperaturesType (*this, f, c);
    }

    TemperaturesType& TemperaturesType::
    operator= (const TemperaturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Temperature_ = x.Temperature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TemperaturesType::
    ~TemperaturesType ()
    {
    }

    // TemperatureType
    //

    TemperatureType::
    TemperatureType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Temperature_ (this),
      TimeStamp_ (this)
    {
    }

    TemperatureType::
    TemperatureType (const Temperature_type& Temperature)
    : ::xml_schema::type (),
      Attributes_ (this),
      Temperature_ (Temperature, this),
      TimeStamp_ (this)
    {
    }

    TemperatureType::
    TemperatureType (::std::unique_ptr< Temperature_type > Temperature)
    : ::xml_schema::type (),
      Attributes_ (this),
      Temperature_ (std::move (Temperature), this),
      TimeStamp_ (this)
    {
    }

    TemperatureType::
    TemperatureType (const TemperatureType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Temperature_ (x.Temperature_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this)
    {
    }

    TemperatureType::
    TemperatureType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Temperature_ (this),
      TimeStamp_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Temperature
        //
        if (n.name () == L"Temperature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          if (!Temperature_.present ())
          {
            this->Temperature_.set (::std::move (r));
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == L"TimeStamp" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!this->TimeStamp_)
          {
            this->TimeStamp_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Temperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Temperature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TemperatureType* TemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureType (*this, f, c);
    }

    TemperatureType& TemperatureType::
    operator= (const TemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Temperature_ = x.Temperature_;
        this->TimeStamp_ = x.TimeStamp_;
      }

      return *this;
    }

    TemperatureType::
    ~TemperatureType ()
    {
    }

    // LinearVariableDifferentialTransformerEnumType
    //

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_LinearVariableDifferentialTransformerEnumType_convert ();
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_LinearVariableDifferentialTransformerEnumType_convert ();
    }

    LinearVariableDifferentialTransformerEnumType::
    LinearVariableDifferentialTransformerEnumType (const ::std::wstring& s,
                                                   const xercesc::DOMElement* e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_LinearVariableDifferentialTransformerEnumType_convert ();
    }

    LinearVariableDifferentialTransformerEnumType* LinearVariableDifferentialTransformerEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearVariableDifferentialTransformerEnumType (*this, f, c);
    }

    LinearVariableDifferentialTransformerEnumType::value LinearVariableDifferentialTransformerEnumType::
    _xsd_LinearVariableDifferentialTransformerEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LinearVariableDifferentialTransformerEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LinearVariableDifferentialTransformerEnumType_indexes_,
                        _xsd_LinearVariableDifferentialTransformerEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_LinearVariableDifferentialTransformerEnumType_indexes_ + 2 || _xsd_LinearVariableDifferentialTransformerEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LinearVariableDifferentialTransformerEnumType::
    _xsd_LinearVariableDifferentialTransformerEnumType_literals_[2] =
    {
      L"AC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER",
      L"DC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER"
    };

    const LinearVariableDifferentialTransformerEnumType::value LinearVariableDifferentialTransformerEnumType::
    _xsd_LinearVariableDifferentialTransformerEnumType_indexes_[2] =
    {
      ::xsd::qif30::LinearVariableDifferentialTransformerEnumType::AC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER,
      ::xsd::qif30::LinearVariableDifferentialTransformerEnumType::DC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER
    };

    // LinearVariableDifferentialTransformerSensorType
    //

    LinearVariableDifferentialTransformerSensorType::
    LinearVariableDifferentialTransformerSensorType ()
    : ::xsd::qif30::DetachableSensorBaseType (),
      TypeOfLinearVariableDifferentialTransformer_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      ExcitationFrequency_ (this),
      ExcitationAmplitude_ (this),
      Diameter_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      ElectronicDescription_ (this)
    {
    }

    LinearVariableDifferentialTransformerSensorType::
    LinearVariableDifferentialTransformerSensorType (const Name_type& Name,
                                                     const id_type& id)
    : ::xsd::qif30::DetachableSensorBaseType (Name,
                                              id),
      TypeOfLinearVariableDifferentialTransformer_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      ExcitationFrequency_ (this),
      ExcitationAmplitude_ (this),
      Diameter_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      ElectronicDescription_ (this)
    {
    }

    LinearVariableDifferentialTransformerSensorType::
    LinearVariableDifferentialTransformerSensorType (const LinearVariableDifferentialTransformerSensorType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (x, f, c),
      TypeOfLinearVariableDifferentialTransformer_ (x.TypeOfLinearVariableDifferentialTransformer_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      TemperatureStability_ (x.TemperatureStability_, f, this),
      ExcitationFrequency_ (x.ExcitationFrequency_, f, this),
      ExcitationAmplitude_ (x.ExcitationAmplitude_, f, this),
      Diameter_ (x.Diameter_, f, this),
      ShockTolerance_ (x.ShockTolerance_, f, this),
      VibrationTolerance_ (x.VibrationTolerance_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      ElectronicDescription_ (x.ElectronicDescription_, f, this)
    {
    }

    LinearVariableDifferentialTransformerSensorType::
    LinearVariableDifferentialTransformerSensorType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (e, f | ::xml_schema::flags::base, c),
      TypeOfLinearVariableDifferentialTransformer_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      ExcitationFrequency_ (this),
      ExcitationAmplitude_ (this),
      Diameter_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      ElectronicDescription_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LinearVariableDifferentialTransformerSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DetachableSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TypeOfLinearVariableDifferentialTransformer
        //
        if (n.name () == L"TypeOfLinearVariableDifferentialTransformer" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TypeOfLinearVariableDifferentialTransformer_type > r (
            TypeOfLinearVariableDifferentialTransformer_traits::create (i, f, this));

          if (!this->TypeOfLinearVariableDifferentialTransformer_)
          {
            this->TypeOfLinearVariableDifferentialTransformer_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureStability
        //
        if (n.name () == L"TemperatureStability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStability_type > r (
            TemperatureStability_traits::create (i, f, this));

          if (!this->TemperatureStability_)
          {
            this->TemperatureStability_.set (::std::move (r));
            continue;
          }
        }

        // ExcitationFrequency
        //
        if (n.name () == L"ExcitationFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExcitationFrequency_type > r (
            ExcitationFrequency_traits::create (i, f, this));

          if (!this->ExcitationFrequency_)
          {
            this->ExcitationFrequency_.set (::std::move (r));
            continue;
          }
        }

        // ExcitationAmplitude
        //
        if (n.name () == L"ExcitationAmplitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExcitationAmplitude_type > r (
            ExcitationAmplitude_traits::create (i, f, this));

          if (!this->ExcitationAmplitude_)
          {
            this->ExcitationAmplitude_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // ShockTolerance
        //
        if (n.name () == L"ShockTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShockTolerance_type > r (
            ShockTolerance_traits::create (i, f, this));

          if (!this->ShockTolerance_)
          {
            this->ShockTolerance_.set (::std::move (r));
            continue;
          }
        }

        // VibrationTolerance
        //
        if (n.name () == L"VibrationTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VibrationTolerance_type > r (
            VibrationTolerance_traits::create (i, f, this));

          if (!this->VibrationTolerance_)
          {
            this->VibrationTolerance_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // ElectronicDescription
        //
        if (n.name () == L"ElectronicDescription" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElectronicDescription_type > r (
            ElectronicDescription_traits::create (i, f, this));

          if (!this->ElectronicDescription_)
          {
            this->ElectronicDescription_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LinearVariableDifferentialTransformerSensorType* LinearVariableDifferentialTransformerSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearVariableDifferentialTransformerSensorType (*this, f, c);
    }

    LinearVariableDifferentialTransformerSensorType& LinearVariableDifferentialTransformerSensorType::
    operator= (const LinearVariableDifferentialTransformerSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DetachableSensorBaseType& > (*this) = x;
        this->TypeOfLinearVariableDifferentialTransformer_ = x.TypeOfLinearVariableDifferentialTransformer_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->TemperatureStability_ = x.TemperatureStability_;
        this->ExcitationFrequency_ = x.ExcitationFrequency_;
        this->ExcitationAmplitude_ = x.ExcitationAmplitude_;
        this->Diameter_ = x.Diameter_;
        this->ShockTolerance_ = x.ShockTolerance_;
        this->VibrationTolerance_ = x.VibrationTolerance_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->ElectronicDescription_ = x.ElectronicDescription_;
      }

      return *this;
    }

    LinearVariableDifferentialTransformerSensorType::
    ~LinearVariableDifferentialTransformerSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearVariableDifferentialTransformerSensorType >
    _xsd_LinearVariableDifferentialTransformerSensorType_type_factory_init (
      L"LinearVariableDifferentialTransformerSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // CapacitiveSensorType
    //

    CapacitiveSensorType::
    CapacitiveSensorType ()
    : ::xsd::qif30::DetachableSensorBaseType (),
      MinOperatingVoltage_ (this),
      MaxOperatingVoltage_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      MinimumTargetDiameter_ (this),
      HousingMaterial_ (this),
      Mounting_ (this)
    {
    }

    CapacitiveSensorType::
    CapacitiveSensorType (const Name_type& Name,
                          const id_type& id)
    : ::xsd::qif30::DetachableSensorBaseType (Name,
                                              id),
      MinOperatingVoltage_ (this),
      MaxOperatingVoltage_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      MinimumTargetDiameter_ (this),
      HousingMaterial_ (this),
      Mounting_ (this)
    {
    }

    CapacitiveSensorType::
    CapacitiveSensorType (const CapacitiveSensorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (x, f, c),
      MinOperatingVoltage_ (x.MinOperatingVoltage_, f, this),
      MaxOperatingVoltage_ (x.MaxOperatingVoltage_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      TemperatureStability_ (x.TemperatureStability_, f, this),
      MinimumTargetDiameter_ (x.MinimumTargetDiameter_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      Mounting_ (x.Mounting_, f, this)
    {
    }

    CapacitiveSensorType::
    CapacitiveSensorType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (e, f | ::xml_schema::flags::base, c),
      MinOperatingVoltage_ (this),
      MaxOperatingVoltage_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      MinimumTargetDiameter_ (this),
      HousingMaterial_ (this),
      Mounting_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CapacitiveSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::DetachableSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinOperatingVoltage
        //
        if (n.name () == L"MinOperatingVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinOperatingVoltage_type > r (
            MinOperatingVoltage_traits::create (i, f, this));

          if (!this->MinOperatingVoltage_)
          {
            this->MinOperatingVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MaxOperatingVoltage
        //
        if (n.name () == L"MaxOperatingVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxOperatingVoltage_type > r (
            MaxOperatingVoltage_traits::create (i, f, this));

          if (!this->MaxOperatingVoltage_)
          {
            this->MaxOperatingVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureStability
        //
        if (n.name () == L"TemperatureStability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStability_type > r (
            TemperatureStability_traits::create (i, f, this));

          if (!this->TemperatureStability_)
          {
            this->TemperatureStability_.set (::std::move (r));
            continue;
          }
        }

        // MinimumTargetDiameter
        //
        if (n.name () == L"MinimumTargetDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinimumTargetDiameter_type > r (
            MinimumTargetDiameter_traits::create (i, f, this));

          if (!this->MinimumTargetDiameter_)
          {
            this->MinimumTargetDiameter_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // Mounting
        //
        if (n.name () == L"Mounting" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Mounting_type > r (
            Mounting_traits::create (i, f, this));

          if (!this->Mounting_)
          {
            this->Mounting_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CapacitiveSensorType* CapacitiveSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CapacitiveSensorType (*this, f, c);
    }

    CapacitiveSensorType& CapacitiveSensorType::
    operator= (const CapacitiveSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::DetachableSensorBaseType& > (*this) = x;
        this->MinOperatingVoltage_ = x.MinOperatingVoltage_;
        this->MaxOperatingVoltage_ = x.MaxOperatingVoltage_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->TemperatureStability_ = x.TemperatureStability_;
        this->MinimumTargetDiameter_ = x.MinimumTargetDiameter_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->Mounting_ = x.Mounting_;
      }

      return *this;
    }

    CapacitiveSensorType::
    ~CapacitiveSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CapacitiveSensorType >
    _xsd_CapacitiveSensorType_type_factory_init (
      L"CapacitiveSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // EddyCurrentSensorType
    //

    EddyCurrentSensorType::
    EddyCurrentSensorType ()
    : ::xsd::qif30::SensorType (),
      MaxPressureFront_ (this),
      MaxPressureSide_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      OffsetDistance_ (this),
      FrequencyResponse_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      HousingMaterial_ (this),
      MeasurementObjectMaterial_ (this)
    {
    }

    EddyCurrentSensorType::
    EddyCurrentSensorType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      MaxPressureFront_ (this),
      MaxPressureSide_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      OffsetDistance_ (this),
      FrequencyResponse_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      HousingMaterial_ (this),
      MeasurementObjectMaterial_ (this)
    {
    }

    EddyCurrentSensorType::
    EddyCurrentSensorType (const EddyCurrentSensorType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      MaxPressureFront_ (x.MaxPressureFront_, f, this),
      MaxPressureSide_ (x.MaxPressureSide_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      TemperatureStability_ (x.TemperatureStability_, f, this),
      OffsetDistance_ (x.OffsetDistance_, f, this),
      FrequencyResponse_ (x.FrequencyResponse_, f, this),
      MinPowerSupplyVoltage_ (x.MinPowerSupplyVoltage_, f, this),
      MaxPowerSupplyVoltage_ (x.MaxPowerSupplyVoltage_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      MeasurementObjectMaterial_ (x.MeasurementObjectMaterial_, f, this)
    {
    }

    EddyCurrentSensorType::
    EddyCurrentSensorType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      MaxPressureFront_ (this),
      MaxPressureSide_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      TemperatureStability_ (this),
      OffsetDistance_ (this),
      FrequencyResponse_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      HousingMaterial_ (this),
      MeasurementObjectMaterial_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EddyCurrentSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxPressureFront
        //
        if (n.name () == L"MaxPressureFront" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPressureFront_type > r (
            MaxPressureFront_traits::create (i, f, this));

          if (!this->MaxPressureFront_)
          {
            this->MaxPressureFront_.set (::std::move (r));
            continue;
          }
        }

        // MaxPressureSide
        //
        if (n.name () == L"MaxPressureSide" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPressureSide_type > r (
            MaxPressureSide_traits::create (i, f, this));

          if (!this->MaxPressureSide_)
          {
            this->MaxPressureSide_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureStability
        //
        if (n.name () == L"TemperatureStability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStability_type > r (
            TemperatureStability_traits::create (i, f, this));

          if (!this->TemperatureStability_)
          {
            this->TemperatureStability_.set (::std::move (r));
            continue;
          }
        }

        // OffsetDistance
        //
        if (n.name () == L"OffsetDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OffsetDistance_type > r (
            OffsetDistance_traits::create (i, f, this));

          if (!this->OffsetDistance_)
          {
            this->OffsetDistance_.set (::std::move (r));
            continue;
          }
        }

        // FrequencyResponse
        //
        if (n.name () == L"FrequencyResponse" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FrequencyResponse_type > r (
            FrequencyResponse_traits::create (i, f, this));

          if (!this->FrequencyResponse_)
          {
            this->FrequencyResponse_.set (::std::move (r));
            continue;
          }
        }

        // MinPowerSupplyVoltage
        //
        if (n.name () == L"MinPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPowerSupplyVoltage_type > r (
            MinPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MinPowerSupplyVoltage_)
          {
            this->MinPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MaxPowerSupplyVoltage
        //
        if (n.name () == L"MaxPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPowerSupplyVoltage_type > r (
            MaxPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MaxPowerSupplyVoltage_)
          {
            this->MaxPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementObjectMaterial
        //
        if (n.name () == L"MeasurementObjectMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementObjectMaterial_type > r (
            MeasurementObjectMaterial_traits::create (i, f, this));

          if (!this->MeasurementObjectMaterial_)
          {
            this->MeasurementObjectMaterial_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EddyCurrentSensorType* EddyCurrentSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EddyCurrentSensorType (*this, f, c);
    }

    EddyCurrentSensorType& EddyCurrentSensorType::
    operator= (const EddyCurrentSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->MaxPressureFront_ = x.MaxPressureFront_;
        this->MaxPressureSide_ = x.MaxPressureSide_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->TemperatureStability_ = x.TemperatureStability_;
        this->OffsetDistance_ = x.OffsetDistance_;
        this->FrequencyResponse_ = x.FrequencyResponse_;
        this->MinPowerSupplyVoltage_ = x.MinPowerSupplyVoltage_;
        this->MaxPowerSupplyVoltage_ = x.MaxPowerSupplyVoltage_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->MeasurementObjectMaterial_ = x.MeasurementObjectMaterial_;
      }

      return *this;
    }

    EddyCurrentSensorType::
    ~EddyCurrentSensorType ()
    {
    }

    // ConfocalChromaticSensorType
    //

    ConfocalChromaticSensorType::
    ConfocalChromaticSensorType ()
    : ::xsd::qif30::SensorType (),
      SpotDiameter_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MultiPeakMeasurement_ (this),
      LightSource_ (this),
      MaxTilt_ (this),
      HousingMaterial_ (this),
      OpticalFiberCableLength_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this)
    {
    }

    ConfocalChromaticSensorType::
    ConfocalChromaticSensorType (const Name_type& Name,
                                 const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      SpotDiameter_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MultiPeakMeasurement_ (this),
      LightSource_ (this),
      MaxTilt_ (this),
      HousingMaterial_ (this),
      OpticalFiberCableLength_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this)
    {
    }

    ConfocalChromaticSensorType::
    ConfocalChromaticSensorType (const ConfocalChromaticSensorType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      SpotDiameter_ (x.SpotDiameter_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      MultiPeakMeasurement_ (x.MultiPeakMeasurement_, f, this),
      LightSource_ (x.LightSource_, f, this),
      MaxTilt_ (x.MaxTilt_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      OpticalFiberCableLength_ (x.OpticalFiberCableLength_, f, this),
      ShockTolerance_ (x.ShockTolerance_, f, this),
      VibrationTolerance_ (x.VibrationTolerance_, f, this)
    {
    }

    ConfocalChromaticSensorType::
    ConfocalChromaticSensorType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      SpotDiameter_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MultiPeakMeasurement_ (this),
      LightSource_ (this),
      MaxTilt_ (this),
      HousingMaterial_ (this),
      OpticalFiberCableLength_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConfocalChromaticSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SpotDiameter
        //
        if (n.name () == L"SpotDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpotDiameter_type > r (
            SpotDiameter_traits::create (i, f, this));

          if (!this->SpotDiameter_)
          {
            this->SpotDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MultiPeakMeasurement
        //
        if (n.name () == L"MultiPeakMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->MultiPeakMeasurement_)
          {
            this->MultiPeakMeasurement_.set (MultiPeakMeasurement_traits::create (i, f, this));
            continue;
          }
        }

        // LightSource
        //
        if (n.name () == L"LightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LightSource_type > r (
            LightSource_traits::create (i, f, this));

          if (!this->LightSource_)
          {
            this->LightSource_.set (::std::move (r));
            continue;
          }
        }

        // MaxTilt
        //
        if (n.name () == L"MaxTilt" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxTilt_type > r (
            MaxTilt_traits::create (i, f, this));

          if (!this->MaxTilt_)
          {
            this->MaxTilt_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // OpticalFiberCableLength
        //
        if (n.name () == L"OpticalFiberCableLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OpticalFiberCableLength_type > r (
            OpticalFiberCableLength_traits::create (i, f, this));

          if (!this->OpticalFiberCableLength_)
          {
            this->OpticalFiberCableLength_.set (::std::move (r));
            continue;
          }
        }

        // ShockTolerance
        //
        if (n.name () == L"ShockTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShockTolerance_type > r (
            ShockTolerance_traits::create (i, f, this));

          if (!this->ShockTolerance_)
          {
            this->ShockTolerance_.set (::std::move (r));
            continue;
          }
        }

        // VibrationTolerance
        //
        if (n.name () == L"VibrationTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VibrationTolerance_type > r (
            VibrationTolerance_traits::create (i, f, this));

          if (!this->VibrationTolerance_)
          {
            this->VibrationTolerance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConfocalChromaticSensorType* ConfocalChromaticSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConfocalChromaticSensorType (*this, f, c);
    }

    ConfocalChromaticSensorType& ConfocalChromaticSensorType::
    operator= (const ConfocalChromaticSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->SpotDiameter_ = x.SpotDiameter_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->MultiPeakMeasurement_ = x.MultiPeakMeasurement_;
        this->LightSource_ = x.LightSource_;
        this->MaxTilt_ = x.MaxTilt_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->OpticalFiberCableLength_ = x.OpticalFiberCableLength_;
        this->ShockTolerance_ = x.ShockTolerance_;
        this->VibrationTolerance_ = x.VibrationTolerance_;
      }

      return *this;
    }

    ConfocalChromaticSensorType::
    ~ConfocalChromaticSensorType ()
    {
    }

    // DrawWireSensorType
    //

    DrawWireSensorType::
    DrawWireSensorType ()
    : ::xsd::qif30::SensorType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MaxWireExtensionForce_ (this),
      MinWireRetractionForce_ (this),
      MaxWireAcceleration_ (this)
    {
    }

    DrawWireSensorType::
    DrawWireSensorType (const Name_type& Name,
                        const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MaxWireExtensionForce_ (this),
      MinWireRetractionForce_ (this),
      MaxWireAcceleration_ (this)
    {
    }

    DrawWireSensorType::
    DrawWireSensorType (const DrawWireSensorType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      MaxWireExtensionForce_ (x.MaxWireExtensionForce_, f, this),
      MinWireRetractionForce_ (x.MinWireRetractionForce_, f, this),
      MaxWireAcceleration_ (x.MaxWireAcceleration_, f, this)
    {
    }

    DrawWireSensorType::
    DrawWireSensorType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MaxWireExtensionForce_ (this),
      MinWireRetractionForce_ (this),
      MaxWireAcceleration_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DrawWireSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxWireExtensionForce
        //
        if (n.name () == L"MaxWireExtensionForce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWireExtensionForce_type > r (
            MaxWireExtensionForce_traits::create (i, f, this));

          if (!this->MaxWireExtensionForce_)
          {
            this->MaxWireExtensionForce_.set (::std::move (r));
            continue;
          }
        }

        // MinWireRetractionForce
        //
        if (n.name () == L"MinWireRetractionForce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinWireRetractionForce_type > r (
            MinWireRetractionForce_traits::create (i, f, this));

          if (!this->MinWireRetractionForce_)
          {
            this->MinWireRetractionForce_.set (::std::move (r));
            continue;
          }
        }

        // MaxWireAcceleration
        //
        if (n.name () == L"MaxWireAcceleration" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWireAcceleration_type > r (
            MaxWireAcceleration_traits::create (i, f, this));

          if (!this->MaxWireAcceleration_)
          {
            this->MaxWireAcceleration_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DrawWireSensorType* DrawWireSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DrawWireSensorType (*this, f, c);
    }

    DrawWireSensorType& DrawWireSensorType::
    operator= (const DrawWireSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->MaxWireExtensionForce_ = x.MaxWireExtensionForce_;
        this->MinWireRetractionForce_ = x.MinWireRetractionForce_;
        this->MaxWireAcceleration_ = x.MaxWireAcceleration_;
      }

      return *this;
    }

    DrawWireSensorType::
    ~DrawWireSensorType ()
    {
    }

    // MagnetoInductiveSensorType
    //

    MagnetoInductiveSensorType::
    MagnetoInductiveSensorType ()
    : ::xsd::qif30::SensorType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      FrequencyResponse_ (this),
      OffsetDistance_ (this),
      MaxPressure_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      MaxCurrentConsumption_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
    }

    MagnetoInductiveSensorType::
    MagnetoInductiveSensorType (const Name_type& Name,
                                const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      FrequencyResponse_ (this),
      OffsetDistance_ (this),
      MaxPressure_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      MaxCurrentConsumption_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
    }

    MagnetoInductiveSensorType::
    MagnetoInductiveSensorType (const MagnetoInductiveSensorType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      FrequencyResponse_ (x.FrequencyResponse_, f, this),
      OffsetDistance_ (x.OffsetDistance_, f, this),
      MaxPressure_ (x.MaxPressure_, f, this),
      ShockTolerance_ (x.ShockTolerance_, f, this),
      VibrationTolerance_ (x.VibrationTolerance_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      MaxCurrentConsumption_ (x.MaxCurrentConsumption_, f, this),
      MinPowerSupplyVoltage_ (x.MinPowerSupplyVoltage_, f, this),
      MaxPowerSupplyVoltage_ (x.MaxPowerSupplyVoltage_, f, this)
    {
    }

    MagnetoInductiveSensorType::
    MagnetoInductiveSensorType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      FrequencyResponse_ (this),
      OffsetDistance_ (this),
      MaxPressure_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      HousingMaterial_ (this),
      MaxCurrentConsumption_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MagnetoInductiveSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // FrequencyResponse
        //
        if (n.name () == L"FrequencyResponse" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FrequencyResponse_type > r (
            FrequencyResponse_traits::create (i, f, this));

          if (!this->FrequencyResponse_)
          {
            this->FrequencyResponse_.set (::std::move (r));
            continue;
          }
        }

        // OffsetDistance
        //
        if (n.name () == L"OffsetDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OffsetDistance_type > r (
            OffsetDistance_traits::create (i, f, this));

          if (!this->OffsetDistance_)
          {
            this->OffsetDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxPressure
        //
        if (n.name () == L"MaxPressure" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPressure_type > r (
            MaxPressure_traits::create (i, f, this));

          if (!this->MaxPressure_)
          {
            this->MaxPressure_.set (::std::move (r));
            continue;
          }
        }

        // ShockTolerance
        //
        if (n.name () == L"ShockTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShockTolerance_type > r (
            ShockTolerance_traits::create (i, f, this));

          if (!this->ShockTolerance_)
          {
            this->ShockTolerance_.set (::std::move (r));
            continue;
          }
        }

        // VibrationTolerance
        //
        if (n.name () == L"VibrationTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VibrationTolerance_type > r (
            VibrationTolerance_traits::create (i, f, this));

          if (!this->VibrationTolerance_)
          {
            this->VibrationTolerance_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // MaxCurrentConsumption
        //
        if (n.name () == L"MaxCurrentConsumption" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxCurrentConsumption_type > r (
            MaxCurrentConsumption_traits::create (i, f, this));

          if (!this->MaxCurrentConsumption_)
          {
            this->MaxCurrentConsumption_.set (::std::move (r));
            continue;
          }
        }

        // MinPowerSupplyVoltage
        //
        if (n.name () == L"MinPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPowerSupplyVoltage_type > r (
            MinPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MinPowerSupplyVoltage_)
          {
            this->MinPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MaxPowerSupplyVoltage
        //
        if (n.name () == L"MaxPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPowerSupplyVoltage_type > r (
            MaxPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MaxPowerSupplyVoltage_)
          {
            this->MaxPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MagnetoInductiveSensorType* MagnetoInductiveSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MagnetoInductiveSensorType (*this, f, c);
    }

    MagnetoInductiveSensorType& MagnetoInductiveSensorType::
    operator= (const MagnetoInductiveSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->FrequencyResponse_ = x.FrequencyResponse_;
        this->OffsetDistance_ = x.OffsetDistance_;
        this->MaxPressure_ = x.MaxPressure_;
        this->ShockTolerance_ = x.ShockTolerance_;
        this->VibrationTolerance_ = x.VibrationTolerance_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->MaxCurrentConsumption_ = x.MaxCurrentConsumption_;
        this->MinPowerSupplyVoltage_ = x.MinPowerSupplyVoltage_;
        this->MaxPowerSupplyVoltage_ = x.MaxPowerSupplyVoltage_;
      }

      return *this;
    }

    MagnetoInductiveSensorType::
    ~MagnetoInductiveSensorType ()
    {
    }

    // DifferentialVariableReluctanceTransducerSensorType
    //

    DifferentialVariableReluctanceTransducerSensorType::
    DifferentialVariableReluctanceTransducerSensorType ()
    : ::xsd::qif30::SensorType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      Hysteresis_ (this),
      FrequencyResponse_ (this),
      TemperatureStability_ (this),
      HousingMaterial_ (this)
    {
    }

    DifferentialVariableReluctanceTransducerSensorType::
    DifferentialVariableReluctanceTransducerSensorType (const Name_type& Name,
                                                        const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      Hysteresis_ (this),
      FrequencyResponse_ (this),
      TemperatureStability_ (this),
      HousingMaterial_ (this)
    {
    }

    DifferentialVariableReluctanceTransducerSensorType::
    DifferentialVariableReluctanceTransducerSensorType (const DifferentialVariableReluctanceTransducerSensorType& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      Hysteresis_ (x.Hysteresis_, f, this),
      FrequencyResponse_ (x.FrequencyResponse_, f, this),
      TemperatureStability_ (x.TemperatureStability_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this)
    {
    }

    DifferentialVariableReluctanceTransducerSensorType::
    DifferentialVariableReluctanceTransducerSensorType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      Hysteresis_ (this),
      FrequencyResponse_ (this),
      TemperatureStability_ (this),
      HousingMaterial_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DifferentialVariableReluctanceTransducerSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // Hysteresis
        //
        if (n.name () == L"Hysteresis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Hysteresis_type > r (
            Hysteresis_traits::create (i, f, this));

          if (!this->Hysteresis_)
          {
            this->Hysteresis_.set (::std::move (r));
            continue;
          }
        }

        // FrequencyResponse
        //
        if (n.name () == L"FrequencyResponse" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FrequencyResponse_type > r (
            FrequencyResponse_traits::create (i, f, this));

          if (!this->FrequencyResponse_)
          {
            this->FrequencyResponse_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureStability
        //
        if (n.name () == L"TemperatureStability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStability_type > r (
            TemperatureStability_traits::create (i, f, this));

          if (!this->TemperatureStability_)
          {
            this->TemperatureStability_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DifferentialVariableReluctanceTransducerSensorType* DifferentialVariableReluctanceTransducerSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DifferentialVariableReluctanceTransducerSensorType (*this, f, c);
    }

    DifferentialVariableReluctanceTransducerSensorType& DifferentialVariableReluctanceTransducerSensorType::
    operator= (const DifferentialVariableReluctanceTransducerSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->Hysteresis_ = x.Hysteresis_;
        this->FrequencyResponse_ = x.FrequencyResponse_;
        this->TemperatureStability_ = x.TemperatureStability_;
        this->HousingMaterial_ = x.HousingMaterial_;
      }

      return *this;
    }

    DifferentialVariableReluctanceTransducerSensorType::
    ~DifferentialVariableReluctanceTransducerSensorType ()
    {
    }

    // LaserTriangulationSensorType
    //

    LaserTriangulationSensorType::
    LaserTriangulationSensorType ()
    : ::xsd::qif30::SensorType (),
      AverageSpotDiameter_ (this),
      LaserSafetyClass_ (this),
      MaxMeasurementFrequency_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      HousingMaterial_ (this),
      PermissibleAmbientLight_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      OutputPower_ (this),
      Laser_ (this)
    {
    }

    LaserTriangulationSensorType::
    LaserTriangulationSensorType (const Name_type& Name,
                                  const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      AverageSpotDiameter_ (this),
      LaserSafetyClass_ (this),
      MaxMeasurementFrequency_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      HousingMaterial_ (this),
      PermissibleAmbientLight_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      OutputPower_ (this),
      Laser_ (this)
    {
    }

    LaserTriangulationSensorType::
    LaserTriangulationSensorType (const LaserTriangulationSensorType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      AverageSpotDiameter_ (x.AverageSpotDiameter_, f, this),
      LaserSafetyClass_ (x.LaserSafetyClass_, f, this),
      MaxMeasurementFrequency_ (x.MaxMeasurementFrequency_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      HousingMaterial_ (x.HousingMaterial_, f, this),
      PermissibleAmbientLight_ (x.PermissibleAmbientLight_, f, this),
      ShockTolerance_ (x.ShockTolerance_, f, this),
      VibrationTolerance_ (x.VibrationTolerance_, f, this),
      OutputPower_ (x.OutputPower_, f, this),
      Laser_ (x.Laser_, f, this)
    {
    }

    LaserTriangulationSensorType::
    LaserTriangulationSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      AverageSpotDiameter_ (this),
      LaserSafetyClass_ (this),
      MaxMeasurementFrequency_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      HousingMaterial_ (this),
      PermissibleAmbientLight_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      OutputPower_ (this),
      Laser_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LaserTriangulationSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AverageSpotDiameter
        //
        if (n.name () == L"AverageSpotDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AverageSpotDiameter_type > r (
            AverageSpotDiameter_traits::create (i, f, this));

          if (!this->AverageSpotDiameter_)
          {
            this->AverageSpotDiameter_.set (::std::move (r));
            continue;
          }
        }

        // LaserSafetyClass
        //
        if (n.name () == L"LaserSafetyClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserSafetyClass_type > r (
            LaserSafetyClass_traits::create (i, f, this));

          if (!this->LaserSafetyClass_)
          {
            this->LaserSafetyClass_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasurementFrequency
        //
        if (n.name () == L"MaxMeasurementFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasurementFrequency_type > r (
            MaxMeasurementFrequency_traits::create (i, f, this));

          if (!this->MaxMeasurementFrequency_)
          {
            this->MaxMeasurementFrequency_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // HousingMaterial
        //
        if (n.name () == L"HousingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HousingMaterial_type > r (
            HousingMaterial_traits::create (i, f, this));

          if (!this->HousingMaterial_)
          {
            this->HousingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // PermissibleAmbientLight
        //
        if (n.name () == L"PermissibleAmbientLight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PermissibleAmbientLight_type > r (
            PermissibleAmbientLight_traits::create (i, f, this));

          if (!this->PermissibleAmbientLight_)
          {
            this->PermissibleAmbientLight_.set (::std::move (r));
            continue;
          }
        }

        // ShockTolerance
        //
        if (n.name () == L"ShockTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShockTolerance_type > r (
            ShockTolerance_traits::create (i, f, this));

          if (!this->ShockTolerance_)
          {
            this->ShockTolerance_.set (::std::move (r));
            continue;
          }
        }

        // VibrationTolerance
        //
        if (n.name () == L"VibrationTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VibrationTolerance_type > r (
            VibrationTolerance_traits::create (i, f, this));

          if (!this->VibrationTolerance_)
          {
            this->VibrationTolerance_.set (::std::move (r));
            continue;
          }
        }

        // OutputPower
        //
        if (n.name () == L"OutputPower" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OutputPower_type > r (
            OutputPower_traits::create (i, f, this));

          if (!this->OutputPower_)
          {
            this->OutputPower_.set (::std::move (r));
            continue;
          }
        }

        // Laser
        //
        if (n.name () == L"Laser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Laser_type > r (
            Laser_traits::create (i, f, this));

          if (!this->Laser_)
          {
            this->Laser_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LaserTriangulationSensorType* LaserTriangulationSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserTriangulationSensorType (*this, f, c);
    }

    LaserTriangulationSensorType& LaserTriangulationSensorType::
    operator= (const LaserTriangulationSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->AverageSpotDiameter_ = x.AverageSpotDiameter_;
        this->LaserSafetyClass_ = x.LaserSafetyClass_;
        this->MaxMeasurementFrequency_ = x.MaxMeasurementFrequency_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->HousingMaterial_ = x.HousingMaterial_;
        this->PermissibleAmbientLight_ = x.PermissibleAmbientLight_;
        this->ShockTolerance_ = x.ShockTolerance_;
        this->VibrationTolerance_ = x.VibrationTolerance_;
        this->OutputPower_ = x.OutputPower_;
        this->Laser_ = x.Laser_;
      }

      return *this;
    }

    LaserTriangulationSensorType::
    ~LaserTriangulationSensorType ()
    {
    }

    // StructuredLightSensorType
    //

    StructuredLightSensorType::
    StructuredLightSensorType ()
    : ::xsd::qif30::SensorType (),
      OutputFileFormat_ (this),
      MeasurementFieldSize_ (this),
      NumberOfCameraPixels_ (this),
      LightSource_ (this),
      MeasurementRate_ (this),
      WorkingVolume_ (this),
      StandOffDistance_ (this),
      MaxPermissibleProbingError_ (this),
      Laser_ (this)
    {
    }

    StructuredLightSensorType::
    StructuredLightSensorType (const Name_type& Name,
                               const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      OutputFileFormat_ (this),
      MeasurementFieldSize_ (this),
      NumberOfCameraPixels_ (this),
      LightSource_ (this),
      MeasurementRate_ (this),
      WorkingVolume_ (this),
      StandOffDistance_ (this),
      MaxPermissibleProbingError_ (this),
      Laser_ (this)
    {
    }

    StructuredLightSensorType::
    StructuredLightSensorType (const StructuredLightSensorType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      OutputFileFormat_ (x.OutputFileFormat_, f, this),
      MeasurementFieldSize_ (x.MeasurementFieldSize_, f, this),
      NumberOfCameraPixels_ (x.NumberOfCameraPixels_, f, this),
      LightSource_ (x.LightSource_, f, this),
      MeasurementRate_ (x.MeasurementRate_, f, this),
      WorkingVolume_ (x.WorkingVolume_, f, this),
      StandOffDistance_ (x.StandOffDistance_, f, this),
      MaxPermissibleProbingError_ (x.MaxPermissibleProbingError_, f, this),
      Laser_ (x.Laser_, f, this)
    {
    }

    StructuredLightSensorType::
    StructuredLightSensorType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      OutputFileFormat_ (this),
      MeasurementFieldSize_ (this),
      NumberOfCameraPixels_ (this),
      LightSource_ (this),
      MeasurementRate_ (this),
      WorkingVolume_ (this),
      StandOffDistance_ (this),
      MaxPermissibleProbingError_ (this),
      Laser_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StructuredLightSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // OutputFileFormat
        //
        if (n.name () == L"OutputFileFormat" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OutputFileFormat_type > r (
            OutputFileFormat_traits::create (i, f, this));

          if (!this->OutputFileFormat_)
          {
            this->OutputFileFormat_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementFieldSize
        //
        if (n.name () == L"MeasurementFieldSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementFieldSize_type > r (
            MeasurementFieldSize_traits::create (i, f, this));

          if (!this->MeasurementFieldSize_)
          {
            this->MeasurementFieldSize_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfCameraPixels
        //
        if (n.name () == L"NumberOfCameraPixels" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NumberOfCameraPixels_)
          {
            this->NumberOfCameraPixels_.set (NumberOfCameraPixels_traits::create (i, f, this));
            continue;
          }
        }

        // LightSource
        //
        if (n.name () == L"LightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LightSource_type > r (
            LightSource_traits::create (i, f, this));

          if (!this->LightSource_)
          {
            this->LightSource_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementRate
        //
        if (n.name () == L"MeasurementRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementRate_type > r (
            MeasurementRate_traits::create (i, f, this));

          if (!this->MeasurementRate_)
          {
            this->MeasurementRate_.set (::std::move (r));
            continue;
          }
        }

        // WorkingVolume
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"WorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->WorkingVolume_)
            {
              ::std::unique_ptr< WorkingVolume_type > r (
                dynamic_cast< WorkingVolume_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->WorkingVolume_.set (::std::move (r));
              continue;
            }
          }
        }

        // StandOffDistance
        //
        if (n.name () == L"StandOffDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandOffDistance_type > r (
            StandOffDistance_traits::create (i, f, this));

          if (!this->StandOffDistance_)
          {
            this->StandOffDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxPermissibleProbingError
        //
        if (n.name () == L"MaxPermissibleProbingError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPermissibleProbingError_type > r (
            MaxPermissibleProbingError_traits::create (i, f, this));

          if (!this->MaxPermissibleProbingError_)
          {
            this->MaxPermissibleProbingError_.set (::std::move (r));
            continue;
          }
        }

        // Laser
        //
        if (n.name () == L"Laser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Laser_type > r (
            Laser_traits::create (i, f, this));

          if (!this->Laser_)
          {
            this->Laser_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StructuredLightSensorType* StructuredLightSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StructuredLightSensorType (*this, f, c);
    }

    StructuredLightSensorType& StructuredLightSensorType::
    operator= (const StructuredLightSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->OutputFileFormat_ = x.OutputFileFormat_;
        this->MeasurementFieldSize_ = x.MeasurementFieldSize_;
        this->NumberOfCameraPixels_ = x.NumberOfCameraPixels_;
        this->LightSource_ = x.LightSource_;
        this->MeasurementRate_ = x.MeasurementRate_;
        this->WorkingVolume_ = x.WorkingVolume_;
        this->StandOffDistance_ = x.StandOffDistance_;
        this->MaxPermissibleProbingError_ = x.MaxPermissibleProbingError_;
        this->Laser_ = x.Laser_;
      }

      return *this;
    }

    StructuredLightSensorType::
    ~StructuredLightSensorType ()
    {
    }

    // UltrasonicSensorType
    //

    UltrasonicSensorType::
    UltrasonicSensorType ()
    : ::xsd::qif30::SensorType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      SamplingFrequency_ (this),
      AppliedFrequency_ (this),
      MaxResponseTime_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
    }

    UltrasonicSensorType::
    UltrasonicSensorType (const Name_type& Name,
                          const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      SamplingFrequency_ (this),
      AppliedFrequency_ (this),
      MaxResponseTime_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
    }

    UltrasonicSensorType::
    UltrasonicSensorType (const UltrasonicSensorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      SamplingFrequency_ (x.SamplingFrequency_, f, this),
      AppliedFrequency_ (x.AppliedFrequency_, f, this),
      MaxResponseTime_ (x.MaxResponseTime_, f, this),
      ShockTolerance_ (x.ShockTolerance_, f, this),
      VibrationTolerance_ (x.VibrationTolerance_, f, this),
      MinPowerSupplyVoltage_ (x.MinPowerSupplyVoltage_, f, this),
      MaxPowerSupplyVoltage_ (x.MaxPowerSupplyVoltage_, f, this)
    {
    }

    UltrasonicSensorType::
    UltrasonicSensorType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      SamplingFrequency_ (this),
      AppliedFrequency_ (this),
      MaxResponseTime_ (this),
      ShockTolerance_ (this),
      VibrationTolerance_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void UltrasonicSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // SamplingFrequency
        //
        if (n.name () == L"SamplingFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingFrequency_type > r (
            SamplingFrequency_traits::create (i, f, this));

          if (!this->SamplingFrequency_)
          {
            this->SamplingFrequency_.set (::std::move (r));
            continue;
          }
        }

        // AppliedFrequency
        //
        if (n.name () == L"AppliedFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AppliedFrequency_type > r (
            AppliedFrequency_traits::create (i, f, this));

          if (!this->AppliedFrequency_)
          {
            this->AppliedFrequency_.set (::std::move (r));
            continue;
          }
        }

        // MaxResponseTime
        //
        if (n.name () == L"MaxResponseTime" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxResponseTime_type > r (
            MaxResponseTime_traits::create (i, f, this));

          if (!this->MaxResponseTime_)
          {
            this->MaxResponseTime_.set (::std::move (r));
            continue;
          }
        }

        // ShockTolerance
        //
        if (n.name () == L"ShockTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShockTolerance_type > r (
            ShockTolerance_traits::create (i, f, this));

          if (!this->ShockTolerance_)
          {
            this->ShockTolerance_.set (::std::move (r));
            continue;
          }
        }

        // VibrationTolerance
        //
        if (n.name () == L"VibrationTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VibrationTolerance_type > r (
            VibrationTolerance_traits::create (i, f, this));

          if (!this->VibrationTolerance_)
          {
            this->VibrationTolerance_.set (::std::move (r));
            continue;
          }
        }

        // MinPowerSupplyVoltage
        //
        if (n.name () == L"MinPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPowerSupplyVoltage_type > r (
            MinPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MinPowerSupplyVoltage_)
          {
            this->MinPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MaxPowerSupplyVoltage
        //
        if (n.name () == L"MaxPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPowerSupplyVoltage_type > r (
            MaxPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MaxPowerSupplyVoltage_)
          {
            this->MaxPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UltrasonicSensorType* UltrasonicSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UltrasonicSensorType (*this, f, c);
    }

    UltrasonicSensorType& UltrasonicSensorType::
    operator= (const UltrasonicSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->SamplingFrequency_ = x.SamplingFrequency_;
        this->AppliedFrequency_ = x.AppliedFrequency_;
        this->MaxResponseTime_ = x.MaxResponseTime_;
        this->ShockTolerance_ = x.ShockTolerance_;
        this->VibrationTolerance_ = x.VibrationTolerance_;
        this->MinPowerSupplyVoltage_ = x.MinPowerSupplyVoltage_;
        this->MaxPowerSupplyVoltage_ = x.MaxPowerSupplyVoltage_;
      }

      return *this;
    }

    UltrasonicSensorType::
    ~UltrasonicSensorType ()
    {
    }

    // TipEndGeometryEnumType
    //

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_TipEndGeometryEnumType_convert ();
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_TipEndGeometryEnumType_convert ();
    }

    TipEndGeometryEnumType::
    TipEndGeometryEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_TipEndGeometryEnumType_convert ();
    }

    TipEndGeometryEnumType* TipEndGeometryEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TipEndGeometryEnumType (*this, f, c);
    }

    TipEndGeometryEnumType::value TipEndGeometryEnumType::
    _xsd_TipEndGeometryEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_TipEndGeometryEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TipEndGeometryEnumType_indexes_,
                        _xsd_TipEndGeometryEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_TipEndGeometryEnumType_indexes_ + 6 || _xsd_TipEndGeometryEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const TipEndGeometryEnumType::
    _xsd_TipEndGeometryEnumType_literals_[6] =
    {
      L"SPHERE",
      L"CYLINDER",
      L"CYLINDER_WITH_SPHERE",
      L"HEMISPHERE",
      L"SPHERICAL_DISC",
      L"POINT"
    };

    const TipEndGeometryEnumType::value TipEndGeometryEnumType::
    _xsd_TipEndGeometryEnumType_indexes_[6] =
    {
      ::xsd::qif30::TipEndGeometryEnumType::CYLINDER,
      ::xsd::qif30::TipEndGeometryEnumType::CYLINDER_WITH_SPHERE,
      ::xsd::qif30::TipEndGeometryEnumType::HEMISPHERE,
      ::xsd::qif30::TipEndGeometryEnumType::POINT,
      ::xsd::qif30::TipEndGeometryEnumType::SPHERE,
      ::xsd::qif30::TipEndGeometryEnumType::SPHERICAL_DISC
    };

    // TipEndGeometryType
    //

    TipEndGeometryType::
    TipEndGeometryType ()
    : ::xml_schema::type (),
      TipEndGeometryEnum_ (this),
      OtherTipEndGeometry_ (this)
    {
    }

    TipEndGeometryType::
    TipEndGeometryType (const TipEndGeometryType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TipEndGeometryEnum_ (x.TipEndGeometryEnum_, f, this),
      OtherTipEndGeometry_ (x.OtherTipEndGeometry_, f, this)
    {
    }

    TipEndGeometryType::
    TipEndGeometryType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TipEndGeometryEnum_ (this),
      OtherTipEndGeometry_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TipEndGeometryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TipEndGeometryEnum
        //
        if (n.name () == L"TipEndGeometryEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndGeometryEnum_type > r (
            TipEndGeometryEnum_traits::create (i, f, this));

          if (!this->TipEndGeometryEnum_)
          {
            this->TipEndGeometryEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherTipEndGeometry
        //
        if (n.name () == L"OtherTipEndGeometry" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherTipEndGeometry_type > r (
            OtherTipEndGeometry_traits::create (i, f, this));

          if (!this->OtherTipEndGeometry_)
          {
            this->OtherTipEndGeometry_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TipEndGeometryType* TipEndGeometryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TipEndGeometryType (*this, f, c);
    }

    TipEndGeometryType& TipEndGeometryType::
    operator= (const TipEndGeometryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TipEndGeometryEnum_ = x.TipEndGeometryEnum_;
        this->OtherTipEndGeometry_ = x.OtherTipEndGeometry_;
      }

      return *this;
    }

    TipEndGeometryType::
    ~TipEndGeometryType ()
    {
    }

    // TactileProbeSensorBaseType
    //

    TactileProbeSensorBaseType::
    TactileProbeSensorBaseType ()
    : ::xsd::qif30::DetachableSensorBaseType ()
    {
    }

    TactileProbeSensorBaseType::
    TactileProbeSensorBaseType (const Name_type& Name,
                                const id_type& id)
    : ::xsd::qif30::DetachableSensorBaseType (Name,
                                              id)
    {
    }

    TactileProbeSensorBaseType::
    TactileProbeSensorBaseType (const TactileProbeSensorBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (x, f, c)
    {
    }

    TactileProbeSensorBaseType::
    TactileProbeSensorBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::DetachableSensorBaseType (e, f, c)
    {
    }

    TactileProbeSensorBaseType::
    ~TactileProbeSensorBaseType ()
    {
    }

    // SimpleTactileProbeSensorType
    //

    SimpleTactileProbeSensorType::
    SimpleTactileProbeSensorType ()
    : ::xsd::qif30::TactileProbeSensorBaseType (),
      Qualifications_ (this),
      Length_ (this),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
    }

    SimpleTactileProbeSensorType::
    SimpleTactileProbeSensorType (const Name_type& Name,
                                  const id_type& id)
    : ::xsd::qif30::TactileProbeSensorBaseType (Name,
                                                id),
      Qualifications_ (this),
      Length_ (this),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
    }

    SimpleTactileProbeSensorType::
    SimpleTactileProbeSensorType (const SimpleTactileProbeSensorType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::TactileProbeSensorBaseType (x, f, c),
      Qualifications_ (x.Qualifications_, f, this),
      Length_ (x.Length_, f, this),
      TipEndGeometry_ (x.TipEndGeometry_, f, this),
      TipEndDiameter_ (x.TipEndDiameter_, f, this),
      TipEndMaterial_ (x.TipEndMaterial_, f, this),
      StemMaterial_ (x.StemMaterial_, f, this),
      StemDiameter_ (x.StemDiameter_, f, this)
    {
    }

    SimpleTactileProbeSensorType::
    SimpleTactileProbeSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::TactileProbeSensorBaseType (e, f | ::xml_schema::flags::base, c),
      Qualifications_ (this),
      Length_ (this),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SimpleTactileProbeSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TactileProbeSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Qualifications
        //
        if (n.name () == L"Qualifications" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Qualifications_type > r (
            Qualifications_traits::create (i, f, this));

          if (!this->Qualifications_)
          {
            this->Qualifications_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // TipEndGeometry
        //
        if (n.name () == L"TipEndGeometry" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndGeometry_type > r (
            TipEndGeometry_traits::create (i, f, this));

          if (!this->TipEndGeometry_)
          {
            this->TipEndGeometry_.set (::std::move (r));
            continue;
          }
        }

        // TipEndDiameter
        //
        if (n.name () == L"TipEndDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndDiameter_type > r (
            TipEndDiameter_traits::create (i, f, this));

          if (!this->TipEndDiameter_)
          {
            this->TipEndDiameter_.set (::std::move (r));
            continue;
          }
        }

        // TipEndMaterial
        //
        if (n.name () == L"TipEndMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndMaterial_type > r (
            TipEndMaterial_traits::create (i, f, this));

          if (!this->TipEndMaterial_)
          {
            this->TipEndMaterial_.set (::std::move (r));
            continue;
          }
        }

        // StemMaterial
        //
        if (n.name () == L"StemMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StemMaterial_type > r (
            StemMaterial_traits::create (i, f, this));

          if (!this->StemMaterial_)
          {
            this->StemMaterial_.set (::std::move (r));
            continue;
          }
        }

        // StemDiameter
        //
        if (n.name () == L"StemDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StemDiameter_type > r (
            StemDiameter_traits::create (i, f, this));

          if (!this->StemDiameter_)
          {
            this->StemDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SimpleTactileProbeSensorType* SimpleTactileProbeSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimpleTactileProbeSensorType (*this, f, c);
    }

    SimpleTactileProbeSensorType& SimpleTactileProbeSensorType::
    operator= (const SimpleTactileProbeSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TactileProbeSensorBaseType& > (*this) = x;
        this->Qualifications_ = x.Qualifications_;
        this->Length_ = x.Length_;
        this->TipEndGeometry_ = x.TipEndGeometry_;
        this->TipEndDiameter_ = x.TipEndDiameter_;
        this->TipEndMaterial_ = x.TipEndMaterial_;
        this->StemMaterial_ = x.StemMaterial_;
        this->StemDiameter_ = x.StemDiameter_;
      }

      return *this;
    }

    SimpleTactileProbeSensorType::
    ~SimpleTactileProbeSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SimpleTactileProbeSensorType >
    _xsd_SimpleTactileProbeSensorType_type_factory_init (
      L"SimpleTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // ComplexTactileProbeSensorType
    //

    ComplexTactileProbeSensorType::
    ComplexTactileProbeSensorType ()
    : ::xsd::qif30::TactileProbeSensorBaseType (),
      LocatedTips_ (this)
    {
    }

    ComplexTactileProbeSensorType::
    ComplexTactileProbeSensorType (const Name_type& Name,
                                   const id_type& id,
                                   const LocatedTips_type& LocatedTips)
    : ::xsd::qif30::TactileProbeSensorBaseType (Name,
                                                id),
      LocatedTips_ (LocatedTips, this)
    {
    }

    ComplexTactileProbeSensorType::
    ComplexTactileProbeSensorType (const Name_type& Name,
                                   const id_type& id,
                                   ::std::unique_ptr< LocatedTips_type > LocatedTips)
    : ::xsd::qif30::TactileProbeSensorBaseType (Name,
                                                id),
      LocatedTips_ (std::move (LocatedTips), this)
    {
    }

    ComplexTactileProbeSensorType::
    ComplexTactileProbeSensorType (const ComplexTactileProbeSensorType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::TactileProbeSensorBaseType (x, f, c),
      LocatedTips_ (x.LocatedTips_, f, this)
    {
    }

    ComplexTactileProbeSensorType::
    ComplexTactileProbeSensorType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::TactileProbeSensorBaseType (e, f | ::xml_schema::flags::base, c),
      LocatedTips_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComplexTactileProbeSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TactileProbeSensorBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LocatedTips
        //
        if (n.name () == L"LocatedTips" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocatedTips_type > r (
            LocatedTips_traits::create (i, f, this));

          if (!LocatedTips_.present ())
          {
            this->LocatedTips_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LocatedTips_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LocatedTips",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ComplexTactileProbeSensorType* ComplexTactileProbeSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComplexTactileProbeSensorType (*this, f, c);
    }

    ComplexTactileProbeSensorType& ComplexTactileProbeSensorType::
    operator= (const ComplexTactileProbeSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TactileProbeSensorBaseType& > (*this) = x;
        this->LocatedTips_ = x.LocatedTips_;
      }

      return *this;
    }

    ComplexTactileProbeSensorType::
    ~ComplexTactileProbeSensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ComplexTactileProbeSensorType >
    _xsd_ComplexTactileProbeSensorType_type_factory_init (
      L"ComplexTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");

    // LocatedTipsType
    //

    LocatedTipsType::
    LocatedTipsType ()
    : ::xml_schema::type (),
      LocatedTip_ (this),
      n_ (this)
    {
    }

    LocatedTipsType::
    LocatedTipsType (const n_type& n)
    : ::xml_schema::type (),
      LocatedTip_ (this),
      n_ (n, this)
    {
    }

    LocatedTipsType::
    LocatedTipsType (const LocatedTipsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocatedTip_ (x.LocatedTip_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LocatedTipsType::
    LocatedTipsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocatedTip_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LocatedTipsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LocatedTip
        //
        if (n.name () == L"LocatedTip" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocatedTip_type > r (
            LocatedTip_traits::create (i, f, this));

          this->LocatedTip_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LocatedTipsType* LocatedTipsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocatedTipsType (*this, f, c);
    }

    LocatedTipsType& LocatedTipsType::
    operator= (const LocatedTipsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LocatedTip_ = x.LocatedTip_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LocatedTipsType::
    ~LocatedTipsType ()
    {
    }

    // ProbeTipType
    //

    ProbeTipType::
    ProbeTipType ()
    : ::xsd::qif30::MeasurementResourceBaseType (),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
    }

    ProbeTipType::
    ProbeTipType (const Name_type& Name,
                  const id_type& id)
    : ::xsd::qif30::MeasurementResourceBaseType (Name,
                                                 id),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
    }

    ProbeTipType::
    ProbeTipType (const ProbeTipType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (x, f, c),
      TipEndGeometry_ (x.TipEndGeometry_, f, this),
      TipEndDiameter_ (x.TipEndDiameter_, f, this),
      TipEndMaterial_ (x.TipEndMaterial_, f, this),
      StemMaterial_ (x.StemMaterial_, f, this),
      StemDiameter_ (x.StemDiameter_, f, this)
    {
    }

    ProbeTipType::
    ProbeTipType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      TipEndGeometry_ (this),
      TipEndDiameter_ (this),
      TipEndMaterial_ (this),
      StemMaterial_ (this),
      StemDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProbeTipType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TipEndGeometry
        //
        if (n.name () == L"TipEndGeometry" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndGeometry_type > r (
            TipEndGeometry_traits::create (i, f, this));

          if (!this->TipEndGeometry_)
          {
            this->TipEndGeometry_.set (::std::move (r));
            continue;
          }
        }

        // TipEndDiameter
        //
        if (n.name () == L"TipEndDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndDiameter_type > r (
            TipEndDiameter_traits::create (i, f, this));

          if (!this->TipEndDiameter_)
          {
            this->TipEndDiameter_.set (::std::move (r));
            continue;
          }
        }

        // TipEndMaterial
        //
        if (n.name () == L"TipEndMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndMaterial_type > r (
            TipEndMaterial_traits::create (i, f, this));

          if (!this->TipEndMaterial_)
          {
            this->TipEndMaterial_.set (::std::move (r));
            continue;
          }
        }

        // StemMaterial
        //
        if (n.name () == L"StemMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StemMaterial_type > r (
            StemMaterial_traits::create (i, f, this));

          if (!this->StemMaterial_)
          {
            this->StemMaterial_.set (::std::move (r));
            continue;
          }
        }

        // StemDiameter
        //
        if (n.name () == L"StemDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StemDiameter_type > r (
            StemDiameter_traits::create (i, f, this));

          if (!this->StemDiameter_)
          {
            this->StemDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProbeTipType* ProbeTipType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProbeTipType (*this, f, c);
    }

    ProbeTipType& ProbeTipType::
    operator= (const ProbeTipType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementResourceBaseType& > (*this) = x;
        this->TipEndGeometry_ = x.TipEndGeometry_;
        this->TipEndDiameter_ = x.TipEndDiameter_;
        this->TipEndMaterial_ = x.TipEndMaterial_;
        this->StemMaterial_ = x.StemMaterial_;
        this->StemDiameter_ = x.StemDiameter_;
      }

      return *this;
    }

    ProbeTipType::
    ~ProbeTipType ()
    {
    }

    // LocatedTipType
    //

    LocatedTipType::
    LocatedTipType ()
    : ::xml_schema::type (),
      ProbeTip_ (this),
      TipEndLocation_ (this)
    {
    }

    LocatedTipType::
    LocatedTipType (const ProbeTip_type& ProbeTip,
                    const TipEndLocation_type& TipEndLocation)
    : ::xml_schema::type (),
      ProbeTip_ (ProbeTip, this),
      TipEndLocation_ (TipEndLocation, this)
    {
    }

    LocatedTipType::
    LocatedTipType (::std::unique_ptr< ProbeTip_type > ProbeTip,
                    ::std::unique_ptr< TipEndLocation_type > TipEndLocation)
    : ::xml_schema::type (),
      ProbeTip_ (std::move (ProbeTip), this),
      TipEndLocation_ (std::move (TipEndLocation), this)
    {
    }

    LocatedTipType::
    LocatedTipType (const LocatedTipType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ProbeTip_ (x.ProbeTip_, f, this),
      TipEndLocation_ (x.TipEndLocation_, f, this)
    {
    }

    LocatedTipType::
    LocatedTipType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ProbeTip_ (this),
      TipEndLocation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LocatedTipType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProbeTip
        //
        if (n.name () == L"ProbeTip" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProbeTip_type > r (
            ProbeTip_traits::create (i, f, this));

          if (!ProbeTip_.present ())
          {
            this->ProbeTip_.set (::std::move (r));
            continue;
          }
        }

        // TipEndLocation
        //
        if (n.name () == L"TipEndLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipEndLocation_type > r (
            TipEndLocation_traits::create (i, f, this));

          if (!TipEndLocation_.present ())
          {
            this->TipEndLocation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProbeTip_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProbeTip",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TipEndLocation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TipEndLocation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LocatedTipType* LocatedTipType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocatedTipType (*this, f, c);
    }

    LocatedTipType& LocatedTipType::
    operator= (const LocatedTipType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ProbeTip_ = x.ProbeTip_;
        this->TipEndLocation_ = x.TipEndLocation_;
      }

      return *this;
    }

    LocatedTipType::
    ~LocatedTipType ()
    {
    }

    // ChargeCoupledDeviceCameraSensorType
    //

    ChargeCoupledDeviceCameraSensorType::
    ChargeCoupledDeviceCameraSensorType ()
    : ::xsd::qif30::SensorType (),
      NumberOfPixels_ (this),
      MaxReadoutFrequency_ (this),
      HorizontalFieldOfView_ (this),
      VerticalFieldOfView_ (this),
      MaxReadNoise_ (this),
      MaxFrameRate_ (this),
      PixelSize_ (this),
      SustainedDataRate_ (this),
      DarkCurrent_ (this),
      MaxPixelClockSpeed_ (this),
      Linearity_ (this),
      MaxOutputVoltage_ (this)
    {
    }

    ChargeCoupledDeviceCameraSensorType::
    ChargeCoupledDeviceCameraSensorType (const Name_type& Name,
                                         const id_type& id)
    : ::xsd::qif30::SensorType (Name,
                                id),
      NumberOfPixels_ (this),
      MaxReadoutFrequency_ (this),
      HorizontalFieldOfView_ (this),
      VerticalFieldOfView_ (this),
      MaxReadNoise_ (this),
      MaxFrameRate_ (this),
      PixelSize_ (this),
      SustainedDataRate_ (this),
      DarkCurrent_ (this),
      MaxPixelClockSpeed_ (this),
      Linearity_ (this),
      MaxOutputVoltage_ (this)
    {
    }

    ChargeCoupledDeviceCameraSensorType::
    ChargeCoupledDeviceCameraSensorType (const ChargeCoupledDeviceCameraSensorType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (x, f, c),
      NumberOfPixels_ (x.NumberOfPixels_, f, this),
      MaxReadoutFrequency_ (x.MaxReadoutFrequency_, f, this),
      HorizontalFieldOfView_ (x.HorizontalFieldOfView_, f, this),
      VerticalFieldOfView_ (x.VerticalFieldOfView_, f, this),
      MaxReadNoise_ (x.MaxReadNoise_, f, this),
      MaxFrameRate_ (x.MaxFrameRate_, f, this),
      PixelSize_ (x.PixelSize_, f, this),
      SustainedDataRate_ (x.SustainedDataRate_, f, this),
      DarkCurrent_ (x.DarkCurrent_, f, this),
      MaxPixelClockSpeed_ (x.MaxPixelClockSpeed_, f, this),
      Linearity_ (x.Linearity_, f, this),
      MaxOutputVoltage_ (x.MaxOutputVoltage_, f, this)
    {
    }

    ChargeCoupledDeviceCameraSensorType::
    ChargeCoupledDeviceCameraSensorType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SensorType (e, f | ::xml_schema::flags::base, c),
      NumberOfPixels_ (this),
      MaxReadoutFrequency_ (this),
      HorizontalFieldOfView_ (this),
      VerticalFieldOfView_ (this),
      MaxReadNoise_ (this),
      MaxFrameRate_ (this),
      PixelSize_ (this),
      SustainedDataRate_ (this),
      DarkCurrent_ (this),
      MaxPixelClockSpeed_ (this),
      Linearity_ (this),
      MaxOutputVoltage_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChargeCoupledDeviceCameraSensorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfPixels
        //
        if (n.name () == L"NumberOfPixels" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NumberOfPixels_)
          {
            this->NumberOfPixels_.set (NumberOfPixels_traits::create (i, f, this));
            continue;
          }
        }

        // MaxReadoutFrequency
        //
        if (n.name () == L"MaxReadoutFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxReadoutFrequency_type > r (
            MaxReadoutFrequency_traits::create (i, f, this));

          if (!this->MaxReadoutFrequency_)
          {
            this->MaxReadoutFrequency_.set (::std::move (r));
            continue;
          }
        }

        // HorizontalFieldOfView
        //
        if (n.name () == L"HorizontalFieldOfView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HorizontalFieldOfView_type > r (
            HorizontalFieldOfView_traits::create (i, f, this));

          if (!this->HorizontalFieldOfView_)
          {
            this->HorizontalFieldOfView_.set (::std::move (r));
            continue;
          }
        }

        // VerticalFieldOfView
        //
        if (n.name () == L"VerticalFieldOfView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VerticalFieldOfView_type > r (
            VerticalFieldOfView_traits::create (i, f, this));

          if (!this->VerticalFieldOfView_)
          {
            this->VerticalFieldOfView_.set (::std::move (r));
            continue;
          }
        }

        // MaxReadNoise
        //
        if (n.name () == L"MaxReadNoise" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxReadNoise_type > r (
            MaxReadNoise_traits::create (i, f, this));

          if (!this->MaxReadNoise_)
          {
            this->MaxReadNoise_.set (::std::move (r));
            continue;
          }
        }

        // MaxFrameRate
        //
        if (n.name () == L"MaxFrameRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFrameRate_type > r (
            MaxFrameRate_traits::create (i, f, this));

          if (!this->MaxFrameRate_)
          {
            this->MaxFrameRate_.set (::std::move (r));
            continue;
          }
        }

        // PixelSize
        //
        if (n.name () == L"PixelSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PixelSize_type > r (
            PixelSize_traits::create (i, f, this));

          if (!this->PixelSize_)
          {
            this->PixelSize_.set (::std::move (r));
            continue;
          }
        }

        // SustainedDataRate
        //
        if (n.name () == L"SustainedDataRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SustainedDataRate_type > r (
            SustainedDataRate_traits::create (i, f, this));

          if (!this->SustainedDataRate_)
          {
            this->SustainedDataRate_.set (::std::move (r));
            continue;
          }
        }

        // DarkCurrent
        //
        if (n.name () == L"DarkCurrent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DarkCurrent_type > r (
            DarkCurrent_traits::create (i, f, this));

          if (!this->DarkCurrent_)
          {
            this->DarkCurrent_.set (::std::move (r));
            continue;
          }
        }

        // MaxPixelClockSpeed
        //
        if (n.name () == L"MaxPixelClockSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPixelClockSpeed_type > r (
            MaxPixelClockSpeed_traits::create (i, f, this));

          if (!this->MaxPixelClockSpeed_)
          {
            this->MaxPixelClockSpeed_.set (::std::move (r));
            continue;
          }
        }

        // Linearity
        //
        if (n.name () == L"Linearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Linearity_type > r (
            Linearity_traits::create (i, f, this));

          if (!this->Linearity_)
          {
            this->Linearity_.set (::std::move (r));
            continue;
          }
        }

        // MaxOutputVoltage
        //
        if (n.name () == L"MaxOutputVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxOutputVoltage_type > r (
            MaxOutputVoltage_traits::create (i, f, this));

          if (!this->MaxOutputVoltage_)
          {
            this->MaxOutputVoltage_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ChargeCoupledDeviceCameraSensorType* ChargeCoupledDeviceCameraSensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ChargeCoupledDeviceCameraSensorType (*this, f, c);
    }

    ChargeCoupledDeviceCameraSensorType& ChargeCoupledDeviceCameraSensorType::
    operator= (const ChargeCoupledDeviceCameraSensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SensorType& > (*this) = x;
        this->NumberOfPixels_ = x.NumberOfPixels_;
        this->MaxReadoutFrequency_ = x.MaxReadoutFrequency_;
        this->HorizontalFieldOfView_ = x.HorizontalFieldOfView_;
        this->VerticalFieldOfView_ = x.VerticalFieldOfView_;
        this->MaxReadNoise_ = x.MaxReadNoise_;
        this->MaxFrameRate_ = x.MaxFrameRate_;
        this->PixelSize_ = x.PixelSize_;
        this->SustainedDataRate_ = x.SustainedDataRate_;
        this->DarkCurrent_ = x.DarkCurrent_;
        this->MaxPixelClockSpeed_ = x.MaxPixelClockSpeed_;
        this->Linearity_ = x.Linearity_;
        this->MaxOutputVoltage_ = x.MaxOutputVoltage_;
      }

      return *this;
    }

    ChargeCoupledDeviceCameraSensorType::
    ~ChargeCoupledDeviceCameraSensorType ()
    {
    }

    // CMMType
    //

    CMMType::
    CMMType ()
    : ::xsd::qif30::UniversalDeviceType ()
    {
    }

    CMMType::
    CMMType (const Name_type& Name,
             const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id)
    {
    }

    CMMType::
    CMMType (const CMMType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c)
    {
    }

    CMMType::
    CMMType (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f, c)
    {
    }

    CMMType* CMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMType (*this, f, c);
    }

    CMMType::
    ~CMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CMMType >
    _xsd_CMMType_type_factory_init (
      L"CMMType",
      L"http://qifstandards.org/xsd/qif3");

    // CartesianCMMType
    //

    CartesianCMMType::
    CartesianCMMType ()
    : ::xsd::qif30::CMMType (),
      HomeLocation_ (this),
      CMMGeometry_ (this),
      CMMAxisDirections_ (this),
      Scales_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceMass_ (this),
      JoystickSpeeds_ (this),
      CMMSpeeds_ (this),
      RotaryTable_ (this),
      Accuracies_ (this),
      ToolIds_ (this),
      SensorIds_ (this)
    {
    }

    CartesianCMMType::
    CartesianCMMType (const Name_type& Name,
                      const id_type& id)
    : ::xsd::qif30::CMMType (Name,
                             id),
      HomeLocation_ (this),
      CMMGeometry_ (this),
      CMMAxisDirections_ (this),
      Scales_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceMass_ (this),
      JoystickSpeeds_ (this),
      CMMSpeeds_ (this),
      RotaryTable_ (this),
      Accuracies_ (this),
      ToolIds_ (this),
      SensorIds_ (this)
    {
    }

    CartesianCMMType::
    CartesianCMMType (const CartesianCMMType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (x, f, c),
      HomeLocation_ (x.HomeLocation_, f, this),
      CMMGeometry_ (x.CMMGeometry_, f, this),
      CMMAxisDirections_ (x.CMMAxisDirections_, f, this),
      Scales_ (x.Scales_, f, this),
      MaxWorkpieceHeight_ (x.MaxWorkpieceHeight_, f, this),
      MaxWorkpieceMass_ (x.MaxWorkpieceMass_, f, this),
      JoystickSpeeds_ (x.JoystickSpeeds_, f, this),
      CMMSpeeds_ (x.CMMSpeeds_, f, this),
      RotaryTable_ (x.RotaryTable_, f, this),
      Accuracies_ (x.Accuracies_, f, this),
      ToolIds_ (x.ToolIds_, f, this),
      SensorIds_ (x.SensorIds_, f, this)
    {
    }

    CartesianCMMType::
    CartesianCMMType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (e, f | ::xml_schema::flags::base, c),
      HomeLocation_ (this),
      CMMGeometry_ (this),
      CMMAxisDirections_ (this),
      Scales_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceMass_ (this),
      JoystickSpeeds_ (this),
      CMMSpeeds_ (this),
      RotaryTable_ (this),
      Accuracies_ (this),
      ToolIds_ (this),
      SensorIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CartesianCMMType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CMMType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HomeLocation
        //
        if (n.name () == L"HomeLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HomeLocation_type > r (
            HomeLocation_traits::create (i, f, this));

          if (!this->HomeLocation_)
          {
            this->HomeLocation_.set (::std::move (r));
            continue;
          }
        }

        // CMMGeometry
        //
        if (n.name () == L"CMMGeometry" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CMMGeometry_type > r (
            CMMGeometry_traits::create (i, f, this));

          if (!this->CMMGeometry_)
          {
            this->CMMGeometry_.set (::std::move (r));
            continue;
          }
        }

        // CMMAxisDirections
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CMMAxisDirections",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CMMAxisDirections_)
            {
              ::std::unique_ptr< CMMAxisDirections_type > r (
                dynamic_cast< CMMAxisDirections_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CMMAxisDirections_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scales
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Scales",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scales_)
            {
              ::std::unique_ptr< Scales_type > r (
                dynamic_cast< Scales_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Scales_.set (::std::move (r));
              continue;
            }
          }
        }

        // MaxWorkpieceHeight
        //
        if (n.name () == L"MaxWorkpieceHeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceHeight_type > r (
            MaxWorkpieceHeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceHeight_)
          {
            this->MaxWorkpieceHeight_.set (::std::move (r));
            continue;
          }
        }

        // MaxWorkpieceMass
        //
        if (n.name () == L"MaxWorkpieceMass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceMass_type > r (
            MaxWorkpieceMass_traits::create (i, f, this));

          if (!this->MaxWorkpieceMass_)
          {
            this->MaxWorkpieceMass_.set (::std::move (r));
            continue;
          }
        }

        // JoystickSpeeds
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"JoystickSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< JoystickSpeeds_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->JoystickSpeeds_)
            {
              ::std::unique_ptr< JoystickSpeeds_type > r (
                dynamic_cast< JoystickSpeeds_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->JoystickSpeeds_.set (::std::move (r));
              continue;
            }
          }
        }

        // CMMSpeeds
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CMMSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CMMSpeeds_)
            {
              ::std::unique_ptr< CMMSpeeds_type > r (
                dynamic_cast< CMMSpeeds_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CMMSpeeds_.set (::std::move (r));
              continue;
            }
          }
        }

        // RotaryTable
        //
        if (n.name () == L"RotaryTable" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RotaryTable_type > r (
            RotaryTable_traits::create (i, f, this));

          if (!this->RotaryTable_)
          {
            this->RotaryTable_.set (::std::move (r));
            continue;
          }
        }

        // Accuracies
        //
        if (n.name () == L"Accuracies" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracies_type > r (
            Accuracies_traits::create (i, f, this));

          if (!this->Accuracies_)
          {
            this->Accuracies_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        // SensorIds
        //
        if (n.name () == L"SensorIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SensorIds_type > r (
            SensorIds_traits::create (i, f, this));

          if (!this->SensorIds_)
          {
            this->SensorIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CartesianCMMType* CartesianCMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMType (*this, f, c);
    }

    CartesianCMMType& CartesianCMMType::
    operator= (const CartesianCMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMType& > (*this) = x;
        this->HomeLocation_ = x.HomeLocation_;
        this->CMMGeometry_ = x.CMMGeometry_;
        this->CMMAxisDirections_ = x.CMMAxisDirections_;
        this->Scales_ = x.Scales_;
        this->MaxWorkpieceHeight_ = x.MaxWorkpieceHeight_;
        this->MaxWorkpieceMass_ = x.MaxWorkpieceMass_;
        this->JoystickSpeeds_ = x.JoystickSpeeds_;
        this->CMMSpeeds_ = x.CMMSpeeds_;
        this->RotaryTable_ = x.RotaryTable_;
        this->Accuracies_ = x.Accuracies_;
        this->ToolIds_ = x.ToolIds_;
        this->SensorIds_ = x.SensorIds_;
      }

      return *this;
    }

    CartesianCMMType::
    ~CartesianCMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianCMMType >
    _xsd_CartesianCMMType_type_factory_init (
      L"CartesianCMMType",
      L"http://qifstandards.org/xsd/qif3");

    // MultipleCarriageCartesianCMMType
    //

    MultipleCarriageCartesianCMMType::
    MultipleCarriageCartesianCMMType ()
    : ::xsd::qif30::CartesianCMMType (),
      Carriages_ (this)
    {
    }

    MultipleCarriageCartesianCMMType::
    MultipleCarriageCartesianCMMType (const Name_type& Name,
                                      const id_type& id,
                                      const Carriages_type& Carriages)
    : ::xsd::qif30::CartesianCMMType (Name,
                                      id),
      Carriages_ (Carriages, this)
    {
    }

    MultipleCarriageCartesianCMMType::
    MultipleCarriageCartesianCMMType (const Name_type& Name,
                                      const id_type& id,
                                      ::std::unique_ptr< Carriages_type > Carriages)
    : ::xsd::qif30::CartesianCMMType (Name,
                                      id),
      Carriages_ (std::move (Carriages), this)
    {
    }

    MultipleCarriageCartesianCMMType::
    MultipleCarriageCartesianCMMType (const MultipleCarriageCartesianCMMType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CartesianCMMType (x, f, c),
      Carriages_ (x.Carriages_, f, this)
    {
    }

    MultipleCarriageCartesianCMMType::
    MultipleCarriageCartesianCMMType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CartesianCMMType (e, f | ::xml_schema::flags::base, c),
      Carriages_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MultipleCarriageCartesianCMMType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CartesianCMMType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Carriages
        //
        if (n.name () == L"Carriages" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Carriages_type > r (
            Carriages_traits::create (i, f, this));

          if (!Carriages_.present ())
          {
            this->Carriages_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Carriages_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Carriages",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MultipleCarriageCartesianCMMType* MultipleCarriageCartesianCMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MultipleCarriageCartesianCMMType (*this, f, c);
    }

    MultipleCarriageCartesianCMMType& MultipleCarriageCartesianCMMType::
    operator= (const MultipleCarriageCartesianCMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CartesianCMMType& > (*this) = x;
        this->Carriages_ = x.Carriages_;
      }

      return *this;
    }

    MultipleCarriageCartesianCMMType::
    ~MultipleCarriageCartesianCMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MultipleCarriageCartesianCMMType >
    _xsd_MultipleCarriageCartesianCMMType_type_factory_init (
      L"MultipleCarriageCartesianCMMType",
      L"http://qifstandards.org/xsd/qif3");

    // LightPenCMMType
    //

    LightPenCMMType::
    LightPenCMMType ()
    : ::xsd::qif30::CMMType (),
      LightPenCMMChargeCoupledDeviceCameraSensor_ (this),
      LightSource_ (this),
      NominalVolumetricAccuracy_ (this),
      ActualVolumetricAccuracy_ (this),
      NominalSinglePointAccuracy_ (this),
      ActualSinglePointAccuracy_ (this),
      ScanningSpeed_ (this),
      LaserClass_ (this)
    {
    }

    LightPenCMMType::
    LightPenCMMType (const Name_type& Name,
                     const id_type& id)
    : ::xsd::qif30::CMMType (Name,
                             id),
      LightPenCMMChargeCoupledDeviceCameraSensor_ (this),
      LightSource_ (this),
      NominalVolumetricAccuracy_ (this),
      ActualVolumetricAccuracy_ (this),
      NominalSinglePointAccuracy_ (this),
      ActualSinglePointAccuracy_ (this),
      ScanningSpeed_ (this),
      LaserClass_ (this)
    {
    }

    LightPenCMMType::
    LightPenCMMType (const LightPenCMMType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (x, f, c),
      LightPenCMMChargeCoupledDeviceCameraSensor_ (x.LightPenCMMChargeCoupledDeviceCameraSensor_, f, this),
      LightSource_ (x.LightSource_, f, this),
      NominalVolumetricAccuracy_ (x.NominalVolumetricAccuracy_, f, this),
      ActualVolumetricAccuracy_ (x.ActualVolumetricAccuracy_, f, this),
      NominalSinglePointAccuracy_ (x.NominalSinglePointAccuracy_, f, this),
      ActualSinglePointAccuracy_ (x.ActualSinglePointAccuracy_, f, this),
      ScanningSpeed_ (x.ScanningSpeed_, f, this),
      LaserClass_ (x.LaserClass_, f, this)
    {
    }

    LightPenCMMType::
    LightPenCMMType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (e, f | ::xml_schema::flags::base, c),
      LightPenCMMChargeCoupledDeviceCameraSensor_ (this),
      LightSource_ (this),
      NominalVolumetricAccuracy_ (this),
      ActualVolumetricAccuracy_ (this),
      NominalSinglePointAccuracy_ (this),
      ActualSinglePointAccuracy_ (this),
      ScanningSpeed_ (this),
      LaserClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LightPenCMMType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CMMType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LightPenCMMChargeCoupledDeviceCameraSensor
        //
        if (n.name () == L"LightPenCMMChargeCoupledDeviceCameraSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LightPenCMMChargeCoupledDeviceCameraSensor_type > r (
            LightPenCMMChargeCoupledDeviceCameraSensor_traits::create (i, f, this));

          if (!this->LightPenCMMChargeCoupledDeviceCameraSensor_)
          {
            this->LightPenCMMChargeCoupledDeviceCameraSensor_.set (::std::move (r));
            continue;
          }
        }

        // LightSource
        //
        if (n.name () == L"LightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LightSource_type > r (
            LightSource_traits::create (i, f, this));

          if (!this->LightSource_)
          {
            this->LightSource_.set (::std::move (r));
            continue;
          }
        }

        // NominalVolumetricAccuracy
        //
        if (n.name () == L"NominalVolumetricAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalVolumetricAccuracy_type > r (
            NominalVolumetricAccuracy_traits::create (i, f, this));

          if (!this->NominalVolumetricAccuracy_)
          {
            this->NominalVolumetricAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // ActualVolumetricAccuracy
        //
        if (n.name () == L"ActualVolumetricAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActualVolumetricAccuracy_type > r (
            ActualVolumetricAccuracy_traits::create (i, f, this));

          if (!this->ActualVolumetricAccuracy_)
          {
            this->ActualVolumetricAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // NominalSinglePointAccuracy
        //
        if (n.name () == L"NominalSinglePointAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalSinglePointAccuracy_type > r (
            NominalSinglePointAccuracy_traits::create (i, f, this));

          if (!this->NominalSinglePointAccuracy_)
          {
            this->NominalSinglePointAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // ActualSinglePointAccuracy
        //
        if (n.name () == L"ActualSinglePointAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActualSinglePointAccuracy_type > r (
            ActualSinglePointAccuracy_traits::create (i, f, this));

          if (!this->ActualSinglePointAccuracy_)
          {
            this->ActualSinglePointAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // ScanningSpeed
        //
        if (n.name () == L"ScanningSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScanningSpeed_type > r (
            ScanningSpeed_traits::create (i, f, this));

          if (!this->ScanningSpeed_)
          {
            this->ScanningSpeed_.set (::std::move (r));
            continue;
          }
        }

        // LaserClass
        //
        if (n.name () == L"LaserClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LaserClass_type > r (
            LaserClass_traits::create (i, f, this));

          if (!this->LaserClass_)
          {
            this->LaserClass_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LightPenCMMType* LightPenCMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LightPenCMMType (*this, f, c);
    }

    LightPenCMMType& LightPenCMMType::
    operator= (const LightPenCMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMType& > (*this) = x;
        this->LightPenCMMChargeCoupledDeviceCameraSensor_ = x.LightPenCMMChargeCoupledDeviceCameraSensor_;
        this->LightSource_ = x.LightSource_;
        this->NominalVolumetricAccuracy_ = x.NominalVolumetricAccuracy_;
        this->ActualVolumetricAccuracy_ = x.ActualVolumetricAccuracy_;
        this->NominalSinglePointAccuracy_ = x.NominalSinglePointAccuracy_;
        this->ActualSinglePointAccuracy_ = x.ActualSinglePointAccuracy_;
        this->ScanningSpeed_ = x.ScanningSpeed_;
        this->LaserClass_ = x.LaserClass_;
      }

      return *this;
    }

    LightPenCMMType::
    ~LightPenCMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LightPenCMMType >
    _xsd_LightPenCMMType_type_factory_init (
      L"LightPenCMMType",
      L"http://qifstandards.org/xsd/qif3");

    // ParallelLinkCMMType
    //

    ParallelLinkCMMType::
    ParallelLinkCMMType ()
    : ::xsd::qif30::CMMType (),
      CMMSpeeds_ (this),
      AxesTravelDistance_ (this),
      AxesRotationAngle_ (this),
      AxisBacklash_ (this),
      AxisRepeatability_ (this),
      MaxLoad_ (this),
      StageMaterial_ (this),
      MaxHoldingForce_ (this),
      MotorType_ (this),
      LinksStiffness_ (this),
      ToolIds_ (this)
    {
    }

    ParallelLinkCMMType::
    ParallelLinkCMMType (const Name_type& Name,
                         const id_type& id)
    : ::xsd::qif30::CMMType (Name,
                             id),
      CMMSpeeds_ (this),
      AxesTravelDistance_ (this),
      AxesRotationAngle_ (this),
      AxisBacklash_ (this),
      AxisRepeatability_ (this),
      MaxLoad_ (this),
      StageMaterial_ (this),
      MaxHoldingForce_ (this),
      MotorType_ (this),
      LinksStiffness_ (this),
      ToolIds_ (this)
    {
    }

    ParallelLinkCMMType::
    ParallelLinkCMMType (const ParallelLinkCMMType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (x, f, c),
      CMMSpeeds_ (x.CMMSpeeds_, f, this),
      AxesTravelDistance_ (x.AxesTravelDistance_, f, this),
      AxesRotationAngle_ (x.AxesRotationAngle_, f, this),
      AxisBacklash_ (x.AxisBacklash_, f, this),
      AxisRepeatability_ (x.AxisRepeatability_, f, this),
      MaxLoad_ (x.MaxLoad_, f, this),
      StageMaterial_ (x.StageMaterial_, f, this),
      MaxHoldingForce_ (x.MaxHoldingForce_, f, this),
      MotorType_ (x.MotorType_, f, this),
      LinksStiffness_ (x.LinksStiffness_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    ParallelLinkCMMType::
    ParallelLinkCMMType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (e, f | ::xml_schema::flags::base, c),
      CMMSpeeds_ (this),
      AxesTravelDistance_ (this),
      AxesRotationAngle_ (this),
      AxisBacklash_ (this),
      AxisRepeatability_ (this),
      MaxLoad_ (this),
      StageMaterial_ (this),
      MaxHoldingForce_ (this),
      MotorType_ (this),
      LinksStiffness_ (this),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ParallelLinkCMMType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CMMType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CMMSpeeds
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CMMSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CMMSpeeds_)
            {
              ::std::unique_ptr< CMMSpeeds_type > r (
                dynamic_cast< CMMSpeeds_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CMMSpeeds_.set (::std::move (r));
              continue;
            }
          }
        }

        // AxesTravelDistance
        //
        if (n.name () == L"AxesTravelDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxesTravelDistance_type > r (
            AxesTravelDistance_traits::create (i, f, this));

          if (!this->AxesTravelDistance_)
          {
            this->AxesTravelDistance_.set (::std::move (r));
            continue;
          }
        }

        // AxesRotationAngle
        //
        if (n.name () == L"AxesRotationAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxesRotationAngle_type > r (
            AxesRotationAngle_traits::create (i, f, this));

          if (!this->AxesRotationAngle_)
          {
            this->AxesRotationAngle_.set (::std::move (r));
            continue;
          }
        }

        // AxisBacklash
        //
        if (n.name () == L"AxisBacklash" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisBacklash_type > r (
            AxisBacklash_traits::create (i, f, this));

          if (!this->AxisBacklash_)
          {
            this->AxisBacklash_.set (::std::move (r));
            continue;
          }
        }

        // AxisRepeatability
        //
        if (n.name () == L"AxisRepeatability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisRepeatability_type > r (
            AxisRepeatability_traits::create (i, f, this));

          if (!this->AxisRepeatability_)
          {
            this->AxisRepeatability_.set (::std::move (r));
            continue;
          }
        }

        // MaxLoad
        //
        if (n.name () == L"MaxLoad" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxLoad_type > r (
            MaxLoad_traits::create (i, f, this));

          if (!this->MaxLoad_)
          {
            this->MaxLoad_.set (::std::move (r));
            continue;
          }
        }

        // StageMaterial
        //
        if (n.name () == L"StageMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StageMaterial_type > r (
            StageMaterial_traits::create (i, f, this));

          if (!this->StageMaterial_)
          {
            this->StageMaterial_.set (::std::move (r));
            continue;
          }
        }

        // MaxHoldingForce
        //
        if (n.name () == L"MaxHoldingForce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxHoldingForce_type > r (
            MaxHoldingForce_traits::create (i, f, this));

          if (!this->MaxHoldingForce_)
          {
            this->MaxHoldingForce_.set (::std::move (r));
            continue;
          }
        }

        // MotorType
        //
        if (n.name () == L"MotorType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MotorType_type > r (
            MotorType_traits::create (i, f, this));

          if (!this->MotorType_)
          {
            this->MotorType_.set (::std::move (r));
            continue;
          }
        }

        // LinksStiffness
        //
        if (n.name () == L"LinksStiffness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinksStiffness_type > r (
            LinksStiffness_traits::create (i, f, this));

          if (!this->LinksStiffness_)
          {
            this->LinksStiffness_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ParallelLinkCMMType* ParallelLinkCMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParallelLinkCMMType (*this, f, c);
    }

    ParallelLinkCMMType& ParallelLinkCMMType::
    operator= (const ParallelLinkCMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMType& > (*this) = x;
        this->CMMSpeeds_ = x.CMMSpeeds_;
        this->AxesTravelDistance_ = x.AxesTravelDistance_;
        this->AxesRotationAngle_ = x.AxesRotationAngle_;
        this->AxisBacklash_ = x.AxisBacklash_;
        this->AxisRepeatability_ = x.AxisRepeatability_;
        this->MaxLoad_ = x.MaxLoad_;
        this->StageMaterial_ = x.StageMaterial_;
        this->MaxHoldingForce_ = x.MaxHoldingForce_;
        this->MotorType_ = x.MotorType_;
        this->LinksStiffness_ = x.LinksStiffness_;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    ParallelLinkCMMType::
    ~ParallelLinkCMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ParallelLinkCMMType >
    _xsd_ParallelLinkCMMType_type_factory_init (
      L"ParallelLinkCMMType",
      L"http://qifstandards.org/xsd/qif3");

    // AACMMType
    //

    AACMMType::
    AACMMType ()
    : ::xsd::qif30::CMMType (),
      HomeLocation_ (this),
      NumberOfJoints_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ProbeTipDiameter_ (this),
      Accuracies_ (this)
    {
    }

    AACMMType::
    AACMMType (const Name_type& Name,
               const id_type& id)
    : ::xsd::qif30::CMMType (Name,
                             id),
      HomeLocation_ (this),
      NumberOfJoints_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ProbeTipDiameter_ (this),
      Accuracies_ (this)
    {
    }

    AACMMType::
    AACMMType (const AACMMType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (x, f, c),
      HomeLocation_ (x.HomeLocation_, f, this),
      NumberOfJoints_ (x.NumberOfJoints_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      ProbeTipDiameter_ (x.ProbeTipDiameter_, f, this),
      Accuracies_ (x.Accuracies_, f, this)
    {
    }

    AACMMType::
    AACMMType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::CMMType (e, f | ::xml_schema::flags::base, c),
      HomeLocation_ (this),
      NumberOfJoints_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ProbeTipDiameter_ (this),
      Accuracies_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AACMMType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CMMType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HomeLocation
        //
        if (n.name () == L"HomeLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HomeLocation_type > r (
            HomeLocation_traits::create (i, f, this));

          if (!this->HomeLocation_)
          {
            this->HomeLocation_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfJoints
        //
        if (n.name () == L"NumberOfJoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NumberOfJoints_)
          {
            this->NumberOfJoints_.set (NumberOfJoints_traits::create (i, f, this));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // ProbeTipDiameter
        //
        if (n.name () == L"ProbeTipDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProbeTipDiameter_type > r (
            ProbeTipDiameter_traits::create (i, f, this));

          if (!this->ProbeTipDiameter_)
          {
            this->ProbeTipDiameter_.set (::std::move (r));
            continue;
          }
        }

        // Accuracies
        //
        if (n.name () == L"Accuracies" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracies_type > r (
            Accuracies_traits::create (i, f, this));

          if (!this->Accuracies_)
          {
            this->Accuracies_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AACMMType* AACMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AACMMType (*this, f, c);
    }

    AACMMType& AACMMType::
    operator= (const AACMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMType& > (*this) = x;
        this->HomeLocation_ = x.HomeLocation_;
        this->NumberOfJoints_ = x.NumberOfJoints_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->ProbeTipDiameter_ = x.ProbeTipDiameter_;
        this->Accuracies_ = x.Accuracies_;
      }

      return *this;
    }

    AACMMType::
    ~AACMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AACMMType >
    _xsd_AACMMType_type_factory_init (
      L"AACMMType",
      L"http://qifstandards.org/xsd/qif3");

    // CaliperType
    //

    CaliperType::
    CaliperType ()
    : ::xsd::qif30::ManualMeasurementDeviceType (),
      LinearResolution_ (this),
      Accuracy_ (this),
      CanMeasureInnerD_ (this),
      CanMeasureOuterD_ (this),
      CanMeasureDepth_ (this)
    {
    }

    CaliperType::
    CaliperType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif30::ManualMeasurementDeviceType (Name,
                                                 id),
      LinearResolution_ (this),
      Accuracy_ (this),
      CanMeasureInnerD_ (this),
      CanMeasureOuterD_ (this),
      CanMeasureDepth_ (this)
    {
    }

    CaliperType::
    CaliperType (const CaliperType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (x, f, c),
      LinearResolution_ (x.LinearResolution_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      CanMeasureInnerD_ (x.CanMeasureInnerD_, f, this),
      CanMeasureOuterD_ (x.CanMeasureOuterD_, f, this),
      CanMeasureDepth_ (x.CanMeasureDepth_, f, this)
    {
    }

    CaliperType::
    CaliperType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      LinearResolution_ (this),
      Accuracy_ (this),
      CanMeasureInnerD_ (this),
      CanMeasureOuterD_ (this),
      CanMeasureDepth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CaliperType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ManualMeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearResolution
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"LinearResolution",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< LinearResolution_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->LinearResolution_)
            {
              ::std::unique_ptr< LinearResolution_type > r (
                dynamic_cast< LinearResolution_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->LinearResolution_.set (::std::move (r));
              continue;
            }
          }
        }

        // Accuracy
        //
        if (n.name () == L"Accuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (::std::move (r));
            continue;
          }
        }

        // CanMeasureInnerD
        //
        if (n.name () == L"CanMeasureInnerD" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->CanMeasureInnerD_)
          {
            this->CanMeasureInnerD_.set (CanMeasureInnerD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureOuterD
        //
        if (n.name () == L"CanMeasureOuterD" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->CanMeasureOuterD_)
          {
            this->CanMeasureOuterD_.set (CanMeasureOuterD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureDepth
        //
        if (n.name () == L"CanMeasureDepth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->CanMeasureDepth_)
          {
            this->CanMeasureDepth_.set (CanMeasureDepth_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    CaliperType* CaliperType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CaliperType (*this, f, c);
    }

    CaliperType& CaliperType::
    operator= (const CaliperType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ManualMeasurementDeviceType& > (*this) = x;
        this->LinearResolution_ = x.LinearResolution_;
        this->Accuracy_ = x.Accuracy_;
        this->CanMeasureInnerD_ = x.CanMeasureInnerD_;
        this->CanMeasureOuterD_ = x.CanMeasureOuterD_;
        this->CanMeasureDepth_ = x.CanMeasureDepth_;
      }

      return *this;
    }

    CaliperType::
    ~CaliperType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CaliperType >
    _xsd_CaliperType_type_factory_init (
      L"CaliperType",
      L"http://qifstandards.org/xsd/qif3");

    // CaliperDialType
    //

    CaliperDialType::
    CaliperDialType ()
    : ::xsd::qif30::CaliperType ()
    {
    }

    CaliperDialType::
    CaliperDialType (const Name_type& Name,
                     const id_type& id)
    : ::xsd::qif30::CaliperType (Name,
                                 id)
    {
    }

    CaliperDialType::
    CaliperDialType (const CaliperDialType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CaliperType (x, f, c)
    {
    }

    CaliperDialType::
    CaliperDialType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CaliperType (e, f, c)
    {
    }

    CaliperDialType* CaliperDialType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CaliperDialType (*this, f, c);
    }

    CaliperDialType::
    ~CaliperDialType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CaliperDialType >
    _xsd_CaliperDialType_type_factory_init (
      L"CaliperDialType",
      L"http://qifstandards.org/xsd/qif3");

    // CaliperDigitalType
    //

    CaliperDigitalType::
    CaliperDigitalType ()
    : ::xsd::qif30::CaliperType ()
    {
    }

    CaliperDigitalType::
    CaliperDigitalType (const Name_type& Name,
                        const id_type& id)
    : ::xsd::qif30::CaliperType (Name,
                                 id)
    {
    }

    CaliperDigitalType::
    CaliperDigitalType (const CaliperDigitalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CaliperType (x, f, c)
    {
    }

    CaliperDigitalType::
    CaliperDigitalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CaliperType (e, f, c)
    {
    }

    CaliperDigitalType* CaliperDigitalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CaliperDigitalType (*this, f, c);
    }

    CaliperDigitalType::
    ~CaliperDigitalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CaliperDigitalType >
    _xsd_CaliperDigitalType_type_factory_init (
      L"CaliperDigitalType",
      L"http://qifstandards.org/xsd/qif3");

    // MicrometerType
    //

    const MicrometerType::InternalExternal_type MicrometerType::InternalExternal_default_value_ (
      L"INTERNAL");

    MicrometerType::
    MicrometerType ()
    : ::xsd::qif30::ManualMeasurementDeviceType (),
      LinearResolution_ (this),
      Accuracy_ (this),
      MeasuringForce_ (this),
      InternalExternal_ (this)
    {
    }

    MicrometerType::
    MicrometerType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif30::ManualMeasurementDeviceType (Name,
                                                 id),
      LinearResolution_ (this),
      Accuracy_ (this),
      MeasuringForce_ (this),
      InternalExternal_ (this)
    {
    }

    MicrometerType::
    MicrometerType (const MicrometerType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (x, f, c),
      LinearResolution_ (x.LinearResolution_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      MeasuringForce_ (x.MeasuringForce_, f, this),
      InternalExternal_ (x.InternalExternal_, f, this)
    {
    }

    MicrometerType::
    MicrometerType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      LinearResolution_ (this),
      Accuracy_ (this),
      MeasuringForce_ (this),
      InternalExternal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MicrometerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ManualMeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearResolution
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"LinearResolution",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< LinearResolution_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->LinearResolution_)
            {
              ::std::unique_ptr< LinearResolution_type > r (
                dynamic_cast< LinearResolution_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->LinearResolution_.set (::std::move (r));
              continue;
            }
          }
        }

        // Accuracy
        //
        if (n.name () == L"Accuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (::std::move (r));
            continue;
          }
        }

        // MeasuringForce
        //
        if (n.name () == L"MeasuringForce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuringForce_type > r (
            MeasuringForce_traits::create (i, f, this));

          if (!this->MeasuringForce_)
          {
            this->MeasuringForce_.set (::std::move (r));
            continue;
          }
        }

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!this->InternalExternal_)
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MicrometerType* MicrometerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MicrometerType (*this, f, c);
    }

    MicrometerType& MicrometerType::
    operator= (const MicrometerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ManualMeasurementDeviceType& > (*this) = x;
        this->LinearResolution_ = x.LinearResolution_;
        this->Accuracy_ = x.Accuracy_;
        this->MeasuringForce_ = x.MeasuringForce_;
        this->InternalExternal_ = x.InternalExternal_;
      }

      return *this;
    }

    MicrometerType::
    ~MicrometerType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MicrometerType >
    _xsd_MicrometerType_type_factory_init (
      L"MicrometerType",
      L"http://qifstandards.org/xsd/qif3");

    // MicrometerAnalogType
    //

    MicrometerAnalogType::
    MicrometerAnalogType ()
    : ::xsd::qif30::MicrometerType ()
    {
    }

    MicrometerAnalogType::
    MicrometerAnalogType (const Name_type& Name,
                          const id_type& id)
    : ::xsd::qif30::MicrometerType (Name,
                                    id)
    {
    }

    MicrometerAnalogType::
    MicrometerAnalogType (const MicrometerAnalogType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::MicrometerType (x, f, c)
    {
    }

    MicrometerAnalogType::
    MicrometerAnalogType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::MicrometerType (e, f, c)
    {
    }

    MicrometerAnalogType* MicrometerAnalogType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MicrometerAnalogType (*this, f, c);
    }

    MicrometerAnalogType::
    ~MicrometerAnalogType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MicrometerAnalogType >
    _xsd_MicrometerAnalogType_type_factory_init (
      L"MicrometerAnalogType",
      L"http://qifstandards.org/xsd/qif3");

    // MicrometerDigitalType
    //

    MicrometerDigitalType::
    MicrometerDigitalType ()
    : ::xsd::qif30::MicrometerType ()
    {
    }

    MicrometerDigitalType::
    MicrometerDigitalType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif30::MicrometerType (Name,
                                    id)
    {
    }

    MicrometerDigitalType::
    MicrometerDigitalType (const MicrometerDigitalType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MicrometerType (x, f, c)
    {
    }

    MicrometerDigitalType::
    MicrometerDigitalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MicrometerType (e, f, c)
    {
    }

    MicrometerDigitalType* MicrometerDigitalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MicrometerDigitalType (*this, f, c);
    }

    MicrometerDigitalType::
    ~MicrometerDigitalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MicrometerDigitalType >
    _xsd_MicrometerDigitalType_type_factory_init (
      L"MicrometerDigitalType",
      L"http://qifstandards.org/xsd/qif3");

    // GageDeviceType
    //

    GageDeviceType::
    GageDeviceType ()
    : ::xsd::qif30::ManualMeasurementDeviceType ()
    {
    }

    GageDeviceType::
    GageDeviceType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif30::ManualMeasurementDeviceType (Name,
                                                 id)
    {
    }

    GageDeviceType::
    GageDeviceType (const GageDeviceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (x, f, c)
    {
    }

    GageDeviceType::
    GageDeviceType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (e, f, c)
    {
    }

    GageDeviceType* GageDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageDeviceType (*this, f, c);
    }

    GageDeviceType::
    ~GageDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GageDeviceType >
    _xsd_GageDeviceType_type_factory_init (
      L"GageDeviceType",
      L"http://qifstandards.org/xsd/qif3");

    // SineBarType
    //

    SineBarType::
    SineBarType ()
    : ::xsd::qif30::ManualMeasurementDeviceType (),
      NominalBallCenterToBallCenterLength_ (this),
      CylinderCenterToCylinderCenterAccuracy_ (this),
      Parallelism_ (this),
      OverallLength_ (this),
      Material_ (this),
      Magnetic_ (this),
      Width_ (this)
    {
    }

    SineBarType::
    SineBarType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif30::ManualMeasurementDeviceType (Name,
                                                 id),
      NominalBallCenterToBallCenterLength_ (this),
      CylinderCenterToCylinderCenterAccuracy_ (this),
      Parallelism_ (this),
      OverallLength_ (this),
      Material_ (this),
      Magnetic_ (this),
      Width_ (this)
    {
    }

    SineBarType::
    SineBarType (const SineBarType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (x, f, c),
      NominalBallCenterToBallCenterLength_ (x.NominalBallCenterToBallCenterLength_, f, this),
      CylinderCenterToCylinderCenterAccuracy_ (x.CylinderCenterToCylinderCenterAccuracy_, f, this),
      Parallelism_ (x.Parallelism_, f, this),
      OverallLength_ (x.OverallLength_, f, this),
      Material_ (x.Material_, f, this),
      Magnetic_ (x.Magnetic_, f, this),
      Width_ (x.Width_, f, this)
    {
    }

    SineBarType::
    SineBarType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ManualMeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      NominalBallCenterToBallCenterLength_ (this),
      CylinderCenterToCylinderCenterAccuracy_ (this),
      Parallelism_ (this),
      OverallLength_ (this),
      Material_ (this),
      Magnetic_ (this),
      Width_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SineBarType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ManualMeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NominalBallCenterToBallCenterLength
        //
        if (n.name () == L"NominalBallCenterToBallCenterLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalBallCenterToBallCenterLength_type > r (
            NominalBallCenterToBallCenterLength_traits::create (i, f, this));

          if (!this->NominalBallCenterToBallCenterLength_)
          {
            this->NominalBallCenterToBallCenterLength_.set (::std::move (r));
            continue;
          }
        }

        // CylinderCenterToCylinderCenterAccuracy
        //
        if (n.name () == L"CylinderCenterToCylinderCenterAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CylinderCenterToCylinderCenterAccuracy_type > r (
            CylinderCenterToCylinderCenterAccuracy_traits::create (i, f, this));

          if (!this->CylinderCenterToCylinderCenterAccuracy_)
          {
            this->CylinderCenterToCylinderCenterAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // Parallelism
        //
        if (n.name () == L"Parallelism" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parallelism_type > r (
            Parallelism_traits::create (i, f, this));

          if (!this->Parallelism_)
          {
            this->Parallelism_.set (::std::move (r));
            continue;
          }
        }

        // OverallLength
        //
        if (n.name () == L"OverallLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OverallLength_type > r (
            OverallLength_traits::create (i, f, this));

          if (!this->OverallLength_)
          {
            this->OverallLength_.set (::std::move (r));
            continue;
          }
        }

        // Material
        //
        if (n.name () == L"Material" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Material_type > r (
            Material_traits::create (i, f, this));

          if (!this->Material_)
          {
            this->Material_.set (::std::move (r));
            continue;
          }
        }

        // Magnetic
        //
        if (n.name () == L"Magnetic" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Magnetic_)
          {
            this->Magnetic_.set (Magnetic_traits::create (i, f, this));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SineBarType* SineBarType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SineBarType (*this, f, c);
    }

    SineBarType& SineBarType::
    operator= (const SineBarType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ManualMeasurementDeviceType& > (*this) = x;
        this->NominalBallCenterToBallCenterLength_ = x.NominalBallCenterToBallCenterLength_;
        this->CylinderCenterToCylinderCenterAccuracy_ = x.CylinderCenterToCylinderCenterAccuracy_;
        this->Parallelism_ = x.Parallelism_;
        this->OverallLength_ = x.OverallLength_;
        this->Material_ = x.Material_;
        this->Magnetic_ = x.Magnetic_;
        this->Width_ = x.Width_;
      }

      return *this;
    }

    SineBarType::
    ~SineBarType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SineBarType >
    _xsd_SineBarType_type_factory_init (
      L"SineBarType",
      L"http://qifstandards.org/xsd/qif3");

    // TheodoliteType
    //

    TheodoliteType::
    TheodoliteType ()
    : ::xsd::qif30::UniversalDeviceType (),
      LongitudinalTrackingSpeed_ (this),
      LateralTrackingSpeed_ (this),
      Magnification_ (this),
      FieldOfViewDiameter_ (this),
      ApertureSize_ (this),
      MaxFocusDistance_ (this),
      AngularAccuracy_ (this),
      MaxTiltCompensation_ (this),
      ChargeCoupledDeviceCameraSensor_ (this),
      MinFocusDistance_ (this),
      EffectiveDiameterOfObjective_ (this),
      StadiaBaseConstant_ (this),
      StadiaRateConstant_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      Laser_ (this)
    {
    }

    TheodoliteType::
    TheodoliteType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      LongitudinalTrackingSpeed_ (this),
      LateralTrackingSpeed_ (this),
      Magnification_ (this),
      FieldOfViewDiameter_ (this),
      ApertureSize_ (this),
      MaxFocusDistance_ (this),
      AngularAccuracy_ (this),
      MaxTiltCompensation_ (this),
      ChargeCoupledDeviceCameraSensor_ (this),
      MinFocusDistance_ (this),
      EffectiveDiameterOfObjective_ (this),
      StadiaBaseConstant_ (this),
      StadiaRateConstant_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      Laser_ (this)
    {
    }

    TheodoliteType::
    TheodoliteType (const TheodoliteType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      LongitudinalTrackingSpeed_ (x.LongitudinalTrackingSpeed_, f, this),
      LateralTrackingSpeed_ (x.LateralTrackingSpeed_, f, this),
      Magnification_ (x.Magnification_, f, this),
      FieldOfViewDiameter_ (x.FieldOfViewDiameter_, f, this),
      ApertureSize_ (x.ApertureSize_, f, this),
      MaxFocusDistance_ (x.MaxFocusDistance_, f, this),
      AngularAccuracy_ (x.AngularAccuracy_, f, this),
      MaxTiltCompensation_ (x.MaxTiltCompensation_, f, this),
      ChargeCoupledDeviceCameraSensor_ (x.ChargeCoupledDeviceCameraSensor_, f, this),
      MinFocusDistance_ (x.MinFocusDistance_, f, this),
      EffectiveDiameterOfObjective_ (x.EffectiveDiameterOfObjective_, f, this),
      StadiaBaseConstant_ (x.StadiaBaseConstant_, f, this),
      StadiaRateConstant_ (x.StadiaRateConstant_, f, this),
      MinPowerSupplyVoltage_ (x.MinPowerSupplyVoltage_, f, this),
      MaxPowerSupplyVoltage_ (x.MaxPowerSupplyVoltage_, f, this),
      Laser_ (x.Laser_, f, this)
    {
    }

    TheodoliteType::
    TheodoliteType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      LongitudinalTrackingSpeed_ (this),
      LateralTrackingSpeed_ (this),
      Magnification_ (this),
      FieldOfViewDiameter_ (this),
      ApertureSize_ (this),
      MaxFocusDistance_ (this),
      AngularAccuracy_ (this),
      MaxTiltCompensation_ (this),
      ChargeCoupledDeviceCameraSensor_ (this),
      MinFocusDistance_ (this),
      EffectiveDiameterOfObjective_ (this),
      StadiaBaseConstant_ (this),
      StadiaRateConstant_ (this),
      MinPowerSupplyVoltage_ (this),
      MaxPowerSupplyVoltage_ (this),
      Laser_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TheodoliteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LongitudinalTrackingSpeed
        //
        if (n.name () == L"LongitudinalTrackingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LongitudinalTrackingSpeed_type > r (
            LongitudinalTrackingSpeed_traits::create (i, f, this));

          if (!this->LongitudinalTrackingSpeed_)
          {
            this->LongitudinalTrackingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // LateralTrackingSpeed
        //
        if (n.name () == L"LateralTrackingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LateralTrackingSpeed_type > r (
            LateralTrackingSpeed_traits::create (i, f, this));

          if (!this->LateralTrackingSpeed_)
          {
            this->LateralTrackingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // Magnification
        //
        if (n.name () == L"Magnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Magnification_)
          {
            this->Magnification_.set (Magnification_traits::create (i, f, this));
            continue;
          }
        }

        // FieldOfViewDiameter
        //
        if (n.name () == L"FieldOfViewDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FieldOfViewDiameter_type > r (
            FieldOfViewDiameter_traits::create (i, f, this));

          if (!this->FieldOfViewDiameter_)
          {
            this->FieldOfViewDiameter_.set (::std::move (r));
            continue;
          }
        }

        // ApertureSize
        //
        if (n.name () == L"ApertureSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApertureSize_type > r (
            ApertureSize_traits::create (i, f, this));

          if (!this->ApertureSize_)
          {
            this->ApertureSize_.set (::std::move (r));
            continue;
          }
        }

        // MaxFocusDistance
        //
        if (n.name () == L"MaxFocusDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFocusDistance_type > r (
            MaxFocusDistance_traits::create (i, f, this));

          if (!this->MaxFocusDistance_)
          {
            this->MaxFocusDistance_.set (::std::move (r));
            continue;
          }
        }

        // AngularAccuracy
        //
        if (n.name () == L"AngularAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularAccuracy_type > r (
            AngularAccuracy_traits::create (i, f, this));

          if (!this->AngularAccuracy_)
          {
            this->AngularAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // MaxTiltCompensation
        //
        if (n.name () == L"MaxTiltCompensation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxTiltCompensation_type > r (
            MaxTiltCompensation_traits::create (i, f, this));

          if (!this->MaxTiltCompensation_)
          {
            this->MaxTiltCompensation_.set (::std::move (r));
            continue;
          }
        }

        // ChargeCoupledDeviceCameraSensor
        //
        if (n.name () == L"ChargeCoupledDeviceCameraSensor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > r (
            ChargeCoupledDeviceCameraSensor_traits::create (i, f, this));

          if (!this->ChargeCoupledDeviceCameraSensor_)
          {
            this->ChargeCoupledDeviceCameraSensor_.set (::std::move (r));
            continue;
          }
        }

        // MinFocusDistance
        //
        if (n.name () == L"MinFocusDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinFocusDistance_type > r (
            MinFocusDistance_traits::create (i, f, this));

          if (!this->MinFocusDistance_)
          {
            this->MinFocusDistance_.set (::std::move (r));
            continue;
          }
        }

        // EffectiveDiameterOfObjective
        //
        if (n.name () == L"EffectiveDiameterOfObjective" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EffectiveDiameterOfObjective_type > r (
            EffectiveDiameterOfObjective_traits::create (i, f, this));

          if (!this->EffectiveDiameterOfObjective_)
          {
            this->EffectiveDiameterOfObjective_.set (::std::move (r));
            continue;
          }
        }

        // StadiaBaseConstant
        //
        if (n.name () == L"StadiaBaseConstant" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StadiaBaseConstant_type > r (
            StadiaBaseConstant_traits::create (i, f, this));

          if (!this->StadiaBaseConstant_)
          {
            this->StadiaBaseConstant_.set (::std::move (r));
            continue;
          }
        }

        // StadiaRateConstant
        //
        if (n.name () == L"StadiaRateConstant" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StadiaRateConstant_type > r (
            StadiaRateConstant_traits::create (i, f, this));

          if (!this->StadiaRateConstant_)
          {
            this->StadiaRateConstant_.set (::std::move (r));
            continue;
          }
        }

        // MinPowerSupplyVoltage
        //
        if (n.name () == L"MinPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinPowerSupplyVoltage_type > r (
            MinPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MinPowerSupplyVoltage_)
          {
            this->MinPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // MaxPowerSupplyVoltage
        //
        if (n.name () == L"MaxPowerSupplyVoltage" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPowerSupplyVoltage_type > r (
            MaxPowerSupplyVoltage_traits::create (i, f, this));

          if (!this->MaxPowerSupplyVoltage_)
          {
            this->MaxPowerSupplyVoltage_.set (::std::move (r));
            continue;
          }
        }

        // Laser
        //
        if (n.name () == L"Laser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Laser_type > r (
            Laser_traits::create (i, f, this));

          if (!this->Laser_)
          {
            this->Laser_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TheodoliteType* TheodoliteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TheodoliteType (*this, f, c);
    }

    TheodoliteType& TheodoliteType::
    operator= (const TheodoliteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->LongitudinalTrackingSpeed_ = x.LongitudinalTrackingSpeed_;
        this->LateralTrackingSpeed_ = x.LateralTrackingSpeed_;
        this->Magnification_ = x.Magnification_;
        this->FieldOfViewDiameter_ = x.FieldOfViewDiameter_;
        this->ApertureSize_ = x.ApertureSize_;
        this->MaxFocusDistance_ = x.MaxFocusDistance_;
        this->AngularAccuracy_ = x.AngularAccuracy_;
        this->MaxTiltCompensation_ = x.MaxTiltCompensation_;
        this->ChargeCoupledDeviceCameraSensor_ = x.ChargeCoupledDeviceCameraSensor_;
        this->MinFocusDistance_ = x.MinFocusDistance_;
        this->EffectiveDiameterOfObjective_ = x.EffectiveDiameterOfObjective_;
        this->StadiaBaseConstant_ = x.StadiaBaseConstant_;
        this->StadiaRateConstant_ = x.StadiaRateConstant_;
        this->MinPowerSupplyVoltage_ = x.MinPowerSupplyVoltage_;
        this->MaxPowerSupplyVoltage_ = x.MaxPowerSupplyVoltage_;
        this->Laser_ = x.Laser_;
      }

      return *this;
    }

    TheodoliteType::
    ~TheodoliteType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TheodoliteType >
    _xsd_TheodoliteType_type_factory_init (
      L"TheodoliteType",
      L"http://qifstandards.org/xsd/qif3");

    // UniversalLengthMeasuringType
    //

    UniversalLengthMeasuringType::
    UniversalLengthMeasuringType ()
    : ::xsd::qif30::UniversalDeviceType (),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MeasuringForce_ (this),
      Accuracy_ (this),
      Repeatability_ (this),
      ToolIds_ (this),
      MaxWorkpieceWeight_ (this)
    {
    }

    UniversalLengthMeasuringType::
    UniversalLengthMeasuringType (const Name_type& Name,
                                  const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MeasuringForce_ (this),
      Accuracy_ (this),
      Repeatability_ (this),
      ToolIds_ (this),
      MaxWorkpieceWeight_ (this)
    {
    }

    UniversalLengthMeasuringType::
    UniversalLengthMeasuringType (const UniversalLengthMeasuringType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      MeasuringForce_ (x.MeasuringForce_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      Repeatability_ (x.Repeatability_, f, this),
      ToolIds_ (x.ToolIds_, f, this),
      MaxWorkpieceWeight_ (x.MaxWorkpieceWeight_, f, this)
    {
    }

    UniversalLengthMeasuringType::
    UniversalLengthMeasuringType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      MeasuringForce_ (this),
      Accuracy_ (this),
      Repeatability_ (this),
      ToolIds_ (this),
      MaxWorkpieceWeight_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void UniversalLengthMeasuringType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MeasuringForce
        //
        if (n.name () == L"MeasuringForce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuringForce_type > r (
            MeasuringForce_traits::create (i, f, this));

          if (!this->MeasuringForce_)
          {
            this->MeasuringForce_.set (::std::move (r));
            continue;
          }
        }

        // Accuracy
        //
        if (n.name () == L"Accuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (::std::move (r));
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == L"Repeatability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!this->Repeatability_)
          {
            this->Repeatability_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        // MaxWorkpieceWeight
        //
        if (n.name () == L"MaxWorkpieceWeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceWeight_type > r (
            MaxWorkpieceWeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceWeight_)
          {
            this->MaxWorkpieceWeight_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    UniversalLengthMeasuringType* UniversalLengthMeasuringType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UniversalLengthMeasuringType (*this, f, c);
    }

    UniversalLengthMeasuringType& UniversalLengthMeasuringType::
    operator= (const UniversalLengthMeasuringType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->MeasuringForce_ = x.MeasuringForce_;
        this->Accuracy_ = x.Accuracy_;
        this->Repeatability_ = x.Repeatability_;
        this->ToolIds_ = x.ToolIds_;
        this->MaxWorkpieceWeight_ = x.MaxWorkpieceWeight_;
      }

      return *this;
    }

    UniversalLengthMeasuringType::
    ~UniversalLengthMeasuringType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UniversalLengthMeasuringType >
    _xsd_UniversalLengthMeasuringType_type_factory_init (
      L"UniversalLengthMeasuringType",
      L"http://qifstandards.org/xsd/qif3");

    // ComputedTomographyType
    //

    ComputedTomographyType::
    ComputedTomographyType ()
    : ::xsd::qif30::UniversalDeviceType (),
      SourceDescription_ (this),
      SamplePenetratingMaterial_ (this),
      SamplePenetratingMaterialLength_ (this),
      FocalSpotSize_ (this),
      MaxWorkpieceMass_ (this),
      SafetyLevel_ (this),
      CabinetDimensions_ (this),
      MaxPower_ (this),
      DetectorBitNumber_ (this),
      DetectorPixelSize_ (this),
      ActivePixelsNumber_ (this),
      MaxKV_ (this),
      MinOperatingCurrent_ (this),
      MaxOperatingCurrent_ (this),
      MaxFramePerSecond_ (this),
      RotaryTable_ (this),
      ToolIds_ (this)
    {
    }

    ComputedTomographyType::
    ComputedTomographyType (const Name_type& Name,
                            const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      SourceDescription_ (this),
      SamplePenetratingMaterial_ (this),
      SamplePenetratingMaterialLength_ (this),
      FocalSpotSize_ (this),
      MaxWorkpieceMass_ (this),
      SafetyLevel_ (this),
      CabinetDimensions_ (this),
      MaxPower_ (this),
      DetectorBitNumber_ (this),
      DetectorPixelSize_ (this),
      ActivePixelsNumber_ (this),
      MaxKV_ (this),
      MinOperatingCurrent_ (this),
      MaxOperatingCurrent_ (this),
      MaxFramePerSecond_ (this),
      RotaryTable_ (this),
      ToolIds_ (this)
    {
    }

    ComputedTomographyType::
    ComputedTomographyType (const ComputedTomographyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      SourceDescription_ (x.SourceDescription_, f, this),
      SamplePenetratingMaterial_ (x.SamplePenetratingMaterial_, f, this),
      SamplePenetratingMaterialLength_ (x.SamplePenetratingMaterialLength_, f, this),
      FocalSpotSize_ (x.FocalSpotSize_, f, this),
      MaxWorkpieceMass_ (x.MaxWorkpieceMass_, f, this),
      SafetyLevel_ (x.SafetyLevel_, f, this),
      CabinetDimensions_ (x.CabinetDimensions_, f, this),
      MaxPower_ (x.MaxPower_, f, this),
      DetectorBitNumber_ (x.DetectorBitNumber_, f, this),
      DetectorPixelSize_ (x.DetectorPixelSize_, f, this),
      ActivePixelsNumber_ (x.ActivePixelsNumber_, f, this),
      MaxKV_ (x.MaxKV_, f, this),
      MinOperatingCurrent_ (x.MinOperatingCurrent_, f, this),
      MaxOperatingCurrent_ (x.MaxOperatingCurrent_, f, this),
      MaxFramePerSecond_ (x.MaxFramePerSecond_, f, this),
      RotaryTable_ (x.RotaryTable_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    ComputedTomographyType::
    ComputedTomographyType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      SourceDescription_ (this),
      SamplePenetratingMaterial_ (this),
      SamplePenetratingMaterialLength_ (this),
      FocalSpotSize_ (this),
      MaxWorkpieceMass_ (this),
      SafetyLevel_ (this),
      CabinetDimensions_ (this),
      MaxPower_ (this),
      DetectorBitNumber_ (this),
      DetectorPixelSize_ (this),
      ActivePixelsNumber_ (this),
      MaxKV_ (this),
      MinOperatingCurrent_ (this),
      MaxOperatingCurrent_ (this),
      MaxFramePerSecond_ (this),
      RotaryTable_ (this),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComputedTomographyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SourceDescription
        //
        if (n.name () == L"SourceDescription" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SourceDescription_type > r (
            SourceDescription_traits::create (i, f, this));

          if (!this->SourceDescription_)
          {
            this->SourceDescription_.set (::std::move (r));
            continue;
          }
        }

        // SamplePenetratingMaterial
        //
        if (n.name () == L"SamplePenetratingMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplePenetratingMaterial_type > r (
            SamplePenetratingMaterial_traits::create (i, f, this));

          if (!this->SamplePenetratingMaterial_)
          {
            this->SamplePenetratingMaterial_.set (::std::move (r));
            continue;
          }
        }

        // SamplePenetratingMaterialLength
        //
        if (n.name () == L"SamplePenetratingMaterialLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplePenetratingMaterialLength_type > r (
            SamplePenetratingMaterialLength_traits::create (i, f, this));

          if (!this->SamplePenetratingMaterialLength_)
          {
            this->SamplePenetratingMaterialLength_.set (::std::move (r));
            continue;
          }
        }

        // FocalSpotSize
        //
        if (n.name () == L"FocalSpotSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FocalSpotSize_type > r (
            FocalSpotSize_traits::create (i, f, this));

          if (!this->FocalSpotSize_)
          {
            this->FocalSpotSize_.set (::std::move (r));
            continue;
          }
        }

        // MaxWorkpieceMass
        //
        if (n.name () == L"MaxWorkpieceMass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceMass_type > r (
            MaxWorkpieceMass_traits::create (i, f, this));

          if (!this->MaxWorkpieceMass_)
          {
            this->MaxWorkpieceMass_.set (::std::move (r));
            continue;
          }
        }

        // SafetyLevel
        //
        if (n.name () == L"SafetyLevel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SafetyLevel_type > r (
            SafetyLevel_traits::create (i, f, this));

          if (!this->SafetyLevel_)
          {
            this->SafetyLevel_.set (::std::move (r));
            continue;
          }
        }

        // CabinetDimensions
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CabinetDimensions",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< CabinetDimensions_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CabinetDimensions_)
            {
              ::std::unique_ptr< CabinetDimensions_type > r (
                dynamic_cast< CabinetDimensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CabinetDimensions_.set (::std::move (r));
              continue;
            }
          }
        }

        // MaxPower
        //
        if (n.name () == L"MaxPower" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPower_type > r (
            MaxPower_traits::create (i, f, this));

          if (!this->MaxPower_)
          {
            this->MaxPower_.set (::std::move (r));
            continue;
          }
        }

        // DetectorBitNumber
        //
        if (n.name () == L"DetectorBitNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->DetectorBitNumber_)
          {
            this->DetectorBitNumber_.set (DetectorBitNumber_traits::create (i, f, this));
            continue;
          }
        }

        // DetectorPixelSize
        //
        if (n.name () == L"DetectorPixelSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DetectorPixelSize_type > r (
            DetectorPixelSize_traits::create (i, f, this));

          if (!this->DetectorPixelSize_)
          {
            this->DetectorPixelSize_.set (::std::move (r));
            continue;
          }
        }

        // ActivePixelsNumber
        //
        if (n.name () == L"ActivePixelsNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActivePixelsNumber_type > r (
            ActivePixelsNumber_traits::create (i, f, this));

          if (!this->ActivePixelsNumber_)
          {
            this->ActivePixelsNumber_.set (::std::move (r));
            continue;
          }
        }

        // MaxKV
        //
        if (n.name () == L"MaxKV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxKV_type > r (
            MaxKV_traits::create (i, f, this));

          if (!this->MaxKV_)
          {
            this->MaxKV_.set (::std::move (r));
            continue;
          }
        }

        // MinOperatingCurrent
        //
        if (n.name () == L"MinOperatingCurrent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinOperatingCurrent_type > r (
            MinOperatingCurrent_traits::create (i, f, this));

          if (!this->MinOperatingCurrent_)
          {
            this->MinOperatingCurrent_.set (::std::move (r));
            continue;
          }
        }

        // MaxOperatingCurrent
        //
        if (n.name () == L"MaxOperatingCurrent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxOperatingCurrent_type > r (
            MaxOperatingCurrent_traits::create (i, f, this));

          if (!this->MaxOperatingCurrent_)
          {
            this->MaxOperatingCurrent_.set (::std::move (r));
            continue;
          }
        }

        // MaxFramePerSecond
        //
        if (n.name () == L"MaxFramePerSecond" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxFramePerSecond_type > r (
            MaxFramePerSecond_traits::create (i, f, this));

          if (!this->MaxFramePerSecond_)
          {
            this->MaxFramePerSecond_.set (::std::move (r));
            continue;
          }
        }

        // RotaryTable
        //
        if (n.name () == L"RotaryTable" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RotaryTable_type > r (
            RotaryTable_traits::create (i, f, this));

          if (!this->RotaryTable_)
          {
            this->RotaryTable_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ComputedTomographyType* ComputedTomographyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComputedTomographyType (*this, f, c);
    }

    ComputedTomographyType& ComputedTomographyType::
    operator= (const ComputedTomographyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->SourceDescription_ = x.SourceDescription_;
        this->SamplePenetratingMaterial_ = x.SamplePenetratingMaterial_;
        this->SamplePenetratingMaterialLength_ = x.SamplePenetratingMaterialLength_;
        this->FocalSpotSize_ = x.FocalSpotSize_;
        this->MaxWorkpieceMass_ = x.MaxWorkpieceMass_;
        this->SafetyLevel_ = x.SafetyLevel_;
        this->CabinetDimensions_ = x.CabinetDimensions_;
        this->MaxPower_ = x.MaxPower_;
        this->DetectorBitNumber_ = x.DetectorBitNumber_;
        this->DetectorPixelSize_ = x.DetectorPixelSize_;
        this->ActivePixelsNumber_ = x.ActivePixelsNumber_;
        this->MaxKV_ = x.MaxKV_;
        this->MinOperatingCurrent_ = x.MinOperatingCurrent_;
        this->MaxOperatingCurrent_ = x.MaxOperatingCurrent_;
        this->MaxFramePerSecond_ = x.MaxFramePerSecond_;
        this->RotaryTable_ = x.RotaryTable_;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    ComputedTomographyType::
    ~ComputedTomographyType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ComputedTomographyType >
    _xsd_ComputedTomographyType_type_factory_init (
      L"ComputedTomographyType",
      L"http://qifstandards.org/xsd/qif3");

    // OpticalComparatorType
    //

    OpticalComparatorType::
    OpticalComparatorType ()
    : ::xsd::qif30::UniversalDeviceType (),
      Magnification_ (this),
      EffectiveScreenDiameter_ (this),
      ScreenMaterial_ (this),
      AngleResolution_ (this),
      SurfaceIlluminationLightSource_ (this),
      ContourIlluminationLightSource_ (this),
      MaxWorkpieceHeight_ (this),
      WorkingDistance_ (this),
      ToolIds_ (this)
    {
    }

    OpticalComparatorType::
    OpticalComparatorType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      Magnification_ (this),
      EffectiveScreenDiameter_ (this),
      ScreenMaterial_ (this),
      AngleResolution_ (this),
      SurfaceIlluminationLightSource_ (this),
      ContourIlluminationLightSource_ (this),
      MaxWorkpieceHeight_ (this),
      WorkingDistance_ (this),
      ToolIds_ (this)
    {
    }

    OpticalComparatorType::
    OpticalComparatorType (const OpticalComparatorType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      Magnification_ (x.Magnification_, f, this),
      EffectiveScreenDiameter_ (x.EffectiveScreenDiameter_, f, this),
      ScreenMaterial_ (x.ScreenMaterial_, f, this),
      AngleResolution_ (x.AngleResolution_, f, this),
      SurfaceIlluminationLightSource_ (x.SurfaceIlluminationLightSource_, f, this),
      ContourIlluminationLightSource_ (x.ContourIlluminationLightSource_, f, this),
      MaxWorkpieceHeight_ (x.MaxWorkpieceHeight_, f, this),
      WorkingDistance_ (x.WorkingDistance_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    OpticalComparatorType::
    OpticalComparatorType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      Magnification_ (this),
      EffectiveScreenDiameter_ (this),
      ScreenMaterial_ (this),
      AngleResolution_ (this),
      SurfaceIlluminationLightSource_ (this),
      ContourIlluminationLightSource_ (this),
      MaxWorkpieceHeight_ (this),
      WorkingDistance_ (this),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OpticalComparatorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Magnification
        //
        if (n.name () == L"Magnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Magnification_)
          {
            this->Magnification_.set (Magnification_traits::create (i, f, this));
            continue;
          }
        }

        // EffectiveScreenDiameter
        //
        if (n.name () == L"EffectiveScreenDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EffectiveScreenDiameter_type > r (
            EffectiveScreenDiameter_traits::create (i, f, this));

          if (!this->EffectiveScreenDiameter_)
          {
            this->EffectiveScreenDiameter_.set (::std::move (r));
            continue;
          }
        }

        // ScreenMaterial
        //
        if (n.name () == L"ScreenMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScreenMaterial_type > r (
            ScreenMaterial_traits::create (i, f, this));

          if (!this->ScreenMaterial_)
          {
            this->ScreenMaterial_.set (::std::move (r));
            continue;
          }
        }

        // AngleResolution
        //
        if (n.name () == L"AngleResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngleResolution_type > r (
            AngleResolution_traits::create (i, f, this));

          if (!this->AngleResolution_)
          {
            this->AngleResolution_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceIlluminationLightSource
        //
        if (n.name () == L"SurfaceIlluminationLightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceIlluminationLightSource_type > r (
            SurfaceIlluminationLightSource_traits::create (i, f, this));

          if (!this->SurfaceIlluminationLightSource_)
          {
            this->SurfaceIlluminationLightSource_.set (::std::move (r));
            continue;
          }
        }

        // ContourIlluminationLightSource
        //
        if (n.name () == L"ContourIlluminationLightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ContourIlluminationLightSource_type > r (
            ContourIlluminationLightSource_traits::create (i, f, this));

          if (!this->ContourIlluminationLightSource_)
          {
            this->ContourIlluminationLightSource_.set (::std::move (r));
            continue;
          }
        }

        // MaxWorkpieceHeight
        //
        if (n.name () == L"MaxWorkpieceHeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceHeight_type > r (
            MaxWorkpieceHeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceHeight_)
          {
            this->MaxWorkpieceHeight_.set (::std::move (r));
            continue;
          }
        }

        // WorkingDistance
        //
        if (n.name () == L"WorkingDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkingDistance_type > r (
            WorkingDistance_traits::create (i, f, this));

          if (!this->WorkingDistance_)
          {
            this->WorkingDistance_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OpticalComparatorType* OpticalComparatorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OpticalComparatorType (*this, f, c);
    }

    OpticalComparatorType& OpticalComparatorType::
    operator= (const OpticalComparatorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->Magnification_ = x.Magnification_;
        this->EffectiveScreenDiameter_ = x.EffectiveScreenDiameter_;
        this->ScreenMaterial_ = x.ScreenMaterial_;
        this->AngleResolution_ = x.AngleResolution_;
        this->SurfaceIlluminationLightSource_ = x.SurfaceIlluminationLightSource_;
        this->ContourIlluminationLightSource_ = x.ContourIlluminationLightSource_;
        this->MaxWorkpieceHeight_ = x.MaxWorkpieceHeight_;
        this->WorkingDistance_ = x.WorkingDistance_;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    OpticalComparatorType::
    ~OpticalComparatorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OpticalComparatorType >
    _xsd_OpticalComparatorType_type_factory_init (
      L"OpticalComparatorType",
      L"http://qifstandards.org/xsd/qif3");

    // MicroscopeType
    //

    MicroscopeType::
    MicroscopeType ()
    : ::xsd::qif30::UniversalDeviceType (),
      IlluminationUnit_ (this),
      TotalMagnification_ (this),
      EyePieceMagnification_ (this),
      ObjectiveMagnification_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceWeight_ (this),
      Accuracy_ (this),
      StageSwivelingAngle_ (this),
      ToolIds_ (this)
    {
    }

    MicroscopeType::
    MicroscopeType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      IlluminationUnit_ (this),
      TotalMagnification_ (this),
      EyePieceMagnification_ (this),
      ObjectiveMagnification_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceWeight_ (this),
      Accuracy_ (this),
      StageSwivelingAngle_ (this),
      ToolIds_ (this)
    {
    }

    MicroscopeType::
    MicroscopeType (const MicroscopeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      IlluminationUnit_ (x.IlluminationUnit_, f, this),
      TotalMagnification_ (x.TotalMagnification_, f, this),
      EyePieceMagnification_ (x.EyePieceMagnification_, f, this),
      ObjectiveMagnification_ (x.ObjectiveMagnification_, f, this),
      MaxWorkpieceHeight_ (x.MaxWorkpieceHeight_, f, this),
      MaxWorkpieceWeight_ (x.MaxWorkpieceWeight_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      StageSwivelingAngle_ (x.StageSwivelingAngle_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    MicroscopeType::
    MicroscopeType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      IlluminationUnit_ (this),
      TotalMagnification_ (this),
      EyePieceMagnification_ (this),
      ObjectiveMagnification_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceWeight_ (this),
      Accuracy_ (this),
      StageSwivelingAngle_ (this),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MicroscopeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IlluminationUnit
        //
        if (n.name () == L"IlluminationUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IlluminationUnit_type > r (
            IlluminationUnit_traits::create (i, f, this));

          if (!this->IlluminationUnit_)
          {
            this->IlluminationUnit_.set (::std::move (r));
            continue;
          }
        }

        // TotalMagnification
        //
        if (n.name () == L"TotalMagnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->TotalMagnification_)
          {
            this->TotalMagnification_.set (TotalMagnification_traits::create (i, f, this));
            continue;
          }
        }

        // EyePieceMagnification
        //
        if (n.name () == L"EyePieceMagnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->EyePieceMagnification_)
          {
            this->EyePieceMagnification_.set (EyePieceMagnification_traits::create (i, f, this));
            continue;
          }
        }

        // ObjectiveMagnification
        //
        if (n.name () == L"ObjectiveMagnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ObjectiveMagnification_)
          {
            this->ObjectiveMagnification_.set (ObjectiveMagnification_traits::create (i, f, this));
            continue;
          }
        }

        // MaxWorkpieceHeight
        //
        if (n.name () == L"MaxWorkpieceHeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceHeight_type > r (
            MaxWorkpieceHeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceHeight_)
          {
            this->MaxWorkpieceHeight_.set (::std::move (r));
            continue;
          }
        }

        // MaxWorkpieceWeight
        //
        if (n.name () == L"MaxWorkpieceWeight" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxWorkpieceWeight_type > r (
            MaxWorkpieceWeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceWeight_)
          {
            this->MaxWorkpieceWeight_.set (::std::move (r));
            continue;
          }
        }

        // Accuracy
        //
        if (n.name () == L"Accuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (::std::move (r));
            continue;
          }
        }

        // StageSwivelingAngle
        //
        if (n.name () == L"StageSwivelingAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StageSwivelingAngle_type > r (
            StageSwivelingAngle_traits::create (i, f, this));

          if (!this->StageSwivelingAngle_)
          {
            this->StageSwivelingAngle_.set (::std::move (r));
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == L"ToolIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MicroscopeType* MicroscopeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MicroscopeType (*this, f, c);
    }

    MicroscopeType& MicroscopeType::
    operator= (const MicroscopeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->IlluminationUnit_ = x.IlluminationUnit_;
        this->TotalMagnification_ = x.TotalMagnification_;
        this->EyePieceMagnification_ = x.EyePieceMagnification_;
        this->ObjectiveMagnification_ = x.ObjectiveMagnification_;
        this->MaxWorkpieceHeight_ = x.MaxWorkpieceHeight_;
        this->MaxWorkpieceWeight_ = x.MaxWorkpieceWeight_;
        this->Accuracy_ = x.Accuracy_;
        this->StageSwivelingAngle_ = x.StageSwivelingAngle_;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    MicroscopeType::
    ~MicroscopeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MicroscopeType >
    _xsd_MicroscopeType_type_factory_init (
      L"MicroscopeType",
      L"http://qifstandards.org/xsd/qif3");

    // AutocollimatorType
    //

    AutocollimatorType::
    AutocollimatorType ()
    : ::xsd::qif30::UniversalDeviceType (),
      LightSource_ (this),
      MeasuringAccuracy_ (this),
      Magnification_ (this),
      ApertureSize_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ObjectiveFocalLength_ (this),
      FieldOfView_ (this)
    {
    }

    AutocollimatorType::
    AutocollimatorType (const Name_type& Name,
                        const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      LightSource_ (this),
      MeasuringAccuracy_ (this),
      Magnification_ (this),
      ApertureSize_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ObjectiveFocalLength_ (this),
      FieldOfView_ (this)
    {
    }

    AutocollimatorType::
    AutocollimatorType (const AutocollimatorType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      LightSource_ (x.LightSource_, f, this),
      MeasuringAccuracy_ (x.MeasuringAccuracy_, f, this),
      Magnification_ (x.Magnification_, f, this),
      ApertureSize_ (x.ApertureSize_, f, this),
      MinMeasuringDistance_ (x.MinMeasuringDistance_, f, this),
      MaxMeasuringDistance_ (x.MaxMeasuringDistance_, f, this),
      ObjectiveFocalLength_ (x.ObjectiveFocalLength_, f, this),
      FieldOfView_ (x.FieldOfView_, f, this)
    {
    }

    AutocollimatorType::
    AutocollimatorType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      LightSource_ (this),
      MeasuringAccuracy_ (this),
      Magnification_ (this),
      ApertureSize_ (this),
      MinMeasuringDistance_ (this),
      MaxMeasuringDistance_ (this),
      ObjectiveFocalLength_ (this),
      FieldOfView_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AutocollimatorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LightSource
        //
        if (n.name () == L"LightSource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LightSource_type > r (
            LightSource_traits::create (i, f, this));

          if (!this->LightSource_)
          {
            this->LightSource_.set (::std::move (r));
            continue;
          }
        }

        // MeasuringAccuracy
        //
        if (n.name () == L"MeasuringAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuringAccuracy_type > r (
            MeasuringAccuracy_traits::create (i, f, this));

          if (!this->MeasuringAccuracy_)
          {
            this->MeasuringAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // Magnification
        //
        if (n.name () == L"Magnification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Magnification_)
          {
            this->Magnification_.set (Magnification_traits::create (i, f, this));
            continue;
          }
        }

        // ApertureSize
        //
        if (n.name () == L"ApertureSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ApertureSize_type > r (
            ApertureSize_traits::create (i, f, this));

          if (!this->ApertureSize_)
          {
            this->ApertureSize_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasuringDistance
        //
        if (n.name () == L"MinMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasuringDistance_type > r (
            MinMeasuringDistance_traits::create (i, f, this));

          if (!this->MinMeasuringDistance_)
          {
            this->MinMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasuringDistance
        //
        if (n.name () == L"MaxMeasuringDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasuringDistance_type > r (
            MaxMeasuringDistance_traits::create (i, f, this));

          if (!this->MaxMeasuringDistance_)
          {
            this->MaxMeasuringDistance_.set (::std::move (r));
            continue;
          }
        }

        // ObjectiveFocalLength
        //
        if (n.name () == L"ObjectiveFocalLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ObjectiveFocalLength_type > r (
            ObjectiveFocalLength_traits::create (i, f, this));

          if (!this->ObjectiveFocalLength_)
          {
            this->ObjectiveFocalLength_.set (::std::move (r));
            continue;
          }
        }

        // FieldOfView
        //
        if (n.name () == L"FieldOfView" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FieldOfView_type > r (
            FieldOfView_traits::create (i, f, this));

          if (!this->FieldOfView_)
          {
            this->FieldOfView_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AutocollimatorType* AutocollimatorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AutocollimatorType (*this, f, c);
    }

    AutocollimatorType& AutocollimatorType::
    operator= (const AutocollimatorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->LightSource_ = x.LightSource_;
        this->MeasuringAccuracy_ = x.MeasuringAccuracy_;
        this->Magnification_ = x.Magnification_;
        this->ApertureSize_ = x.ApertureSize_;
        this->MinMeasuringDistance_ = x.MinMeasuringDistance_;
        this->MaxMeasuringDistance_ = x.MaxMeasuringDistance_;
        this->ObjectiveFocalLength_ = x.ObjectiveFocalLength_;
        this->FieldOfView_ = x.FieldOfView_;
      }

      return *this;
    }

    AutocollimatorType::
    ~AutocollimatorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AutocollimatorType >
    _xsd_AutocollimatorType_type_factory_init (
      L"AutocollimatorType",
      L"http://qifstandards.org/xsd/qif3");

    // LaserTrackerType
    //

    LaserTrackerType::
    LaserTrackerType ()
    : ::xsd::qif30::UniversalDeviceType (),
      MaximumAngularVelocity_ (this),
      DistanceAccuracy_ (this),
      AngularAccuracy_ (this),
      SamplingRate_ (this),
      TargetMirror_ (this),
      HeadMass_ (this),
      HeadSize_ (this),
      MaximumWorkingAmplitude_ (this),
      Laser_ (this),
      Repeatability_ (this)
    {
    }

    LaserTrackerType::
    LaserTrackerType (const Name_type& Name,
                      const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      MaximumAngularVelocity_ (this),
      DistanceAccuracy_ (this),
      AngularAccuracy_ (this),
      SamplingRate_ (this),
      TargetMirror_ (this),
      HeadMass_ (this),
      HeadSize_ (this),
      MaximumWorkingAmplitude_ (this),
      Laser_ (this),
      Repeatability_ (this)
    {
    }

    LaserTrackerType::
    LaserTrackerType (const LaserTrackerType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      MaximumAngularVelocity_ (x.MaximumAngularVelocity_, f, this),
      DistanceAccuracy_ (x.DistanceAccuracy_, f, this),
      AngularAccuracy_ (x.AngularAccuracy_, f, this),
      SamplingRate_ (x.SamplingRate_, f, this),
      TargetMirror_ (x.TargetMirror_, f, this),
      HeadMass_ (x.HeadMass_, f, this),
      HeadSize_ (x.HeadSize_, f, this),
      MaximumWorkingAmplitude_ (x.MaximumWorkingAmplitude_, f, this),
      Laser_ (x.Laser_, f, this),
      Repeatability_ (x.Repeatability_, f, this)
    {
    }

    LaserTrackerType::
    LaserTrackerType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      MaximumAngularVelocity_ (this),
      DistanceAccuracy_ (this),
      AngularAccuracy_ (this),
      SamplingRate_ (this),
      TargetMirror_ (this),
      HeadMass_ (this),
      HeadSize_ (this),
      MaximumWorkingAmplitude_ (this),
      Laser_ (this),
      Repeatability_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LaserTrackerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaximumAngularVelocity
        //
        if (n.name () == L"MaximumAngularVelocity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumAngularVelocity_type > r (
            MaximumAngularVelocity_traits::create (i, f, this));

          if (!this->MaximumAngularVelocity_)
          {
            this->MaximumAngularVelocity_.set (::std::move (r));
            continue;
          }
        }

        // DistanceAccuracy
        //
        if (n.name () == L"DistanceAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DistanceAccuracy_type > r (
            DistanceAccuracy_traits::create (i, f, this));

          if (!this->DistanceAccuracy_)
          {
            this->DistanceAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // AngularAccuracy
        //
        if (n.name () == L"AngularAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularAccuracy_type > r (
            AngularAccuracy_traits::create (i, f, this));

          if (!this->AngularAccuracy_)
          {
            this->AngularAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // SamplingRate
        //
        if (n.name () == L"SamplingRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingRate_type > r (
            SamplingRate_traits::create (i, f, this));

          if (!this->SamplingRate_)
          {
            this->SamplingRate_.set (::std::move (r));
            continue;
          }
        }

        // TargetMirror
        //
        if (n.name () == L"TargetMirror" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TargetMirror_type > r (
            TargetMirror_traits::create (i, f, this));

          if (!this->TargetMirror_)
          {
            this->TargetMirror_.set (::std::move (r));
            continue;
          }
        }

        // HeadMass
        //
        if (n.name () == L"HeadMass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HeadMass_type > r (
            HeadMass_traits::create (i, f, this));

          if (!this->HeadMass_)
          {
            this->HeadMass_.set (::std::move (r));
            continue;
          }
        }

        // HeadSize
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"HeadSize",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< HeadSize_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->HeadSize_)
            {
              ::std::unique_ptr< HeadSize_type > r (
                dynamic_cast< HeadSize_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->HeadSize_.set (::std::move (r));
              continue;
            }
          }
        }

        // MaximumWorkingAmplitude
        //
        if (n.name () == L"MaximumWorkingAmplitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumWorkingAmplitude_type > r (
            MaximumWorkingAmplitude_traits::create (i, f, this));

          if (!this->MaximumWorkingAmplitude_)
          {
            this->MaximumWorkingAmplitude_.set (::std::move (r));
            continue;
          }
        }

        // Laser
        //
        if (n.name () == L"Laser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Laser_type > r (
            Laser_traits::create (i, f, this));

          if (!this->Laser_)
          {
            this->Laser_.set (::std::move (r));
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == L"Repeatability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!this->Repeatability_)
          {
            this->Repeatability_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LaserTrackerType* LaserTrackerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserTrackerType (*this, f, c);
    }

    LaserTrackerType& LaserTrackerType::
    operator= (const LaserTrackerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->MaximumAngularVelocity_ = x.MaximumAngularVelocity_;
        this->DistanceAccuracy_ = x.DistanceAccuracy_;
        this->AngularAccuracy_ = x.AngularAccuracy_;
        this->SamplingRate_ = x.SamplingRate_;
        this->TargetMirror_ = x.TargetMirror_;
        this->HeadMass_ = x.HeadMass_;
        this->HeadSize_ = x.HeadSize_;
        this->MaximumWorkingAmplitude_ = x.MaximumWorkingAmplitude_;
        this->Laser_ = x.Laser_;
        this->Repeatability_ = x.Repeatability_;
      }

      return *this;
    }

    LaserTrackerType::
    ~LaserTrackerType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LaserTrackerType >
    _xsd_LaserTrackerType_type_factory_init (
      L"LaserTrackerType",
      L"http://qifstandards.org/xsd/qif3");

    // LaserRadarType
    //

    LaserRadarType::
    LaserRadarType ()
    : ::xsd::qif30::UniversalDeviceType (),
      MeasurementLaser_ (this),
      PointingLaser_ (this),
      MaxPointsRate_ (this),
      MaxMeasurementRange_ (this),
      MinMeasurementRange_ (this),
      ScanningSpeed_ (this),
      DistanceAccuracy_ (this),
      AzimuthAngularAccuracy_ (this),
      ElevationAngularAccuracy_ (this),
      RangeForVolumetricUncertainty_ (this),
      VolumetricUncertainty_ (this),
      MaxEnvironmentalAltitude_ (this),
      MinEnvironmentalAltitude_ (this),
      SurfacePointsSpeed_ (this),
      ToolingBallSpeed_ (this),
      FeatureSpeed_ (this)
    {
    }

    LaserRadarType::
    LaserRadarType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif30::UniversalDeviceType (Name,
                                         id),
      MeasurementLaser_ (this),
      PointingLaser_ (this),
      MaxPointsRate_ (this),
      MaxMeasurementRange_ (this),
      MinMeasurementRange_ (this),
      ScanningSpeed_ (this),
      DistanceAccuracy_ (this),
      AzimuthAngularAccuracy_ (this),
      ElevationAngularAccuracy_ (this),
      RangeForVolumetricUncertainty_ (this),
      VolumetricUncertainty_ (this),
      MaxEnvironmentalAltitude_ (this),
      MinEnvironmentalAltitude_ (this),
      SurfacePointsSpeed_ (this),
      ToolingBallSpeed_ (this),
      FeatureSpeed_ (this)
    {
    }

    LaserRadarType::
    LaserRadarType (const LaserRadarType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (x, f, c),
      MeasurementLaser_ (x.MeasurementLaser_, f, this),
      PointingLaser_ (x.PointingLaser_, f, this),
      MaxPointsRate_ (x.MaxPointsRate_, f, this),
      MaxMeasurementRange_ (x.MaxMeasurementRange_, f, this),
      MinMeasurementRange_ (x.MinMeasurementRange_, f, this),
      ScanningSpeed_ (x.ScanningSpeed_, f, this),
      DistanceAccuracy_ (x.DistanceAccuracy_, f, this),
      AzimuthAngularAccuracy_ (x.AzimuthAngularAccuracy_, f, this),
      ElevationAngularAccuracy_ (x.ElevationAngularAccuracy_, f, this),
      RangeForVolumetricUncertainty_ (x.RangeForVolumetricUncertainty_, f, this),
      VolumetricUncertainty_ (x.VolumetricUncertainty_, f, this),
      MaxEnvironmentalAltitude_ (x.MaxEnvironmentalAltitude_, f, this),
      MinEnvironmentalAltitude_ (x.MinEnvironmentalAltitude_, f, this),
      SurfacePointsSpeed_ (x.SurfacePointsSpeed_, f, this),
      ToolingBallSpeed_ (x.ToolingBallSpeed_, f, this),
      FeatureSpeed_ (x.FeatureSpeed_, f, this)
    {
    }

    LaserRadarType::
    LaserRadarType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UniversalDeviceType (e, f | ::xml_schema::flags::base, c),
      MeasurementLaser_ (this),
      PointingLaser_ (this),
      MaxPointsRate_ (this),
      MaxMeasurementRange_ (this),
      MinMeasurementRange_ (this),
      ScanningSpeed_ (this),
      DistanceAccuracy_ (this),
      AzimuthAngularAccuracy_ (this),
      ElevationAngularAccuracy_ (this),
      RangeForVolumetricUncertainty_ (this),
      VolumetricUncertainty_ (this),
      MaxEnvironmentalAltitude_ (this),
      MinEnvironmentalAltitude_ (this),
      SurfacePointsSpeed_ (this),
      ToolingBallSpeed_ (this),
      FeatureSpeed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LaserRadarType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UniversalDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementLaser
        //
        if (n.name () == L"MeasurementLaser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementLaser_type > r (
            MeasurementLaser_traits::create (i, f, this));

          if (!this->MeasurementLaser_)
          {
            this->MeasurementLaser_.set (::std::move (r));
            continue;
          }
        }

        // PointingLaser
        //
        if (n.name () == L"PointingLaser" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointingLaser_type > r (
            PointingLaser_traits::create (i, f, this));

          if (!this->PointingLaser_)
          {
            this->PointingLaser_.set (::std::move (r));
            continue;
          }
        }

        // MaxPointsRate
        //
        if (n.name () == L"MaxPointsRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxPointsRate_type > r (
            MaxPointsRate_traits::create (i, f, this));

          if (!this->MaxPointsRate_)
          {
            this->MaxPointsRate_.set (::std::move (r));
            continue;
          }
        }

        // MaxMeasurementRange
        //
        if (n.name () == L"MaxMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxMeasurementRange_type > r (
            MaxMeasurementRange_traits::create (i, f, this));

          if (!this->MaxMeasurementRange_)
          {
            this->MaxMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // MinMeasurementRange
        //
        if (n.name () == L"MinMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinMeasurementRange_type > r (
            MinMeasurementRange_traits::create (i, f, this));

          if (!this->MinMeasurementRange_)
          {
            this->MinMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // ScanningSpeed
        //
        if (n.name () == L"ScanningSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScanningSpeed_type > r (
            ScanningSpeed_traits::create (i, f, this));

          if (!this->ScanningSpeed_)
          {
            this->ScanningSpeed_.set (::std::move (r));
            continue;
          }
        }

        // DistanceAccuracy
        //
        if (n.name () == L"DistanceAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DistanceAccuracy_type > r (
            DistanceAccuracy_traits::create (i, f, this));

          if (!this->DistanceAccuracy_)
          {
            this->DistanceAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // AzimuthAngularAccuracy
        //
        if (n.name () == L"AzimuthAngularAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AzimuthAngularAccuracy_type > r (
            AzimuthAngularAccuracy_traits::create (i, f, this));

          if (!this->AzimuthAngularAccuracy_)
          {
            this->AzimuthAngularAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // ElevationAngularAccuracy
        //
        if (n.name () == L"ElevationAngularAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElevationAngularAccuracy_type > r (
            ElevationAngularAccuracy_traits::create (i, f, this));

          if (!this->ElevationAngularAccuracy_)
          {
            this->ElevationAngularAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // RangeForVolumetricUncertainty
        //
        if (n.name () == L"RangeForVolumetricUncertainty" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RangeForVolumetricUncertainty_type > r (
            RangeForVolumetricUncertainty_traits::create (i, f, this));

          if (!this->RangeForVolumetricUncertainty_)
          {
            this->RangeForVolumetricUncertainty_.set (::std::move (r));
            continue;
          }
        }

        // VolumetricUncertainty
        //
        if (n.name () == L"VolumetricUncertainty" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VolumetricUncertainty_type > r (
            VolumetricUncertainty_traits::create (i, f, this));

          if (!this->VolumetricUncertainty_)
          {
            this->VolumetricUncertainty_.set (::std::move (r));
            continue;
          }
        }

        // MaxEnvironmentalAltitude
        //
        if (n.name () == L"MaxEnvironmentalAltitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxEnvironmentalAltitude_type > r (
            MaxEnvironmentalAltitude_traits::create (i, f, this));

          if (!this->MaxEnvironmentalAltitude_)
          {
            this->MaxEnvironmentalAltitude_.set (::std::move (r));
            continue;
          }
        }

        // MinEnvironmentalAltitude
        //
        if (n.name () == L"MinEnvironmentalAltitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinEnvironmentalAltitude_type > r (
            MinEnvironmentalAltitude_traits::create (i, f, this));

          if (!this->MinEnvironmentalAltitude_)
          {
            this->MinEnvironmentalAltitude_.set (::std::move (r));
            continue;
          }
        }

        // SurfacePointsSpeed
        //
        if (n.name () == L"SurfacePointsSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfacePointsSpeed_type > r (
            SurfacePointsSpeed_traits::create (i, f, this));

          if (!this->SurfacePointsSpeed_)
          {
            this->SurfacePointsSpeed_.set (::std::move (r));
            continue;
          }
        }

        // ToolingBallSpeed
        //
        if (n.name () == L"ToolingBallSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToolingBallSpeed_type > r (
            ToolingBallSpeed_traits::create (i, f, this));

          if (!this->ToolingBallSpeed_)
          {
            this->ToolingBallSpeed_.set (::std::move (r));
            continue;
          }
        }

        // FeatureSpeed
        //
        if (n.name () == L"FeatureSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureSpeed_type > r (
            FeatureSpeed_traits::create (i, f, this));

          if (!this->FeatureSpeed_)
          {
            this->FeatureSpeed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LaserRadarType* LaserRadarType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserRadarType (*this, f, c);
    }

    LaserRadarType& LaserRadarType::
    operator= (const LaserRadarType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UniversalDeviceType& > (*this) = x;
        this->MeasurementLaser_ = x.MeasurementLaser_;
        this->PointingLaser_ = x.PointingLaser_;
        this->MaxPointsRate_ = x.MaxPointsRate_;
        this->MaxMeasurementRange_ = x.MaxMeasurementRange_;
        this->MinMeasurementRange_ = x.MinMeasurementRange_;
        this->ScanningSpeed_ = x.ScanningSpeed_;
        this->DistanceAccuracy_ = x.DistanceAccuracy_;
        this->AzimuthAngularAccuracy_ = x.AzimuthAngularAccuracy_;
        this->ElevationAngularAccuracy_ = x.ElevationAngularAccuracy_;
        this->RangeForVolumetricUncertainty_ = x.RangeForVolumetricUncertainty_;
        this->VolumetricUncertainty_ = x.VolumetricUncertainty_;
        this->MaxEnvironmentalAltitude_ = x.MaxEnvironmentalAltitude_;
        this->MinEnvironmentalAltitude_ = x.MinEnvironmentalAltitude_;
        this->SurfacePointsSpeed_ = x.SurfacePointsSpeed_;
        this->ToolingBallSpeed_ = x.ToolingBallSpeed_;
        this->FeatureSpeed_ = x.FeatureSpeed_;
      }

      return *this;
    }

    LaserRadarType::
    ~LaserRadarType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LaserRadarType >
    _xsd_LaserRadarType_type_factory_init (
      L"LaserRadarType",
      L"http://qifstandards.org/xsd/qif3");

    // StiffnessType
    //

    StiffnessType::
    StiffnessType ()
    : ::xml_schema::type (),
      XStiffness_ (this),
      YStiffness_ (this),
      ZStiffness_ (this)
    {
    }

    StiffnessType::
    StiffnessType (const StiffnessType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XStiffness_ (x.XStiffness_, f, this),
      YStiffness_ (x.YStiffness_, f, this),
      ZStiffness_ (x.ZStiffness_, f, this)
    {
    }

    StiffnessType::
    StiffnessType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XStiffness_ (this),
      YStiffness_ (this),
      ZStiffness_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StiffnessType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XStiffness
        //
        if (n.name () == L"XStiffness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XStiffness_type > r (
            XStiffness_traits::create (i, f, this));

          if (!this->XStiffness_)
          {
            this->XStiffness_.set (::std::move (r));
            continue;
          }
        }

        // YStiffness
        //
        if (n.name () == L"YStiffness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YStiffness_type > r (
            YStiffness_traits::create (i, f, this));

          if (!this->YStiffness_)
          {
            this->YStiffness_.set (::std::move (r));
            continue;
          }
        }

        // ZStiffness
        //
        if (n.name () == L"ZStiffness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZStiffness_type > r (
            ZStiffness_traits::create (i, f, this));

          if (!this->ZStiffness_)
          {
            this->ZStiffness_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StiffnessType* StiffnessType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StiffnessType (*this, f, c);
    }

    StiffnessType& StiffnessType::
    operator= (const StiffnessType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XStiffness_ = x.XStiffness_;
        this->YStiffness_ = x.YStiffness_;
        this->ZStiffness_ = x.ZStiffness_;
      }

      return *this;
    }

    StiffnessType::
    ~StiffnessType ()
    {
    }

    // CMMDirectionEnumType
    //

    CMMDirectionEnumType::
    CMMDirectionEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType* CMMDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMDirectionEnumType (*this, f, c);
    }

    CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CMMDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CMMDirectionEnumType_indexes_,
                        _xsd_CMMDirectionEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_CMMDirectionEnumType_indexes_ + 6 || _xsd_CMMDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_literals_[6] =
    {
      L"RIGHT",
      L"LEFT",
      L"FRONT",
      L"BACK",
      L"UP",
      L"DOWN"
    };

    const CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_indexes_[6] =
    {
      ::xsd::qif30::CMMDirectionEnumType::BACK,
      ::xsd::qif30::CMMDirectionEnumType::DOWN,
      ::xsd::qif30::CMMDirectionEnumType::FRONT,
      ::xsd::qif30::CMMDirectionEnumType::LEFT,
      ::xsd::qif30::CMMDirectionEnumType::RIGHT,
      ::xsd::qif30::CMMDirectionEnumType::UP
    };

    // CartesianCMMGeometryType
    //

    CartesianCMMGeometryType::
    CartesianCMMGeometryType ()
    : ::xml_schema::type (),
      CartesianCMMGeometryEnum_ (this),
      OtherCartesianCMMGeometry_ (this)
    {
    }

    CartesianCMMGeometryType::
    CartesianCMMGeometryType (const CartesianCMMGeometryType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CartesianCMMGeometryEnum_ (x.CartesianCMMGeometryEnum_, f, this),
      OtherCartesianCMMGeometry_ (x.OtherCartesianCMMGeometry_, f, this)
    {
    }

    CartesianCMMGeometryType::
    CartesianCMMGeometryType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CartesianCMMGeometryEnum_ (this),
      OtherCartesianCMMGeometry_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianCMMGeometryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CartesianCMMGeometryEnum
        //
        if (n.name () == L"CartesianCMMGeometryEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CartesianCMMGeometryEnum_type > r (
            CartesianCMMGeometryEnum_traits::create (i, f, this));

          if (!this->CartesianCMMGeometryEnum_)
          {
            this->CartesianCMMGeometryEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherCartesianCMMGeometry
        //
        if (n.name () == L"OtherCartesianCMMGeometry" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherCartesianCMMGeometry_type > r (
            OtherCartesianCMMGeometry_traits::create (i, f, this));

          if (!this->OtherCartesianCMMGeometry_)
          {
            this->OtherCartesianCMMGeometry_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CartesianCMMGeometryType* CartesianCMMGeometryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMGeometryType (*this, f, c);
    }

    CartesianCMMGeometryType& CartesianCMMGeometryType::
    operator= (const CartesianCMMGeometryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CartesianCMMGeometryEnum_ = x.CartesianCMMGeometryEnum_;
        this->OtherCartesianCMMGeometry_ = x.OtherCartesianCMMGeometry_;
      }

      return *this;
    }

    CartesianCMMGeometryType::
    ~CartesianCMMGeometryType ()
    {
    }

    // CartesianCMMGeometryEnumType
    //

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CartesianCMMGeometryEnumType_convert ();
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CartesianCMMGeometryEnumType_convert ();
    }

    CartesianCMMGeometryEnumType::
    CartesianCMMGeometryEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CartesianCMMGeometryEnumType_convert ();
    }

    CartesianCMMGeometryEnumType* CartesianCMMGeometryEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMGeometryEnumType (*this, f, c);
    }

    CartesianCMMGeometryEnumType::value CartesianCMMGeometryEnumType::
    _xsd_CartesianCMMGeometryEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CartesianCMMGeometryEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CartesianCMMGeometryEnumType_indexes_,
                        _xsd_CartesianCMMGeometryEnumType_indexes_ + 10,
                        *this,
                        c));

      if (i == _xsd_CartesianCMMGeometryEnumType_indexes_ + 10 || _xsd_CartesianCMMGeometryEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CartesianCMMGeometryEnumType::
    _xsd_CartesianCMMGeometryEnumType_literals_[10] =
    {
      L"FIXED_BRIDGE",
      L"MOVING_BRIDGE",
      L"L_SHAPED_BRIDGE",
      L"COLUMN",
      L"FIXED_TABLE_CANTILEVER_ARM",
      L"MOVING_TABLE_CANTILEVER_ARM",
      L"FIXED_TABLE_HORIZONTAL_ARM",
      L"MOVING_TABLE_HORIZONTAL_ARM",
      L"MOVING_RAM_HORIZONTAL_ARM",
      L"GANTRY"
    };

    const CartesianCMMGeometryEnumType::value CartesianCMMGeometryEnumType::
    _xsd_CartesianCMMGeometryEnumType_indexes_[10] =
    {
      ::xsd::qif30::CartesianCMMGeometryEnumType::COLUMN,
      ::xsd::qif30::CartesianCMMGeometryEnumType::FIXED_BRIDGE,
      ::xsd::qif30::CartesianCMMGeometryEnumType::FIXED_TABLE_CANTILEVER_ARM,
      ::xsd::qif30::CartesianCMMGeometryEnumType::FIXED_TABLE_HORIZONTAL_ARM,
      ::xsd::qif30::CartesianCMMGeometryEnumType::GANTRY,
      ::xsd::qif30::CartesianCMMGeometryEnumType::L_SHAPED_BRIDGE,
      ::xsd::qif30::CartesianCMMGeometryEnumType::MOVING_BRIDGE,
      ::xsd::qif30::CartesianCMMGeometryEnumType::MOVING_RAM_HORIZONTAL_ARM,
      ::xsd::qif30::CartesianCMMGeometryEnumType::MOVING_TABLE_CANTILEVER_ARM,
      ::xsd::qif30::CartesianCMMGeometryEnumType::MOVING_TABLE_HORIZONTAL_ARM
    };

    // CMMAxisDirectionsBaseType
    //

    CMMAxisDirectionsBaseType::
    CMMAxisDirectionsBaseType ()
    : ::xml_schema::type ()
    {
    }

    CMMAxisDirectionsBaseType::
    CMMAxisDirectionsBaseType (const CMMAxisDirectionsBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    CMMAxisDirectionsBaseType::
    CMMAxisDirectionsBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    CMMAxisDirectionsBaseType::
    CMMAxisDirectionsBaseType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    CMMAxisDirectionsBaseType::
    CMMAxisDirectionsBaseType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    CMMAxisDirectionsBaseType::
    ~CMMAxisDirectionsBaseType ()
    {
    }

    // CartesianCMMAxisDirectionsType
    //

    CartesianCMMAxisDirectionsType::
    CartesianCMMAxisDirectionsType ()
    : ::xsd::qif30::CMMAxisDirectionsBaseType (),
      XAxisDirection_ (this),
      YAxisDirection_ (this),
      ZAxisDirection_ (this)
    {
    }

    CartesianCMMAxisDirectionsType::
    CartesianCMMAxisDirectionsType (const XAxisDirection_type& XAxisDirection,
                                    const YAxisDirection_type& YAxisDirection,
                                    const ZAxisDirection_type& ZAxisDirection)
    : ::xsd::qif30::CMMAxisDirectionsBaseType (),
      XAxisDirection_ (XAxisDirection, this),
      YAxisDirection_ (YAxisDirection, this),
      ZAxisDirection_ (ZAxisDirection, this)
    {
    }

    CartesianCMMAxisDirectionsType::
    CartesianCMMAxisDirectionsType (const CartesianCMMAxisDirectionsType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::CMMAxisDirectionsBaseType (x, f, c),
      XAxisDirection_ (x.XAxisDirection_, f, this),
      YAxisDirection_ (x.YAxisDirection_, f, this),
      ZAxisDirection_ (x.ZAxisDirection_, f, this)
    {
    }

    CartesianCMMAxisDirectionsType::
    CartesianCMMAxisDirectionsType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::CMMAxisDirectionsBaseType (e, f | ::xml_schema::flags::base, c),
      XAxisDirection_ (this),
      YAxisDirection_ (this),
      ZAxisDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianCMMAxisDirectionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XAxisDirection
        //
        if (n.name () == L"XAxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisDirection_type > r (
            XAxisDirection_traits::create (i, f, this));

          if (!XAxisDirection_.present ())
          {
            this->XAxisDirection_.set (::std::move (r));
            continue;
          }
        }

        // YAxisDirection
        //
        if (n.name () == L"YAxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisDirection_type > r (
            YAxisDirection_traits::create (i, f, this));

          if (!YAxisDirection_.present ())
          {
            this->YAxisDirection_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisDirection
        //
        if (n.name () == L"ZAxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisDirection_type > r (
            ZAxisDirection_traits::create (i, f, this));

          if (!ZAxisDirection_.present ())
          {
            this->ZAxisDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CartesianCMMAxisDirectionsType* CartesianCMMAxisDirectionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMAxisDirectionsType (*this, f, c);
    }

    CartesianCMMAxisDirectionsType& CartesianCMMAxisDirectionsType::
    operator= (const CartesianCMMAxisDirectionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAxisDirectionsBaseType& > (*this) = x;
        this->XAxisDirection_ = x.XAxisDirection_;
        this->YAxisDirection_ = x.YAxisDirection_;
        this->ZAxisDirection_ = x.ZAxisDirection_;
      }

      return *this;
    }

    CartesianCMMAxisDirectionsType::
    ~CartesianCMMAxisDirectionsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianCMMAxisDirectionsType >
    _xsd_CartesianCMMAxisDirectionsType_type_factory_init (
      L"CartesianCMMAxisDirectionsType",
      L"http://qifstandards.org/xsd/qif3");

    // XYZLinearSpecificationType
    //

    XYZLinearSpecificationType::
    XYZLinearSpecificationType ()
    : ::xml_schema::type (),
      X_ (this),
      Y_ (this),
      Z_ (this)
    {
    }

    XYZLinearSpecificationType::
    XYZLinearSpecificationType (const XYZLinearSpecificationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      X_ (x.X_, f, this),
      Y_ (x.Y_, f, this),
      Z_ (x.Z_, f, this)
    {
    }

    XYZLinearSpecificationType::
    XYZLinearSpecificationType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      X_ (this),
      Y_ (this),
      Z_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void XYZLinearSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // X
        //
        if (n.name () == L"X" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X_type > r (
            X_traits::create (i, f, this));

          if (!this->X_)
          {
            this->X_.set (::std::move (r));
            continue;
          }
        }

        // Y
        //
        if (n.name () == L"Y" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Y_type > r (
            Y_traits::create (i, f, this));

          if (!this->Y_)
          {
            this->Y_.set (::std::move (r));
            continue;
          }
        }

        // Z
        //
        if (n.name () == L"Z" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Z_type > r (
            Z_traits::create (i, f, this));

          if (!this->Z_)
          {
            this->Z_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    XYZLinearSpecificationType* XYZLinearSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class XYZLinearSpecificationType (*this, f, c);
    }

    XYZLinearSpecificationType& XYZLinearSpecificationType::
    operator= (const XYZLinearSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->X_ = x.X_;
        this->Y_ = x.Y_;
        this->Z_ = x.Z_;
      }

      return *this;
    }

    XYZLinearSpecificationType::
    ~XYZLinearSpecificationType ()
    {
    }

    // TargetMirrorEnumType
    //

    TargetMirrorEnumType::
    TargetMirrorEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_TargetMirrorEnumType_convert ();
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_TargetMirrorEnumType_convert ();
    }

    TargetMirrorEnumType::
    TargetMirrorEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_TargetMirrorEnumType_convert ();
    }

    TargetMirrorEnumType* TargetMirrorEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetMirrorEnumType (*this, f, c);
    }

    TargetMirrorEnumType::value TargetMirrorEnumType::
    _xsd_TargetMirrorEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_TargetMirrorEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TargetMirrorEnumType_indexes_,
                        _xsd_TargetMirrorEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_TargetMirrorEnumType_indexes_ + 3 || _xsd_TargetMirrorEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const TargetMirrorEnumType::
    _xsd_TargetMirrorEnumType_literals_[3] =
    {
      L"CUBE_CORNER",
      L"CATS_EYE",
      L"PLANE_MIRROR"
    };

    const TargetMirrorEnumType::value TargetMirrorEnumType::
    _xsd_TargetMirrorEnumType_indexes_[3] =
    {
      ::xsd::qif30::TargetMirrorEnumType::CATS_EYE,
      ::xsd::qif30::TargetMirrorEnumType::CUBE_CORNER,
      ::xsd::qif30::TargetMirrorEnumType::PLANE_MIRROR
    };

    // MeasurementDeviceScalesBaseType
    //

    MeasurementDeviceScalesBaseType::
    MeasurementDeviceScalesBaseType ()
    : ::xml_schema::type ()
    {
    }

    MeasurementDeviceScalesBaseType::
    MeasurementDeviceScalesBaseType (const MeasurementDeviceScalesBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    MeasurementDeviceScalesBaseType::
    MeasurementDeviceScalesBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    MeasurementDeviceScalesBaseType::
    MeasurementDeviceScalesBaseType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    MeasurementDeviceScalesBaseType::
    MeasurementDeviceScalesBaseType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    MeasurementDeviceScalesBaseType::
    ~MeasurementDeviceScalesBaseType ()
    {
    }

    // CartesianMeasurementDeviceScalesType
    //

    CartesianMeasurementDeviceScalesType::
    CartesianMeasurementDeviceScalesType ()
    : ::xsd::qif30::MeasurementDeviceScalesBaseType (),
      XScale_ (this),
      YScale_ (this),
      ZScale_ (this)
    {
    }

    CartesianMeasurementDeviceScalesType::
    CartesianMeasurementDeviceScalesType (const XScale_type& XScale,
                                          const YScale_type& YScale,
                                          const ZScale_type& ZScale)
    : ::xsd::qif30::MeasurementDeviceScalesBaseType (),
      XScale_ (XScale, this),
      YScale_ (YScale, this),
      ZScale_ (ZScale, this)
    {
    }

    CartesianMeasurementDeviceScalesType::
    CartesianMeasurementDeviceScalesType (::std::unique_ptr< XScale_type > XScale,
                                          ::std::unique_ptr< YScale_type > YScale,
                                          ::std::unique_ptr< ZScale_type > ZScale)
    : ::xsd::qif30::MeasurementDeviceScalesBaseType (),
      XScale_ (std::move (XScale), this),
      YScale_ (std::move (YScale), this),
      ZScale_ (std::move (ZScale), this)
    {
    }

    CartesianMeasurementDeviceScalesType::
    CartesianMeasurementDeviceScalesType (const CartesianMeasurementDeviceScalesType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceScalesBaseType (x, f, c),
      XScale_ (x.XScale_, f, this),
      YScale_ (x.YScale_, f, this),
      ZScale_ (x.ZScale_, f, this)
    {
    }

    CartesianMeasurementDeviceScalesType::
    CartesianMeasurementDeviceScalesType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceScalesBaseType (e, f | ::xml_schema::flags::base, c),
      XScale_ (this),
      YScale_ (this),
      ZScale_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianMeasurementDeviceScalesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XScale
        //
        if (n.name () == L"XScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XScale_type > r (
            XScale_traits::create (i, f, this));

          if (!XScale_.present ())
          {
            this->XScale_.set (::std::move (r));
            continue;
          }
        }

        // YScale
        //
        if (n.name () == L"YScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YScale_type > r (
            YScale_traits::create (i, f, this));

          if (!YScale_.present ())
          {
            this->YScale_.set (::std::move (r));
            continue;
          }
        }

        // ZScale
        //
        if (n.name () == L"ZScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZScale_type > r (
            ZScale_traits::create (i, f, this));

          if (!ZScale_.present ())
          {
            this->ZScale_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XScale",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YScale",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZScale",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CartesianMeasurementDeviceScalesType* CartesianMeasurementDeviceScalesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianMeasurementDeviceScalesType (*this, f, c);
    }

    CartesianMeasurementDeviceScalesType& CartesianMeasurementDeviceScalesType::
    operator= (const CartesianMeasurementDeviceScalesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceScalesBaseType& > (*this) = x;
        this->XScale_ = x.XScale_;
        this->YScale_ = x.YScale_;
        this->ZScale_ = x.ZScale_;
      }

      return *this;
    }

    CartesianMeasurementDeviceScalesType::
    ~CartesianMeasurementDeviceScalesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianMeasurementDeviceScalesType >
    _xsd_CartesianMeasurementDeviceScalesType_type_factory_init (
      L"CartesianMeasurementDeviceScalesType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasurementDeviceScaleType
    //

    MeasurementDeviceScaleType::
    MeasurementDeviceScaleType ()
    : ::xml_schema::type (),
      ScaleMaterial_ (this),
      ScaleCoefficientOfExpansion_ (this),
      ScaleCoefficientOfExpansionUncertainty_ (this),
      TypeOfScale_ (this),
      ScaleResolution_ (this),
      ScaleReference_ (this)
    {
    }

    MeasurementDeviceScaleType::
    MeasurementDeviceScaleType (const MeasurementDeviceScaleType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleMaterial_ (x.ScaleMaterial_, f, this),
      ScaleCoefficientOfExpansion_ (x.ScaleCoefficientOfExpansion_, f, this),
      ScaleCoefficientOfExpansionUncertainty_ (x.ScaleCoefficientOfExpansionUncertainty_, f, this),
      TypeOfScale_ (x.TypeOfScale_, f, this),
      ScaleResolution_ (x.ScaleResolution_, f, this),
      ScaleReference_ (x.ScaleReference_, f, this)
    {
    }

    MeasurementDeviceScaleType::
    MeasurementDeviceScaleType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleMaterial_ (this),
      ScaleCoefficientOfExpansion_ (this),
      ScaleCoefficientOfExpansionUncertainty_ (this),
      TypeOfScale_ (this),
      ScaleResolution_ (this),
      ScaleReference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementDeviceScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ScaleMaterial
        //
        if (n.name () == L"ScaleMaterial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScaleMaterial_type > r (
            ScaleMaterial_traits::create (i, f, this));

          if (!this->ScaleMaterial_)
          {
            this->ScaleMaterial_.set (::std::move (r));
            continue;
          }
        }

        // ScaleCoefficientOfExpansion
        //
        if (n.name () == L"ScaleCoefficientOfExpansion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ScaleCoefficientOfExpansion_)
          {
            this->ScaleCoefficientOfExpansion_.set (ScaleCoefficientOfExpansion_traits::create (i, f, this));
            continue;
          }
        }

        // ScaleCoefficientOfExpansionUncertainty
        //
        if (n.name () == L"ScaleCoefficientOfExpansionUncertainty" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ScaleCoefficientOfExpansionUncertainty_)
          {
            this->ScaleCoefficientOfExpansionUncertainty_.set (ScaleCoefficientOfExpansionUncertainty_traits::create (i, f, this));
            continue;
          }
        }

        // TypeOfScale
        //
        if (n.name () == L"TypeOfScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TypeOfScale_type > r (
            TypeOfScale_traits::create (i, f, this));

          if (!this->TypeOfScale_)
          {
            this->TypeOfScale_.set (::std::move (r));
            continue;
          }
        }

        // ScaleResolution
        //
        if (n.name () == L"ScaleResolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScaleResolution_type > r (
            ScaleResolution_traits::create (i, f, this));

          if (!this->ScaleResolution_)
          {
            this->ScaleResolution_.set (::std::move (r));
            continue;
          }
        }

        // ScaleReference
        //
        if (n.name () == L"ScaleReference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ScaleReference_type > r (
            ScaleReference_traits::create (i, f, this));

          if (!this->ScaleReference_)
          {
            this->ScaleReference_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasurementDeviceScaleType* MeasurementDeviceScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceScaleType (*this, f, c);
    }

    MeasurementDeviceScaleType& MeasurementDeviceScaleType::
    operator= (const MeasurementDeviceScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ScaleMaterial_ = x.ScaleMaterial_;
        this->ScaleCoefficientOfExpansion_ = x.ScaleCoefficientOfExpansion_;
        this->ScaleCoefficientOfExpansionUncertainty_ = x.ScaleCoefficientOfExpansionUncertainty_;
        this->TypeOfScale_ = x.TypeOfScale_;
        this->ScaleResolution_ = x.ScaleResolution_;
        this->ScaleReference_ = x.ScaleReference_;
      }

      return *this;
    }

    MeasurementDeviceScaleType::
    ~MeasurementDeviceScaleType ()
    {
    }

    // ScaleReferenceEnumType
    //

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ScaleReferenceEnumType_convert ();
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ScaleReferenceEnumType_convert ();
    }

    ScaleReferenceEnumType::
    ScaleReferenceEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ScaleReferenceEnumType_convert ();
    }

    ScaleReferenceEnumType* ScaleReferenceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScaleReferenceEnumType (*this, f, c);
    }

    ScaleReferenceEnumType::value ScaleReferenceEnumType::
    _xsd_ScaleReferenceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ScaleReferenceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ScaleReferenceEnumType_indexes_,
                        _xsd_ScaleReferenceEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ScaleReferenceEnumType_indexes_ + 2 || _xsd_ScaleReferenceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ScaleReferenceEnumType::
    _xsd_ScaleReferenceEnumType_literals_[2] =
    {
      L"SCALE_ABSOLUTE",
      L"SCALE_INCREMENTAL"
    };

    const ScaleReferenceEnumType::value ScaleReferenceEnumType::
    _xsd_ScaleReferenceEnumType_indexes_[2] =
    {
      ::xsd::qif30::ScaleReferenceEnumType::SCALE_ABSOLUTE,
      ::xsd::qif30::ScaleReferenceEnumType::SCALE_INCREMENTAL
    };

    // TypeOfScaleEnumType
    //

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_TypeOfScaleEnumType_convert ();
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_TypeOfScaleEnumType_convert ();
    }

    TypeOfScaleEnumType::
    TypeOfScaleEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_TypeOfScaleEnumType_convert ();
    }

    TypeOfScaleEnumType* TypeOfScaleEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TypeOfScaleEnumType (*this, f, c);
    }

    TypeOfScaleEnumType::value TypeOfScaleEnumType::
    _xsd_TypeOfScaleEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_TypeOfScaleEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TypeOfScaleEnumType_indexes_,
                        _xsd_TypeOfScaleEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_TypeOfScaleEnumType_indexes_ + 4 || _xsd_TypeOfScaleEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const TypeOfScaleEnumType::
    _xsd_TypeOfScaleEnumType_literals_[4] =
    {
      L"ELECTROOPTICAL_LINEAR",
      L"ELECTROOPTICAL_ROTARY",
      L"LASER_INTERFEROMETER_LINEAR",
      L"TIME_OF_FLIGHT_LINEAR"
    };

    const TypeOfScaleEnumType::value TypeOfScaleEnumType::
    _xsd_TypeOfScaleEnumType_indexes_[4] =
    {
      ::xsd::qif30::TypeOfScaleEnumType::ELECTROOPTICAL_LINEAR,
      ::xsd::qif30::TypeOfScaleEnumType::ELECTROOPTICAL_ROTARY,
      ::xsd::qif30::TypeOfScaleEnumType::LASER_INTERFEROMETER_LINEAR,
      ::xsd::qif30::TypeOfScaleEnumType::TIME_OF_FLIGHT_LINEAR
    };

    // TypeOfScaleType
    //

    TypeOfScaleType::
    TypeOfScaleType ()
    : ::xml_schema::type (),
      TypeOfScaleEnum_ (this),
      OtherTypeOfScale_ (this)
    {
    }

    TypeOfScaleType::
    TypeOfScaleType (const TypeOfScaleType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TypeOfScaleEnum_ (x.TypeOfScaleEnum_, f, this),
      OtherTypeOfScale_ (x.OtherTypeOfScale_, f, this)
    {
    }

    TypeOfScaleType::
    TypeOfScaleType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TypeOfScaleEnum_ (this),
      OtherTypeOfScale_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TypeOfScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TypeOfScaleEnum
        //
        if (n.name () == L"TypeOfScaleEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TypeOfScaleEnum_type > r (
            TypeOfScaleEnum_traits::create (i, f, this));

          if (!this->TypeOfScaleEnum_)
          {
            this->TypeOfScaleEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherTypeOfScale
        //
        if (n.name () == L"OtherTypeOfScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherTypeOfScale_type > r (
            OtherTypeOfScale_traits::create (i, f, this));

          if (!this->OtherTypeOfScale_)
          {
            this->OtherTypeOfScale_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TypeOfScaleType* TypeOfScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TypeOfScaleType (*this, f, c);
    }

    TypeOfScaleType& TypeOfScaleType::
    operator= (const TypeOfScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TypeOfScaleEnum_ = x.TypeOfScaleEnum_;
        this->OtherTypeOfScale_ = x.OtherTypeOfScale_;
      }

      return *this;
    }

    TypeOfScaleType::
    ~TypeOfScaleType ()
    {
    }

    // CMMSpeedsBaseType
    //

    CMMSpeedsBaseType::
    CMMSpeedsBaseType ()
    : ::xml_schema::type ()
    {
    }

    CMMSpeedsBaseType::
    CMMSpeedsBaseType (const CMMSpeedsBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    CMMSpeedsBaseType::
    CMMSpeedsBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    CMMSpeedsBaseType::
    CMMSpeedsBaseType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    CMMSpeedsBaseType::
    CMMSpeedsBaseType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    CMMSpeedsBaseType::
    ~CMMSpeedsBaseType ()
    {
    }

    // CartesianCMMSpeedsType
    //

    CartesianCMMSpeedsType::
    CartesianCMMSpeedsType ()
    : ::xsd::qif30::CMMSpeedsBaseType (),
      MaxXTraverseSpeed_ (this),
      MaxYTraverseSpeed_ (this),
      MaxZTraverseSpeed_ (this),
      MaxXProbingSpeed_ (this),
      MaxYProbingSpeed_ (this),
      MaxZProbingSpeed_ (this)
    {
    }

    CartesianCMMSpeedsType::
    CartesianCMMSpeedsType (const CartesianCMMSpeedsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CMMSpeedsBaseType (x, f, c),
      MaxXTraverseSpeed_ (x.MaxXTraverseSpeed_, f, this),
      MaxYTraverseSpeed_ (x.MaxYTraverseSpeed_, f, this),
      MaxZTraverseSpeed_ (x.MaxZTraverseSpeed_, f, this),
      MaxXProbingSpeed_ (x.MaxXProbingSpeed_, f, this),
      MaxYProbingSpeed_ (x.MaxYProbingSpeed_, f, this),
      MaxZProbingSpeed_ (x.MaxZProbingSpeed_, f, this)
    {
    }

    CartesianCMMSpeedsType::
    CartesianCMMSpeedsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CMMSpeedsBaseType (e, f | ::xml_schema::flags::base, c),
      MaxXTraverseSpeed_ (this),
      MaxYTraverseSpeed_ (this),
      MaxZTraverseSpeed_ (this),
      MaxXProbingSpeed_ (this),
      MaxYProbingSpeed_ (this),
      MaxZProbingSpeed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianCMMSpeedsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxXTraverseSpeed
        //
        if (n.name () == L"MaxXTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxXTraverseSpeed_type > r (
            MaxXTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxXTraverseSpeed_)
          {
            this->MaxXTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxYTraverseSpeed
        //
        if (n.name () == L"MaxYTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxYTraverseSpeed_type > r (
            MaxYTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxYTraverseSpeed_)
          {
            this->MaxYTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxZTraverseSpeed
        //
        if (n.name () == L"MaxZTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZTraverseSpeed_type > r (
            MaxZTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxZTraverseSpeed_)
          {
            this->MaxZTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxXProbingSpeed
        //
        if (n.name () == L"MaxXProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxXProbingSpeed_type > r (
            MaxXProbingSpeed_traits::create (i, f, this));

          if (!this->MaxXProbingSpeed_)
          {
            this->MaxXProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxYProbingSpeed
        //
        if (n.name () == L"MaxYProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxYProbingSpeed_type > r (
            MaxYProbingSpeed_traits::create (i, f, this));

          if (!this->MaxYProbingSpeed_)
          {
            this->MaxYProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxZProbingSpeed
        //
        if (n.name () == L"MaxZProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZProbingSpeed_type > r (
            MaxZProbingSpeed_traits::create (i, f, this));

          if (!this->MaxZProbingSpeed_)
          {
            this->MaxZProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CartesianCMMSpeedsType* CartesianCMMSpeedsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMSpeedsType (*this, f, c);
    }

    CartesianCMMSpeedsType& CartesianCMMSpeedsType::
    operator= (const CartesianCMMSpeedsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMSpeedsBaseType& > (*this) = x;
        this->MaxXTraverseSpeed_ = x.MaxXTraverseSpeed_;
        this->MaxYTraverseSpeed_ = x.MaxYTraverseSpeed_;
        this->MaxZTraverseSpeed_ = x.MaxZTraverseSpeed_;
        this->MaxXProbingSpeed_ = x.MaxXProbingSpeed_;
        this->MaxYProbingSpeed_ = x.MaxYProbingSpeed_;
        this->MaxZProbingSpeed_ = x.MaxZProbingSpeed_;
      }

      return *this;
    }

    CartesianCMMSpeedsType::
    ~CartesianCMMSpeedsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianCMMSpeedsType >
    _xsd_CartesianCMMSpeedsType_type_factory_init (
      L"CartesianCMMSpeedsType",
      L"http://qifstandards.org/xsd/qif3");

    // ParallelLinkCMMSpeedsType
    //

    ParallelLinkCMMSpeedsType::
    ParallelLinkCMMSpeedsType ()
    : ::xsd::qif30::CMMSpeedsBaseType (),
      MaxXTraverseSpeed_ (this),
      MaxYTraverseSpeed_ (this),
      MaxZTraverseSpeed_ (this),
      MaxXProbingSpeed_ (this),
      MaxYProbingSpeed_ (this),
      MaxZProbingSpeed_ (this),
      MaxXRotation_ (this),
      MaxYRotation_ (this),
      MaxZRotation_ (this)
    {
    }

    ParallelLinkCMMSpeedsType::
    ParallelLinkCMMSpeedsType (const ParallelLinkCMMSpeedsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CMMSpeedsBaseType (x, f, c),
      MaxXTraverseSpeed_ (x.MaxXTraverseSpeed_, f, this),
      MaxYTraverseSpeed_ (x.MaxYTraverseSpeed_, f, this),
      MaxZTraverseSpeed_ (x.MaxZTraverseSpeed_, f, this),
      MaxXProbingSpeed_ (x.MaxXProbingSpeed_, f, this),
      MaxYProbingSpeed_ (x.MaxYProbingSpeed_, f, this),
      MaxZProbingSpeed_ (x.MaxZProbingSpeed_, f, this),
      MaxXRotation_ (x.MaxXRotation_, f, this),
      MaxYRotation_ (x.MaxYRotation_, f, this),
      MaxZRotation_ (x.MaxZRotation_, f, this)
    {
    }

    ParallelLinkCMMSpeedsType::
    ParallelLinkCMMSpeedsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CMMSpeedsBaseType (e, f | ::xml_schema::flags::base, c),
      MaxXTraverseSpeed_ (this),
      MaxYTraverseSpeed_ (this),
      MaxZTraverseSpeed_ (this),
      MaxXProbingSpeed_ (this),
      MaxYProbingSpeed_ (this),
      MaxZProbingSpeed_ (this),
      MaxXRotation_ (this),
      MaxYRotation_ (this),
      MaxZRotation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ParallelLinkCMMSpeedsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxXTraverseSpeed
        //
        if (n.name () == L"MaxXTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxXTraverseSpeed_type > r (
            MaxXTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxXTraverseSpeed_)
          {
            this->MaxXTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxYTraverseSpeed
        //
        if (n.name () == L"MaxYTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxYTraverseSpeed_type > r (
            MaxYTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxYTraverseSpeed_)
          {
            this->MaxYTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxZTraverseSpeed
        //
        if (n.name () == L"MaxZTraverseSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZTraverseSpeed_type > r (
            MaxZTraverseSpeed_traits::create (i, f, this));

          if (!this->MaxZTraverseSpeed_)
          {
            this->MaxZTraverseSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxXProbingSpeed
        //
        if (n.name () == L"MaxXProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxXProbingSpeed_type > r (
            MaxXProbingSpeed_traits::create (i, f, this));

          if (!this->MaxXProbingSpeed_)
          {
            this->MaxXProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxYProbingSpeed
        //
        if (n.name () == L"MaxYProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxYProbingSpeed_type > r (
            MaxYProbingSpeed_traits::create (i, f, this));

          if (!this->MaxYProbingSpeed_)
          {
            this->MaxYProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxZProbingSpeed
        //
        if (n.name () == L"MaxZProbingSpeed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZProbingSpeed_type > r (
            MaxZProbingSpeed_traits::create (i, f, this));

          if (!this->MaxZProbingSpeed_)
          {
            this->MaxZProbingSpeed_.set (::std::move (r));
            continue;
          }
        }

        // MaxXRotation
        //
        if (n.name () == L"MaxXRotation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxXRotation_type > r (
            MaxXRotation_traits::create (i, f, this));

          if (!this->MaxXRotation_)
          {
            this->MaxXRotation_.set (::std::move (r));
            continue;
          }
        }

        // MaxYRotation
        //
        if (n.name () == L"MaxYRotation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxYRotation_type > r (
            MaxYRotation_traits::create (i, f, this));

          if (!this->MaxYRotation_)
          {
            this->MaxYRotation_.set (::std::move (r));
            continue;
          }
        }

        // MaxZRotation
        //
        if (n.name () == L"MaxZRotation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxZRotation_type > r (
            MaxZRotation_traits::create (i, f, this));

          if (!this->MaxZRotation_)
          {
            this->MaxZRotation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ParallelLinkCMMSpeedsType* ParallelLinkCMMSpeedsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParallelLinkCMMSpeedsType (*this, f, c);
    }

    ParallelLinkCMMSpeedsType& ParallelLinkCMMSpeedsType::
    operator= (const ParallelLinkCMMSpeedsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMSpeedsBaseType& > (*this) = x;
        this->MaxXTraverseSpeed_ = x.MaxXTraverseSpeed_;
        this->MaxYTraverseSpeed_ = x.MaxYTraverseSpeed_;
        this->MaxZTraverseSpeed_ = x.MaxZTraverseSpeed_;
        this->MaxXProbingSpeed_ = x.MaxXProbingSpeed_;
        this->MaxYProbingSpeed_ = x.MaxYProbingSpeed_;
        this->MaxZProbingSpeed_ = x.MaxZProbingSpeed_;
        this->MaxXRotation_ = x.MaxXRotation_;
        this->MaxYRotation_ = x.MaxYRotation_;
        this->MaxZRotation_ = x.MaxZRotation_;
      }

      return *this;
    }

    ParallelLinkCMMSpeedsType::
    ~ParallelLinkCMMSpeedsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ParallelLinkCMMSpeedsType >
    _xsd_ParallelLinkCMMSpeedsType_type_factory_init (
      L"ParallelLinkCMMSpeedsType",
      L"http://qifstandards.org/xsd/qif3");

    // FunctionDiscreteType
    //

    FunctionDiscreteType::
    FunctionDiscreteType ()
    : ::xml_schema::type (),
      DomainValues_ (this),
      RangeValues_ (this),
      n_ (this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const DomainValues_type& DomainValues,
                          const RangeValues_type& RangeValues,
                          const n_type& n)
    : ::xml_schema::type (),
      DomainValues_ (DomainValues, this),
      RangeValues_ (RangeValues, this),
      n_ (n, this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const FunctionDiscreteType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DomainValues_ (x.DomainValues_, f, this),
      RangeValues_ (x.RangeValues_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DomainValues_ (this),
      RangeValues_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DomainValues
        //
        if (n.name () == L"DomainValues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainValues_type > r (
            DomainValues_traits::create (i, f, this));

          if (!DomainValues_.present ())
          {
            this->DomainValues_.set (::std::move (r));
            continue;
          }
        }

        // RangeValues
        //
        if (n.name () == L"RangeValues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RangeValues_type > r (
            RangeValues_traits::create (i, f, this));

          if (!RangeValues_.present ())
          {
            this->RangeValues_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DomainValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainValues",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RangeValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RangeValues",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FunctionDiscreteType* FunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FunctionDiscreteType (*this, f, c);
    }

    FunctionDiscreteType& FunctionDiscreteType::
    operator= (const FunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DomainValues_ = x.DomainValues_;
        this->RangeValues_ = x.RangeValues_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FunctionDiscreteType::
    ~FunctionDiscreteType ()
    {
    }

    // LengthFunctionDiscreteType
    //

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType ()
    : ::xsd::qif30::FunctionDiscreteType (),
      DomainLinearUnit_ (this),
      RangeLinearUnit_ (this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const DomainValues_type& DomainValues,
                                const RangeValues_type& RangeValues,
                                const n_type& n,
                                const DomainLinearUnit_type& DomainLinearUnit,
                                const RangeLinearUnit_type& RangeLinearUnit)
    : ::xsd::qif30::FunctionDiscreteType (DomainValues,
                                          RangeValues,
                                          n),
      DomainLinearUnit_ (DomainLinearUnit, this),
      RangeLinearUnit_ (RangeLinearUnit, this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const LengthFunctionDiscreteType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeLinearUnit_ (x.RangeLinearUnit_, f, this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (this),
      RangeLinearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LengthFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FunctionDiscreteType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DomainLinearUnit
        //
        if (n.name () == L"DomainLinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (::std::move (r));
            continue;
          }
        }

        // RangeLinearUnit
        //
        if (n.name () == L"RangeLinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RangeLinearUnit_type > r (
            RangeLinearUnit_traits::create (i, f, this));

          if (!RangeLinearUnit_.present ())
          {
            this->RangeLinearUnit_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainLinearUnit",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RangeLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RangeLinearUnit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LengthFunctionDiscreteType* LengthFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LengthFunctionDiscreteType (*this, f, c);
    }

    LengthFunctionDiscreteType& LengthFunctionDiscreteType::
    operator= (const LengthFunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FunctionDiscreteType& > (*this) = x;
        this->DomainLinearUnit_ = x.DomainLinearUnit_;
        this->RangeLinearUnit_ = x.RangeLinearUnit_;
      }

      return *this;
    }

    LengthFunctionDiscreteType::
    ~LengthFunctionDiscreteType ()
    {
    }

    // AngleFunctionDiscreteType
    //

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType ()
    : ::xsd::qif30::FunctionDiscreteType (),
      DomainLinearUnit_ (this),
      RangeAngularUnit_ (this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const DomainValues_type& DomainValues,
                               const RangeValues_type& RangeValues,
                               const n_type& n,
                               const DomainLinearUnit_type& DomainLinearUnit,
                               const RangeAngularUnit_type& RangeAngularUnit)
    : ::xsd::qif30::FunctionDiscreteType (DomainValues,
                                          RangeValues,
                                          n),
      DomainLinearUnit_ (DomainLinearUnit, this),
      RangeAngularUnit_ (RangeAngularUnit, this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const AngleFunctionDiscreteType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeAngularUnit_ (x.RangeAngularUnit_, f, this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (this),
      RangeAngularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AngleFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FunctionDiscreteType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DomainLinearUnit
        //
        if (n.name () == L"DomainLinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (::std::move (r));
            continue;
          }
        }

        // RangeAngularUnit
        //
        if (n.name () == L"RangeAngularUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RangeAngularUnit_type > r (
            RangeAngularUnit_traits::create (i, f, this));

          if (!RangeAngularUnit_.present ())
          {
            this->RangeAngularUnit_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainLinearUnit",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RangeAngularUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RangeAngularUnit",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AngleFunctionDiscreteType* AngleFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleFunctionDiscreteType (*this, f, c);
    }

    AngleFunctionDiscreteType& AngleFunctionDiscreteType::
    operator= (const AngleFunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FunctionDiscreteType& > (*this) = x;
        this->DomainLinearUnit_ = x.DomainLinearUnit_;
        this->RangeAngularUnit_ = x.RangeAngularUnit_;
      }

      return *this;
    }

    AngleFunctionDiscreteType::
    ~AngleFunctionDiscreteType ()
    {
    }

    // MeasurementDeviceAccuracyBaseType
    //

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType ()
    : ::xml_schema::type (),
      EnvironmentalRange_ (this)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const EnvironmentalRange_type& EnvironmentalRange)
    : ::xml_schema::type (),
      EnvironmentalRange_ (EnvironmentalRange, this)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (::std::unique_ptr< EnvironmentalRange_type > EnvironmentalRange)
    : ::xml_schema::type (),
      EnvironmentalRange_ (std::move (EnvironmentalRange), this)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const MeasurementDeviceAccuracyBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EnvironmentalRange_ (x.EnvironmentalRange_, f, this)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EnvironmentalRange_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementDeviceAccuracyBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EnvironmentalRange
        //
        if (n.name () == L"EnvironmentalRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EnvironmentalRange_type > r (
            EnvironmentalRange_traits::create (i, f, this));

          if (!EnvironmentalRange_.present ())
          {
            this->EnvironmentalRange_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!EnvironmentalRange_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EnvironmentalRange",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasurementDeviceAccuracyBaseType& MeasurementDeviceAccuracyBaseType::
    operator= (const MeasurementDeviceAccuracyBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EnvironmentalRange_ = x.EnvironmentalRange_;
      }

      return *this;
    }

    MeasurementDeviceAccuracyBaseType::
    ~MeasurementDeviceAccuracyBaseType ()
    {
    }

    // NumericalLengthAccuracyType
    //

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType ()
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (),
      AccuracyValue_ (this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const EnvironmentalRange_type& EnvironmentalRange,
                                 const AccuracyValue_type& AccuracyValue)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (EnvironmentalRange),
      AccuracyValue_ (AccuracyValue, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (::std::unique_ptr< EnvironmentalRange_type > EnvironmentalRange,
                                 ::std::unique_ptr< AccuracyValue_type > AccuracyValue)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (std::move (EnvironmentalRange)),
      AccuracyValue_ (std::move (AccuracyValue), this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const NumericalLengthAccuracyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (x, f, c),
      AccuracyValue_ (x.AccuracyValue_, f, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      AccuracyValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NumericalLengthAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementDeviceAccuracyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AccuracyValue
        //
        if (n.name () == L"AccuracyValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AccuracyValue_type > r (
            AccuracyValue_traits::create (i, f, this));

          if (!AccuracyValue_.present ())
          {
            this->AccuracyValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AccuracyValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AccuracyValue",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NumericalLengthAccuracyType* NumericalLengthAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumericalLengthAccuracyType (*this, f, c);
    }

    NumericalLengthAccuracyType& NumericalLengthAccuracyType::
    operator= (const NumericalLengthAccuracyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (*this) = x;
        this->AccuracyValue_ = x.AccuracyValue_;
      }

      return *this;
    }

    NumericalLengthAccuracyType::
    ~NumericalLengthAccuracyType ()
    {
    }

    // EnvironmentalRangeType
    //

    EnvironmentalRangeType::
    EnvironmentalRangeType ()
    : ::xml_schema::type (),
      Name_ (this),
      Description_ (this),
      MaxAmbientTemperature_ (this),
      MinAmbientTemperature_ (this),
      MaxAmbientAirPressure_ (this),
      MinAmbientAirPressure_ (this),
      MaxAmbientRelativeHumidity_ (this),
      MinAmbientRelativeHumidity_ (this),
      MaxVibration_ (this),
      Attributes_ (this)
    {
    }

    EnvironmentalRangeType::
    EnvironmentalRangeType (const EnvironmentalRangeType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      MaxAmbientTemperature_ (x.MaxAmbientTemperature_, f, this),
      MinAmbientTemperature_ (x.MinAmbientTemperature_, f, this),
      MaxAmbientAirPressure_ (x.MaxAmbientAirPressure_, f, this),
      MinAmbientAirPressure_ (x.MinAmbientAirPressure_, f, this),
      MaxAmbientRelativeHumidity_ (x.MaxAmbientRelativeHumidity_, f, this),
      MinAmbientRelativeHumidity_ (x.MinAmbientRelativeHumidity_, f, this),
      MaxVibration_ (x.MaxVibration_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    EnvironmentalRangeType::
    EnvironmentalRangeType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Description_ (this),
      MaxAmbientTemperature_ (this),
      MinAmbientTemperature_ (this),
      MaxAmbientAirPressure_ (this),
      MinAmbientAirPressure_ (this),
      MaxAmbientRelativeHumidity_ (this),
      MinAmbientRelativeHumidity_ (this),
      MaxVibration_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EnvironmentalRangeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // MaxAmbientTemperature
        //
        if (n.name () == L"MaxAmbientTemperature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAmbientTemperature_type > r (
            MaxAmbientTemperature_traits::create (i, f, this));

          if (!this->MaxAmbientTemperature_)
          {
            this->MaxAmbientTemperature_.set (::std::move (r));
            continue;
          }
        }

        // MinAmbientTemperature
        //
        if (n.name () == L"MinAmbientTemperature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAmbientTemperature_type > r (
            MinAmbientTemperature_traits::create (i, f, this));

          if (!this->MinAmbientTemperature_)
          {
            this->MinAmbientTemperature_.set (::std::move (r));
            continue;
          }
        }

        // MaxAmbientAirPressure
        //
        if (n.name () == L"MaxAmbientAirPressure" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAmbientAirPressure_type > r (
            MaxAmbientAirPressure_traits::create (i, f, this));

          if (!this->MaxAmbientAirPressure_)
          {
            this->MaxAmbientAirPressure_.set (::std::move (r));
            continue;
          }
        }

        // MinAmbientAirPressure
        //
        if (n.name () == L"MinAmbientAirPressure" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAmbientAirPressure_type > r (
            MinAmbientAirPressure_traits::create (i, f, this));

          if (!this->MinAmbientAirPressure_)
          {
            this->MinAmbientAirPressure_.set (::std::move (r));
            continue;
          }
        }

        // MaxAmbientRelativeHumidity
        //
        if (n.name () == L"MaxAmbientRelativeHumidity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxAmbientRelativeHumidity_type > r (
            MaxAmbientRelativeHumidity_traits::create (i, f, this));

          if (!this->MaxAmbientRelativeHumidity_)
          {
            this->MaxAmbientRelativeHumidity_.set (::std::move (r));
            continue;
          }
        }

        // MinAmbientRelativeHumidity
        //
        if (n.name () == L"MinAmbientRelativeHumidity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinAmbientRelativeHumidity_type > r (
            MinAmbientRelativeHumidity_traits::create (i, f, this));

          if (!this->MinAmbientRelativeHumidity_)
          {
            this->MinAmbientRelativeHumidity_.set (::std::move (r));
            continue;
          }
        }

        // MaxVibration
        //
        if (n.name () == L"MaxVibration" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxVibration_type > r (
            MaxVibration_traits::create (i, f, this));

          if (!this->MaxVibration_)
          {
            this->MaxVibration_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EnvironmentalRangeType* EnvironmentalRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EnvironmentalRangeType (*this, f, c);
    }

    EnvironmentalRangeType& EnvironmentalRangeType::
    operator= (const EnvironmentalRangeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->MaxAmbientTemperature_ = x.MaxAmbientTemperature_;
        this->MinAmbientTemperature_ = x.MinAmbientTemperature_;
        this->MaxAmbientAirPressure_ = x.MaxAmbientAirPressure_;
        this->MinAmbientAirPressure_ = x.MinAmbientAirPressure_;
        this->MaxAmbientRelativeHumidity_ = x.MaxAmbientRelativeHumidity_;
        this->MinAmbientRelativeHumidity_ = x.MinAmbientRelativeHumidity_;
        this->MaxVibration_ = x.MaxVibration_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    EnvironmentalRangeType::
    ~EnvironmentalRangeType ()
    {
    }

    // CartesianCMMAccuracyType
    //

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType ()
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (),
      CartesianCMMAccuracyTest_ (this),
      AccuracySource_ (this)
    {
    }

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType (const EnvironmentalRange_type& EnvironmentalRange,
                              const CartesianCMMAccuracyTest_type& CartesianCMMAccuracyTest,
                              const AccuracySource_type& AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (EnvironmentalRange),
      CartesianCMMAccuracyTest_ (CartesianCMMAccuracyTest, this),
      AccuracySource_ (AccuracySource, this)
    {
    }

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType (::std::unique_ptr< EnvironmentalRange_type > EnvironmentalRange,
                              const CartesianCMMAccuracyTest_type& CartesianCMMAccuracyTest,
                              ::std::unique_ptr< AccuracySource_type > AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (std::move (EnvironmentalRange)),
      CartesianCMMAccuracyTest_ (CartesianCMMAccuracyTest, this),
      AccuracySource_ (std::move (AccuracySource), this)
    {
    }

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType (const EnvironmentalRange_type& EnvironmentalRange,
                              ::std::unique_ptr< CartesianCMMAccuracyTest_type > CartesianCMMAccuracyTest,
                              const AccuracySource_type& AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (EnvironmentalRange),
      CartesianCMMAccuracyTest_ (std::move (CartesianCMMAccuracyTest), this),
      AccuracySource_ (AccuracySource, this)
    {
    }

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType (const CartesianCMMAccuracyType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (x, f, c),
      CartesianCMMAccuracyTest_ (x.CartesianCMMAccuracyTest_, f, this),
      AccuracySource_ (x.AccuracySource_, f, this)
    {
    }

    CartesianCMMAccuracyType::
    CartesianCMMAccuracyType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      CartesianCMMAccuracyTest_ (this),
      AccuracySource_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianCMMAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementDeviceAccuracyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CartesianCMMAccuracyTest
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"CartesianCMMAccuracyTest",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!CartesianCMMAccuracyTest_.present ())
            {
              ::std::unique_ptr< CartesianCMMAccuracyTest_type > r (
                dynamic_cast< CartesianCMMAccuracyTest_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CartesianCMMAccuracyTest_.set (::std::move (r));
              continue;
            }
          }
        }

        // AccuracySource
        //
        if (n.name () == L"AccuracySource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AccuracySource_type > r (
            AccuracySource_traits::create (i, f, this));

          if (!AccuracySource_.present ())
          {
            this->AccuracySource_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CartesianCMMAccuracyTest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CartesianCMMAccuracyTest",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AccuracySource_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AccuracySource",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CartesianCMMAccuracyType* CartesianCMMAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMAccuracyType (*this, f, c);
    }

    CartesianCMMAccuracyType& CartesianCMMAccuracyType::
    operator= (const CartesianCMMAccuracyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (*this) = x;
        this->CartesianCMMAccuracyTest_ = x.CartesianCMMAccuracyTest_;
        this->AccuracySource_ = x.AccuracySource_;
      }

      return *this;
    }

    CartesianCMMAccuracyType::
    ~CartesianCMMAccuracyType ()
    {
    }

    // AACMMAccuracyType
    //

    AACMMAccuracyType::
    AACMMAccuracyType ()
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (),
      AACMMAccuracyTest_ (this),
      AccuracySource_ (this)
    {
    }

    AACMMAccuracyType::
    AACMMAccuracyType (const EnvironmentalRange_type& EnvironmentalRange,
                       const AACMMAccuracyTest_type& AACMMAccuracyTest,
                       const AccuracySource_type& AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (EnvironmentalRange),
      AACMMAccuracyTest_ (AACMMAccuracyTest, this),
      AccuracySource_ (AccuracySource, this)
    {
    }

    AACMMAccuracyType::
    AACMMAccuracyType (::std::unique_ptr< EnvironmentalRange_type > EnvironmentalRange,
                       const AACMMAccuracyTest_type& AACMMAccuracyTest,
                       ::std::unique_ptr< AccuracySource_type > AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (std::move (EnvironmentalRange)),
      AACMMAccuracyTest_ (AACMMAccuracyTest, this),
      AccuracySource_ (std::move (AccuracySource), this)
    {
    }

    AACMMAccuracyType::
    AACMMAccuracyType (const EnvironmentalRange_type& EnvironmentalRange,
                       ::std::unique_ptr< AACMMAccuracyTest_type > AACMMAccuracyTest,
                       const AccuracySource_type& AccuracySource)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (EnvironmentalRange),
      AACMMAccuracyTest_ (std::move (AACMMAccuracyTest), this),
      AccuracySource_ (AccuracySource, this)
    {
    }

    AACMMAccuracyType::
    AACMMAccuracyType (const AACMMAccuracyType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (x, f, c),
      AACMMAccuracyTest_ (x.AACMMAccuracyTest_, f, this),
      AccuracySource_ (x.AccuracySource_, f, this)
    {
    }

    AACMMAccuracyType::
    AACMMAccuracyType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      AACMMAccuracyTest_ (this),
      AccuracySource_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AACMMAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurementDeviceAccuracyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AACMMAccuracyTest
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"AACMMAccuracyTest",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!AACMMAccuracyTest_.present ())
            {
              ::std::unique_ptr< AACMMAccuracyTest_type > r (
                dynamic_cast< AACMMAccuracyTest_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AACMMAccuracyTest_.set (::std::move (r));
              continue;
            }
          }
        }

        // AccuracySource
        //
        if (n.name () == L"AccuracySource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AccuracySource_type > r (
            AccuracySource_traits::create (i, f, this));

          if (!AccuracySource_.present ())
          {
            this->AccuracySource_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AACMMAccuracyTest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AACMMAccuracyTest",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AccuracySource_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AccuracySource",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AACMMAccuracyType* AACMMAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AACMMAccuracyType (*this, f, c);
    }

    AACMMAccuracyType& AACMMAccuracyType::
    operator= (const AACMMAccuracyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (*this) = x;
        this->AACMMAccuracyTest_ = x.AACMMAccuracyTest_;
        this->AccuracySource_ = x.AccuracySource_;
      }

      return *this;
    }

    AACMMAccuracyType::
    ~AACMMAccuracyType ()
    {
    }

    // CartesianCMMAccuraciesType
    //

    CartesianCMMAccuraciesType::
    CartesianCMMAccuraciesType ()
    : ::xml_schema::type (),
      CartesianCMMAccuracy_ (this),
      n_ (this)
    {
    }

    CartesianCMMAccuraciesType::
    CartesianCMMAccuraciesType (const n_type& n)
    : ::xml_schema::type (),
      CartesianCMMAccuracy_ (this),
      n_ (n, this)
    {
    }

    CartesianCMMAccuraciesType::
    CartesianCMMAccuraciesType (const CartesianCMMAccuraciesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CartesianCMMAccuracy_ (x.CartesianCMMAccuracy_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CartesianCMMAccuraciesType::
    CartesianCMMAccuraciesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CartesianCMMAccuracy_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CartesianCMMAccuraciesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CartesianCMMAccuracy
        //
        if (n.name () == L"CartesianCMMAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CartesianCMMAccuracy_type > r (
            CartesianCMMAccuracy_traits::create (i, f, this));

          this->CartesianCMMAccuracy_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CartesianCMMAccuraciesType* CartesianCMMAccuraciesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMAccuraciesType (*this, f, c);
    }

    CartesianCMMAccuraciesType& CartesianCMMAccuraciesType::
    operator= (const CartesianCMMAccuraciesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CartesianCMMAccuracy_ = x.CartesianCMMAccuracy_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CartesianCMMAccuraciesType::
    ~CartesianCMMAccuraciesType ()
    {
    }

    // AACMMAccuraciesType
    //

    AACMMAccuraciesType::
    AACMMAccuraciesType ()
    : ::xml_schema::type (),
      AACMMAccuracy_ (this),
      n_ (this)
    {
    }

    AACMMAccuraciesType::
    AACMMAccuraciesType (const n_type& n)
    : ::xml_schema::type (),
      AACMMAccuracy_ (this),
      n_ (n, this)
    {
    }

    AACMMAccuraciesType::
    AACMMAccuraciesType (const AACMMAccuraciesType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AACMMAccuracy_ (x.AACMMAccuracy_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AACMMAccuraciesType::
    AACMMAccuraciesType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AACMMAccuracy_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AACMMAccuraciesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AACMMAccuracy
        //
        if (n.name () == L"AACMMAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AACMMAccuracy_type > r (
            AACMMAccuracy_traits::create (i, f, this));

          this->AACMMAccuracy_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AACMMAccuraciesType* AACMMAccuraciesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AACMMAccuraciesType (*this, f, c);
    }

    AACMMAccuraciesType& AACMMAccuraciesType::
    operator= (const AACMMAccuraciesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AACMMAccuracy_ = x.AACMMAccuracy_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AACMMAccuraciesType::
    ~AACMMAccuraciesType ()
    {
    }

    // AccuracySourceType
    //

    AccuracySourceType::
    AccuracySourceType ()
    : ::xml_schema::type (),
      AccuracySourceEnum_ (this),
      OtherAccuracySource_ (this)
    {
    }

    AccuracySourceType::
    AccuracySourceType (const AccuracySourceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AccuracySourceEnum_ (x.AccuracySourceEnum_, f, this),
      OtherAccuracySource_ (x.OtherAccuracySource_, f, this)
    {
    }

    AccuracySourceType::
    AccuracySourceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AccuracySourceEnum_ (this),
      OtherAccuracySource_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AccuracySourceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AccuracySourceEnum
        //
        if (n.name () == L"AccuracySourceEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AccuracySourceEnum_type > r (
            AccuracySourceEnum_traits::create (i, f, this));

          if (!this->AccuracySourceEnum_)
          {
            this->AccuracySourceEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherAccuracySource
        //
        if (n.name () == L"OtherAccuracySource" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherAccuracySource_type > r (
            OtherAccuracySource_traits::create (i, f, this));

          if (!this->OtherAccuracySource_)
          {
            this->OtherAccuracySource_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AccuracySourceType* AccuracySourceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AccuracySourceType (*this, f, c);
    }

    AccuracySourceType& AccuracySourceType::
    operator= (const AccuracySourceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AccuracySourceEnum_ = x.AccuracySourceEnum_;
        this->OtherAccuracySource_ = x.OtherAccuracySource_;
      }

      return *this;
    }

    AccuracySourceType::
    ~AccuracySourceType ()
    {
    }

    // AccuracySourceEnumType
    //

    AccuracySourceEnumType::
    AccuracySourceEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AccuracySourceEnumType_convert ();
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AccuracySourceEnumType_convert ();
    }

    AccuracySourceEnumType::
    AccuracySourceEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AccuracySourceEnumType_convert ();
    }

    AccuracySourceEnumType* AccuracySourceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AccuracySourceEnumType (*this, f, c);
    }

    AccuracySourceEnumType::value AccuracySourceEnumType::
    _xsd_AccuracySourceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AccuracySourceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AccuracySourceEnumType_indexes_,
                        _xsd_AccuracySourceEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_AccuracySourceEnumType_indexes_ + 2 || _xsd_AccuracySourceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AccuracySourceEnumType::
    _xsd_AccuracySourceEnumType_literals_[2] =
    {
      L"MANUFACTURER_SPECIFICATION",
      L"CUSTOM_CERTIFICATION"
    };

    const AccuracySourceEnumType::value AccuracySourceEnumType::
    _xsd_AccuracySourceEnumType_indexes_[2] =
    {
      ::xsd::qif30::AccuracySourceEnumType::CUSTOM_CERTIFICATION,
      ::xsd::qif30::AccuracySourceEnumType::MANUFACTURER_SPECIFICATION
    };

    // CMMAccuracyTestBaseType
    //

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType ()
    : ::xml_schema::type ()
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const CMMAccuracyTestBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    ~CMMAccuracyTestBaseType ()
    {
    }

    // FPSTestType
    //

    FPSTestType::
    FPSTestType ()
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearity_ (this),
      YLinearity_ (this),
      ZLinearity_ (this),
      XAxisRoll_ (this),
      XAxisPitch_ (this),
      XAxisYaw_ (this),
      YAxisRoll_ (this),
      YAxisPitch_ (this),
      YAxisYaw_ (this),
      ZAxisRoll_ (this),
      ZAxisPitch_ (this),
      ZAxisYaw_ (this),
      XAxisStraightnessY_ (this),
      XAxisStraightnessZ_ (this),
      YAxisStraightnessX_ (this),
      YAxisStraightnessZ_ (this),
      ZAxisStraightnessX_ (this),
      ZAxisStraightnessY_ (this),
      XYSquareness_ (this),
      XZSquareness_ (this),
      YZSquareness_ (this)
    {
    }

    FPSTestType::
    FPSTestType (const XLinearity_type& XLinearity,
                 const YLinearity_type& YLinearity,
                 const ZLinearity_type& ZLinearity,
                 const XAxisRoll_type& XAxisRoll,
                 const XAxisPitch_type& XAxisPitch,
                 const XAxisYaw_type& XAxisYaw,
                 const YAxisRoll_type& YAxisRoll,
                 const YAxisPitch_type& YAxisPitch,
                 const YAxisYaw_type& YAxisYaw,
                 const ZAxisRoll_type& ZAxisRoll,
                 const ZAxisPitch_type& ZAxisPitch,
                 const ZAxisYaw_type& ZAxisYaw,
                 const XAxisStraightnessY_type& XAxisStraightnessY,
                 const XAxisStraightnessZ_type& XAxisStraightnessZ,
                 const YAxisStraightnessX_type& YAxisStraightnessX,
                 const YAxisStraightnessZ_type& YAxisStraightnessZ,
                 const ZAxisStraightnessX_type& ZAxisStraightnessX,
                 const ZAxisStraightnessY_type& ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearity_ (XLinearity, this),
      YLinearity_ (YLinearity, this),
      ZLinearity_ (ZLinearity, this),
      XAxisRoll_ (XAxisRoll, this),
      XAxisPitch_ (XAxisPitch, this),
      XAxisYaw_ (XAxisYaw, this),
      YAxisRoll_ (YAxisRoll, this),
      YAxisPitch_ (YAxisPitch, this),
      YAxisYaw_ (YAxisYaw, this),
      ZAxisRoll_ (ZAxisRoll, this),
      ZAxisPitch_ (ZAxisPitch, this),
      ZAxisYaw_ (ZAxisYaw, this),
      XAxisStraightnessY_ (XAxisStraightnessY, this),
      XAxisStraightnessZ_ (XAxisStraightnessZ, this),
      YAxisStraightnessX_ (YAxisStraightnessX, this),
      YAxisStraightnessZ_ (YAxisStraightnessZ, this),
      ZAxisStraightnessX_ (ZAxisStraightnessX, this),
      ZAxisStraightnessY_ (ZAxisStraightnessY, this),
      XYSquareness_ (XYSquareness, this),
      XZSquareness_ (XZSquareness, this),
      YZSquareness_ (YZSquareness, this)
    {
    }

    FPSTestType::
    FPSTestType (::std::unique_ptr< XLinearity_type > XLinearity,
                 ::std::unique_ptr< YLinearity_type > YLinearity,
                 ::std::unique_ptr< ZLinearity_type > ZLinearity,
                 ::std::unique_ptr< XAxisRoll_type > XAxisRoll,
                 ::std::unique_ptr< XAxisPitch_type > XAxisPitch,
                 ::std::unique_ptr< XAxisYaw_type > XAxisYaw,
                 ::std::unique_ptr< YAxisRoll_type > YAxisRoll,
                 ::std::unique_ptr< YAxisPitch_type > YAxisPitch,
                 ::std::unique_ptr< YAxisYaw_type > YAxisYaw,
                 ::std::unique_ptr< ZAxisRoll_type > ZAxisRoll,
                 ::std::unique_ptr< ZAxisPitch_type > ZAxisPitch,
                 ::std::unique_ptr< ZAxisYaw_type > ZAxisYaw,
                 ::std::unique_ptr< XAxisStraightnessY_type > XAxisStraightnessY,
                 ::std::unique_ptr< XAxisStraightnessZ_type > XAxisStraightnessZ,
                 ::std::unique_ptr< YAxisStraightnessX_type > YAxisStraightnessX,
                 ::std::unique_ptr< YAxisStraightnessZ_type > YAxisStraightnessZ,
                 ::std::unique_ptr< ZAxisStraightnessX_type > ZAxisStraightnessX,
                 ::std::unique_ptr< ZAxisStraightnessY_type > ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearity_ (std::move (XLinearity), this),
      YLinearity_ (std::move (YLinearity), this),
      ZLinearity_ (std::move (ZLinearity), this),
      XAxisRoll_ (std::move (XAxisRoll), this),
      XAxisPitch_ (std::move (XAxisPitch), this),
      XAxisYaw_ (std::move (XAxisYaw), this),
      YAxisRoll_ (std::move (YAxisRoll), this),
      YAxisPitch_ (std::move (YAxisPitch), this),
      YAxisYaw_ (std::move (YAxisYaw), this),
      ZAxisRoll_ (std::move (ZAxisRoll), this),
      ZAxisPitch_ (std::move (ZAxisPitch), this),
      ZAxisYaw_ (std::move (ZAxisYaw), this),
      XAxisStraightnessY_ (std::move (XAxisStraightnessY), this),
      XAxisStraightnessZ_ (std::move (XAxisStraightnessZ), this),
      YAxisStraightnessX_ (std::move (YAxisStraightnessX), this),
      YAxisStraightnessZ_ (std::move (YAxisStraightnessZ), this),
      ZAxisStraightnessX_ (std::move (ZAxisStraightnessX), this),
      ZAxisStraightnessY_ (std::move (ZAxisStraightnessY), this),
      XYSquareness_ (XYSquareness, this),
      XZSquareness_ (XZSquareness, this),
      YZSquareness_ (YZSquareness, this)
    {
    }

    FPSTestType::
    FPSTestType (const FPSTestType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (x, f, c),
      XLinearity_ (x.XLinearity_, f, this),
      YLinearity_ (x.YLinearity_, f, this),
      ZLinearity_ (x.ZLinearity_, f, this),
      XAxisRoll_ (x.XAxisRoll_, f, this),
      XAxisPitch_ (x.XAxisPitch_, f, this),
      XAxisYaw_ (x.XAxisYaw_, f, this),
      YAxisRoll_ (x.YAxisRoll_, f, this),
      YAxisPitch_ (x.YAxisPitch_, f, this),
      YAxisYaw_ (x.YAxisYaw_, f, this),
      ZAxisRoll_ (x.ZAxisRoll_, f, this),
      ZAxisPitch_ (x.ZAxisPitch_, f, this),
      ZAxisYaw_ (x.ZAxisYaw_, f, this),
      XAxisStraightnessY_ (x.XAxisStraightnessY_, f, this),
      XAxisStraightnessZ_ (x.XAxisStraightnessZ_, f, this),
      YAxisStraightnessX_ (x.YAxisStraightnessX_, f, this),
      YAxisStraightnessZ_ (x.YAxisStraightnessZ_, f, this),
      ZAxisStraightnessX_ (x.ZAxisStraightnessX_, f, this),
      ZAxisStraightnessY_ (x.ZAxisStraightnessY_, f, this),
      XYSquareness_ (x.XYSquareness_, f, this),
      XZSquareness_ (x.XZSquareness_, f, this),
      YZSquareness_ (x.YZSquareness_, f, this)
    {
    }

    FPSTestType::
    FPSTestType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearity_ (this),
      YLinearity_ (this),
      ZLinearity_ (this),
      XAxisRoll_ (this),
      XAxisPitch_ (this),
      XAxisYaw_ (this),
      YAxisRoll_ (this),
      YAxisPitch_ (this),
      YAxisYaw_ (this),
      ZAxisRoll_ (this),
      ZAxisPitch_ (this),
      ZAxisYaw_ (this),
      XAxisStraightnessY_ (this),
      XAxisStraightnessZ_ (this),
      YAxisStraightnessX_ (this),
      YAxisStraightnessZ_ (this),
      ZAxisStraightnessX_ (this),
      ZAxisStraightnessY_ (this),
      XYSquareness_ (this),
      XZSquareness_ (this),
      YZSquareness_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FPSTestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XLinearity
        //
        if (n.name () == L"XLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XLinearity_type > r (
            XLinearity_traits::create (i, f, this));

          if (!XLinearity_.present ())
          {
            this->XLinearity_.set (::std::move (r));
            continue;
          }
        }

        // YLinearity
        //
        if (n.name () == L"YLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YLinearity_type > r (
            YLinearity_traits::create (i, f, this));

          if (!YLinearity_.present ())
          {
            this->YLinearity_.set (::std::move (r));
            continue;
          }
        }

        // ZLinearity
        //
        if (n.name () == L"ZLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZLinearity_type > r (
            ZLinearity_traits::create (i, f, this));

          if (!ZLinearity_.present ())
          {
            this->ZLinearity_.set (::std::move (r));
            continue;
          }
        }

        // XAxisRoll
        //
        if (n.name () == L"XAxisRoll" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisRoll_type > r (
            XAxisRoll_traits::create (i, f, this));

          if (!XAxisRoll_.present ())
          {
            this->XAxisRoll_.set (::std::move (r));
            continue;
          }
        }

        // XAxisPitch
        //
        if (n.name () == L"XAxisPitch" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisPitch_type > r (
            XAxisPitch_traits::create (i, f, this));

          if (!XAxisPitch_.present ())
          {
            this->XAxisPitch_.set (::std::move (r));
            continue;
          }
        }

        // XAxisYaw
        //
        if (n.name () == L"XAxisYaw" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisYaw_type > r (
            XAxisYaw_traits::create (i, f, this));

          if (!XAxisYaw_.present ())
          {
            this->XAxisYaw_.set (::std::move (r));
            continue;
          }
        }

        // YAxisRoll
        //
        if (n.name () == L"YAxisRoll" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisRoll_type > r (
            YAxisRoll_traits::create (i, f, this));

          if (!YAxisRoll_.present ())
          {
            this->YAxisRoll_.set (::std::move (r));
            continue;
          }
        }

        // YAxisPitch
        //
        if (n.name () == L"YAxisPitch" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisPitch_type > r (
            YAxisPitch_traits::create (i, f, this));

          if (!YAxisPitch_.present ())
          {
            this->YAxisPitch_.set (::std::move (r));
            continue;
          }
        }

        // YAxisYaw
        //
        if (n.name () == L"YAxisYaw" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisYaw_type > r (
            YAxisYaw_traits::create (i, f, this));

          if (!YAxisYaw_.present ())
          {
            this->YAxisYaw_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisRoll
        //
        if (n.name () == L"ZAxisRoll" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisRoll_type > r (
            ZAxisRoll_traits::create (i, f, this));

          if (!ZAxisRoll_.present ())
          {
            this->ZAxisRoll_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisPitch
        //
        if (n.name () == L"ZAxisPitch" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisPitch_type > r (
            ZAxisPitch_traits::create (i, f, this));

          if (!ZAxisPitch_.present ())
          {
            this->ZAxisPitch_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisYaw
        //
        if (n.name () == L"ZAxisYaw" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisYaw_type > r (
            ZAxisYaw_traits::create (i, f, this));

          if (!ZAxisYaw_.present ())
          {
            this->ZAxisYaw_.set (::std::move (r));
            continue;
          }
        }

        // XAxisStraightnessY
        //
        if (n.name () == L"XAxisStraightnessY" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisStraightnessY_type > r (
            XAxisStraightnessY_traits::create (i, f, this));

          if (!XAxisStraightnessY_.present ())
          {
            this->XAxisStraightnessY_.set (::std::move (r));
            continue;
          }
        }

        // XAxisStraightnessZ
        //
        if (n.name () == L"XAxisStraightnessZ" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XAxisStraightnessZ_type > r (
            XAxisStraightnessZ_traits::create (i, f, this));

          if (!XAxisStraightnessZ_.present ())
          {
            this->XAxisStraightnessZ_.set (::std::move (r));
            continue;
          }
        }

        // YAxisStraightnessX
        //
        if (n.name () == L"YAxisStraightnessX" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisStraightnessX_type > r (
            YAxisStraightnessX_traits::create (i, f, this));

          if (!YAxisStraightnessX_.present ())
          {
            this->YAxisStraightnessX_.set (::std::move (r));
            continue;
          }
        }

        // YAxisStraightnessZ
        //
        if (n.name () == L"YAxisStraightnessZ" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YAxisStraightnessZ_type > r (
            YAxisStraightnessZ_traits::create (i, f, this));

          if (!YAxisStraightnessZ_.present ())
          {
            this->YAxisStraightnessZ_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisStraightnessX
        //
        if (n.name () == L"ZAxisStraightnessX" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisStraightnessX_type > r (
            ZAxisStraightnessX_traits::create (i, f, this));

          if (!ZAxisStraightnessX_.present ())
          {
            this->ZAxisStraightnessX_.set (::std::move (r));
            continue;
          }
        }

        // ZAxisStraightnessY
        //
        if (n.name () == L"ZAxisStraightnessY" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZAxisStraightnessY_type > r (
            ZAxisStraightnessY_traits::create (i, f, this));

          if (!ZAxisStraightnessY_.present ())
          {
            this->ZAxisStraightnessY_.set (::std::move (r));
            continue;
          }
        }

        // XYSquareness
        //
        if (n.name () == L"XYSquareness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!XYSquareness_.present ())
          {
            this->XYSquareness_.set (XYSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // XZSquareness
        //
        if (n.name () == L"XZSquareness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!XZSquareness_.present ())
          {
            this->XZSquareness_.set (XZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // YZSquareness
        //
        if (n.name () == L"YZSquareness" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!YZSquareness_.present ())
          {
            this->YZSquareness_.set (YZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!XLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XLinearity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YLinearity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZLinearity",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisRoll",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisPitch",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisYaw",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisRoll",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisPitch",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisYaw",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisRoll",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisPitch",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisYaw",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisStraightnessY",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XAxisStraightnessZ",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisStraightnessX",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YAxisStraightnessZ",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisStraightnessX",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZAxisStraightnessY",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XYSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XYSquareness",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XZSquareness",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YZSquareness",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FPSTestType* FPSTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FPSTestType (*this, f, c);
    }

    FPSTestType& FPSTestType::
    operator= (const FPSTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAccuracyTestBaseType& > (*this) = x;
        this->XLinearity_ = x.XLinearity_;
        this->YLinearity_ = x.YLinearity_;
        this->ZLinearity_ = x.ZLinearity_;
        this->XAxisRoll_ = x.XAxisRoll_;
        this->XAxisPitch_ = x.XAxisPitch_;
        this->XAxisYaw_ = x.XAxisYaw_;
        this->YAxisRoll_ = x.YAxisRoll_;
        this->YAxisPitch_ = x.YAxisPitch_;
        this->YAxisYaw_ = x.YAxisYaw_;
        this->ZAxisRoll_ = x.ZAxisRoll_;
        this->ZAxisPitch_ = x.ZAxisPitch_;
        this->ZAxisYaw_ = x.ZAxisYaw_;
        this->XAxisStraightnessY_ = x.XAxisStraightnessY_;
        this->XAxisStraightnessZ_ = x.XAxisStraightnessZ_;
        this->YAxisStraightnessX_ = x.YAxisStraightnessX_;
        this->YAxisStraightnessZ_ = x.YAxisStraightnessZ_;
        this->ZAxisStraightnessX_ = x.ZAxisStraightnessX_;
        this->ZAxisStraightnessY_ = x.ZAxisStraightnessY_;
        this->XYSquareness_ = x.XYSquareness_;
        this->XZSquareness_ = x.XZSquareness_;
        this->YZSquareness_ = x.YZSquareness_;
      }

      return *this;
    }

    FPSTestType::
    ~FPSTestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FPSTestType >
    _xsd_FPSTestType_type_factory_init (
      L"FPSTestType",
      L"http://qifstandards.org/xsd/qif3");

    // CartesianCMMB89TestType
    //

    CartesianCMMB89TestType::
    CartesianCMMB89TestType ()
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (this),
      YLinearAccuracy_ (this),
      ZLinearAccuracy_ (this),
      OffsetVolumetricPerformance_ (this),
      VolumetricPerformance_ (this),
      Repeatability_ (this)
    {
    }

    CartesianCMMB89TestType::
    CartesianCMMB89TestType (const XLinearAccuracy_type& XLinearAccuracy,
                             const YLinearAccuracy_type& YLinearAccuracy,
                             const ZLinearAccuracy_type& ZLinearAccuracy,
                             const OffsetVolumetricPerformance_type& OffsetVolumetricPerformance,
                             const VolumetricPerformance_type& VolumetricPerformance,
                             const Repeatability_type& Repeatability)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (XLinearAccuracy, this),
      YLinearAccuracy_ (YLinearAccuracy, this),
      ZLinearAccuracy_ (ZLinearAccuracy, this),
      OffsetVolumetricPerformance_ (OffsetVolumetricPerformance, this),
      VolumetricPerformance_ (VolumetricPerformance, this),
      Repeatability_ (Repeatability, this)
    {
    }

    CartesianCMMB89TestType::
    CartesianCMMB89TestType (::std::unique_ptr< XLinearAccuracy_type > XLinearAccuracy,
                             ::std::unique_ptr< YLinearAccuracy_type > YLinearAccuracy,
                             ::std::unique_ptr< ZLinearAccuracy_type > ZLinearAccuracy,
                             ::std::unique_ptr< OffsetVolumetricPerformance_type > OffsetVolumetricPerformance,
                             ::std::unique_ptr< VolumetricPerformance_type > VolumetricPerformance,
                             ::std::unique_ptr< Repeatability_type > Repeatability)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (std::move (XLinearAccuracy), this),
      YLinearAccuracy_ (std::move (YLinearAccuracy), this),
      ZLinearAccuracy_ (std::move (ZLinearAccuracy), this),
      OffsetVolumetricPerformance_ (std::move (OffsetVolumetricPerformance), this),
      VolumetricPerformance_ (std::move (VolumetricPerformance), this),
      Repeatability_ (std::move (Repeatability), this)
    {
    }

    CartesianCMMB89TestType::
    CartesianCMMB89TestType (const CartesianCMMB89TestType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (x, f, c),
      XLinearAccuracy_ (x.XLinearAccuracy_, f, this),
      YLinearAccuracy_ (x.YLinearAccuracy_, f, this),
      ZLinearAccuracy_ (x.ZLinearAccuracy_, f, this),
      OffsetVolumetricPerformance_ (x.OffsetVolumetricPerformance_, f, this),
      VolumetricPerformance_ (x.VolumetricPerformance_, f, this),
      Repeatability_ (x.Repeatability_, f, this)
    {
    }

    CartesianCMMB89TestType::
    CartesianCMMB89TestType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearAccuracy_ (this),
      YLinearAccuracy_ (this),
      ZLinearAccuracy_ (this),
      OffsetVolumetricPerformance_ (this),
      VolumetricPerformance_ (this),
      Repeatability_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CartesianCMMB89TestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XLinearAccuracy
        //
        if (n.name () == L"XLinearAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XLinearAccuracy_type > r (
            XLinearAccuracy_traits::create (i, f, this));

          if (!XLinearAccuracy_.present ())
          {
            this->XLinearAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // YLinearAccuracy
        //
        if (n.name () == L"YLinearAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YLinearAccuracy_type > r (
            YLinearAccuracy_traits::create (i, f, this));

          if (!YLinearAccuracy_.present ())
          {
            this->YLinearAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // ZLinearAccuracy
        //
        if (n.name () == L"ZLinearAccuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZLinearAccuracy_type > r (
            ZLinearAccuracy_traits::create (i, f, this));

          if (!ZLinearAccuracy_.present ())
          {
            this->ZLinearAccuracy_.set (::std::move (r));
            continue;
          }
        }

        // OffsetVolumetricPerformance
        //
        if (n.name () == L"OffsetVolumetricPerformance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OffsetVolumetricPerformance_type > r (
            OffsetVolumetricPerformance_traits::create (i, f, this));

          if (!OffsetVolumetricPerformance_.present ())
          {
            this->OffsetVolumetricPerformance_.set (::std::move (r));
            continue;
          }
        }

        // VolumetricPerformance
        //
        if (n.name () == L"VolumetricPerformance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VolumetricPerformance_type > r (
            VolumetricPerformance_traits::create (i, f, this));

          if (!VolumetricPerformance_.present ())
          {
            this->VolumetricPerformance_.set (::std::move (r));
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == L"Repeatability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!Repeatability_.present ())
          {
            this->Repeatability_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XLinearAccuracy",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YLinearAccuracy",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZLinearAccuracy",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!OffsetVolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OffsetVolumetricPerformance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!VolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VolumetricPerformance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Repeatability_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Repeatability",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CartesianCMMB89TestType* CartesianCMMB89TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CartesianCMMB89TestType (*this, f, c);
    }

    CartesianCMMB89TestType& CartesianCMMB89TestType::
    operator= (const CartesianCMMB89TestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAccuracyTestBaseType& > (*this) = x;
        this->XLinearAccuracy_ = x.XLinearAccuracy_;
        this->YLinearAccuracy_ = x.YLinearAccuracy_;
        this->ZLinearAccuracy_ = x.ZLinearAccuracy_;
        this->OffsetVolumetricPerformance_ = x.OffsetVolumetricPerformance_;
        this->VolumetricPerformance_ = x.VolumetricPerformance_;
        this->Repeatability_ = x.Repeatability_;
      }

      return *this;
    }

    CartesianCMMB89TestType::
    ~CartesianCMMB89TestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CartesianCMMB89TestType >
    _xsd_CartesianCMMB89TestType_type_factory_init (
      L"CartesianCMMB89TestType",
      L"http://qifstandards.org/xsd/qif3");

    // AACMMB89TestType
    //

    AACMMB89TestType::
    AACMMB89TestType ()
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      EffectiveDiameterPerformanceTest_ (this),
      SinglePointArticulationPerformanceTest_ (this),
      VolumetricPerformanceTest_ (this)
    {
    }

    AACMMB89TestType::
    AACMMB89TestType (const AACMMB89TestType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (x, f, c),
      EffectiveDiameterPerformanceTest_ (x.EffectiveDiameterPerformanceTest_, f, this),
      SinglePointArticulationPerformanceTest_ (x.SinglePointArticulationPerformanceTest_, f, this),
      VolumetricPerformanceTest_ (x.VolumetricPerformanceTest_, f, this)
    {
    }

    AACMMB89TestType::
    AACMMB89TestType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      EffectiveDiameterPerformanceTest_ (this),
      SinglePointArticulationPerformanceTest_ (this),
      VolumetricPerformanceTest_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AACMMB89TestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EffectiveDiameterPerformanceTest
        //
        if (n.name () == L"EffectiveDiameterPerformanceTest" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EffectiveDiameterPerformanceTest_type > r (
            EffectiveDiameterPerformanceTest_traits::create (i, f, this));

          if (!this->EffectiveDiameterPerformanceTest_)
          {
            this->EffectiveDiameterPerformanceTest_.set (::std::move (r));
            continue;
          }
        }

        // SinglePointArticulationPerformanceTest
        //
        if (n.name () == L"SinglePointArticulationPerformanceTest" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SinglePointArticulationPerformanceTest_type > r (
            SinglePointArticulationPerformanceTest_traits::create (i, f, this));

          if (!this->SinglePointArticulationPerformanceTest_)
          {
            this->SinglePointArticulationPerformanceTest_.set (::std::move (r));
            continue;
          }
        }

        // VolumetricPerformanceTest
        //
        if (n.name () == L"VolumetricPerformanceTest" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VolumetricPerformanceTest_type > r (
            VolumetricPerformanceTest_traits::create (i, f, this));

          if (!this->VolumetricPerformanceTest_)
          {
            this->VolumetricPerformanceTest_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    AACMMB89TestType* AACMMB89TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AACMMB89TestType (*this, f, c);
    }

    AACMMB89TestType& AACMMB89TestType::
    operator= (const AACMMB89TestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAccuracyTestBaseType& > (*this) = x;
        this->EffectiveDiameterPerformanceTest_ = x.EffectiveDiameterPerformanceTest_;
        this->SinglePointArticulationPerformanceTest_ = x.SinglePointArticulationPerformanceTest_;
        this->VolumetricPerformanceTest_ = x.VolumetricPerformanceTest_;
      }

      return *this;
    }

    AACMMB89TestType::
    ~AACMMB89TestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AACMMB89TestType >
    _xsd_AACMMB89TestType_type_factory_init (
      L"AACMMB89TestType",
      L"http://qifstandards.org/xsd/qif3");

    // EffectiveDiameterPerformanceTestType
    //

    EffectiveDiameterPerformanceTestType::
    EffectiveDiameterPerformanceTestType ()
    : ::xml_schema::type (),
      AverageDiameter_ (this),
      StandardDeviation_ (this)
    {
    }

    EffectiveDiameterPerformanceTestType::
    EffectiveDiameterPerformanceTestType (const AverageDiameter_type& AverageDiameter,
                                          const StandardDeviation_type& StandardDeviation)
    : ::xml_schema::type (),
      AverageDiameter_ (AverageDiameter, this),
      StandardDeviation_ (StandardDeviation, this)
    {
    }

    EffectiveDiameterPerformanceTestType::
    EffectiveDiameterPerformanceTestType (const EffectiveDiameterPerformanceTestType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AverageDiameter_ (x.AverageDiameter_, f, this),
      StandardDeviation_ (x.StandardDeviation_, f, this)
    {
    }

    EffectiveDiameterPerformanceTestType::
    EffectiveDiameterPerformanceTestType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AverageDiameter_ (this),
      StandardDeviation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveDiameterPerformanceTestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AverageDiameter
        //
        if (n.name () == L"AverageDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!AverageDiameter_.present ())
          {
            this->AverageDiameter_.set (AverageDiameter_traits::create (i, f, this));
            continue;
          }
        }

        // StandardDeviation
        //
        if (n.name () == L"StandardDeviation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!StandardDeviation_.present ())
          {
            this->StandardDeviation_.set (StandardDeviation_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!AverageDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AverageDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!StandardDeviation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StandardDeviation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EffectiveDiameterPerformanceTestType* EffectiveDiameterPerformanceTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveDiameterPerformanceTestType (*this, f, c);
    }

    EffectiveDiameterPerformanceTestType& EffectiveDiameterPerformanceTestType::
    operator= (const EffectiveDiameterPerformanceTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AverageDiameter_ = x.AverageDiameter_;
        this->StandardDeviation_ = x.StandardDeviation_;
      }

      return *this;
    }

    EffectiveDiameterPerformanceTestType::
    ~EffectiveDiameterPerformanceTestType ()
    {
    }

    // SinglePointArticulationPerformanceTestType
    //

    SinglePointArticulationPerformanceTestType::
    SinglePointArticulationPerformanceTestType ()
    : ::xml_schema::type (),
      MaxDeviationFromAverageNear_ (this),
      MaxDeviationFromAverageFar_ (this),
      MaxDeviationFromAverageMiddle_ (this),
      TwiceStandardDeviationNear_ (this),
      TwiceStandardDeviationFar_ (this),
      TwiceStandardDeviationMiddle_ (this)
    {
    }

    SinglePointArticulationPerformanceTestType::
    SinglePointArticulationPerformanceTestType (const MaxDeviationFromAverageNear_type& MaxDeviationFromAverageNear,
                                                const MaxDeviationFromAverageFar_type& MaxDeviationFromAverageFar,
                                                const MaxDeviationFromAverageMiddle_type& MaxDeviationFromAverageMiddle,
                                                const TwiceStandardDeviationNear_type& TwiceStandardDeviationNear,
                                                const TwiceStandardDeviationFar_type& TwiceStandardDeviationFar,
                                                const TwiceStandardDeviationMiddle_type& TwiceStandardDeviationMiddle)
    : ::xml_schema::type (),
      MaxDeviationFromAverageNear_ (MaxDeviationFromAverageNear, this),
      MaxDeviationFromAverageFar_ (MaxDeviationFromAverageFar, this),
      MaxDeviationFromAverageMiddle_ (MaxDeviationFromAverageMiddle, this),
      TwiceStandardDeviationNear_ (TwiceStandardDeviationNear, this),
      TwiceStandardDeviationFar_ (TwiceStandardDeviationFar, this),
      TwiceStandardDeviationMiddle_ (TwiceStandardDeviationMiddle, this)
    {
    }

    SinglePointArticulationPerformanceTestType::
    SinglePointArticulationPerformanceTestType (::std::unique_ptr< MaxDeviationFromAverageNear_type > MaxDeviationFromAverageNear,
                                                ::std::unique_ptr< MaxDeviationFromAverageFar_type > MaxDeviationFromAverageFar,
                                                ::std::unique_ptr< MaxDeviationFromAverageMiddle_type > MaxDeviationFromAverageMiddle,
                                                ::std::unique_ptr< TwiceStandardDeviationNear_type > TwiceStandardDeviationNear,
                                                ::std::unique_ptr< TwiceStandardDeviationFar_type > TwiceStandardDeviationFar,
                                                ::std::unique_ptr< TwiceStandardDeviationMiddle_type > TwiceStandardDeviationMiddle)
    : ::xml_schema::type (),
      MaxDeviationFromAverageNear_ (std::move (MaxDeviationFromAverageNear), this),
      MaxDeviationFromAverageFar_ (std::move (MaxDeviationFromAverageFar), this),
      MaxDeviationFromAverageMiddle_ (std::move (MaxDeviationFromAverageMiddle), this),
      TwiceStandardDeviationNear_ (std::move (TwiceStandardDeviationNear), this),
      TwiceStandardDeviationFar_ (std::move (TwiceStandardDeviationFar), this),
      TwiceStandardDeviationMiddle_ (std::move (TwiceStandardDeviationMiddle), this)
    {
    }

    SinglePointArticulationPerformanceTestType::
    SinglePointArticulationPerformanceTestType (const SinglePointArticulationPerformanceTestType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxDeviationFromAverageNear_ (x.MaxDeviationFromAverageNear_, f, this),
      MaxDeviationFromAverageFar_ (x.MaxDeviationFromAverageFar_, f, this),
      MaxDeviationFromAverageMiddle_ (x.MaxDeviationFromAverageMiddle_, f, this),
      TwiceStandardDeviationNear_ (x.TwiceStandardDeviationNear_, f, this),
      TwiceStandardDeviationFar_ (x.TwiceStandardDeviationFar_, f, this),
      TwiceStandardDeviationMiddle_ (x.TwiceStandardDeviationMiddle_, f, this)
    {
    }

    SinglePointArticulationPerformanceTestType::
    SinglePointArticulationPerformanceTestType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxDeviationFromAverageNear_ (this),
      MaxDeviationFromAverageFar_ (this),
      MaxDeviationFromAverageMiddle_ (this),
      TwiceStandardDeviationNear_ (this),
      TwiceStandardDeviationFar_ (this),
      TwiceStandardDeviationMiddle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SinglePointArticulationPerformanceTestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxDeviationFromAverageNear
        //
        if (n.name () == L"MaxDeviationFromAverageNear" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationFromAverageNear_type > r (
            MaxDeviationFromAverageNear_traits::create (i, f, this));

          if (!MaxDeviationFromAverageNear_.present ())
          {
            this->MaxDeviationFromAverageNear_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationFromAverageFar
        //
        if (n.name () == L"MaxDeviationFromAverageFar" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationFromAverageFar_type > r (
            MaxDeviationFromAverageFar_traits::create (i, f, this));

          if (!MaxDeviationFromAverageFar_.present ())
          {
            this->MaxDeviationFromAverageFar_.set (::std::move (r));
            continue;
          }
        }

        // MaxDeviationFromAverageMiddle
        //
        if (n.name () == L"MaxDeviationFromAverageMiddle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxDeviationFromAverageMiddle_type > r (
            MaxDeviationFromAverageMiddle_traits::create (i, f, this));

          if (!MaxDeviationFromAverageMiddle_.present ())
          {
            this->MaxDeviationFromAverageMiddle_.set (::std::move (r));
            continue;
          }
        }

        // TwiceStandardDeviationNear
        //
        if (n.name () == L"TwiceStandardDeviationNear" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TwiceStandardDeviationNear_type > r (
            TwiceStandardDeviationNear_traits::create (i, f, this));

          if (!TwiceStandardDeviationNear_.present ())
          {
            this->TwiceStandardDeviationNear_.set (::std::move (r));
            continue;
          }
        }

        // TwiceStandardDeviationFar
        //
        if (n.name () == L"TwiceStandardDeviationFar" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TwiceStandardDeviationFar_type > r (
            TwiceStandardDeviationFar_traits::create (i, f, this));

          if (!TwiceStandardDeviationFar_.present ())
          {
            this->TwiceStandardDeviationFar_.set (::std::move (r));
            continue;
          }
        }

        // TwiceStandardDeviationMiddle
        //
        if (n.name () == L"TwiceStandardDeviationMiddle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TwiceStandardDeviationMiddle_type > r (
            TwiceStandardDeviationMiddle_traits::create (i, f, this));

          if (!TwiceStandardDeviationMiddle_.present ())
          {
            this->TwiceStandardDeviationMiddle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MaxDeviationFromAverageNear_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxDeviationFromAverageNear",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxDeviationFromAverageFar_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxDeviationFromAverageFar",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MaxDeviationFromAverageMiddle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxDeviationFromAverageMiddle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TwiceStandardDeviationNear_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TwiceStandardDeviationNear",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TwiceStandardDeviationFar_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TwiceStandardDeviationFar",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TwiceStandardDeviationMiddle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TwiceStandardDeviationMiddle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SinglePointArticulationPerformanceTestType* SinglePointArticulationPerformanceTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SinglePointArticulationPerformanceTestType (*this, f, c);
    }

    SinglePointArticulationPerformanceTestType& SinglePointArticulationPerformanceTestType::
    operator= (const SinglePointArticulationPerformanceTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxDeviationFromAverageNear_ = x.MaxDeviationFromAverageNear_;
        this->MaxDeviationFromAverageFar_ = x.MaxDeviationFromAverageFar_;
        this->MaxDeviationFromAverageMiddle_ = x.MaxDeviationFromAverageMiddle_;
        this->TwiceStandardDeviationNear_ = x.TwiceStandardDeviationNear_;
        this->TwiceStandardDeviationFar_ = x.TwiceStandardDeviationFar_;
        this->TwiceStandardDeviationMiddle_ = x.TwiceStandardDeviationMiddle_;
      }

      return *this;
    }

    SinglePointArticulationPerformanceTestType::
    ~SinglePointArticulationPerformanceTestType ()
    {
    }

    // VolumetricPerformanceTestType
    //

    VolumetricPerformanceTestType::
    VolumetricPerformanceTestType ()
    : ::xml_schema::type (),
      DeviationsFromCalibration_ (this),
      TwiceStandardDeviation_ (this)
    {
    }

    VolumetricPerformanceTestType::
    VolumetricPerformanceTestType (const DeviationsFromCalibration_type& DeviationsFromCalibration,
                                   const TwiceStandardDeviation_type& TwiceStandardDeviation)
    : ::xml_schema::type (),
      DeviationsFromCalibration_ (DeviationsFromCalibration, this),
      TwiceStandardDeviation_ (TwiceStandardDeviation, this)
    {
    }

    VolumetricPerformanceTestType::
    VolumetricPerformanceTestType (::std::unique_ptr< DeviationsFromCalibration_type > DeviationsFromCalibration,
                                   ::std::unique_ptr< TwiceStandardDeviation_type > TwiceStandardDeviation)
    : ::xml_schema::type (),
      DeviationsFromCalibration_ (std::move (DeviationsFromCalibration), this),
      TwiceStandardDeviation_ (std::move (TwiceStandardDeviation), this)
    {
    }

    VolumetricPerformanceTestType::
    VolumetricPerformanceTestType (const VolumetricPerformanceTestType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DeviationsFromCalibration_ (x.DeviationsFromCalibration_, f, this),
      TwiceStandardDeviation_ (x.TwiceStandardDeviation_, f, this)
    {
    }

    VolumetricPerformanceTestType::
    VolumetricPerformanceTestType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DeviationsFromCalibration_ (this),
      TwiceStandardDeviation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VolumetricPerformanceTestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeviationsFromCalibration
        //
        if (n.name () == L"DeviationsFromCalibration" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeviationsFromCalibration_type > r (
            DeviationsFromCalibration_traits::create (i, f, this));

          if (!DeviationsFromCalibration_.present ())
          {
            this->DeviationsFromCalibration_.set (::std::move (r));
            continue;
          }
        }

        // TwiceStandardDeviation
        //
        if (n.name () == L"TwiceStandardDeviation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TwiceStandardDeviation_type > r (
            TwiceStandardDeviation_traits::create (i, f, this));

          if (!TwiceStandardDeviation_.present ())
          {
            this->TwiceStandardDeviation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeviationsFromCalibration_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeviationsFromCalibration",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TwiceStandardDeviation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TwiceStandardDeviation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VolumetricPerformanceTestType* VolumetricPerformanceTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VolumetricPerformanceTestType (*this, f, c);
    }

    VolumetricPerformanceTestType& VolumetricPerformanceTestType::
    operator= (const VolumetricPerformanceTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DeviationsFromCalibration_ = x.DeviationsFromCalibration_;
        this->TwiceStandardDeviation_ = x.TwiceStandardDeviation_;
      }

      return *this;
    }

    VolumetricPerformanceTestType::
    ~VolumetricPerformanceTestType ()
    {
    }

    // TwentyLinearValuesType
    //

    TwentyLinearValuesType::
    TwentyLinearValuesType ()
    : ::xml_schema::type (),
      LinearValue_ (this),
      n_ (this)
    {
    }

    TwentyLinearValuesType::
    TwentyLinearValuesType (const n_type& n)
    : ::xml_schema::type (),
      LinearValue_ (this),
      n_ (n, this)
    {
    }

    TwentyLinearValuesType::
    TwentyLinearValuesType (const TwentyLinearValuesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearValue_ (x.LinearValue_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TwentyLinearValuesType::
    TwentyLinearValuesType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearValue_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TwentyLinearValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearValue
        //
        if (n.name () == L"LinearValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearValue_type > r (
            LinearValue_traits::create (i, f, this));

          this->LinearValue_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TwentyLinearValuesType* TwentyLinearValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TwentyLinearValuesType (*this, f, c);
    }

    TwentyLinearValuesType& TwentyLinearValuesType::
    operator= (const TwentyLinearValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearValue_ = x.LinearValue_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TwentyLinearValuesType::
    ~TwentyLinearValuesType ()
    {
    }

    // ISO10360TestType
    //

    ISO10360TestType::
    ISO10360TestType ()
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      MaxErrorConstant_ (this),
      LinearError_ (this),
      LesserError_ (this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const ISO10360TestType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this),
      LesserError_ (x.LesserError_, f, this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (this),
      LinearError_ (this),
      LesserError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ISO10360TestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxErrorConstant
        //
        if (n.name () == L"MaxErrorConstant" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!this->MaxErrorConstant_)
          {
            this->MaxErrorConstant_.set (::std::move (r));
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == L"LinearError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!this->LinearError_)
          {
            this->LinearError_.set (::std::move (r));
            continue;
          }
        }

        // LesserError
        //
        if (n.name () == L"LesserError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LesserError_type > r (
            LesserError_traits::create (i, f, this));

          if (!this->LesserError_)
          {
            this->LesserError_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ISO10360TestType* ISO10360TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ISO10360TestType (*this, f, c);
    }

    ISO10360TestType& ISO10360TestType::
    operator= (const ISO10360TestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAccuracyTestBaseType& > (*this) = x;
        this->MaxErrorConstant_ = x.MaxErrorConstant_;
        this->LinearError_ = x.LinearError_;
        this->LesserError_ = x.LesserError_;
      }

      return *this;
    }

    ISO10360TestType::
    ~ISO10360TestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ISO10360TestType >
    _xsd_ISO10360TestType_type_factory_init (
      L"ISO10360TestType",
      L"http://qifstandards.org/xsd/qif3");

    // LinearErrorType
    //

    LinearErrorType::
    LinearErrorType ()
    : ::xml_schema::type (),
      BaseError_ (this),
      ErrorRate_ (this)
    {
    }

    LinearErrorType::
    LinearErrorType (const BaseError_type& BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    LinearErrorType::
    LinearErrorType (::std::unique_ptr< BaseError_type > BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (std::move (BaseError), this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    LinearErrorType::
    LinearErrorType (const LinearErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseError_ (x.BaseError_, f, this),
      ErrorRate_ (x.ErrorRate_, f, this)
    {
    }

    LinearErrorType::
    LinearErrorType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseError_ (this),
      ErrorRate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearErrorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseError
        //
        if (n.name () == L"BaseError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseError_type > r (
            BaseError_traits::create (i, f, this));

          if (!BaseError_.present ())
          {
            this->BaseError_.set (::std::move (r));
            continue;
          }
        }

        // ErrorRate
        //
        if (n.name () == L"ErrorRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!ErrorRate_.present ())
          {
            this->ErrorRate_.set (ErrorRate_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!BaseError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseError",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ErrorRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ErrorRate",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearErrorType* LinearErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearErrorType (*this, f, c);
    }

    LinearErrorType& LinearErrorType::
    operator= (const LinearErrorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BaseError_ = x.BaseError_;
        this->ErrorRate_ = x.ErrorRate_;
      }

      return *this;
    }

    LinearErrorType::
    ~LinearErrorType ()
    {
    }

    // LesserErrorType
    //

    LesserErrorType::
    LesserErrorType ()
    : ::xml_schema::type (),
      MaxErrorConstant_ (this),
      LinearError_ (this)
    {
    }

    LesserErrorType::
    LesserErrorType (const MaxErrorConstant_type& MaxErrorConstant,
                     const LinearError_type& LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (MaxErrorConstant, this),
      LinearError_ (LinearError, this)
    {
    }

    LesserErrorType::
    LesserErrorType (::std::unique_ptr< MaxErrorConstant_type > MaxErrorConstant,
                     ::std::unique_ptr< LinearError_type > LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (std::move (MaxErrorConstant), this),
      LinearError_ (std::move (LinearError), this)
    {
    }

    LesserErrorType::
    LesserErrorType (const LesserErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this)
    {
    }

    LesserErrorType::
    LesserErrorType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (this),
      LinearError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LesserErrorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MaxErrorConstant
        //
        if (n.name () == L"MaxErrorConstant" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!MaxErrorConstant_.present ())
          {
            this->MaxErrorConstant_.set (::std::move (r));
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == L"LinearError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!LinearError_.present ())
          {
            this->LinearError_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MaxErrorConstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MaxErrorConstant",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LinearError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LinearError",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LesserErrorType* LesserErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LesserErrorType (*this, f, c);
    }

    LesserErrorType& LesserErrorType::
    operator= (const LesserErrorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxErrorConstant_ = x.MaxErrorConstant_;
        this->LinearError_ = x.LinearError_;
      }

      return *this;
    }

    LesserErrorType::
    ~LesserErrorType ()
    {
    }

    // PointAccuracyTestType
    //

    PointAccuracyTestType::
    PointAccuracyTestType ()
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      Accuracy_ (this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const Accuracy_type& Accuracy)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      Accuracy_ (Accuracy, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (::std::unique_ptr< Accuracy_type > Accuracy)
    : ::xsd::qif30::CMMAccuracyTestBaseType (),
      Accuracy_ (std::move (Accuracy), this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const PointAccuracyTestType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (x, f, c),
      Accuracy_ (x.Accuracy_, f, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      Accuracy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointAccuracyTestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Accuracy
        //
        if (n.name () == L"Accuracy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!Accuracy_.present ())
          {
            this->Accuracy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Accuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Accuracy",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointAccuracyTestType* PointAccuracyTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointAccuracyTestType (*this, f, c);
    }

    PointAccuracyTestType& PointAccuracyTestType::
    operator= (const PointAccuracyTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CMMAccuracyTestBaseType& > (*this) = x;
        this->Accuracy_ = x.Accuracy_;
      }

      return *this;
    }

    PointAccuracyTestType::
    ~PointAccuracyTestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointAccuracyTestType >
    _xsd_PointAccuracyTestType_type_factory_init (
      L"PointAccuracyTestType",
      L"http://qifstandards.org/xsd/qif3");

    // AngularErrorType
    //

    AngularErrorType::
    AngularErrorType ()
    : ::xml_schema::type (),
      BaseError_ (this),
      ErrorRate_ (this)
    {
    }

    AngularErrorType::
    AngularErrorType (const BaseError_type& BaseError,
                      const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    AngularErrorType::
    AngularErrorType (::std::unique_ptr< BaseError_type > BaseError,
                      const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (std::move (BaseError), this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    AngularErrorType::
    AngularErrorType (const AngularErrorType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseError_ (x.BaseError_, f, this),
      ErrorRate_ (x.ErrorRate_, f, this)
    {
    }

    AngularErrorType::
    AngularErrorType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseError_ (this),
      ErrorRate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularErrorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseError
        //
        if (n.name () == L"BaseError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseError_type > r (
            BaseError_traits::create (i, f, this));

          if (!BaseError_.present ())
          {
            this->BaseError_.set (::std::move (r));
            continue;
          }
        }

        // ErrorRate
        //
        if (n.name () == L"ErrorRate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!ErrorRate_.present ())
          {
            this->ErrorRate_.set (ErrorRate_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!BaseError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseError",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ErrorRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ErrorRate",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AngularErrorType* AngularErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularErrorType (*this, f, c);
    }

    AngularErrorType& AngularErrorType::
    operator= (const AngularErrorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BaseError_ = x.BaseError_;
        this->ErrorRate_ = x.ErrorRate_;
      }

      return *this;
    }

    AngularErrorType::
    ~AngularErrorType ()
    {
    }

    // RotaryTableType
    //

    RotaryTableType::
    RotaryTableType ()
    : ::xml_schema::type (),
      LocationOnCMM_ (this),
      AxisDirection_ (this),
      ZeroIndexDirection_ (this),
      TableRadius_ (this),
      TableErrors_ (this)
    {
    }

    RotaryTableType::
    RotaryTableType (const LocationOnCMM_type& LocationOnCMM,
                     const AxisDirection_type& AxisDirection,
                     const ZeroIndexDirection_type& ZeroIndexDirection,
                     const TableRadius_type& TableRadius,
                     const TableErrors_type& TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (LocationOnCMM, this),
      AxisDirection_ (AxisDirection, this),
      ZeroIndexDirection_ (ZeroIndexDirection, this),
      TableRadius_ (TableRadius, this),
      TableErrors_ (TableErrors, this)
    {
    }

    RotaryTableType::
    RotaryTableType (::std::unique_ptr< LocationOnCMM_type > LocationOnCMM,
                     ::std::unique_ptr< AxisDirection_type > AxisDirection,
                     ::std::unique_ptr< ZeroIndexDirection_type > ZeroIndexDirection,
                     ::std::unique_ptr< TableRadius_type > TableRadius,
                     ::std::unique_ptr< TableErrors_type > TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (std::move (LocationOnCMM), this),
      AxisDirection_ (std::move (AxisDirection), this),
      ZeroIndexDirection_ (std::move (ZeroIndexDirection), this),
      TableRadius_ (std::move (TableRadius), this),
      TableErrors_ (std::move (TableErrors), this)
    {
    }

    RotaryTableType::
    RotaryTableType (const RotaryTableType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocationOnCMM_ (x.LocationOnCMM_, f, this),
      AxisDirection_ (x.AxisDirection_, f, this),
      ZeroIndexDirection_ (x.ZeroIndexDirection_, f, this),
      TableRadius_ (x.TableRadius_, f, this),
      TableErrors_ (x.TableErrors_, f, this)
    {
    }

    RotaryTableType::
    RotaryTableType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocationOnCMM_ (this),
      AxisDirection_ (this),
      ZeroIndexDirection_ (this),
      TableRadius_ (this),
      TableErrors_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RotaryTableType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LocationOnCMM
        //
        if (n.name () == L"LocationOnCMM" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocationOnCMM_type > r (
            LocationOnCMM_traits::create (i, f, this));

          if (!LocationOnCMM_.present ())
          {
            this->LocationOnCMM_.set (::std::move (r));
            continue;
          }
        }

        // AxisDirection
        //
        if (n.name () == L"AxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisDirection_type > r (
            AxisDirection_traits::create (i, f, this));

          if (!AxisDirection_.present ())
          {
            this->AxisDirection_.set (::std::move (r));
            continue;
          }
        }

        // ZeroIndexDirection
        //
        if (n.name () == L"ZeroIndexDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZeroIndexDirection_type > r (
            ZeroIndexDirection_traits::create (i, f, this));

          if (!ZeroIndexDirection_.present ())
          {
            this->ZeroIndexDirection_.set (::std::move (r));
            continue;
          }
        }

        // TableRadius
        //
        if (n.name () == L"TableRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TableRadius_type > r (
            TableRadius_traits::create (i, f, this));

          if (!TableRadius_.present ())
          {
            this->TableRadius_.set (::std::move (r));
            continue;
          }
        }

        // TableErrors
        //
        if (n.name () == L"TableErrors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TableErrors_type > r (
            TableErrors_traits::create (i, f, this));

          if (!TableErrors_.present ())
          {
            this->TableErrors_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LocationOnCMM_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LocationOnCMM",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZeroIndexDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZeroIndexDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TableRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TableRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TableErrors_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TableErrors",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RotaryTableType* RotaryTableType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RotaryTableType (*this, f, c);
    }

    RotaryTableType& RotaryTableType::
    operator= (const RotaryTableType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LocationOnCMM_ = x.LocationOnCMM_;
        this->AxisDirection_ = x.AxisDirection_;
        this->ZeroIndexDirection_ = x.ZeroIndexDirection_;
        this->TableRadius_ = x.TableRadius_;
        this->TableErrors_ = x.TableErrors_;
      }

      return *this;
    }

    RotaryTableType::
    ~RotaryTableType ()
    {
    }

    // TableErrorsType
    //

    TableErrorsType::
    TableErrorsType ()
    : ::xml_schema::type (),
      AxialError_ (this),
      RadialError_ (this),
      TangentialError_ (this)
    {
    }

    TableErrorsType::
    TableErrorsType (const AxialError_type& AxialError,
                     const RadialError_type& RadialError,
                     const TangentialError_type& TangentialError)
    : ::xml_schema::type (),
      AxialError_ (AxialError, this),
      RadialError_ (RadialError, this),
      TangentialError_ (TangentialError, this)
    {
    }

    TableErrorsType::
    TableErrorsType (::std::unique_ptr< AxialError_type > AxialError,
                     ::std::unique_ptr< RadialError_type > RadialError,
                     ::std::unique_ptr< TangentialError_type > TangentialError)
    : ::xml_schema::type (),
      AxialError_ (std::move (AxialError), this),
      RadialError_ (std::move (RadialError), this),
      TangentialError_ (std::move (TangentialError), this)
    {
    }

    TableErrorsType::
    TableErrorsType (const TableErrorsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxialError_ (x.AxialError_, f, this),
      RadialError_ (x.RadialError_, f, this),
      TangentialError_ (x.TangentialError_, f, this)
    {
    }

    TableErrorsType::
    TableErrorsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxialError_ (this),
      RadialError_ (this),
      TangentialError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TableErrorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AxialError
        //
        if (n.name () == L"AxialError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxialError_type > r (
            AxialError_traits::create (i, f, this));

          if (!AxialError_.present ())
          {
            this->AxialError_.set (::std::move (r));
            continue;
          }
        }

        // RadialError
        //
        if (n.name () == L"RadialError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadialError_type > r (
            RadialError_traits::create (i, f, this));

          if (!RadialError_.present ())
          {
            this->RadialError_.set (::std::move (r));
            continue;
          }
        }

        // TangentialError
        //
        if (n.name () == L"TangentialError" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentialError_type > r (
            TangentialError_traits::create (i, f, this));

          if (!TangentialError_.present ())
          {
            this->TangentialError_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AxialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxialError",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RadialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RadialError",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TangentialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TangentialError",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TableErrorsType* TableErrorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TableErrorsType (*this, f, c);
    }

    TableErrorsType& TableErrorsType::
    operator= (const TableErrorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AxialError_ = x.AxialError_;
        this->RadialError_ = x.RadialError_;
        this->TangentialError_ = x.TangentialError_;
      }

      return *this;
    }

    TableErrorsType::
    ~TableErrorsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Caliper_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Caliper",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CaliperType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CaliperDial_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CaliperDial",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CaliperDialType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CaliperDigital_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CaliperDigital",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CaliperDigitalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Micrometer_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Micrometer",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MicrometerType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MicrometerAnalog_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"MicrometerAnalog",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MicrometerAnalogType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MicrometerDigital_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"MicrometerDigital",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MicrometerDigitalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GageDevice_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"GageDevice",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GageDeviceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SineBar_element_factory_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"SineBar",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SineBarType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CMM_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ManualMeasurementDevice_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ManualMeasurementDeviceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Microscope_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Microscope",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MicroscopeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Autocollimator_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Autocollimator",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AutocollimatorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OpticalComparator_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"OpticalComparator",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OpticalComparatorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UniversalLengthMeasuring_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"UniversalLengthMeasuring",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UniversalLengthMeasuringType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LaserRadar_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserRadar",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LaserRadarType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LaserTracker_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserTracker",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LaserTrackerType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ComputedTomography_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"ComputedTomography",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ComputedTomographyType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Theodolite_element_factory_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Theodolite",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TheodoliteType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AACMM_element_factory_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AACMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMM_element_factory_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianCMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MultipleCarriageCartesianCMM_element_factory_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"MultipleCarriageCartesianCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MultipleCarriageCartesianCMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ParallelLinkCMM_element_factory_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelLinkCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ParallelLinkCMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LightPenCMM_element_factory_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"LightPenCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LightPenCMMType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMFPSTest_element_factory_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMFPSTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FPSTestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMB89Test_element_factory_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMB89Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianCMMB89TestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMISO10360Test_element_factory_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMISO10360Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ISO10360TestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMPointAccuracyTest_element_factory_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMPointAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointAccuracyTestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AACMMB89Test_element_factory_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMB89Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AACMMB89TestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AACMMISO10360Test_element_factory_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMISO10360Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ISO10360TestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AACMMPointAccuracyTest_element_factory_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMPointAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointAccuracyTestType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DetachableTactileProbeSensor_element_factory_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SimpleTactileProbeSensor_element_factory_init (
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SimpleTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ComplexTactileProbeSensor_element_factory_init (
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ComplexTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ComplexTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DetachableCapacitiveSensor_element_factory_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableCapacitiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CapacitiveSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DetachableLVDTSensor_element_factory_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableLVDTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearVariableDifferentialTransformerSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ClosedShellSetWorkingVolume_element_factory_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"ClosedShellSetWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ClosedShellSetWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianWorkingVolume_element_factory_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalWorkingVolume_element_factory_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricalWorkingVolume_element_factory_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedWorkingVolume_element_factory_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveClosedShellSetWorkingVolume_element_factory_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveClosedShellSetWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EffectiveClosedShellSetWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveCartesianWorkingVolume_element_factory_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveCartesianWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EffectiveCartesianWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveSphericalWorkingVolume_element_factory_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveSphericalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EffectiveSphericalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveCylindricalWorkingVolume_element_factory_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveCylindricalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EffectiveCylindricalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EffectiveUserDefinedWorkingVolume_element_factory_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveUserDefinedWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EffectiveUserDefinedWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearResolution_element_factory_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearResolutionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianResolution_element_factory_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianResolutionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalResolution_element_factory_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalResolutionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UserDefinedResolution_element_factory_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UserDefinedResolutionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMSpeeds_element_factory_init (
      L"CMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianCMMSpeedsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ParallelLinkCMMSpeeds_element_factory_init (
      L"CMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelLinkCMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ParallelLinkCMMSpeedsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RotaryAxis_element_factory_init (
      L"Axis",
      L"http://qifstandards.org/xsd/qif3",
      L"RotaryAxis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::RotaryAxisType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearAxis_element_factory_init (
      L"Axis",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearAxis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearAxisType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianMeasurementDeviceScales_element_factory_init (
      L"Scales",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianMeasurementDeviceScales",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianMeasurementDeviceScalesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CartesianCMMAxisDirections_element_factory_init (
      L"CMMAxisDirections",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMAxisDirections",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CartesianCMMAxisDirectionsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithIntegratedSensor_element_factory_init (
      L"Tool",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithLVDTSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithLVDTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithLVDTSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithCapacitiveSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithCapacitiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithCapacitiveSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithEddyCurrentSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithEddyCurrentSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithEddyCurrentSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithConfocalChromaticSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithConfocalChromaticSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithConfocalChromaticSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithDrawWireSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDrawWireSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithDrawWireSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithMagnetoInductiveSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithMagnetoInductiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithMagnetoInductiveSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithDVRTSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDVRTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithDVRTSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithLaserTriangulationSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithLaserTriangulationSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithLaserTriangulationSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithStructuredLightSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithStructuredLightSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithStructuredLightSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithUltrasonicSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithUltrasonicSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithUltrasonicSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithSimpleTactileProbeSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithSimpleTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithSimpleTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithComplexTactileProbeSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithComplexTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithComplexTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithCCDCameraSensor_element_factory_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithCCDCameraSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithCCDCameraSensorType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToolWithDetachableSensors_element_factory_init (
      L"Tool",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDetachableSensors",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToolWithDetachableSensorsType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const MeasurementResourcesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Fixtures
      //
      if (i.Fixtures ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Fixtures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Fixtures ();
      }

      // MeasurementRooms
      //
      if (i.MeasurementRooms ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementRooms",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementRooms ();
      }

      // MeasurementDevices
      //
      if (i.MeasurementDevices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDevices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDevices ();
      }

      // DetachableSensors
      //
      if (i.DetachableSensors ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DetachableSensors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DetachableSensors ();
      }

      // Tools
      //
      if (i.Tools ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Tools",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Tools ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementResourceBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // Manufacturer
      //
      if (i.Manufacturer ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Manufacturer",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Manufacturer ();
      }

      // ModelNumber
      //
      if (i.ModelNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ModelNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ModelNumber ();
      }

      // SerialNumber
      //
      if (i.SerialNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SerialNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SerialNumber ();
      }

      // Mass
      //
      if (i.Mass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Mass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Mass ();
      }

      // Size
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Size ())
        {
          const MeasurementResourceBaseType::Size_type& x (*i.Size ());
          if (typeid (MeasurementResourceBaseType::Size_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Size",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Size",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // LocationId
      //
      if (i.LocationId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocationId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LocationId ();
      }

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CarriageType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CarriagesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Carriage
      //
      for (CarriagesType::Carriage_const_iterator
           b (i.Carriage ().begin ()), n (i.Carriage ().end ());
           b != n; ++b)
      {
        const CarriagesType::Carriage_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Carriage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FixturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Fixture
      //
      for (FixturesType::Fixture_const_iterator
           b (i.Fixture ().begin ()), n (i.Fixture ().end ());
           b != n; ++b)
      {
        const FixturesType::Fixture_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Fixture",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementRoomType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // TemperatureRangeMin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureRangeMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TemperatureRangeMin ();
      }

      // TemperatureRangeMax
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureRangeMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TemperatureRangeMax ();
      }

      // TemperatureControlMin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureControlMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TemperatureControlMin ();
      }

      // TemperatureControlMax
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureControlMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TemperatureControlMax ();
      }

      // RelativeHumidityRangeMin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeHumidityRangeMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RelativeHumidityRangeMin ();
      }

      // RelativeHumidityRangeMax
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeHumidityRangeMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RelativeHumidityRangeMax ();
      }

      // RelativeHumidityControlMin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeHumidityControlMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RelativeHumidityControlMin ();
      }

      // RelativeHumidityControlMax
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeHumidityControlMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RelativeHumidityControlMax ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementRoomsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurementRoom
      //
      for (MeasurementRoomsType::MeasurementRoom_const_iterator
           b (i.MeasurementRoom ().begin ()), n (i.MeasurementRoom ().end ());
           b != n; ++b)
      {
        const MeasurementRoomsType::MeasurementRoom_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementRoom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FixtureType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SensorType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // ProtectionClass
      //
      if (i.ProtectionClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProtectionClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ProtectionClass ();
      }

      // LinearityError
      //
      if (i.LinearityError ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearityError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearityError ();
      }

      // Repeatability
      //
      if (i.Repeatability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Repeatability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Repeatability ();
      }

      // Sensitivity
      //
      if (i.Sensitivity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sensitivity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Sensitivity ());
      }

      // Resolution
      //
      if (i.Resolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Resolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Resolution ();
      }

      // EnvironmentalRange
      //
      if (i.EnvironmentalRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EnvironmentalRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EnvironmentalRange ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LaserType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // LaserSource
      //
      if (i.LaserSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserSource ();
      }

      // LaserWaveLength
      //
      if (i.LaserWaveLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserWaveLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserWaveLength ();
      }

      // LaserPower
      //
      if (i.LaserPower ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserPower",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserPower ();
      }

      // LaserSafetyClass
      //
      if (i.LaserSafetyClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserSafetyClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserSafetyClass ();
      }

      // LaserEffectiveLength
      //
      if (i.LaserEffectiveLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserEffectiveLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserEffectiveLength ();
      }

      // LaserSpotSize
      //
      if (i.LaserSpotSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserSpotSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserSpotSize ();
      }

      // LaserPowerSupply
      //
      if (i.LaserPowerSupply ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserPowerSupply",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserPowerSupply ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DetachableSensorBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DetachableSensorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DetachableSensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (DetachableSensorsType::DetachableSensor_const_iterator
             b (i.DetachableSensor ().begin ()), n (i.DetachableSensor ().end ());
             b != n; ++b)
        {
          const DetachableSensorsType::DetachableSensor_type& x (*b);

          if (typeid (DetachableSensorsType::DetachableSensor_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"DetachableSensor",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"DetachableSensor",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToolsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Tool
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ToolsType::Tool_const_iterator
             b (i.Tool ().begin ()), n (i.Tool ().end ());
             b != n; ++b)
        {
          const ToolsType::Tool_type& x (*b);

          if (typeid (ToolsType::Tool_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Tool",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Tool",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToolBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ToolWithIntegratedSensorBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ToolWithLVDTSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // LVDTSensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ToolWithLVDTSensorType::LVDTSensor_type& x (i.LVDTSensor ());
        if (typeid (ToolWithLVDTSensorType::LVDTSensor_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"LVDTSensor",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"LVDTSensor",
            L"http://qifstandards.org/xsd/qif3",
            false, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithLVDTSensorType >
    _xsd_ToolWithLVDTSensorType_type_serializer_init (
      L"ToolWithLVDTSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithCapacitiveSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // CapacitiveSensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ToolWithCapacitiveSensorType::CapacitiveSensor_type& x (i.CapacitiveSensor ());
        if (typeid (ToolWithCapacitiveSensorType::CapacitiveSensor_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CapacitiveSensor",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"CapacitiveSensor",
            L"http://qifstandards.org/xsd/qif3",
            false, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithCapacitiveSensorType >
    _xsd_ToolWithCapacitiveSensorType_type_serializer_init (
      L"ToolWithCapacitiveSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithEddyCurrentSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // EddyCurrentSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EddyCurrentSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EddyCurrentSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithEddyCurrentSensorType >
    _xsd_ToolWithEddyCurrentSensorType_type_serializer_init (
      L"ToolWithEddyCurrentSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithConfocalChromaticSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // ConfocalChromaticSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ConfocalChromaticSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ConfocalChromaticSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithConfocalChromaticSensorType >
    _xsd_ToolWithConfocalChromaticSensorType_type_serializer_init (
      L"ToolWithConfocalChromaticSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithDrawWireSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // DrawWireSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DrawWireSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DrawWireSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithDrawWireSensorType >
    _xsd_ToolWithDrawWireSensorType_type_serializer_init (
      L"ToolWithDrawWireSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithMagnetoInductiveSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // MagnetoInductiveSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MagnetoInductiveSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MagnetoInductiveSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithMagnetoInductiveSensorType >
    _xsd_ToolWithMagnetoInductiveSensorType_type_serializer_init (
      L"ToolWithMagnetoInductiveSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithDVRTSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // DVRTSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DVRTSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DVRTSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithDVRTSensorType >
    _xsd_ToolWithDVRTSensorType_type_serializer_init (
      L"ToolWithDVRTSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithLaserTriangulationSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // LaserTriangulationSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserTriangulationSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LaserTriangulationSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithLaserTriangulationSensorType >
    _xsd_ToolWithLaserTriangulationSensorType_type_serializer_init (
      L"ToolWithLaserTriangulationSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithStructuredLightSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // StructuredLightSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StructuredLightSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StructuredLightSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithStructuredLightSensorType >
    _xsd_ToolWithStructuredLightSensorType_type_serializer_init (
      L"ToolWithStructuredLightSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithUltrasonicSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // UltrasonicSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UltrasonicSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UltrasonicSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithUltrasonicSensorType >
    _xsd_ToolWithUltrasonicSensorType_type_serializer_init (
      L"ToolWithUltrasonicSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithSimpleTactileProbeSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // SimpleTactileProbeSensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ToolWithSimpleTactileProbeSensorType::SimpleTactileProbeSensor_type& x (i.SimpleTactileProbeSensor ());
        if (typeid (ToolWithSimpleTactileProbeSensorType::SimpleTactileProbeSensor_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SimpleTactileProbeSensor",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"SimpleTactileProbeSensor",
            L"http://qifstandards.org/xsd/qif3",
            false, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithSimpleTactileProbeSensorType >
    _xsd_ToolWithSimpleTactileProbeSensorType_type_serializer_init (
      L"ToolWithSimpleTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithComplexTactileProbeSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // ComplexTactileProbeSensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ToolWithComplexTactileProbeSensorType::ComplexTactileProbeSensor_type& x (i.ComplexTactileProbeSensor ());
        if (typeid (ToolWithComplexTactileProbeSensorType::ComplexTactileProbeSensor_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ComplexTactileProbeSensor",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ComplexTactileProbeSensor",
            L"http://qifstandards.org/xsd/qif3",
            false, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithComplexTactileProbeSensorType >
    _xsd_ToolWithComplexTactileProbeSensorType_type_serializer_init (
      L"ToolWithComplexTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithCCDCameraSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolWithIntegratedSensorBaseType& > (i);

      // ChargeCoupledDeviceCameraSensor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ChargeCoupledDeviceCameraSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ChargeCoupledDeviceCameraSensor ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithCCDCameraSensorType >
    _xsd_ToolWithCCDCameraSensorType_type_serializer_init (
      L"ToolWithCCDCameraSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToolWithDetachableSensorsType& i)
    {
      e << static_cast< const ::xsd::qif30::ToolBaseType& > (i);

      // SensorIds
      //
      if (i.SensorIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SensorIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SensorIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToolWithDetachableSensorsType >
    _xsd_ToolWithDetachableSensorsType_type_serializer_init (
      L"ToolWithDetachableSensorsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasurementDevicesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurementDevice
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (MeasurementDevicesType::MeasurementDevice_const_iterator
             b (i.MeasurementDevice ().begin ()), n (i.MeasurementDevice ().end ());
             b != n; ++b)
        {
          const MeasurementDevicesType::MeasurementDevice_type& x (*b);

          if (typeid (MeasurementDevicesType::MeasurementDevice_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"MeasurementDevice",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"MeasurementDevice",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementDeviceType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // Calibrations
      //
      if (i.Calibrations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Calibrations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Calibrations ();
      }

      // EnvironmentalRange
      //
      if (i.EnvironmentalRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EnvironmentalRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EnvironmentalRange ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasurementDeviceType >
    _xsd_MeasurementDeviceType_type_serializer_init (
      L"MeasurementDeviceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ManualMeasurementDeviceType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ManualMeasurementDeviceType >
    _xsd_ManualMeasurementDeviceType_type_serializer_init (
      L"ManualMeasurementDeviceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UniversalDeviceType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceType& > (i);

      // Resolution
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Resolution ())
        {
          const UniversalDeviceType::Resolution_type& x (*i.Resolution ());
          if (typeid (UniversalDeviceType::Resolution_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Resolution",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Resolution",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // WorkingVolume
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.WorkingVolume ())
        {
          const UniversalDeviceType::WorkingVolume_type& x (*i.WorkingVolume ());
          if (typeid (UniversalDeviceType::WorkingVolume_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"WorkingVolume",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"WorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // EffectiveWorkingVolume
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EffectiveWorkingVolume ())
        {
          const UniversalDeviceType::EffectiveWorkingVolume_type& x (*i.EffectiveWorkingVolume ());
          if (typeid (UniversalDeviceType::EffectiveWorkingVolume_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EffectiveWorkingVolume",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EffectiveWorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // TemperatureCompensation
      //
      if (i.TemperatureCompensation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureCompensation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureCompensation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UniversalDeviceType >
    _xsd_UniversalDeviceType_type_serializer_init (
      L"UniversalDeviceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TemperatureCompensationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TemperatureCompensationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TemperatureCompensationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperatureCompensationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TemperatureCompensationEnum
      //
      if (i.TemperatureCompensationEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureCompensationEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureCompensationEnum ();
      }

      // OtherTemperatureCompensation
      //
      if (i.OtherTemperatureCompensation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherTemperatureCompensation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherTemperatureCompensation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WorkingVolumeBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const WorkingVolumeBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const WorkingVolumeBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const ClosedShellSetWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkingVolumeBaseType& > (i);

      // WorkingClosedShellSet
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkingClosedShellSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.WorkingClosedShellSet ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ClosedShellSetWorkingVolumeType >
    _xsd_ClosedShellSetWorkingVolumeType_type_serializer_init (
      L"ClosedShellSetWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ClosedShellSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSet
      //
      if (i.PointSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSet ();
      }

      // Curve12Set
      //
      if (i.Curve12Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve12Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Curve12Set ();
      }

      // Curve13Set
      //
      if (i.Curve13Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve13Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Curve13Set ();
      }

      // SurfaceSet
      //
      if (i.SurfaceSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceSet ();
      }

      // CurveMeshSet
      //
      if (i.CurveMeshSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveMeshSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CurveMeshSet ();
      }

      // SurfaceMeshSet
      //
      if (i.SurfaceMeshSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceMeshSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceMeshSet ();
      }

      // VertexSet
      //
      if (i.VertexSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VertexSet ();
      }

      // EdgeSet
      //
      if (i.EdgeSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgeSet ();
      }

      // LoopSet
      //
      if (i.LoopSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LoopSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LoopSet ();
      }

      // FaceSet
      //
      if (i.FaceSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FaceSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FaceSet ();
      }

      // ShellSet
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShellSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ShellSet ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkingVolumeBaseType& > (i);

      // XAxisLength
      //
      if (i.XAxisLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.XAxisLength ();
      }

      // YAxisLength
      //
      if (i.YAxisLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.YAxisLength ();
      }

      // ZAxisLength
      //
      if (i.ZAxisLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZAxisLength ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianWorkingVolumeType >
    _xsd_CartesianWorkingVolumeType_type_serializer_init (
      L"CartesianWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkingVolumeBaseType& > (i);

      // RadialAxisLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadialAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RadialAxisLength ();
      }

      // MinAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinAzimuthalAxisAngle ();
      }

      // MaxAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxAzimuthalAxisAngle ();
      }

      // MinPolarAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPolarAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinPolarAxisAngle ();
      }

      // MaxPolarAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPolarAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxPolarAxisAngle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalWorkingVolumeType >
    _xsd_SphericalWorkingVolumeType_type_serializer_init (
      L"SphericalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkingVolumeBaseType& > (i);

      // RadialAxisLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadialAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RadialAxisLength ();
      }

      // MinAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinAzimuthalAxisAngle ();
      }

      // MaxAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxAzimuthalAxisAngle ();
      }

      // ZAxisLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisLength ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricalWorkingVolumeType >
    _xsd_CylindricalWorkingVolumeType_type_serializer_init (
      L"CylindricalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDefinedWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkingVolumeBaseType& > (i);

      // FirstAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstAxis ();
      }

      // SecondAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondAxis ();
      }

      // ThirdAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThirdAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThirdAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedWorkingVolumeType >
    _xsd_UserDefinedWorkingVolumeType_type_serializer_init (
      L"UserDefinedWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LinearOrRotaryAxisType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Axis
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const LinearOrRotaryAxisType::Axis_type& x (i.Axis ());
        if (typeid (LinearOrRotaryAxisType::Axis_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Axis",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UserDefinedAxisType& i)
    {
      e << static_cast< const ::xsd::qif30::LinearOrRotaryAxisType& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // AxisName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EffectiveWorkingVolumeBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const EffectiveWorkingVolumeBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const EffectiveWorkingVolumeBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const EffectiveCylindricalWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (i);

      // MinRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinRadius ();
      }

      // MaxRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxRadius ();
      }

      // MinAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinAzimuthalAxisAngle ();
      }

      // MaxAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxAzimuthalAxisAngle ();
      }

      // MinZAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinZAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinZAxis ();
      }

      // MaxZAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxZAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EffectiveCylindricalWorkingVolumeType >
    _xsd_EffectiveCylindricalWorkingVolumeType_type_serializer_init (
      L"EffectiveCylindricalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EffectiveSphericalWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (i);

      // MinRadialAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinRadialAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinRadialAxis ();
      }

      // MaxRadialAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxRadialAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxRadialAxis ();
      }

      // MinAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinAzimuthalAxisAngle ();
      }

      // MaxAzimuthalAxisAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAzimuthalAxisAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxAzimuthalAxisAngle ();
      }

      // MinPolarAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPolarAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinPolarAxis ();
      }

      // MaxPolarAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPolarAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxPolarAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EffectiveSphericalWorkingVolumeType >
    _xsd_EffectiveSphericalWorkingVolumeType_type_serializer_init (
      L"EffectiveSphericalWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EffectiveCartesianWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (i);

      // MinPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinPoint ();
      }

      // MaxPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxPoint ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EffectiveCartesianWorkingVolumeType >
    _xsd_EffectiveCartesianWorkingVolumeType_type_serializer_init (
      L"EffectiveCartesianWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EffectiveClosedShellSetWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (i);

      // WorkingClosedShellSet
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkingClosedShellSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.WorkingClosedShellSet ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EffectiveClosedShellSetWorkingVolumeType >
    _xsd_EffectiveClosedShellSetWorkingVolumeType_type_serializer_init (
      L"EffectiveClosedShellSetWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EffectiveUserDefinedWorkingVolumeType& i)
    {
      e << static_cast< const ::xsd::qif30::EffectiveWorkingVolumeBaseType& > (i);

      // UserDefinedWorkingVolumeId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedWorkingVolumeId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UserDefinedWorkingVolumeId ();
      }

      // MinFirstAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinFirstAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinFirstAxis ();
      }

      // MaxFirstAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFirstAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxFirstAxis ();
      }

      // MinSecondAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinSecondAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinSecondAxis ();
      }

      // MaxSecondAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxSecondAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxSecondAxis ();
      }

      // MinThirdAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinThirdAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinThirdAxis ();
      }

      // MaxThirdAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxThirdAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxThirdAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EffectiveUserDefinedWorkingVolumeType >
    _xsd_EffectiveUserDefinedWorkingVolumeType_type_serializer_init (
      L"EffectiveUserDefinedWorkingVolumeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserAxisBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const UserAxisBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const UserAxisBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearAxisType& i)
    {
      e << static_cast< const ::xsd::qif30::UserAxisBaseType& > (i);

      // MinLinearAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinLinearAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinLinearAxis ();
      }

      // MaxLinearAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxLinearAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxLinearAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearAxisType >
    _xsd_LinearAxisType_type_serializer_init (
      L"LinearAxisType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const RotaryAxisType& i)
    {
      e << static_cast< const ::xsd::qif30::UserAxisBaseType& > (i);

      // MinRotaryAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinRotaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinRotaryAxis ();
      }

      // MaxRotaryAxis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxRotaryAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxRotaryAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RotaryAxisType >
    _xsd_RotaryAxisType_type_serializer_init (
      L"RotaryAxisType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ResolutionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const ResolutionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const ResolutionBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearResolutionType& i)
    {
      e << static_cast< const ::xsd::qif30::ResolutionBaseType& > (i);

      // LinearValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LinearValue ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearResolutionType >
    _xsd_LinearResolutionType_type_serializer_init (
      L"LinearResolutionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CartesianResolutionType& i)
    {
      e << static_cast< const ::xsd::qif30::ResolutionBaseType& > (i);

      // CombinedCartesianResolution
      //
      if (i.CombinedCartesianResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedCartesianResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CombinedCartesianResolution ();
      }

      // XYZResolution
      //
      if (i.XYZResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XYZResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.XYZResolution ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianResolutionType >
    _xsd_CartesianResolutionType_type_serializer_init (
      L"CartesianResolutionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const XYZResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XResolution ();
      }

      // YResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YResolution ();
      }

      // ZResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZResolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RAPZResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // RadialResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadialResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RadialResolution ();
      }

      // AzimuthalAngleResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AzimuthalAngleResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AzimuthalAngleResolution ();
      }

      // PolarAngleResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PolarAngleResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PolarAngleResolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalResolutionType& i)
    {
      e << static_cast< const ::xsd::qif30::ResolutionBaseType& > (i);

      // CombinedSphericalResolution
      //
      if (i.CombinedSphericalResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedSphericalResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CombinedSphericalResolution ();
      }

      // RAPZResolution
      //
      if (i.RAPZResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RAPZResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RAPZResolution ();
      }

      // RAPResolution
      //
      if (i.RAPResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RAPResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RAPResolution ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalResolutionType >
    _xsd_SphericalResolutionType_type_serializer_init (
      L"SphericalResolutionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CombinedSphericalResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CombinedRadialResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedRadialResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CombinedRadialResolution ();
      }

      // CombinedAzimuthalResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedAzimuthalResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CombinedAzimuthalResolution ();
      }

      // CombinedPolarResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedPolarResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CombinedPolarResolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UserDefinedResolutionType& i)
    {
      e << static_cast< const ::xsd::qif30::ResolutionBaseType& > (i);

      // CombinedUserDefinedResolution
      //
      if (i.CombinedUserDefinedResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CombinedUserDefinedResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CombinedUserDefinedResolution ();
      }

      // ABCResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ABCResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ABCResolution ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UserDefinedResolutionType >
    _xsd_UserDefinedResolutionType_type_serializer_init (
      L"UserDefinedResolutionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ABCResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AAxisResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AAxisResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AAxisResolution ();
      }

      // BAxisResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BAxisResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BAxisResolution ();
      }

      // CAxisResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CAxisResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CAxisResolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CombinedUserDefinedResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ACombinedResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ACombinedResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ACombinedResolution ();
      }

      // BCombinedResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BCombinedResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BCombinedResolution ();
      }

      // CCombinedResolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CCombinedResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CCombinedResolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CalibrationMasterType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SerialNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SerialNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SerialNumber ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CalibrationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CalibrationMaster
      //
      if (i.CalibrationMaster ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CalibrationMaster",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CalibrationMaster ();
      }

      // Temperatures
      //
      if (i.Temperatures ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Temperatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Temperatures ();
      }

      // CalibrationDate
      //
      if (i.CalibrationDate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CalibrationDate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CalibrationDate ();
      }

      // ExpirationDate
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExpirationDate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ExpirationDate ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CalibrationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Calibration
      //
      for (CalibrationsType::Calibration_const_iterator
           b (i.Calibration ().begin ()), n (i.Calibration ().end ());
           b != n; ++b)
      {
        const CalibrationsType::Calibration_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Calibration",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QualificationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Qualification
      //
      for (QualificationsType::Qualification_const_iterator
           b (i.Qualification ().begin ()), n (i.Qualification ().end ());
           b != n; ++b)
      {
        const QualificationsType::Qualification_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Qualification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QualificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Description
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Description ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperaturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Temperature
      //
      for (TemperaturesType::Temperature_const_iterator
           b (i.Temperature ().begin ()), n (i.Temperature ().end ());
           b != n; ++b)
      {
        const TemperaturesType::Temperature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Temperature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Temperature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Temperature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Temperature ();
      }

      // TimeStamp
      //
      if (i.TimeStamp ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStamp",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeStamp ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearVariableDifferentialTransformerEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LinearVariableDifferentialTransformerEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LinearVariableDifferentialTransformerEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearVariableDifferentialTransformerSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::DetachableSensorBaseType& > (i);

      // TypeOfLinearVariableDifferentialTransformer
      //
      if (i.TypeOfLinearVariableDifferentialTransformer ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TypeOfLinearVariableDifferentialTransformer",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TypeOfLinearVariableDifferentialTransformer ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // TemperatureStability
      //
      if (i.TemperatureStability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureStability ();
      }

      // ExcitationFrequency
      //
      if (i.ExcitationFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExcitationFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExcitationFrequency ();
      }

      // ExcitationAmplitude
      //
      if (i.ExcitationAmplitude ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExcitationAmplitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExcitationAmplitude ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // ShockTolerance
      //
      if (i.ShockTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShockTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShockTolerance ();
      }

      // VibrationTolerance
      //
      if (i.VibrationTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VibrationTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VibrationTolerance ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // ElectronicDescription
      //
      if (i.ElectronicDescription ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElectronicDescription",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ElectronicDescription ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearVariableDifferentialTransformerSensorType >
    _xsd_LinearVariableDifferentialTransformerSensorType_type_serializer_init (
      L"LinearVariableDifferentialTransformerSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CapacitiveSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::DetachableSensorBaseType& > (i);

      // MinOperatingVoltage
      //
      if (i.MinOperatingVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinOperatingVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinOperatingVoltage ();
      }

      // MaxOperatingVoltage
      //
      if (i.MaxOperatingVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxOperatingVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxOperatingVoltage ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // TemperatureStability
      //
      if (i.TemperatureStability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureStability ();
      }

      // MinimumTargetDiameter
      //
      if (i.MinimumTargetDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinimumTargetDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinimumTargetDiameter ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // Mounting
      //
      if (i.Mounting ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Mounting",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Mounting ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CapacitiveSensorType >
    _xsd_CapacitiveSensorType_type_serializer_init (
      L"CapacitiveSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EddyCurrentSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // MaxPressureFront
      //
      if (i.MaxPressureFront ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPressureFront",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPressureFront ();
      }

      // MaxPressureSide
      //
      if (i.MaxPressureSide ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPressureSide",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPressureSide ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // TemperatureStability
      //
      if (i.TemperatureStability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureStability ();
      }

      // OffsetDistance
      //
      if (i.OffsetDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OffsetDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OffsetDistance ();
      }

      // FrequencyResponse
      //
      if (i.FrequencyResponse ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FrequencyResponse",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FrequencyResponse ();
      }

      // MinPowerSupplyVoltage
      //
      if (i.MinPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPowerSupplyVoltage ();
      }

      // MaxPowerSupplyVoltage
      //
      if (i.MaxPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPowerSupplyVoltage ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // MeasurementObjectMaterial
      //
      if (i.MeasurementObjectMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementObjectMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementObjectMaterial ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConfocalChromaticSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // SpotDiameter
      //
      if (i.SpotDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpotDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpotDiameter ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // MultiPeakMeasurement
      //
      if (i.MultiPeakMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MultiPeakMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MultiPeakMeasurement ();
      }

      // LightSource
      //
      if (i.LightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LightSource ();
      }

      // MaxTilt
      //
      if (i.MaxTilt ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxTilt",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxTilt ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // OpticalFiberCableLength
      //
      if (i.OpticalFiberCableLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OpticalFiberCableLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OpticalFiberCableLength ();
      }

      // ShockTolerance
      //
      if (i.ShockTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShockTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShockTolerance ();
      }

      // VibrationTolerance
      //
      if (i.VibrationTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VibrationTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VibrationTolerance ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DrawWireSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // MaxWireExtensionForce
      //
      if (i.MaxWireExtensionForce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWireExtensionForce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWireExtensionForce ();
      }

      // MinWireRetractionForce
      //
      if (i.MinWireRetractionForce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinWireRetractionForce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinWireRetractionForce ();
      }

      // MaxWireAcceleration
      //
      if (i.MaxWireAcceleration ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWireAcceleration",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWireAcceleration ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MagnetoInductiveSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // FrequencyResponse
      //
      if (i.FrequencyResponse ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FrequencyResponse",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FrequencyResponse ();
      }

      // OffsetDistance
      //
      if (i.OffsetDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OffsetDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OffsetDistance ();
      }

      // MaxPressure
      //
      if (i.MaxPressure ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPressure",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPressure ();
      }

      // ShockTolerance
      //
      if (i.ShockTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShockTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShockTolerance ();
      }

      // VibrationTolerance
      //
      if (i.VibrationTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VibrationTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VibrationTolerance ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // MaxCurrentConsumption
      //
      if (i.MaxCurrentConsumption ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxCurrentConsumption",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxCurrentConsumption ();
      }

      // MinPowerSupplyVoltage
      //
      if (i.MinPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPowerSupplyVoltage ();
      }

      // MaxPowerSupplyVoltage
      //
      if (i.MaxPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPowerSupplyVoltage ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DifferentialVariableReluctanceTransducerSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // Hysteresis
      //
      if (i.Hysteresis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Hysteresis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Hysteresis ();
      }

      // FrequencyResponse
      //
      if (i.FrequencyResponse ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FrequencyResponse",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FrequencyResponse ();
      }

      // TemperatureStability
      //
      if (i.TemperatureStability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureStability ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LaserTriangulationSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // AverageSpotDiameter
      //
      if (i.AverageSpotDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AverageSpotDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AverageSpotDiameter ();
      }

      // LaserSafetyClass
      //
      if (i.LaserSafetyClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserSafetyClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserSafetyClass ();
      }

      // MaxMeasurementFrequency
      //
      if (i.MaxMeasurementFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasurementFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasurementFrequency ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // HousingMaterial
      //
      if (i.HousingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HousingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HousingMaterial ();
      }

      // PermissibleAmbientLight
      //
      if (i.PermissibleAmbientLight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PermissibleAmbientLight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PermissibleAmbientLight ();
      }

      // ShockTolerance
      //
      if (i.ShockTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShockTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShockTolerance ();
      }

      // VibrationTolerance
      //
      if (i.VibrationTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VibrationTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VibrationTolerance ();
      }

      // OutputPower
      //
      if (i.OutputPower ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OutputPower",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OutputPower ();
      }

      // Laser
      //
      if (i.Laser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Laser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Laser ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StructuredLightSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // OutputFileFormat
      //
      if (i.OutputFileFormat ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OutputFileFormat",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OutputFileFormat ();
      }

      // MeasurementFieldSize
      //
      if (i.MeasurementFieldSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementFieldSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementFieldSize ();
      }

      // NumberOfCameraPixels
      //
      if (i.NumberOfCameraPixels ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfCameraPixels",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfCameraPixels ();
      }

      // LightSource
      //
      if (i.LightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LightSource ();
      }

      // MeasurementRate
      //
      if (i.MeasurementRate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementRate ();
      }

      // WorkingVolume
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.WorkingVolume ())
        {
          const StructuredLightSensorType::WorkingVolume_type& x (*i.WorkingVolume ());
          if (typeid (StructuredLightSensorType::WorkingVolume_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"WorkingVolume",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"WorkingVolume",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // StandOffDistance
      //
      if (i.StandOffDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandOffDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandOffDistance ();
      }

      // MaxPermissibleProbingError
      //
      if (i.MaxPermissibleProbingError ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPermissibleProbingError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPermissibleProbingError ();
      }

      // Laser
      //
      if (i.Laser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Laser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Laser ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UltrasonicSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // SamplingFrequency
      //
      if (i.SamplingFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingFrequency ();
      }

      // AppliedFrequency
      //
      if (i.AppliedFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AppliedFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AppliedFrequency ();
      }

      // MaxResponseTime
      //
      if (i.MaxResponseTime ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxResponseTime",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxResponseTime ();
      }

      // ShockTolerance
      //
      if (i.ShockTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShockTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShockTolerance ();
      }

      // VibrationTolerance
      //
      if (i.VibrationTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VibrationTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VibrationTolerance ();
      }

      // MinPowerSupplyVoltage
      //
      if (i.MinPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPowerSupplyVoltage ();
      }

      // MaxPowerSupplyVoltage
      //
      if (i.MaxPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPowerSupplyVoltage ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TipEndGeometryEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TipEndGeometryEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TipEndGeometryEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TipEndGeometryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TipEndGeometryEnum
      //
      if (i.TipEndGeometryEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndGeometryEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndGeometryEnum ();
      }

      // OtherTipEndGeometry
      //
      if (i.OtherTipEndGeometry ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherTipEndGeometry",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherTipEndGeometry ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TactileProbeSensorBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::DetachableSensorBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SimpleTactileProbeSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::TactileProbeSensorBaseType& > (i);

      // Qualifications
      //
      if (i.Qualifications ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Qualifications",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Qualifications ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // TipEndGeometry
      //
      if (i.TipEndGeometry ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndGeometry",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndGeometry ();
      }

      // TipEndDiameter
      //
      if (i.TipEndDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndDiameter ();
      }

      // TipEndMaterial
      //
      if (i.TipEndMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndMaterial ();
      }

      // StemMaterial
      //
      if (i.StemMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StemMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StemMaterial ();
      }

      // StemDiameter
      //
      if (i.StemDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StemDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StemDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SimpleTactileProbeSensorType >
    _xsd_SimpleTactileProbeSensorType_type_serializer_init (
      L"SimpleTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ComplexTactileProbeSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::TactileProbeSensorBaseType& > (i);

      // LocatedTips
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocatedTips",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LocatedTips ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ComplexTactileProbeSensorType >
    _xsd_ComplexTactileProbeSensorType_type_serializer_init (
      L"ComplexTactileProbeSensorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LocatedTipsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LocatedTip
      //
      for (LocatedTipsType::LocatedTip_const_iterator
           b (i.LocatedTip ().begin ()), n (i.LocatedTip ().end ());
           b != n; ++b)
      {
        const LocatedTipsType::LocatedTip_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocatedTip",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ProbeTipType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementResourceBaseType& > (i);

      // TipEndGeometry
      //
      if (i.TipEndGeometry ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndGeometry",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndGeometry ();
      }

      // TipEndDiameter
      //
      if (i.TipEndDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndDiameter ();
      }

      // TipEndMaterial
      //
      if (i.TipEndMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipEndMaterial ();
      }

      // StemMaterial
      //
      if (i.StemMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StemMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StemMaterial ();
      }

      // StemDiameter
      //
      if (i.StemDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StemDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StemDiameter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LocatedTipType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ProbeTip
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProbeTip",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProbeTip ();
      }

      // TipEndLocation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipEndLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TipEndLocation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ChargeCoupledDeviceCameraSensorType& i)
    {
      e << static_cast< const ::xsd::qif30::SensorType& > (i);

      // NumberOfPixels
      //
      if (i.NumberOfPixels ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfPixels",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfPixels ();
      }

      // MaxReadoutFrequency
      //
      if (i.MaxReadoutFrequency ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxReadoutFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxReadoutFrequency ();
      }

      // HorizontalFieldOfView
      //
      if (i.HorizontalFieldOfView ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HorizontalFieldOfView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HorizontalFieldOfView ();
      }

      // VerticalFieldOfView
      //
      if (i.VerticalFieldOfView ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VerticalFieldOfView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VerticalFieldOfView ();
      }

      // MaxReadNoise
      //
      if (i.MaxReadNoise ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxReadNoise",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxReadNoise ();
      }

      // MaxFrameRate
      //
      if (i.MaxFrameRate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFrameRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxFrameRate ();
      }

      // PixelSize
      //
      if (i.PixelSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PixelSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PixelSize ();
      }

      // SustainedDataRate
      //
      if (i.SustainedDataRate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SustainedDataRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SustainedDataRate ();
      }

      // DarkCurrent
      //
      if (i.DarkCurrent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DarkCurrent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DarkCurrent ();
      }

      // MaxPixelClockSpeed
      //
      if (i.MaxPixelClockSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPixelClockSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPixelClockSpeed ();
      }

      // Linearity
      //
      if (i.Linearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Linearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Linearity ();
      }

      // MaxOutputVoltage
      //
      if (i.MaxOutputVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxOutputVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxOutputVoltage ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CMMType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CMMType >
    _xsd_CMMType_type_serializer_init (
      L"CMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMType& > (i);

      // HomeLocation
      //
      if (i.HomeLocation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HomeLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HomeLocation ();
      }

      // CMMGeometry
      //
      if (i.CMMGeometry ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CMMGeometry",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CMMGeometry ();
      }

      // CMMAxisDirections
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CMMAxisDirections ())
        {
          const CartesianCMMType::CMMAxisDirections_type& x (*i.CMMAxisDirections ());
          if (typeid (CartesianCMMType::CMMAxisDirections_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CMMAxisDirections",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CMMAxisDirections",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // Scales
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Scales ())
        {
          const CartesianCMMType::Scales_type& x (*i.Scales ());
          if (typeid (CartesianCMMType::Scales_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Scales",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Scales",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // MaxWorkpieceHeight
      //
      if (i.MaxWorkpieceHeight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceHeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceHeight ();
      }

      // MaxWorkpieceMass
      //
      if (i.MaxWorkpieceMass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceMass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceMass ();
      }

      // JoystickSpeeds
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.JoystickSpeeds ())
        {
          const CartesianCMMType::JoystickSpeeds_type& x (*i.JoystickSpeeds ());
          if (typeid (CartesianCMMType::JoystickSpeeds_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"JoystickSpeeds",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"JoystickSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // CMMSpeeds
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CMMSpeeds ())
        {
          const CartesianCMMType::CMMSpeeds_type& x (*i.CMMSpeeds ());
          if (typeid (CartesianCMMType::CMMSpeeds_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CMMSpeeds",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CMMSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // RotaryTable
      //
      if (i.RotaryTable ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RotaryTable",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RotaryTable ();
      }

      // Accuracies
      //
      if (i.Accuracies ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracies",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracies ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }

      // SensorIds
      //
      if (i.SensorIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SensorIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SensorIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianCMMType >
    _xsd_CartesianCMMType_type_serializer_init (
      L"CartesianCMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MultipleCarriageCartesianCMMType& i)
    {
      e << static_cast< const ::xsd::qif30::CartesianCMMType& > (i);

      // Carriages
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Carriages",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Carriages ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MultipleCarriageCartesianCMMType >
    _xsd_MultipleCarriageCartesianCMMType_type_serializer_init (
      L"MultipleCarriageCartesianCMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LightPenCMMType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMType& > (i);

      // LightPenCMMChargeCoupledDeviceCameraSensor
      //
      if (i.LightPenCMMChargeCoupledDeviceCameraSensor ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LightPenCMMChargeCoupledDeviceCameraSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LightPenCMMChargeCoupledDeviceCameraSensor ();
      }

      // LightSource
      //
      if (i.LightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LightSource ();
      }

      // NominalVolumetricAccuracy
      //
      if (i.NominalVolumetricAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalVolumetricAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalVolumetricAccuracy ();
      }

      // ActualVolumetricAccuracy
      //
      if (i.ActualVolumetricAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActualVolumetricAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActualVolumetricAccuracy ();
      }

      // NominalSinglePointAccuracy
      //
      if (i.NominalSinglePointAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalSinglePointAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalSinglePointAccuracy ();
      }

      // ActualSinglePointAccuracy
      //
      if (i.ActualSinglePointAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActualSinglePointAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActualSinglePointAccuracy ();
      }

      // ScanningSpeed
      //
      if (i.ScanningSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScanningSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScanningSpeed ();
      }

      // LaserClass
      //
      if (i.LaserClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LaserClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LaserClass ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LightPenCMMType >
    _xsd_LightPenCMMType_type_serializer_init (
      L"LightPenCMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ParallelLinkCMMType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMType& > (i);

      // CMMSpeeds
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CMMSpeeds ())
        {
          const ParallelLinkCMMType::CMMSpeeds_type& x (*i.CMMSpeeds ());
          if (typeid (ParallelLinkCMMType::CMMSpeeds_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CMMSpeeds",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CMMSpeeds",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // AxesTravelDistance
      //
      if (i.AxesTravelDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxesTravelDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxesTravelDistance ();
      }

      // AxesRotationAngle
      //
      if (i.AxesRotationAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxesRotationAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxesRotationAngle ();
      }

      // AxisBacklash
      //
      if (i.AxisBacklash ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisBacklash",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxisBacklash ();
      }

      // AxisRepeatability
      //
      if (i.AxisRepeatability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisRepeatability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxisRepeatability ();
      }

      // MaxLoad
      //
      if (i.MaxLoad ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxLoad",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxLoad ();
      }

      // StageMaterial
      //
      if (i.StageMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StageMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StageMaterial ();
      }

      // MaxHoldingForce
      //
      if (i.MaxHoldingForce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxHoldingForce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxHoldingForce ();
      }

      // MotorType
      //
      if (i.MotorType ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MotorType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MotorType ();
      }

      // LinksStiffness
      //
      if (i.LinksStiffness ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinksStiffness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinksStiffness ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ParallelLinkCMMType >
    _xsd_ParallelLinkCMMType_type_serializer_init (
      L"ParallelLinkCMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AACMMType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMType& > (i);

      // HomeLocation
      //
      if (i.HomeLocation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HomeLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HomeLocation ();
      }

      // NumberOfJoints
      //
      if (i.NumberOfJoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfJoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfJoints ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // ProbeTipDiameter
      //
      if (i.ProbeTipDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProbeTipDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ProbeTipDiameter ();
      }

      // Accuracies
      //
      if (i.Accuracies ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracies",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracies ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AACMMType >
    _xsd_AACMMType_type_serializer_init (
      L"AACMMType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CaliperType& i)
    {
      e << static_cast< const ::xsd::qif30::ManualMeasurementDeviceType& > (i);

      // LinearResolution
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.LinearResolution ())
        {
          const CaliperType::LinearResolution_type& x (*i.LinearResolution ());
          if (typeid (CaliperType::LinearResolution_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"LinearResolution",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"LinearResolution",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // Accuracy
      //
      if (i.Accuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracy ();
      }

      // CanMeasureInnerD
      //
      if (i.CanMeasureInnerD ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CanMeasureInnerD",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CanMeasureInnerD ();
      }

      // CanMeasureOuterD
      //
      if (i.CanMeasureOuterD ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CanMeasureOuterD",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CanMeasureOuterD ();
      }

      // CanMeasureDepth
      //
      if (i.CanMeasureDepth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CanMeasureDepth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CanMeasureDepth ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CaliperType >
    _xsd_CaliperType_type_serializer_init (
      L"CaliperType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CaliperDialType& i)
    {
      e << static_cast< const ::xsd::qif30::CaliperType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CaliperDialType >
    _xsd_CaliperDialType_type_serializer_init (
      L"CaliperDialType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CaliperDigitalType& i)
    {
      e << static_cast< const ::xsd::qif30::CaliperType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CaliperDigitalType >
    _xsd_CaliperDigitalType_type_serializer_init (
      L"CaliperDigitalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MicrometerType& i)
    {
      e << static_cast< const ::xsd::qif30::ManualMeasurementDeviceType& > (i);

      // LinearResolution
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.LinearResolution ())
        {
          const MicrometerType::LinearResolution_type& x (*i.LinearResolution ());
          if (typeid (MicrometerType::LinearResolution_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"LinearResolution",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"LinearResolution",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // Accuracy
      //
      if (i.Accuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracy ();
      }

      // MeasuringForce
      //
      if (i.MeasuringForce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuringForce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuringForce ();
      }

      // InternalExternal
      //
      if (i.InternalExternal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.InternalExternal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MicrometerType >
    _xsd_MicrometerType_type_serializer_init (
      L"MicrometerType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MicrometerAnalogType& i)
    {
      e << static_cast< const ::xsd::qif30::MicrometerType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MicrometerAnalogType >
    _xsd_MicrometerAnalogType_type_serializer_init (
      L"MicrometerAnalogType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MicrometerDigitalType& i)
    {
      e << static_cast< const ::xsd::qif30::MicrometerType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MicrometerDigitalType >
    _xsd_MicrometerDigitalType_type_serializer_init (
      L"MicrometerDigitalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GageDeviceType& i)
    {
      e << static_cast< const ::xsd::qif30::ManualMeasurementDeviceType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GageDeviceType >
    _xsd_GageDeviceType_type_serializer_init (
      L"GageDeviceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SineBarType& i)
    {
      e << static_cast< const ::xsd::qif30::ManualMeasurementDeviceType& > (i);

      // NominalBallCenterToBallCenterLength
      //
      if (i.NominalBallCenterToBallCenterLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalBallCenterToBallCenterLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalBallCenterToBallCenterLength ();
      }

      // CylinderCenterToCylinderCenterAccuracy
      //
      if (i.CylinderCenterToCylinderCenterAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CylinderCenterToCylinderCenterAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CylinderCenterToCylinderCenterAccuracy ();
      }

      // Parallelism
      //
      if (i.Parallelism ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parallelism",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Parallelism ();
      }

      // OverallLength
      //
      if (i.OverallLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OverallLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OverallLength ();
      }

      // Material
      //
      if (i.Material ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Material",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Material ();
      }

      // Magnetic
      //
      if (i.Magnetic ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Magnetic",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Magnetic ();
      }

      // Width
      //
      if (i.Width ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Width ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SineBarType >
    _xsd_SineBarType_type_serializer_init (
      L"SineBarType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TheodoliteType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // LongitudinalTrackingSpeed
      //
      if (i.LongitudinalTrackingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LongitudinalTrackingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LongitudinalTrackingSpeed ();
      }

      // LateralTrackingSpeed
      //
      if (i.LateralTrackingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LateralTrackingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LateralTrackingSpeed ();
      }

      // Magnification
      //
      if (i.Magnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Magnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Magnification ());
      }

      // FieldOfViewDiameter
      //
      if (i.FieldOfViewDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FieldOfViewDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FieldOfViewDiameter ();
      }

      // ApertureSize
      //
      if (i.ApertureSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApertureSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ApertureSize ();
      }

      // MaxFocusDistance
      //
      if (i.MaxFocusDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFocusDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxFocusDistance ();
      }

      // AngularAccuracy
      //
      if (i.AngularAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularAccuracy ();
      }

      // MaxTiltCompensation
      //
      if (i.MaxTiltCompensation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxTiltCompensation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxTiltCompensation ();
      }

      // ChargeCoupledDeviceCameraSensor
      //
      if (i.ChargeCoupledDeviceCameraSensor ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ChargeCoupledDeviceCameraSensor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ChargeCoupledDeviceCameraSensor ();
      }

      // MinFocusDistance
      //
      if (i.MinFocusDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinFocusDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinFocusDistance ();
      }

      // EffectiveDiameterOfObjective
      //
      if (i.EffectiveDiameterOfObjective ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EffectiveDiameterOfObjective",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EffectiveDiameterOfObjective ();
      }

      // StadiaBaseConstant
      //
      if (i.StadiaBaseConstant ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StadiaBaseConstant",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StadiaBaseConstant ();
      }

      // StadiaRateConstant
      //
      if (i.StadiaRateConstant ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StadiaRateConstant",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StadiaRateConstant ();
      }

      // MinPowerSupplyVoltage
      //
      if (i.MinPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinPowerSupplyVoltage ();
      }

      // MaxPowerSupplyVoltage
      //
      if (i.MaxPowerSupplyVoltage ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPowerSupplyVoltage",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPowerSupplyVoltage ();
      }

      // Laser
      //
      if (i.Laser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Laser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Laser ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TheodoliteType >
    _xsd_TheodoliteType_type_serializer_init (
      L"TheodoliteType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UniversalLengthMeasuringType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // MeasuringForce
      //
      if (i.MeasuringForce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuringForce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuringForce ();
      }

      // Accuracy
      //
      if (i.Accuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracy ();
      }

      // Repeatability
      //
      if (i.Repeatability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Repeatability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Repeatability ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }

      // MaxWorkpieceWeight
      //
      if (i.MaxWorkpieceWeight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceWeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceWeight ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UniversalLengthMeasuringType >
    _xsd_UniversalLengthMeasuringType_type_serializer_init (
      L"UniversalLengthMeasuringType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ComputedTomographyType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // SourceDescription
      //
      if (i.SourceDescription ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SourceDescription",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SourceDescription ();
      }

      // SamplePenetratingMaterial
      //
      if (i.SamplePenetratingMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplePenetratingMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplePenetratingMaterial ();
      }

      // SamplePenetratingMaterialLength
      //
      if (i.SamplePenetratingMaterialLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplePenetratingMaterialLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplePenetratingMaterialLength ();
      }

      // FocalSpotSize
      //
      if (i.FocalSpotSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FocalSpotSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FocalSpotSize ();
      }

      // MaxWorkpieceMass
      //
      if (i.MaxWorkpieceMass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceMass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceMass ();
      }

      // SafetyLevel
      //
      if (i.SafetyLevel ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SafetyLevel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SafetyLevel ();
      }

      // CabinetDimensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CabinetDimensions ())
        {
          const ComputedTomographyType::CabinetDimensions_type& x (*i.CabinetDimensions ());
          if (typeid (ComputedTomographyType::CabinetDimensions_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CabinetDimensions",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CabinetDimensions",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // MaxPower
      //
      if (i.MaxPower ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPower",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPower ();
      }

      // DetectorBitNumber
      //
      if (i.DetectorBitNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DetectorBitNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.DetectorBitNumber ());
      }

      // DetectorPixelSize
      //
      if (i.DetectorPixelSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DetectorPixelSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DetectorPixelSize ();
      }

      // ActivePixelsNumber
      //
      if (i.ActivePixelsNumber ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActivePixelsNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActivePixelsNumber ();
      }

      // MaxKV
      //
      if (i.MaxKV ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxKV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxKV ();
      }

      // MinOperatingCurrent
      //
      if (i.MinOperatingCurrent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinOperatingCurrent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinOperatingCurrent ();
      }

      // MaxOperatingCurrent
      //
      if (i.MaxOperatingCurrent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxOperatingCurrent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxOperatingCurrent ();
      }

      // MaxFramePerSecond
      //
      if (i.MaxFramePerSecond ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxFramePerSecond",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxFramePerSecond ();
      }

      // RotaryTable
      //
      if (i.RotaryTable ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RotaryTable",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RotaryTable ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ComputedTomographyType >
    _xsd_ComputedTomographyType_type_serializer_init (
      L"ComputedTomographyType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OpticalComparatorType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // Magnification
      //
      if (i.Magnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Magnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Magnification ());
      }

      // EffectiveScreenDiameter
      //
      if (i.EffectiveScreenDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EffectiveScreenDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EffectiveScreenDiameter ();
      }

      // ScreenMaterial
      //
      if (i.ScreenMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScreenMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScreenMaterial ();
      }

      // AngleResolution
      //
      if (i.AngleResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngleResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngleResolution ();
      }

      // SurfaceIlluminationLightSource
      //
      if (i.SurfaceIlluminationLightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceIlluminationLightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceIlluminationLightSource ();
      }

      // ContourIlluminationLightSource
      //
      if (i.ContourIlluminationLightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ContourIlluminationLightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ContourIlluminationLightSource ();
      }

      // MaxWorkpieceHeight
      //
      if (i.MaxWorkpieceHeight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceHeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceHeight ();
      }

      // WorkingDistance
      //
      if (i.WorkingDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkingDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorkingDistance ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OpticalComparatorType >
    _xsd_OpticalComparatorType_type_serializer_init (
      L"OpticalComparatorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MicroscopeType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // IlluminationUnit
      //
      if (i.IlluminationUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IlluminationUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IlluminationUnit ();
      }

      // TotalMagnification
      //
      if (i.TotalMagnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TotalMagnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.TotalMagnification ());
      }

      // EyePieceMagnification
      //
      if (i.EyePieceMagnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EyePieceMagnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.EyePieceMagnification ());
      }

      // ObjectiveMagnification
      //
      if (i.ObjectiveMagnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ObjectiveMagnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.ObjectiveMagnification ());
      }

      // MaxWorkpieceHeight
      //
      if (i.MaxWorkpieceHeight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceHeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceHeight ();
      }

      // MaxWorkpieceWeight
      //
      if (i.MaxWorkpieceWeight ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxWorkpieceWeight",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxWorkpieceWeight ();
      }

      // Accuracy
      //
      if (i.Accuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Accuracy ();
      }

      // StageSwivelingAngle
      //
      if (i.StageSwivelingAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StageSwivelingAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StageSwivelingAngle ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MicroscopeType >
    _xsd_MicroscopeType_type_serializer_init (
      L"MicroscopeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AutocollimatorType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // LightSource
      //
      if (i.LightSource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LightSource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LightSource ();
      }

      // MeasuringAccuracy
      //
      if (i.MeasuringAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuringAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasuringAccuracy ();
      }

      // Magnification
      //
      if (i.Magnification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Magnification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Magnification ());
      }

      // ApertureSize
      //
      if (i.ApertureSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ApertureSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ApertureSize ();
      }

      // MinMeasuringDistance
      //
      if (i.MinMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasuringDistance ();
      }

      // MaxMeasuringDistance
      //
      if (i.MaxMeasuringDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasuringDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasuringDistance ();
      }

      // ObjectiveFocalLength
      //
      if (i.ObjectiveFocalLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ObjectiveFocalLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ObjectiveFocalLength ();
      }

      // FieldOfView
      //
      if (i.FieldOfView ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FieldOfView",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FieldOfView ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AutocollimatorType >
    _xsd_AutocollimatorType_type_serializer_init (
      L"AutocollimatorType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LaserTrackerType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // MaximumAngularVelocity
      //
      if (i.MaximumAngularVelocity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumAngularVelocity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumAngularVelocity ();
      }

      // DistanceAccuracy
      //
      if (i.DistanceAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DistanceAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DistanceAccuracy ();
      }

      // AngularAccuracy
      //
      if (i.AngularAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularAccuracy ();
      }

      // SamplingRate
      //
      if (i.SamplingRate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SamplingRate ();
      }

      // TargetMirror
      //
      if (i.TargetMirror ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TargetMirror",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TargetMirror ();
      }

      // HeadMass
      //
      if (i.HeadMass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HeadMass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HeadMass ();
      }

      // HeadSize
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.HeadSize ())
        {
          const LaserTrackerType::HeadSize_type& x (*i.HeadSize ());
          if (typeid (LaserTrackerType::HeadSize_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"HeadSize",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"HeadSize",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // MaximumWorkingAmplitude
      //
      if (i.MaximumWorkingAmplitude ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumWorkingAmplitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumWorkingAmplitude ();
      }

      // Laser
      //
      if (i.Laser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Laser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Laser ();
      }

      // Repeatability
      //
      if (i.Repeatability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Repeatability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Repeatability ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LaserTrackerType >
    _xsd_LaserTrackerType_type_serializer_init (
      L"LaserTrackerType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LaserRadarType& i)
    {
      e << static_cast< const ::xsd::qif30::UniversalDeviceType& > (i);

      // MeasurementLaser
      //
      if (i.MeasurementLaser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementLaser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementLaser ();
      }

      // PointingLaser
      //
      if (i.PointingLaser ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointingLaser",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointingLaser ();
      }

      // MaxPointsRate
      //
      if (i.MaxPointsRate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxPointsRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxPointsRate ();
      }

      // MaxMeasurementRange
      //
      if (i.MaxMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxMeasurementRange ();
      }

      // MinMeasurementRange
      //
      if (i.MinMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinMeasurementRange ();
      }

      // ScanningSpeed
      //
      if (i.ScanningSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScanningSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScanningSpeed ();
      }

      // DistanceAccuracy
      //
      if (i.DistanceAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DistanceAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DistanceAccuracy ();
      }

      // AzimuthAngularAccuracy
      //
      if (i.AzimuthAngularAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AzimuthAngularAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AzimuthAngularAccuracy ();
      }

      // ElevationAngularAccuracy
      //
      if (i.ElevationAngularAccuracy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElevationAngularAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ElevationAngularAccuracy ();
      }

      // RangeForVolumetricUncertainty
      //
      if (i.RangeForVolumetricUncertainty ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RangeForVolumetricUncertainty",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RangeForVolumetricUncertainty ();
      }

      // VolumetricUncertainty
      //
      if (i.VolumetricUncertainty ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VolumetricUncertainty",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VolumetricUncertainty ();
      }

      // MaxEnvironmentalAltitude
      //
      if (i.MaxEnvironmentalAltitude ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxEnvironmentalAltitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxEnvironmentalAltitude ();
      }

      // MinEnvironmentalAltitude
      //
      if (i.MinEnvironmentalAltitude ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinEnvironmentalAltitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinEnvironmentalAltitude ();
      }

      // SurfacePointsSpeed
      //
      if (i.SurfacePointsSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfacePointsSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfacePointsSpeed ();
      }

      // ToolingBallSpeed
      //
      if (i.ToolingBallSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToolingBallSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToolingBallSpeed ();
      }

      // FeatureSpeed
      //
      if (i.FeatureSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureSpeed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LaserRadarType >
    _xsd_LaserRadarType_type_serializer_init (
      L"LaserRadarType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const StiffnessType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XStiffness
      //
      if (i.XStiffness ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XStiffness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.XStiffness ();
      }

      // YStiffness
      //
      if (i.YStiffness ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YStiffness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.YStiffness ();
      }

      // ZStiffness
      //
      if (i.ZStiffness ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZStiffness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ZStiffness ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CMMDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CMMDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CMMDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMGeometryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CartesianCMMGeometryEnum
      //
      if (i.CartesianCMMGeometryEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CartesianCMMGeometryEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CartesianCMMGeometryEnum ();
      }

      // OtherCartesianCMMGeometry
      //
      if (i.OtherCartesianCMMGeometry ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherCartesianCMMGeometry",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherCartesianCMMGeometry ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMGeometryEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CartesianCMMGeometryEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CartesianCMMGeometryEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CMMAxisDirectionsBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const CMMAxisDirectionsBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const CMMAxisDirectionsBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMAxisDirectionsType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAxisDirectionsBaseType& > (i);

      // XAxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisDirection ();
      }

      // YAxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisDirection ();
      }

      // ZAxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisDirection ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianCMMAxisDirectionsType >
    _xsd_CartesianCMMAxisDirectionsType_type_serializer_init (
      L"CartesianCMMAxisDirectionsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const XYZLinearSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // X
      //
      if (i.X ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.X ();
      }

      // Y
      //
      if (i.Y ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Y",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Y ();
      }

      // Z
      //
      if (i.Z ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Z",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Z ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TargetMirrorEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TargetMirrorEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TargetMirrorEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementDeviceScalesBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const MeasurementDeviceScalesBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDeviceScalesBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianMeasurementDeviceScalesType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceScalesBaseType& > (i);

      // XScale
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XScale ();
      }

      // YScale
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YScale ();
      }

      // ZScale
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZScale ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianMeasurementDeviceScalesType >
    _xsd_CartesianMeasurementDeviceScalesType_type_serializer_init (
      L"CartesianMeasurementDeviceScalesType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasurementDeviceScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ScaleMaterial
      //
      if (i.ScaleMaterial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleMaterial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScaleMaterial ();
      }

      // ScaleCoefficientOfExpansion
      //
      if (i.ScaleCoefficientOfExpansion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleCoefficientOfExpansion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.ScaleCoefficientOfExpansion ());
      }

      // ScaleCoefficientOfExpansionUncertainty
      //
      if (i.ScaleCoefficientOfExpansionUncertainty ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleCoefficientOfExpansionUncertainty",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.ScaleCoefficientOfExpansionUncertainty ());
      }

      // TypeOfScale
      //
      if (i.TypeOfScale ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TypeOfScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TypeOfScale ();
      }

      // ScaleResolution
      //
      if (i.ScaleResolution ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleResolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScaleResolution ();
      }

      // ScaleReference
      //
      if (i.ScaleReference ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleReference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ScaleReference ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ScaleReferenceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ScaleReferenceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ScaleReferenceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TypeOfScaleEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const TypeOfScaleEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const TypeOfScaleEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TypeOfScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TypeOfScaleEnum
      //
      if (i.TypeOfScaleEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TypeOfScaleEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TypeOfScaleEnum ();
      }

      // OtherTypeOfScale
      //
      if (i.OtherTypeOfScale ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherTypeOfScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherTypeOfScale ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CMMSpeedsBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const CMMSpeedsBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const CMMSpeedsBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMSpeedsType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMSpeedsBaseType& > (i);

      // MaxXTraverseSpeed
      //
      if (i.MaxXTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxXTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxXTraverseSpeed ();
      }

      // MaxYTraverseSpeed
      //
      if (i.MaxYTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxYTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxYTraverseSpeed ();
      }

      // MaxZTraverseSpeed
      //
      if (i.MaxZTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxZTraverseSpeed ();
      }

      // MaxXProbingSpeed
      //
      if (i.MaxXProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxXProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxXProbingSpeed ();
      }

      // MaxYProbingSpeed
      //
      if (i.MaxYProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxYProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxYProbingSpeed ();
      }

      // MaxZProbingSpeed
      //
      if (i.MaxZProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxZProbingSpeed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianCMMSpeedsType >
    _xsd_CartesianCMMSpeedsType_type_serializer_init (
      L"CartesianCMMSpeedsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ParallelLinkCMMSpeedsType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMSpeedsBaseType& > (i);

      // MaxXTraverseSpeed
      //
      if (i.MaxXTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxXTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxXTraverseSpeed ();
      }

      // MaxYTraverseSpeed
      //
      if (i.MaxYTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxYTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxYTraverseSpeed ();
      }

      // MaxZTraverseSpeed
      //
      if (i.MaxZTraverseSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZTraverseSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxZTraverseSpeed ();
      }

      // MaxXProbingSpeed
      //
      if (i.MaxXProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxXProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxXProbingSpeed ();
      }

      // MaxYProbingSpeed
      //
      if (i.MaxYProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxYProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxYProbingSpeed ();
      }

      // MaxZProbingSpeed
      //
      if (i.MaxZProbingSpeed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZProbingSpeed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxZProbingSpeed ();
      }

      // MaxXRotation
      //
      if (i.MaxXRotation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxXRotation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxXRotation ();
      }

      // MaxYRotation
      //
      if (i.MaxYRotation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxYRotation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxYRotation ();
      }

      // MaxZRotation
      //
      if (i.MaxZRotation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxZRotation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxZRotation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ParallelLinkCMMSpeedsType >
    _xsd_ParallelLinkCMMSpeedsType_type_serializer_init (
      L"ParallelLinkCMMSpeedsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FunctionDiscreteType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DomainValues
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainValues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainValues ();
      }

      // RangeValues
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RangeValues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RangeValues ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LengthFunctionDiscreteType& i)
    {
      e << static_cast< const ::xsd::qif30::FunctionDiscreteType& > (i);

      // DomainLinearUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainLinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainLinearUnit ();
      }

      // RangeLinearUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RangeLinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RangeLinearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngleFunctionDiscreteType& i)
    {
      e << static_cast< const ::xsd::qif30::FunctionDiscreteType& > (i);

      // DomainLinearUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainLinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainLinearUnit ();
      }

      // RangeAngularUnit
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RangeAngularUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RangeAngularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasurementDeviceAccuracyBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EnvironmentalRange
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EnvironmentalRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EnvironmentalRange ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NumericalLengthAccuracyType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (i);

      // AccuracyValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AccuracyValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AccuracyValue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EnvironmentalRangeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // MaxAmbientTemperature
      //
      if (i.MaxAmbientTemperature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAmbientTemperature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxAmbientTemperature ();
      }

      // MinAmbientTemperature
      //
      if (i.MinAmbientTemperature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAmbientTemperature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinAmbientTemperature ();
      }

      // MaxAmbientAirPressure
      //
      if (i.MaxAmbientAirPressure ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAmbientAirPressure",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxAmbientAirPressure ();
      }

      // MinAmbientAirPressure
      //
      if (i.MinAmbientAirPressure ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAmbientAirPressure",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinAmbientAirPressure ();
      }

      // MaxAmbientRelativeHumidity
      //
      if (i.MaxAmbientRelativeHumidity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxAmbientRelativeHumidity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxAmbientRelativeHumidity ();
      }

      // MinAmbientRelativeHumidity
      //
      if (i.MinAmbientRelativeHumidity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinAmbientRelativeHumidity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinAmbientRelativeHumidity ();
      }

      // MaxVibration
      //
      if (i.MaxVibration ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxVibration",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxVibration ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMAccuracyType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (i);

      // CartesianCMMAccuracyTest
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const CartesianCMMAccuracyType::CartesianCMMAccuracyTest_type& x (i.CartesianCMMAccuracyTest ());
        if (typeid (CartesianCMMAccuracyType::CartesianCMMAccuracyTest_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CartesianCMMAccuracyTest",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"CartesianCMMAccuracyTest",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // AccuracySource
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AccuracySource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AccuracySource ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AACMMAccuracyType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurementDeviceAccuracyBaseType& > (i);

      // AACMMAccuracyTest
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const AACMMAccuracyType::AACMMAccuracyTest_type& x (i.AACMMAccuracyTest ());
        if (typeid (AACMMAccuracyType::AACMMAccuracyTest_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"AACMMAccuracyTest",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"AACMMAccuracyTest",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // AccuracySource
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AccuracySource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AccuracySource ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMAccuraciesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CartesianCMMAccuracy
      //
      for (CartesianCMMAccuraciesType::CartesianCMMAccuracy_const_iterator
           b (i.CartesianCMMAccuracy ().begin ()), n (i.CartesianCMMAccuracy ().end ());
           b != n; ++b)
      {
        const CartesianCMMAccuraciesType::CartesianCMMAccuracy_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CartesianCMMAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AACMMAccuraciesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AACMMAccuracy
      //
      for (AACMMAccuraciesType::AACMMAccuracy_const_iterator
           b (i.AACMMAccuracy ().begin ()), n (i.AACMMAccuracy ().end ());
           b != n; ++b)
      {
        const AACMMAccuraciesType::AACMMAccuracy_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AACMMAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AccuracySourceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AccuracySourceEnum
      //
      if (i.AccuracySourceEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AccuracySourceEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AccuracySourceEnum ();
      }

      // OtherAccuracySource
      //
      if (i.OtherAccuracySource ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherAccuracySource",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherAccuracySource ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AccuracySourceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const AccuracySourceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AccuracySourceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CMMAccuracyTestBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const CMMAccuracyTestBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const CMMAccuracyTestBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const FPSTestType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAccuracyTestBaseType& > (i);

      // XLinearity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XLinearity ();
      }

      // YLinearity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YLinearity ();
      }

      // ZLinearity
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZLinearity ();
      }

      // XAxisRoll
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisRoll",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisRoll ();
      }

      // XAxisPitch
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisPitch",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisPitch ();
      }

      // XAxisYaw
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisYaw",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisYaw ();
      }

      // YAxisRoll
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisRoll",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisRoll ();
      }

      // YAxisPitch
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisPitch",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisPitch ();
      }

      // YAxisYaw
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisYaw",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisYaw ();
      }

      // ZAxisRoll
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisRoll",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisRoll ();
      }

      // ZAxisPitch
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisPitch",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisPitch ();
      }

      // ZAxisYaw
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisYaw",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisYaw ();
      }

      // XAxisStraightnessY
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisStraightnessY",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisStraightnessY ();
      }

      // XAxisStraightnessZ
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XAxisStraightnessZ",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XAxisStraightnessZ ();
      }

      // YAxisStraightnessX
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisStraightnessX",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisStraightnessX ();
      }

      // YAxisStraightnessZ
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YAxisStraightnessZ",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YAxisStraightnessZ ();
      }

      // ZAxisStraightnessX
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisStraightnessX",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisStraightnessX ();
      }

      // ZAxisStraightnessY
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZAxisStraightnessY",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZAxisStraightnessY ();
      }

      // XYSquareness
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XYSquareness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.XYSquareness ());
      }

      // XZSquareness
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XZSquareness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.XZSquareness ());
      }

      // YZSquareness
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YZSquareness",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.YZSquareness ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FPSTestType >
    _xsd_FPSTestType_type_serializer_init (
      L"FPSTestType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CartesianCMMB89TestType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAccuracyTestBaseType& > (i);

      // XLinearAccuracy
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XLinearAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XLinearAccuracy ();
      }

      // YLinearAccuracy
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YLinearAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YLinearAccuracy ();
      }

      // ZLinearAccuracy
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZLinearAccuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZLinearAccuracy ();
      }

      // OffsetVolumetricPerformance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OffsetVolumetricPerformance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OffsetVolumetricPerformance ();
      }

      // VolumetricPerformance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VolumetricPerformance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VolumetricPerformance ();
      }

      // Repeatability
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Repeatability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Repeatability ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CartesianCMMB89TestType >
    _xsd_CartesianCMMB89TestType_type_serializer_init (
      L"CartesianCMMB89TestType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AACMMB89TestType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAccuracyTestBaseType& > (i);

      // EffectiveDiameterPerformanceTest
      //
      if (i.EffectiveDiameterPerformanceTest ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EffectiveDiameterPerformanceTest",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EffectiveDiameterPerformanceTest ();
      }

      // SinglePointArticulationPerformanceTest
      //
      if (i.SinglePointArticulationPerformanceTest ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SinglePointArticulationPerformanceTest",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SinglePointArticulationPerformanceTest ();
      }

      // VolumetricPerformanceTest
      //
      if (i.VolumetricPerformanceTest ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VolumetricPerformanceTest",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VolumetricPerformanceTest ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AACMMB89TestType >
    _xsd_AACMMB89TestType_type_serializer_init (
      L"AACMMB89TestType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EffectiveDiameterPerformanceTestType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AverageDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AverageDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.AverageDiameter ());
      }

      // StandardDeviation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardDeviation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.StandardDeviation ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SinglePointArticulationPerformanceTestType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxDeviationFromAverageNear
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationFromAverageNear",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxDeviationFromAverageNear ();
      }

      // MaxDeviationFromAverageFar
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationFromAverageFar",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxDeviationFromAverageFar ();
      }

      // MaxDeviationFromAverageMiddle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxDeviationFromAverageMiddle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxDeviationFromAverageMiddle ();
      }

      // TwiceStandardDeviationNear
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TwiceStandardDeviationNear",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TwiceStandardDeviationNear ();
      }

      // TwiceStandardDeviationFar
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TwiceStandardDeviationFar",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TwiceStandardDeviationFar ();
      }

      // TwiceStandardDeviationMiddle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TwiceStandardDeviationMiddle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TwiceStandardDeviationMiddle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VolumetricPerformanceTestType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DeviationsFromCalibration
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeviationsFromCalibration",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeviationsFromCalibration ();
      }

      // TwiceStandardDeviation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TwiceStandardDeviation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TwiceStandardDeviation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TwentyLinearValuesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearValue
      //
      for (TwentyLinearValuesType::LinearValue_const_iterator
           b (i.LinearValue ().begin ()), n (i.LinearValue ().end ());
           b != n; ++b)
      {
        const TwentyLinearValuesType::LinearValue_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ISO10360TestType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAccuracyTestBaseType& > (i);

      // MaxErrorConstant
      //
      if (i.MaxErrorConstant ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxErrorConstant",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaxErrorConstant ();
      }

      // LinearError
      //
      if (i.LinearError ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearError ();
      }

      // LesserError
      //
      if (i.LesserError ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LesserError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LesserError ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ISO10360TestType >
    _xsd_ISO10360TestType_type_serializer_init (
      L"ISO10360TestType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LinearErrorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseError ();
      }

      // ErrorRate
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ErrorRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.ErrorRate ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LesserErrorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxErrorConstant
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaxErrorConstant",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MaxErrorConstant ();
      }

      // LinearError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LinearError ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointAccuracyTestType& i)
    {
      e << static_cast< const ::xsd::qif30::CMMAccuracyTestBaseType& > (i);

      // Accuracy
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Accuracy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Accuracy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointAccuracyTestType >
    _xsd_PointAccuracyTestType_type_serializer_init (
      L"PointAccuracyTestType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AngularErrorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseError ();
      }

      // ErrorRate
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ErrorRate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.ErrorRate ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RotaryTableType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LocationOnCMM
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocationOnCMM",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LocationOnCMM ();
      }

      // AxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisDirection ();
      }

      // ZeroIndexDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZeroIndexDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZeroIndexDirection ();
      }

      // TableRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TableRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TableRadius ();
      }

      // TableErrors
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TableErrors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TableErrors ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TableErrorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AxialError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxialError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxialError ();
      }

      // RadialError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadialError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RadialError ();
      }

      // TangentialError
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentialError",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TangentialError ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CaliperType >
    _xsd_Caliper_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Caliper",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CaliperType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CaliperDialType >
    _xsd_CaliperDial_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CaliperDial",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CaliperDialType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CaliperDigitalType >
    _xsd_CaliperDigital_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CaliperDigital",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CaliperDigitalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MicrometerType >
    _xsd_Micrometer_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Micrometer",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MicrometerType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MicrometerAnalogType >
    _xsd_MicrometerAnalog_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"MicrometerAnalog",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MicrometerAnalogType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MicrometerDigitalType >
    _xsd_MicrometerDigital_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"MicrometerDigital",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MicrometerDigitalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GageDeviceType >
    _xsd_GageDevice_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"GageDevice",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GageDeviceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SineBarType >
    _xsd_SineBar_element_serializer_init (
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"SineBar",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SineBarType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CMMType >
    _xsd_CMM_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ManualMeasurementDeviceType >
    _xsd_ManualMeasurementDevice_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"ManualMeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ManualMeasurementDeviceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MicroscopeType >
    _xsd_Microscope_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Microscope",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MicroscopeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AutocollimatorType >
    _xsd_Autocollimator_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Autocollimator",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AutocollimatorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OpticalComparatorType >
    _xsd_OpticalComparator_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"OpticalComparator",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OpticalComparatorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UniversalLengthMeasuringType >
    _xsd_UniversalLengthMeasuring_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"UniversalLengthMeasuring",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UniversalLengthMeasuringType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LaserRadarType >
    _xsd_LaserRadar_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserRadar",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LaserRadarType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LaserTrackerType >
    _xsd_LaserTracker_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserTracker",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LaserTrackerType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ComputedTomographyType >
    _xsd_ComputedTomography_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"ComputedTomography",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ComputedTomographyType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TheodoliteType >
    _xsd_Theodolite_element_serializer_init (
      L"MeasurementDevice",
      L"http://qifstandards.org/xsd/qif3",
      L"Theodolite",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TheodoliteType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AACMMType >
    _xsd_AACMM_element_serializer_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AACMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianCMMType >
    _xsd_CartesianCMM_element_serializer_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianCMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MultipleCarriageCartesianCMMType >
    _xsd_MultipleCarriageCartesianCMM_element_serializer_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"MultipleCarriageCartesianCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MultipleCarriageCartesianCMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ParallelLinkCMMType >
    _xsd_ParallelLinkCMM_element_serializer_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelLinkCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ParallelLinkCMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LightPenCMMType >
    _xsd_LightPenCMM_element_serializer_init (
      L"CMM",
      L"http://qifstandards.org/xsd/qif3",
      L"LightPenCMM",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LightPenCMMType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FPSTestType >
    _xsd_CartesianCMMFPSTest_element_serializer_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMFPSTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FPSTestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianCMMB89TestType >
    _xsd_CartesianCMMB89Test_element_serializer_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMB89Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianCMMB89TestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ISO10360TestType >
    _xsd_CartesianCMMISO10360Test_element_serializer_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMISO10360Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ISO10360TestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointAccuracyTestType >
    _xsd_CartesianCMMPointAccuracyTest_element_serializer_init (
      L"CartesianCMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMPointAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointAccuracyTestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AACMMB89TestType >
    _xsd_AACMMB89Test_element_serializer_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMB89Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AACMMB89TestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ISO10360TestType >
    _xsd_AACMMISO10360Test_element_serializer_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMISO10360Test",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ISO10360TestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointAccuracyTestType >
    _xsd_AACMMPointAccuracyTest_element_serializer_init (
      L"AACMMAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      L"AACMMPointAccuracyTest",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointAccuracyTestType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TactileProbeSensorBaseType >
    _xsd_DetachableTactileProbeSensor_element_serializer_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SimpleTactileProbeSensorType >
    _xsd_SimpleTactileProbeSensor_element_serializer_init (
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SimpleTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ComplexTactileProbeSensorType >
    _xsd_ComplexTactileProbeSensor_element_serializer_init (
      L"DetachableTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ComplexTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ComplexTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CapacitiveSensorType >
    _xsd_DetachableCapacitiveSensor_element_serializer_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableCapacitiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CapacitiveSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearVariableDifferentialTransformerSensorType >
    _xsd_DetachableLVDTSensor_element_serializer_init (
      L"DetachableSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"DetachableLVDTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearVariableDifferentialTransformerSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ClosedShellSetWorkingVolumeType >
    _xsd_ClosedShellSetWorkingVolume_element_serializer_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"ClosedShellSetWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ClosedShellSetWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianWorkingVolumeType >
    _xsd_CartesianWorkingVolume_element_serializer_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalWorkingVolumeType >
    _xsd_SphericalWorkingVolume_element_serializer_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricalWorkingVolumeType >
    _xsd_CylindricalWorkingVolume_element_serializer_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedWorkingVolumeType >
    _xsd_UserDefinedWorkingVolume_element_serializer_init (
      L"WorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EffectiveClosedShellSetWorkingVolumeType >
    _xsd_EffectiveClosedShellSetWorkingVolume_element_serializer_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveClosedShellSetWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EffectiveClosedShellSetWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EffectiveCartesianWorkingVolumeType >
    _xsd_EffectiveCartesianWorkingVolume_element_serializer_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveCartesianWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EffectiveCartesianWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EffectiveSphericalWorkingVolumeType >
    _xsd_EffectiveSphericalWorkingVolume_element_serializer_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveSphericalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EffectiveSphericalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EffectiveCylindricalWorkingVolumeType >
    _xsd_EffectiveCylindricalWorkingVolume_element_serializer_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveCylindricalWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EffectiveCylindricalWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EffectiveUserDefinedWorkingVolumeType >
    _xsd_EffectiveUserDefinedWorkingVolume_element_serializer_init (
      L"EffectiveWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      L"EffectiveUserDefinedWorkingVolume",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EffectiveUserDefinedWorkingVolumeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearResolutionType >
    _xsd_LinearResolution_element_serializer_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearResolutionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianResolutionType >
    _xsd_CartesianResolution_element_serializer_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianResolutionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalResolutionType >
    _xsd_SphericalResolution_element_serializer_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalResolutionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UserDefinedResolutionType >
    _xsd_UserDefinedResolution_element_serializer_init (
      L"Resolution",
      L"http://qifstandards.org/xsd/qif3",
      L"UserDefinedResolution",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UserDefinedResolutionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianCMMSpeedsType >
    _xsd_CartesianCMMSpeeds_element_serializer_init (
      L"CMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianCMMSpeedsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ParallelLinkCMMSpeedsType >
    _xsd_ParallelLinkCMMSpeeds_element_serializer_init (
      L"CMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      L"ParallelLinkCMMSpeeds",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ParallelLinkCMMSpeedsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::RotaryAxisType >
    _xsd_RotaryAxis_element_serializer_init (
      L"Axis",
      L"http://qifstandards.org/xsd/qif3",
      L"RotaryAxis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::RotaryAxisType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearAxisType >
    _xsd_LinearAxis_element_serializer_init (
      L"Axis",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearAxis",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearAxisType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianMeasurementDeviceScalesType >
    _xsd_CartesianMeasurementDeviceScales_element_serializer_init (
      L"Scales",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianMeasurementDeviceScales",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianMeasurementDeviceScalesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CartesianCMMAxisDirectionsType >
    _xsd_CartesianCMMAxisDirections_element_serializer_init (
      L"CMMAxisDirections",
      L"http://qifstandards.org/xsd/qif3",
      L"CartesianCMMAxisDirections",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CartesianCMMAxisDirectionsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithIntegratedSensorBaseType >
    _xsd_ToolWithIntegratedSensor_element_serializer_init (
      L"Tool",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      0);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithLVDTSensorType >
    _xsd_ToolWithLVDTSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithLVDTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithLVDTSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithCapacitiveSensorType >
    _xsd_ToolWithCapacitiveSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithCapacitiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithCapacitiveSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithEddyCurrentSensorType >
    _xsd_ToolWithEddyCurrentSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithEddyCurrentSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithEddyCurrentSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithConfocalChromaticSensorType >
    _xsd_ToolWithConfocalChromaticSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithConfocalChromaticSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithConfocalChromaticSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithDrawWireSensorType >
    _xsd_ToolWithDrawWireSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDrawWireSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithDrawWireSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithMagnetoInductiveSensorType >
    _xsd_ToolWithMagnetoInductiveSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithMagnetoInductiveSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithMagnetoInductiveSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithDVRTSensorType >
    _xsd_ToolWithDVRTSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDVRTSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithDVRTSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithLaserTriangulationSensorType >
    _xsd_ToolWithLaserTriangulationSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithLaserTriangulationSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithLaserTriangulationSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithStructuredLightSensorType >
    _xsd_ToolWithStructuredLightSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithStructuredLightSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithStructuredLightSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithUltrasonicSensorType >
    _xsd_ToolWithUltrasonicSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithUltrasonicSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithUltrasonicSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithSimpleTactileProbeSensorType >
    _xsd_ToolWithSimpleTactileProbeSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithSimpleTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithSimpleTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithComplexTactileProbeSensorType >
    _xsd_ToolWithComplexTactileProbeSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithComplexTactileProbeSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithComplexTactileProbeSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithCCDCameraSensorType >
    _xsd_ToolWithCCDCameraSensor_element_serializer_init (
      L"ToolWithIntegratedSensor",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithCCDCameraSensor",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithCCDCameraSensorType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToolWithDetachableSensorsType >
    _xsd_ToolWithDetachableSensors_element_serializer_init (
      L"Tool",
      L"http://qifstandards.org/xsd/qif3",
      L"ToolWithDetachableSensors",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToolWithDetachableSensorsType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

