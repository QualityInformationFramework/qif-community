// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFAPPLICATIONS_QIFSTATISTICS_HXX
#define CXX___QIFAPPLICATIONS_QIFSTATISTICS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class StatisticalStudyPlanBaseType;
    class AbsoluteLimitsByUnitType;
    class LinearityStudyPlanType;
    class StabilityStudyPlanType;
    class MultipleProductInstanceStudyPlanBaseType;
    class BiasStudyPlanType;
    class FirstArticleStudyPlanType;
    class ProcessDifferenceStudyPlanType;
    class SimpleStudyPlanType;
    class CapabilityStudyPlanType;
    class GageRandRStudyEnumType;
    class CriteriaByUnitType;
    class GageRandRStudyPlanType;
    class ControlMethodType;
    class ControlMethodsType;
    class ProductionStudyPlanType;
    class StatisticalStudyResultsBaseType;
    class LinearityStudyResultsType;
    class StabilityStudyResultsType;
    class BiasStudyResultsType;
    class AbsoluteMeasurementsByUnitType;
    class FirstArticleStudyResultsType;
    class ProcessDifferenceStudyResultsType;
    class MultipleProductInstanceStudyResultsBaseType;
    class SimpleStudyResultsType;
    class CapabilityStudyResultsType;
    class GageRandRStudyResultsType;
    class ProductionStudyResultsType;
    class StatisticalStudyPlansType;
    class StatisticalStudiesResultsType;
    class CorrectiveActionPlanType;
    class CorrectiveActionPlansType;
    class StatisticsType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Statistics.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL StatisticalStudyPlanBaseType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // FeatureItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureItemIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureItemIds_type > FeatureItemIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureItemIds_type, wchar_t > FeatureItemIds_traits;

      const FeatureItemIds_optional&
      FeatureItemIds () const;

      FeatureItemIds_optional&
      FeatureItemIds ();

      void
      FeatureItemIds (const FeatureItemIds_type& x);

      void
      FeatureItemIds (const FeatureItemIds_optional& x);

      void
      FeatureItemIds (::std::unique_ptr< FeatureItemIds_type > p);

      // CalculateAverageFeatures
      //
      typedef ::xml_schema::boolean CalculateAverageFeatures_type;
      typedef ::xsd::cxx::tree::optional< CalculateAverageFeatures_type > CalculateAverageFeatures_optional;
      typedef ::xsd::cxx::tree::traits< CalculateAverageFeatures_type, wchar_t > CalculateAverageFeatures_traits;

      const CalculateAverageFeatures_optional&
      CalculateAverageFeatures () const;

      CalculateAverageFeatures_optional&
      CalculateAverageFeatures ();

      void
      CalculateAverageFeatures (const CalculateAverageFeatures_type& x);

      void
      CalculateAverageFeatures (const CalculateAverageFeatures_optional& x);

      // CharacteristicItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicItemIds_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicItemIds_type > CharacteristicItemIds_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemIds_type, wchar_t > CharacteristicItemIds_traits;

      const CharacteristicItemIds_optional&
      CharacteristicItemIds () const;

      CharacteristicItemIds_optional&
      CharacteristicItemIds ();

      void
      CharacteristicItemIds (const CharacteristicItemIds_type& x);

      void
      CharacteristicItemIds (const CharacteristicItemIds_optional& x);

      void
      CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > p);

      // StatsValuesPerChar
      //
      typedef ::xsd::qif30::ListAccumulatedStatsValuesType StatsValuesPerChar_type;
      typedef ::xsd::cxx::tree::sequence< StatsValuesPerChar_type > StatsValuesPerChar_sequence;
      typedef xsd::cxx::tree::sequence< StatsValuesPerChar_type >::iterator StatsValuesPerChar_iterator;
      typedef xsd::cxx::tree::sequence< StatsValuesPerChar_type >::const_iterator StatsValuesPerChar_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatsValuesPerChar_type, wchar_t > StatsValuesPerChar_traits;

      const StatsValuesPerChar_sequence&
      StatsValuesPerChar () const;

      StatsValuesPerChar_sequence&
      StatsValuesPerChar ();

      void
      StatsValuesPerChar (const StatsValuesPerChar_sequence& s);

      // StatsValuesPerSubgroup
      //
      typedef ::xsd::qif30::ListSubgroupStatsValuesType StatsValuesPerSubgroup_type;
      typedef ::xsd::cxx::tree::sequence< StatsValuesPerSubgroup_type > StatsValuesPerSubgroup_sequence;
      typedef xsd::cxx::tree::sequence< StatsValuesPerSubgroup_type >::iterator StatsValuesPerSubgroup_iterator;
      typedef xsd::cxx::tree::sequence< StatsValuesPerSubgroup_type >::const_iterator StatsValuesPerSubgroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatsValuesPerSubgroup_type, wchar_t > StatsValuesPerSubgroup_traits;

      const StatsValuesPerSubgroup_sequence&
      StatsValuesPerSubgroup () const;

      StatsValuesPerSubgroup_sequence&
      StatsValuesPerSubgroup ();

      void
      StatsValuesPerSubgroup (const StatsValuesPerSubgroup_sequence& s);

      // StatsValuesSummarys
      //
      typedef ::xsd::qif30::SummaryStatsValuesListType StatsValuesSummarys_type;
      typedef ::xsd::cxx::tree::sequence< StatsValuesSummarys_type > StatsValuesSummarys_sequence;
      typedef xsd::cxx::tree::sequence< StatsValuesSummarys_type >::iterator StatsValuesSummarys_iterator;
      typedef xsd::cxx::tree::sequence< StatsValuesSummarys_type >::const_iterator StatsValuesSummarys_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatsValuesSummarys_type, wchar_t > StatsValuesSummarys_traits;

      const StatsValuesSummarys_sequence&
      StatsValuesSummarys () const;

      StatsValuesSummarys_sequence&
      StatsValuesSummarys ();

      void
      StatsValuesSummarys (const StatsValuesSummarys_sequence& s);

      // PreInspectionTraceability
      //
      typedef ::xsd::qif30::PreInspectionTraceabilityType PreInspectionTraceability_type;
      typedef ::xsd::cxx::tree::optional< PreInspectionTraceability_type > PreInspectionTraceability_optional;
      typedef ::xsd::cxx::tree::traits< PreInspectionTraceability_type, wchar_t > PreInspectionTraceability_traits;

      const PreInspectionTraceability_optional&
      PreInspectionTraceability () const;

      PreInspectionTraceability_optional&
      PreInspectionTraceability ();

      void
      PreInspectionTraceability (const PreInspectionTraceability_type& x);

      void
      PreInspectionTraceability (const PreInspectionTraceability_optional& x);

      void
      PreInspectionTraceability (::std::unique_ptr< PreInspectionTraceability_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // PlanId
      //
      typedef ::xsd::qif30::QIFReferenceType PlanId_type;
      typedef ::xsd::cxx::tree::optional< PlanId_type > PlanId_optional;
      typedef ::xsd::cxx::tree::traits< PlanId_type, wchar_t > PlanId_traits;

      const PlanId_optional&
      PlanId () const;

      PlanId_optional&
      PlanId ();

      void
      PlanId (const PlanId_type& x);

      void
      PlanId (const PlanId_optional& x);

      void
      PlanId (::std::unique_ptr< PlanId_type > p);

      // SoftwareId
      //
      typedef ::xsd::qif30::QIFReferenceType SoftwareId_type;
      typedef ::xsd::cxx::tree::optional< SoftwareId_type > SoftwareId_optional;
      typedef ::xsd::cxx::tree::traits< SoftwareId_type, wchar_t > SoftwareId_traits;

      const SoftwareId_optional&
      SoftwareId () const;

      SoftwareId_optional&
      SoftwareId ();

      void
      SoftwareId (const SoftwareId_type& x);

      void
      SoftwareId (const SoftwareId_optional& x);

      void
      SoftwareId (::std::unique_ptr< SoftwareId_type > p);

      // StandardId
      //
      typedef ::xsd::qif30::QIFReferenceType StandardId_type;
      typedef ::xsd::cxx::tree::optional< StandardId_type > StandardId_optional;
      typedef ::xsd::cxx::tree::traits< StandardId_type, wchar_t > StandardId_traits;

      const StandardId_optional&
      StandardId () const;

      StandardId_optional&
      StandardId ();

      void
      StandardId (const StandardId_type& x);

      void
      StandardId (const StandardId_optional& x);

      void
      StandardId (::std::unique_ptr< StandardId_type > p);

      // CorrectiveActionPlanId
      //
      typedef ::xsd::qif30::QIFReferenceType CorrectiveActionPlanId_type;
      typedef ::xsd::cxx::tree::optional< CorrectiveActionPlanId_type > CorrectiveActionPlanId_optional;
      typedef ::xsd::cxx::tree::traits< CorrectiveActionPlanId_type, wchar_t > CorrectiveActionPlanId_traits;

      const CorrectiveActionPlanId_optional&
      CorrectiveActionPlanId () const;

      CorrectiveActionPlanId_optional&
      CorrectiveActionPlanId ();

      void
      CorrectiveActionPlanId (const CorrectiveActionPlanId_type& x);

      void
      CorrectiveActionPlanId (const CorrectiveActionPlanId_optional& x);

      void
      CorrectiveActionPlanId (::std::unique_ptr< CorrectiveActionPlanId_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      StatisticalStudyPlanBaseType ();

      StatisticalStudyPlanBaseType (const id_type&);

      StatisticalStudyPlanBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      StatisticalStudyPlanBaseType (const StatisticalStudyPlanBaseType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual StatisticalStudyPlanBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      StatisticalStudyPlanBaseType&
      operator= (const StatisticalStudyPlanBaseType& x);

      virtual 
      ~StatisticalStudyPlanBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      Attributes_optional Attributes_;
      FeatureItemIds_optional FeatureItemIds_;
      CalculateAverageFeatures_optional CalculateAverageFeatures_;
      CharacteristicItemIds_optional CharacteristicItemIds_;
      StatsValuesPerChar_sequence StatsValuesPerChar_;
      StatsValuesPerSubgroup_sequence StatsValuesPerSubgroup_;
      StatsValuesSummarys_sequence StatsValuesSummarys_;
      PreInspectionTraceability_optional PreInspectionTraceability_;
      Name_optional Name_;
      Description_optional Description_;
      PlanId_optional PlanId_;
      SoftwareId_optional SoftwareId_;
      StandardId_optional StandardId_;
      CorrectiveActionPlanId_optional CorrectiveActionPlanId_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL AbsoluteLimitsByUnitType: public ::xml_schema::type
    {
      public:
      // LinearLimit
      //
      typedef ::xsd::qif30::LinearValueType LinearLimit_type;
      typedef ::xsd::cxx::tree::optional< LinearLimit_type > LinearLimit_optional;
      typedef ::xsd::cxx::tree::traits< LinearLimit_type, wchar_t > LinearLimit_traits;

      const LinearLimit_optional&
      LinearLimit () const;

      LinearLimit_optional&
      LinearLimit ();

      void
      LinearLimit (const LinearLimit_type& x);

      void
      LinearLimit (const LinearLimit_optional& x);

      void
      LinearLimit (::std::unique_ptr< LinearLimit_type > p);

      // AngularLimit
      //
      typedef ::xsd::qif30::AngularValueType AngularLimit_type;
      typedef ::xsd::cxx::tree::optional< AngularLimit_type > AngularLimit_optional;
      typedef ::xsd::cxx::tree::traits< AngularLimit_type, wchar_t > AngularLimit_traits;

      const AngularLimit_optional&
      AngularLimit () const;

      AngularLimit_optional&
      AngularLimit ();

      void
      AngularLimit (const AngularLimit_type& x);

      void
      AngularLimit (const AngularLimit_optional& x);

      void
      AngularLimit (::std::unique_ptr< AngularLimit_type > p);

      // AreaLimit
      //
      typedef ::xsd::qif30::AreaValueType AreaLimit_type;
      typedef ::xsd::cxx::tree::optional< AreaLimit_type > AreaLimit_optional;
      typedef ::xsd::cxx::tree::traits< AreaLimit_type, wchar_t > AreaLimit_traits;

      const AreaLimit_optional&
      AreaLimit () const;

      AreaLimit_optional&
      AreaLimit ();

      void
      AreaLimit (const AreaLimit_type& x);

      void
      AreaLimit (const AreaLimit_optional& x);

      void
      AreaLimit (::std::unique_ptr< AreaLimit_type > p);

      // ForceLimit
      //
      typedef ::xsd::qif30::ForceValueType ForceLimit_type;
      typedef ::xsd::cxx::tree::optional< ForceLimit_type > ForceLimit_optional;
      typedef ::xsd::cxx::tree::traits< ForceLimit_type, wchar_t > ForceLimit_traits;

      const ForceLimit_optional&
      ForceLimit () const;

      ForceLimit_optional&
      ForceLimit ();

      void
      ForceLimit (const ForceLimit_type& x);

      void
      ForceLimit (const ForceLimit_optional& x);

      void
      ForceLimit (::std::unique_ptr< ForceLimit_type > p);

      // MassLimit
      //
      typedef ::xsd::qif30::MassValueType MassLimit_type;
      typedef ::xsd::cxx::tree::optional< MassLimit_type > MassLimit_optional;
      typedef ::xsd::cxx::tree::traits< MassLimit_type, wchar_t > MassLimit_traits;

      const MassLimit_optional&
      MassLimit () const;

      MassLimit_optional&
      MassLimit ();

      void
      MassLimit (const MassLimit_type& x);

      void
      MassLimit (const MassLimit_optional& x);

      void
      MassLimit (::std::unique_ptr< MassLimit_type > p);

      // PressureLimit
      //
      typedef ::xsd::qif30::PressureValueType PressureLimit_type;
      typedef ::xsd::cxx::tree::optional< PressureLimit_type > PressureLimit_optional;
      typedef ::xsd::cxx::tree::traits< PressureLimit_type, wchar_t > PressureLimit_traits;

      const PressureLimit_optional&
      PressureLimit () const;

      PressureLimit_optional&
      PressureLimit ();

      void
      PressureLimit (const PressureLimit_type& x);

      void
      PressureLimit (const PressureLimit_optional& x);

      void
      PressureLimit (::std::unique_ptr< PressureLimit_type > p);

      // SpeedLimit
      //
      typedef ::xsd::qif30::SpeedValueType SpeedLimit_type;
      typedef ::xsd::cxx::tree::optional< SpeedLimit_type > SpeedLimit_optional;
      typedef ::xsd::cxx::tree::traits< SpeedLimit_type, wchar_t > SpeedLimit_traits;

      const SpeedLimit_optional&
      SpeedLimit () const;

      SpeedLimit_optional&
      SpeedLimit ();

      void
      SpeedLimit (const SpeedLimit_type& x);

      void
      SpeedLimit (const SpeedLimit_optional& x);

      void
      SpeedLimit (::std::unique_ptr< SpeedLimit_type > p);

      // TemperatureLimit
      //
      typedef ::xsd::qif30::TemperatureValueType TemperatureLimit_type;
      typedef ::xsd::cxx::tree::optional< TemperatureLimit_type > TemperatureLimit_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureLimit_type, wchar_t > TemperatureLimit_traits;

      const TemperatureLimit_optional&
      TemperatureLimit () const;

      TemperatureLimit_optional&
      TemperatureLimit ();

      void
      TemperatureLimit (const TemperatureLimit_type& x);

      void
      TemperatureLimit (const TemperatureLimit_optional& x);

      void
      TemperatureLimit (::std::unique_ptr< TemperatureLimit_type > p);

      // TimeLimit
      //
      typedef ::xsd::qif30::TimeValueType TimeLimit_type;
      typedef ::xsd::cxx::tree::optional< TimeLimit_type > TimeLimit_optional;
      typedef ::xsd::cxx::tree::traits< TimeLimit_type, wchar_t > TimeLimit_traits;

      const TimeLimit_optional&
      TimeLimit () const;

      TimeLimit_optional&
      TimeLimit ();

      void
      TimeLimit (const TimeLimit_type& x);

      void
      TimeLimit (const TimeLimit_optional& x);

      void
      TimeLimit (::std::unique_ptr< TimeLimit_type > p);

      // UserDefinedUnitLimit
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType UserDefinedUnitLimit_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnitLimit_type > UserDefinedUnitLimit_sequence;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitLimit_type >::iterator UserDefinedUnitLimit_iterator;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitLimit_type >::const_iterator UserDefinedUnitLimit_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitLimit_type, wchar_t > UserDefinedUnitLimit_traits;

      const UserDefinedUnitLimit_sequence&
      UserDefinedUnitLimit () const;

      UserDefinedUnitLimit_sequence&
      UserDefinedUnitLimit ();

      void
      UserDefinedUnitLimit (const UserDefinedUnitLimit_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AbsoluteLimitsByUnitType ();

      AbsoluteLimitsByUnitType (const n_type&);

      AbsoluteLimitsByUnitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      AbsoluteLimitsByUnitType (const AbsoluteLimitsByUnitType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual AbsoluteLimitsByUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AbsoluteLimitsByUnitType&
      operator= (const AbsoluteLimitsByUnitType& x);

      virtual 
      ~AbsoluteLimitsByUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearLimit_optional LinearLimit_;
      AngularLimit_optional AngularLimit_;
      AreaLimit_optional AreaLimit_;
      ForceLimit_optional ForceLimit_;
      MassLimit_optional MassLimit_;
      PressureLimit_optional PressureLimit_;
      SpeedLimit_optional SpeedLimit_;
      TemperatureLimit_optional TemperatureLimit_;
      TimeLimit_optional TimeLimit_;
      UserDefinedUnitLimit_sequence UserDefinedUnitLimit_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LinearityStudyPlanType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // GoodnessOfFitThreshold
      //
      typedef ::xml_schema::decimal GoodnessOfFitThreshold_type;
      typedef ::xsd::cxx::tree::optional< GoodnessOfFitThreshold_type > GoodnessOfFitThreshold_optional;
      typedef ::xsd::cxx::tree::traits< GoodnessOfFitThreshold_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > GoodnessOfFitThreshold_traits;

      const GoodnessOfFitThreshold_optional&
      GoodnessOfFitThreshold () const;

      GoodnessOfFitThreshold_optional&
      GoodnessOfFitThreshold ();

      void
      GoodnessOfFitThreshold (const GoodnessOfFitThreshold_type& x);

      void
      GoodnessOfFitThreshold (const GoodnessOfFitThreshold_optional& x);

      // AbsoluteMinimums
      //
      typedef ::xsd::qif30::AbsoluteLimitsByUnitType AbsoluteMinimums_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteMinimums_type > AbsoluteMinimums_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteMinimums_type, wchar_t > AbsoluteMinimums_traits;

      const AbsoluteMinimums_optional&
      AbsoluteMinimums () const;

      AbsoluteMinimums_optional&
      AbsoluteMinimums ();

      void
      AbsoluteMinimums (const AbsoluteMinimums_type& x);

      void
      AbsoluteMinimums (const AbsoluteMinimums_optional& x);

      void
      AbsoluteMinimums (::std::unique_ptr< AbsoluteMinimums_type > p);

      // RelativeLinearityMinimum
      //
      typedef ::xml_schema::decimal RelativeLinearityMinimum_type;
      typedef ::xsd::cxx::tree::optional< RelativeLinearityMinimum_type > RelativeLinearityMinimum_optional;
      typedef ::xsd::cxx::tree::traits< RelativeLinearityMinimum_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > RelativeLinearityMinimum_traits;

      const RelativeLinearityMinimum_optional&
      RelativeLinearityMinimum () const;

      RelativeLinearityMinimum_optional&
      RelativeLinearityMinimum ();

      void
      RelativeLinearityMinimum (const RelativeLinearityMinimum_type& x);

      void
      RelativeLinearityMinimum (const RelativeLinearityMinimum_optional& x);

      // Constructors.
      //
      LinearityStudyPlanType ();

      LinearityStudyPlanType (const id_type&);

      LinearityStudyPlanType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LinearityStudyPlanType (const LinearityStudyPlanType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual LinearityStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearityStudyPlanType&
      operator= (const LinearityStudyPlanType& x);

      virtual 
      ~LinearityStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      GoodnessOfFitThreshold_optional GoodnessOfFitThreshold_;
      AbsoluteMinimums_optional AbsoluteMinimums_;
      RelativeLinearityMinimum_optional RelativeLinearityMinimum_;
    };

    class QIF30_SYMBOL_DECL StabilityStudyPlanType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // SampleSize
      //
      typedef ::xml_schema::positive_integer SampleSize_type;
      typedef ::xsd::cxx::tree::traits< SampleSize_type, wchar_t > SampleSize_traits;

      const SampleSize_type&
      SampleSize () const;

      SampleSize_type&
      SampleSize ();

      void
      SampleSize (const SampleSize_type& x);

      // SampleFrequency
      //
      typedef ::xml_schema::positive_integer SampleFrequency_type;
      typedef ::xsd::cxx::tree::traits< SampleFrequency_type, wchar_t > SampleFrequency_traits;

      const SampleFrequency_type&
      SampleFrequency () const;

      SampleFrequency_type&
      SampleFrequency ();

      void
      SampleFrequency (const SampleFrequency_type& x);

      // SamplingInterval
      //
      typedef ::xsd::qif30::SamplingIntervalType SamplingInterval_type;
      typedef ::xsd::cxx::tree::traits< SamplingInterval_type, wchar_t > SamplingInterval_traits;

      const SamplingInterval_type&
      SamplingInterval () const;

      SamplingInterval_type&
      SamplingInterval ();

      void
      SamplingInterval (const SamplingInterval_type& x);

      void
      SamplingInterval (::std::unique_ptr< SamplingInterval_type > p);

      // Constructors.
      //
      StabilityStudyPlanType ();

      StabilityStudyPlanType (const id_type&,
                              const SampleSize_type&,
                              const SampleFrequency_type&,
                              const SamplingInterval_type&);

      StabilityStudyPlanType (const id_type&,
                              const SampleSize_type&,
                              const SampleFrequency_type&,
                              ::std::unique_ptr< SamplingInterval_type >);

      StabilityStudyPlanType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      StabilityStudyPlanType (const StabilityStudyPlanType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual StabilityStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StabilityStudyPlanType&
      operator= (const StabilityStudyPlanType& x);

      virtual 
      ~StabilityStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ::xsd::cxx::tree::one< SampleSize_type > SampleSize_;
      ::xsd::cxx::tree::one< SampleFrequency_type > SampleFrequency_;
      ::xsd::cxx::tree::one< SamplingInterval_type > SamplingInterval_;
    };

    class QIF30_SYMBOL_DECL MultipleProductInstanceStudyPlanBaseType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // NumberOfSamples
      //
      typedef ::xml_schema::positive_integer NumberOfSamples_type;
      typedef ::xsd::cxx::tree::traits< NumberOfSamples_type, wchar_t > NumberOfSamples_traits;

      const NumberOfSamples_type&
      NumberOfSamples () const;

      NumberOfSamples_type&
      NumberOfSamples ();

      void
      NumberOfSamples (const NumberOfSamples_type& x);

      // SubgroupSize
      //
      typedef ::xml_schema::positive_integer SubgroupSize_type;
      typedef ::xsd::cxx::tree::optional< SubgroupSize_type > SubgroupSize_optional;
      typedef ::xsd::cxx::tree::traits< SubgroupSize_type, wchar_t > SubgroupSize_traits;

      const SubgroupSize_optional&
      SubgroupSize () const;

      SubgroupSize_optional&
      SubgroupSize ();

      void
      SubgroupSize (const SubgroupSize_type& x);

      void
      SubgroupSize (const SubgroupSize_optional& x);

      // Constructors.
      //
      MultipleProductInstanceStudyPlanBaseType ();

      MultipleProductInstanceStudyPlanBaseType (const id_type&,
                                                const NumberOfSamples_type&);

      MultipleProductInstanceStudyPlanBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      MultipleProductInstanceStudyPlanBaseType (const MultipleProductInstanceStudyPlanBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual MultipleProductInstanceStudyPlanBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MultipleProductInstanceStudyPlanBaseType&
      operator= (const MultipleProductInstanceStudyPlanBaseType& x);

      virtual 
      ~MultipleProductInstanceStudyPlanBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< NumberOfSamples_type > NumberOfSamples_;
      SubgroupSize_optional SubgroupSize_;
    };

    class QIF30_SYMBOL_DECL BiasStudyPlanType: public ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType
    {
      public:
      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // Constructors.
      //
      BiasStudyPlanType ();

      BiasStudyPlanType (const id_type&,
                         const NumberOfSamples_type&);

      BiasStudyPlanType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      BiasStudyPlanType (const BiasStudyPlanType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual BiasStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BiasStudyPlanType&
      operator= (const BiasStudyPlanType& x);

      virtual 
      ~BiasStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
    };

    class QIF30_SYMBOL_DECL FirstArticleStudyPlanType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // InSpecRatio
      //
      typedef ::xml_schema::decimal InSpecRatio_type;
      typedef ::xsd::cxx::tree::traits< InSpecRatio_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > InSpecRatio_traits;

      const InSpecRatio_type&
      InSpecRatio () const;

      InSpecRatio_type&
      InSpecRatio ();

      void
      InSpecRatio (const InSpecRatio_type& x);

      // AbsoluteMaximums
      //
      typedef ::xsd::qif30::AbsoluteLimitsByUnitType AbsoluteMaximums_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteMaximums_type > AbsoluteMaximums_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteMaximums_type, wchar_t > AbsoluteMaximums_traits;

      const AbsoluteMaximums_optional&
      AbsoluteMaximums () const;

      AbsoluteMaximums_optional&
      AbsoluteMaximums ();

      void
      AbsoluteMaximums (const AbsoluteMaximums_type& x);

      void
      AbsoluteMaximums (const AbsoluteMaximums_optional& x);

      void
      AbsoluteMaximums (::std::unique_ptr< AbsoluteMaximums_type > p);

      // RelativeMaximum
      //
      typedef ::xml_schema::decimal RelativeMaximum_type;
      typedef ::xsd::cxx::tree::optional< RelativeMaximum_type > RelativeMaximum_optional;
      typedef ::xsd::cxx::tree::traits< RelativeMaximum_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > RelativeMaximum_traits;

      const RelativeMaximum_optional&
      RelativeMaximum () const;

      RelativeMaximum_optional&
      RelativeMaximum ();

      void
      RelativeMaximum (const RelativeMaximum_type& x);

      void
      RelativeMaximum (const RelativeMaximum_optional& x);

      // Constructors.
      //
      FirstArticleStudyPlanType ();

      FirstArticleStudyPlanType (const id_type&,
                                 const InSpecRatio_type&);

      FirstArticleStudyPlanType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      FirstArticleStudyPlanType (const FirstArticleStudyPlanType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual FirstArticleStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FirstArticleStudyPlanType&
      operator= (const FirstArticleStudyPlanType& x);

      virtual 
      ~FirstArticleStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InSpecRatio_type > InSpecRatio_;
      AbsoluteMaximums_optional AbsoluteMaximums_;
      RelativeMaximum_optional RelativeMaximum_;
    };

    class QIF30_SYMBOL_DECL ProcessDifferenceStudyPlanType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // NumberOfSamples
      //
      typedef ::xml_schema::positive_integer NumberOfSamples_type;
      typedef ::xsd::cxx::tree::traits< NumberOfSamples_type, wchar_t > NumberOfSamples_traits;

      const NumberOfSamples_type&
      NumberOfSamples () const;

      NumberOfSamples_type&
      NumberOfSamples ();

      void
      NumberOfSamples (const NumberOfSamples_type& x);

      // SubgroupSize
      //
      typedef ::xml_schema::positive_integer SubgroupSize_type;
      typedef ::xsd::cxx::tree::traits< SubgroupSize_type, wchar_t > SubgroupSize_traits;

      const SubgroupSize_type&
      SubgroupSize () const;

      SubgroupSize_type&
      SubgroupSize ();

      void
      SubgroupSize (const SubgroupSize_type& x);

      static SubgroupSize_type
      SubgroupSize_default_value ();

      // ManufacturingProcessId
      //
      typedef ::xsd::qif30::QIFReferenceType ManufacturingProcessId_type;
      typedef ::xsd::cxx::tree::optional< ManufacturingProcessId_type > ManufacturingProcessId_optional;
      typedef ::xsd::cxx::tree::traits< ManufacturingProcessId_type, wchar_t > ManufacturingProcessId_traits;

      const ManufacturingProcessId_optional&
      ManufacturingProcessId () const;

      ManufacturingProcessId_optional&
      ManufacturingProcessId ();

      void
      ManufacturingProcessId (const ManufacturingProcessId_type& x);

      void
      ManufacturingProcessId (const ManufacturingProcessId_optional& x);

      void
      ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > p);

      // AbsoluteDifferences
      //
      typedef ::xsd::qif30::AbsoluteLimitsByUnitType AbsoluteDifferences_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteDifferences_type > AbsoluteDifferences_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteDifferences_type, wchar_t > AbsoluteDifferences_traits;

      const AbsoluteDifferences_optional&
      AbsoluteDifferences () const;

      AbsoluteDifferences_optional&
      AbsoluteDifferences ();

      void
      AbsoluteDifferences (const AbsoluteDifferences_type& x);

      void
      AbsoluteDifferences (const AbsoluteDifferences_optional& x);

      void
      AbsoluteDifferences (::std::unique_ptr< AbsoluteDifferences_type > p);

      // RelativeDifference
      //
      typedef ::xml_schema::decimal RelativeDifference_type;
      typedef ::xsd::cxx::tree::optional< RelativeDifference_type > RelativeDifference_optional;
      typedef ::xsd::cxx::tree::traits< RelativeDifference_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > RelativeDifference_traits;

      const RelativeDifference_optional&
      RelativeDifference () const;

      RelativeDifference_optional&
      RelativeDifference ();

      void
      RelativeDifference (const RelativeDifference_type& x);

      void
      RelativeDifference (const RelativeDifference_optional& x);

      // Constructors.
      //
      ProcessDifferenceStudyPlanType ();

      ProcessDifferenceStudyPlanType (const id_type&,
                                      const NumberOfSamples_type&,
                                      const SubgroupSize_type&);

      ProcessDifferenceStudyPlanType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ProcessDifferenceStudyPlanType (const ProcessDifferenceStudyPlanType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ProcessDifferenceStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProcessDifferenceStudyPlanType&
      operator= (const ProcessDifferenceStudyPlanType& x);

      virtual 
      ~ProcessDifferenceStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< NumberOfSamples_type > NumberOfSamples_;
      ::xsd::cxx::tree::one< SubgroupSize_type > SubgroupSize_;
      ManufacturingProcessId_optional ManufacturingProcessId_;
      AbsoluteDifferences_optional AbsoluteDifferences_;
      RelativeDifference_optional RelativeDifference_;
    };

    class QIF30_SYMBOL_DECL SimpleStudyPlanType: public ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType
    {
      public:
      // Constructors.
      //
      SimpleStudyPlanType ();

      SimpleStudyPlanType (const id_type&,
                           const NumberOfSamples_type&);

      SimpleStudyPlanType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SimpleStudyPlanType (const SimpleStudyPlanType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SimpleStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SimpleStudyPlanType&
      operator= (const SimpleStudyPlanType&) = default;
#endif

      virtual 
      ~SimpleStudyPlanType ();
    };

    class QIF30_SYMBOL_DECL CapabilityStudyPlanType: public ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType
    {
      public:
      // CpkThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType CpkThreshold_type;
      typedef ::xsd::cxx::tree::optional< CpkThreshold_type > CpkThreshold_optional;
      typedef ::xsd::cxx::tree::traits< CpkThreshold_type, wchar_t > CpkThreshold_traits;

      const CpkThreshold_optional&
      CpkThreshold () const;

      CpkThreshold_optional&
      CpkThreshold ();

      void
      CpkThreshold (const CpkThreshold_type& x);

      void
      CpkThreshold (const CpkThreshold_optional& x);

      void
      CpkThreshold (::std::unique_ptr< CpkThreshold_type > p);

      // PpkThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType PpkThreshold_type;
      typedef ::xsd::cxx::tree::optional< PpkThreshold_type > PpkThreshold_optional;
      typedef ::xsd::cxx::tree::traits< PpkThreshold_type, wchar_t > PpkThreshold_traits;

      const PpkThreshold_optional&
      PpkThreshold () const;

      PpkThreshold_optional&
      PpkThreshold ();

      void
      PpkThreshold (const PpkThreshold_type& x);

      void
      PpkThreshold (const PpkThreshold_optional& x);

      void
      PpkThreshold (::std::unique_ptr< PpkThreshold_type > p);

      // Constructors.
      //
      CapabilityStudyPlanType ();

      CapabilityStudyPlanType (const id_type&,
                               const NumberOfSamples_type&);

      CapabilityStudyPlanType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CapabilityStudyPlanType (const CapabilityStudyPlanType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CapabilityStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CapabilityStudyPlanType&
      operator= (const CapabilityStudyPlanType& x);

      virtual 
      ~CapabilityStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CpkThreshold_optional CpkThreshold_;
      PpkThreshold_optional PpkThreshold_;
    };

    class QIF30_SYMBOL_DECL GageRandRStudyEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        RANGE,
        AVGANDRANGE,
        ANOVA
      };

      GageRandRStudyEnumType ();

      GageRandRStudyEnumType (value v);

      GageRandRStudyEnumType (const wchar_t* v);

      GageRandRStudyEnumType (const ::std::wstring& v);

      GageRandRStudyEnumType (const ::xml_schema::nmtoken& v);

      GageRandRStudyEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      GageRandRStudyEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      GageRandRStudyEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      GageRandRStudyEnumType (const GageRandRStudyEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      GageRandRStudyEnumType&
      operator= (const GageRandRStudyEnumType&) = default;
#endif

      virtual GageRandRStudyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GageRandRStudyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_GageRandRStudyEnumType_convert ();
      }

      protected:
      value
      _xsd_GageRandRStudyEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_GageRandRStudyEnumType_literals_[3];
      static const value _xsd_GageRandRStudyEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL CriteriaByUnitType: public ::xml_schema::type
    {
      public:
      // LinearCriterion
      //
      typedef ::xsd::qif30::CriterionLinearType LinearCriterion_type;
      typedef ::xsd::cxx::tree::optional< LinearCriterion_type > LinearCriterion_optional;
      typedef ::xsd::cxx::tree::traits< LinearCriterion_type, wchar_t > LinearCriterion_traits;

      const LinearCriterion_optional&
      LinearCriterion () const;

      LinearCriterion_optional&
      LinearCriterion ();

      void
      LinearCriterion (const LinearCriterion_type& x);

      void
      LinearCriterion (const LinearCriterion_optional& x);

      void
      LinearCriterion (::std::unique_ptr< LinearCriterion_type > p);

      // AngularCriterion
      //
      typedef ::xsd::qif30::CriterionAngularType AngularCriterion_type;
      typedef ::xsd::cxx::tree::optional< AngularCriterion_type > AngularCriterion_optional;
      typedef ::xsd::cxx::tree::traits< AngularCriterion_type, wchar_t > AngularCriterion_traits;

      const AngularCriterion_optional&
      AngularCriterion () const;

      AngularCriterion_optional&
      AngularCriterion ();

      void
      AngularCriterion (const AngularCriterion_type& x);

      void
      AngularCriterion (const AngularCriterion_optional& x);

      void
      AngularCriterion (::std::unique_ptr< AngularCriterion_type > p);

      // AreaCriterion
      //
      typedef ::xsd::qif30::CriterionAreaType AreaCriterion_type;
      typedef ::xsd::cxx::tree::optional< AreaCriterion_type > AreaCriterion_optional;
      typedef ::xsd::cxx::tree::traits< AreaCriterion_type, wchar_t > AreaCriterion_traits;

      const AreaCriterion_optional&
      AreaCriterion () const;

      AreaCriterion_optional&
      AreaCriterion ();

      void
      AreaCriterion (const AreaCriterion_type& x);

      void
      AreaCriterion (const AreaCriterion_optional& x);

      void
      AreaCriterion (::std::unique_ptr< AreaCriterion_type > p);

      // ForceCriterion
      //
      typedef ::xsd::qif30::CriterionForceType ForceCriterion_type;
      typedef ::xsd::cxx::tree::optional< ForceCriterion_type > ForceCriterion_optional;
      typedef ::xsd::cxx::tree::traits< ForceCriterion_type, wchar_t > ForceCriterion_traits;

      const ForceCriterion_optional&
      ForceCriterion () const;

      ForceCriterion_optional&
      ForceCriterion ();

      void
      ForceCriterion (const ForceCriterion_type& x);

      void
      ForceCriterion (const ForceCriterion_optional& x);

      void
      ForceCriterion (::std::unique_ptr< ForceCriterion_type > p);

      // MassCriterion
      //
      typedef ::xsd::qif30::CriterionMassType MassCriterion_type;
      typedef ::xsd::cxx::tree::optional< MassCriterion_type > MassCriterion_optional;
      typedef ::xsd::cxx::tree::traits< MassCriterion_type, wchar_t > MassCriterion_traits;

      const MassCriterion_optional&
      MassCriterion () const;

      MassCriterion_optional&
      MassCriterion ();

      void
      MassCriterion (const MassCriterion_type& x);

      void
      MassCriterion (const MassCriterion_optional& x);

      void
      MassCriterion (::std::unique_ptr< MassCriterion_type > p);

      // PressureCriterion
      //
      typedef ::xsd::qif30::CriterionPressureType PressureCriterion_type;
      typedef ::xsd::cxx::tree::optional< PressureCriterion_type > PressureCriterion_optional;
      typedef ::xsd::cxx::tree::traits< PressureCriterion_type, wchar_t > PressureCriterion_traits;

      const PressureCriterion_optional&
      PressureCriterion () const;

      PressureCriterion_optional&
      PressureCriterion ();

      void
      PressureCriterion (const PressureCriterion_type& x);

      void
      PressureCriterion (const PressureCriterion_optional& x);

      void
      PressureCriterion (::std::unique_ptr< PressureCriterion_type > p);

      // SpeedCriterion
      //
      typedef ::xsd::qif30::CriterionSpeedType SpeedCriterion_type;
      typedef ::xsd::cxx::tree::optional< SpeedCriterion_type > SpeedCriterion_optional;
      typedef ::xsd::cxx::tree::traits< SpeedCriterion_type, wchar_t > SpeedCriterion_traits;

      const SpeedCriterion_optional&
      SpeedCriterion () const;

      SpeedCriterion_optional&
      SpeedCriterion ();

      void
      SpeedCriterion (const SpeedCriterion_type& x);

      void
      SpeedCriterion (const SpeedCriterion_optional& x);

      void
      SpeedCriterion (::std::unique_ptr< SpeedCriterion_type > p);

      // TemperatureCriterion
      //
      typedef ::xsd::qif30::CriterionTemperatureType TemperatureCriterion_type;
      typedef ::xsd::cxx::tree::optional< TemperatureCriterion_type > TemperatureCriterion_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureCriterion_type, wchar_t > TemperatureCriterion_traits;

      const TemperatureCriterion_optional&
      TemperatureCriterion () const;

      TemperatureCriterion_optional&
      TemperatureCriterion ();

      void
      TemperatureCriterion (const TemperatureCriterion_type& x);

      void
      TemperatureCriterion (const TemperatureCriterion_optional& x);

      void
      TemperatureCriterion (::std::unique_ptr< TemperatureCriterion_type > p);

      // TimeCriterion
      //
      typedef ::xsd::qif30::CriterionTimeType TimeCriterion_type;
      typedef ::xsd::cxx::tree::optional< TimeCriterion_type > TimeCriterion_optional;
      typedef ::xsd::cxx::tree::traits< TimeCriterion_type, wchar_t > TimeCriterion_traits;

      const TimeCriterion_optional&
      TimeCriterion () const;

      TimeCriterion_optional&
      TimeCriterion ();

      void
      TimeCriterion (const TimeCriterion_type& x);

      void
      TimeCriterion (const TimeCriterion_optional& x);

      void
      TimeCriterion (::std::unique_ptr< TimeCriterion_type > p);

      // UserDefinedUnitCriterion
      //
      typedef ::xsd::qif30::CriterionUserDefinedUnitType UserDefinedUnitCriterion_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnitCriterion_type > UserDefinedUnitCriterion_sequence;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitCriterion_type >::iterator UserDefinedUnitCriterion_iterator;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitCriterion_type >::const_iterator UserDefinedUnitCriterion_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitCriterion_type, wchar_t > UserDefinedUnitCriterion_traits;

      const UserDefinedUnitCriterion_sequence&
      UserDefinedUnitCriterion () const;

      UserDefinedUnitCriterion_sequence&
      UserDefinedUnitCriterion ();

      void
      UserDefinedUnitCriterion (const UserDefinedUnitCriterion_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CriteriaByUnitType ();

      CriteriaByUnitType (const n_type&);

      CriteriaByUnitType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CriteriaByUnitType (const CriteriaByUnitType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CriteriaByUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriteriaByUnitType&
      operator= (const CriteriaByUnitType& x);

      virtual 
      ~CriteriaByUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearCriterion_optional LinearCriterion_;
      AngularCriterion_optional AngularCriterion_;
      AreaCriterion_optional AreaCriterion_;
      ForceCriterion_optional ForceCriterion_;
      MassCriterion_optional MassCriterion_;
      PressureCriterion_optional PressureCriterion_;
      SpeedCriterion_optional SpeedCriterion_;
      TemperatureCriterion_optional TemperatureCriterion_;
      TimeCriterion_optional TimeCriterion_;
      UserDefinedUnitCriterion_sequence UserDefinedUnitCriterion_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL GageRandRStudyPlanType: public ::xsd::qif30::StatisticalStudyPlanBaseType
    {
      public:
      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // RandRStudyType
      //
      typedef ::xsd::qif30::GageRandRStudyEnumType RandRStudyType_type;
      typedef ::xsd::cxx::tree::traits< RandRStudyType_type, wchar_t > RandRStudyType_traits;

      const RandRStudyType_type&
      RandRStudyType () const;

      RandRStudyType_type&
      RandRStudyType ();

      void
      RandRStudyType (const RandRStudyType_type& x);

      void
      RandRStudyType (::std::unique_ptr< RandRStudyType_type > p);

      // NumberOfAppraisers
      //
      typedef ::xml_schema::positive_integer NumberOfAppraisers_type;
      typedef ::xsd::cxx::tree::traits< NumberOfAppraisers_type, wchar_t > NumberOfAppraisers_traits;

      const NumberOfAppraisers_type&
      NumberOfAppraisers () const;

      NumberOfAppraisers_type&
      NumberOfAppraisers ();

      void
      NumberOfAppraisers (const NumberOfAppraisers_type& x);

      // NumberOfParts
      //
      typedef ::xml_schema::positive_integer NumberOfParts_type;
      typedef ::xsd::cxx::tree::traits< NumberOfParts_type, wchar_t > NumberOfParts_traits;

      const NumberOfParts_type&
      NumberOfParts () const;

      NumberOfParts_type&
      NumberOfParts ();

      void
      NumberOfParts (const NumberOfParts_type& x);

      // NumberOfTrials
      //
      typedef ::xml_schema::positive_integer NumberOfTrials_type;
      typedef ::xsd::cxx::tree::traits< NumberOfTrials_type, wchar_t > NumberOfTrials_traits;

      const NumberOfTrials_type&
      NumberOfTrials () const;

      NumberOfTrials_type&
      NumberOfTrials ();

      void
      NumberOfTrials (const NumberOfTrials_type& x);

      // MaximumRelativeAppraiserVariation
      //
      typedef ::xsd::qif30::CriterionDecimalType MaximumRelativeAppraiserVariation_type;
      typedef ::xsd::cxx::tree::optional< MaximumRelativeAppraiserVariation_type > MaximumRelativeAppraiserVariation_optional;
      typedef ::xsd::cxx::tree::traits< MaximumRelativeAppraiserVariation_type, wchar_t > MaximumRelativeAppraiserVariation_traits;

      const MaximumRelativeAppraiserVariation_optional&
      MaximumRelativeAppraiserVariation () const;

      MaximumRelativeAppraiserVariation_optional&
      MaximumRelativeAppraiserVariation ();

      void
      MaximumRelativeAppraiserVariation (const MaximumRelativeAppraiserVariation_type& x);

      void
      MaximumRelativeAppraiserVariation (const MaximumRelativeAppraiserVariation_optional& x);

      void
      MaximumRelativeAppraiserVariation (::std::unique_ptr< MaximumRelativeAppraiserVariation_type > p);

      // MaximumAbsoluteAppraiserVariation
      //
      typedef ::xsd::qif30::CriteriaByUnitType MaximumAbsoluteAppraiserVariation_type;
      typedef ::xsd::cxx::tree::optional< MaximumAbsoluteAppraiserVariation_type > MaximumAbsoluteAppraiserVariation_optional;
      typedef ::xsd::cxx::tree::traits< MaximumAbsoluteAppraiserVariation_type, wchar_t > MaximumAbsoluteAppraiserVariation_traits;

      const MaximumAbsoluteAppraiserVariation_optional&
      MaximumAbsoluteAppraiserVariation () const;

      MaximumAbsoluteAppraiserVariation_optional&
      MaximumAbsoluteAppraiserVariation ();

      void
      MaximumAbsoluteAppraiserVariation (const MaximumAbsoluteAppraiserVariation_type& x);

      void
      MaximumAbsoluteAppraiserVariation (const MaximumAbsoluteAppraiserVariation_optional& x);

      void
      MaximumAbsoluteAppraiserVariation (::std::unique_ptr< MaximumAbsoluteAppraiserVariation_type > p);

      // MaximumRelativeEquipmentVariation
      //
      typedef ::xsd::qif30::CriterionDecimalType MaximumRelativeEquipmentVariation_type;
      typedef ::xsd::cxx::tree::optional< MaximumRelativeEquipmentVariation_type > MaximumRelativeEquipmentVariation_optional;
      typedef ::xsd::cxx::tree::traits< MaximumRelativeEquipmentVariation_type, wchar_t > MaximumRelativeEquipmentVariation_traits;

      const MaximumRelativeEquipmentVariation_optional&
      MaximumRelativeEquipmentVariation () const;

      MaximumRelativeEquipmentVariation_optional&
      MaximumRelativeEquipmentVariation ();

      void
      MaximumRelativeEquipmentVariation (const MaximumRelativeEquipmentVariation_type& x);

      void
      MaximumRelativeEquipmentVariation (const MaximumRelativeEquipmentVariation_optional& x);

      void
      MaximumRelativeEquipmentVariation (::std::unique_ptr< MaximumRelativeEquipmentVariation_type > p);

      // MaximumAbsoluteEquipmentVariation
      //
      typedef ::xsd::qif30::CriteriaByUnitType MaximumAbsoluteEquipmentVariation_type;
      typedef ::xsd::cxx::tree::optional< MaximumAbsoluteEquipmentVariation_type > MaximumAbsoluteEquipmentVariation_optional;
      typedef ::xsd::cxx::tree::traits< MaximumAbsoluteEquipmentVariation_type, wchar_t > MaximumAbsoluteEquipmentVariation_traits;

      const MaximumAbsoluteEquipmentVariation_optional&
      MaximumAbsoluteEquipmentVariation () const;

      MaximumAbsoluteEquipmentVariation_optional&
      MaximumAbsoluteEquipmentVariation ();

      void
      MaximumAbsoluteEquipmentVariation (const MaximumAbsoluteEquipmentVariation_type& x);

      void
      MaximumAbsoluteEquipmentVariation (const MaximumAbsoluteEquipmentVariation_optional& x);

      void
      MaximumAbsoluteEquipmentVariation (::std::unique_ptr< MaximumAbsoluteEquipmentVariation_type > p);

      // MaximumRelativeTotalRandR
      //
      typedef ::xsd::qif30::CriterionDecimalType MaximumRelativeTotalRandR_type;
      typedef ::xsd::cxx::tree::optional< MaximumRelativeTotalRandR_type > MaximumRelativeTotalRandR_optional;
      typedef ::xsd::cxx::tree::traits< MaximumRelativeTotalRandR_type, wchar_t > MaximumRelativeTotalRandR_traits;

      const MaximumRelativeTotalRandR_optional&
      MaximumRelativeTotalRandR () const;

      MaximumRelativeTotalRandR_optional&
      MaximumRelativeTotalRandR ();

      void
      MaximumRelativeTotalRandR (const MaximumRelativeTotalRandR_type& x);

      void
      MaximumRelativeTotalRandR (const MaximumRelativeTotalRandR_optional& x);

      void
      MaximumRelativeTotalRandR (::std::unique_ptr< MaximumRelativeTotalRandR_type > p);

      // MaximumAbsoluteTotalRandR
      //
      typedef ::xsd::qif30::CriteriaByUnitType MaximumAbsoluteTotalRandR_type;
      typedef ::xsd::cxx::tree::optional< MaximumAbsoluteTotalRandR_type > MaximumAbsoluteTotalRandR_optional;
      typedef ::xsd::cxx::tree::traits< MaximumAbsoluteTotalRandR_type, wchar_t > MaximumAbsoluteTotalRandR_traits;

      const MaximumAbsoluteTotalRandR_optional&
      MaximumAbsoluteTotalRandR () const;

      MaximumAbsoluteTotalRandR_optional&
      MaximumAbsoluteTotalRandR ();

      void
      MaximumAbsoluteTotalRandR (const MaximumAbsoluteTotalRandR_type& x);

      void
      MaximumAbsoluteTotalRandR (const MaximumAbsoluteTotalRandR_optional& x);

      void
      MaximumAbsoluteTotalRandR (::std::unique_ptr< MaximumAbsoluteTotalRandR_type > p);

      // Constructors.
      //
      GageRandRStudyPlanType ();

      GageRandRStudyPlanType (const id_type&,
                              const RandRStudyType_type&,
                              const NumberOfAppraisers_type&,
                              const NumberOfParts_type&,
                              const NumberOfTrials_type&);

      GageRandRStudyPlanType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      GageRandRStudyPlanType (const GageRandRStudyPlanType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual GageRandRStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GageRandRStudyPlanType&
      operator= (const GageRandRStudyPlanType& x);

      virtual 
      ~GageRandRStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ::xsd::cxx::tree::one< RandRStudyType_type > RandRStudyType_;
      ::xsd::cxx::tree::one< NumberOfAppraisers_type > NumberOfAppraisers_;
      ::xsd::cxx::tree::one< NumberOfParts_type > NumberOfParts_;
      ::xsd::cxx::tree::one< NumberOfTrials_type > NumberOfTrials_;
      MaximumRelativeAppraiserVariation_optional MaximumRelativeAppraiserVariation_;
      MaximumAbsoluteAppraiserVariation_optional MaximumAbsoluteAppraiserVariation_;
      MaximumRelativeEquipmentVariation_optional MaximumRelativeEquipmentVariation_;
      MaximumAbsoluteEquipmentVariation_optional MaximumAbsoluteEquipmentVariation_;
      MaximumRelativeTotalRandR_optional MaximumRelativeTotalRandR_;
      MaximumAbsoluteTotalRandR_optional MaximumAbsoluteTotalRandR_;
    };

    class QIF30_SYMBOL_DECL ControlMethodType: public ::xml_schema::type
    {
      public:
      // AssignableCauseIds
      //
      typedef ::xsd::qif30::ArrayReferenceType AssignableCauseIds_type;
      typedef ::xsd::cxx::tree::optional< AssignableCauseIds_type > AssignableCauseIds_optional;
      typedef ::xsd::cxx::tree::traits< AssignableCauseIds_type, wchar_t > AssignableCauseIds_traits;

      const AssignableCauseIds_optional&
      AssignableCauseIds () const;

      AssignableCauseIds_optional&
      AssignableCauseIds ();

      void
      AssignableCauseIds (const AssignableCauseIds_type& x);

      void
      AssignableCauseIds (const AssignableCauseIds_optional& x);

      void
      AssignableCauseIds (::std::unique_ptr< AssignableCauseIds_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // NumOutOfTolerance
      //
      typedef ::xsd::qif30::CriterionIntegerType NumOutOfTolerance_type;
      typedef ::xsd::cxx::tree::optional< NumOutOfTolerance_type > NumOutOfTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NumOutOfTolerance_type, wchar_t > NumOutOfTolerance_traits;

      const NumOutOfTolerance_optional&
      NumOutOfTolerance () const;

      NumOutOfTolerance_optional&
      NumOutOfTolerance ();

      void
      NumOutOfTolerance (const NumOutOfTolerance_type& x);

      void
      NumOutOfTolerance (const NumOutOfTolerance_optional& x);

      void
      NumOutOfTolerance (::std::unique_ptr< NumOutOfTolerance_type > p);

      // CpThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType CpThreshold_type;
      typedef ::xsd::cxx::tree::optional< CpThreshold_type > CpThreshold_optional;
      typedef ::xsd::cxx::tree::traits< CpThreshold_type, wchar_t > CpThreshold_traits;

      const CpThreshold_optional&
      CpThreshold () const;

      CpThreshold_optional&
      CpThreshold ();

      void
      CpThreshold (const CpThreshold_type& x);

      void
      CpThreshold (const CpThreshold_optional& x);

      void
      CpThreshold (::std::unique_ptr< CpThreshold_type > p);

      // CpkThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType CpkThreshold_type;
      typedef ::xsd::cxx::tree::optional< CpkThreshold_type > CpkThreshold_optional;
      typedef ::xsd::cxx::tree::traits< CpkThreshold_type, wchar_t > CpkThreshold_traits;

      const CpkThreshold_optional&
      CpkThreshold () const;

      CpkThreshold_optional&
      CpkThreshold ();

      void
      CpkThreshold (const CpkThreshold_type& x);

      void
      CpkThreshold (const CpkThreshold_optional& x);

      void
      CpkThreshold (::std::unique_ptr< CpkThreshold_type > p);

      // PpThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType PpThreshold_type;
      typedef ::xsd::cxx::tree::optional< PpThreshold_type > PpThreshold_optional;
      typedef ::xsd::cxx::tree::traits< PpThreshold_type, wchar_t > PpThreshold_traits;

      const PpThreshold_optional&
      PpThreshold () const;

      PpThreshold_optional&
      PpThreshold ();

      void
      PpThreshold (const PpThreshold_type& x);

      void
      PpThreshold (const PpThreshold_optional& x);

      void
      PpThreshold (::std::unique_ptr< PpThreshold_type > p);

      // PpkThreshold
      //
      typedef ::xsd::qif30::CriterionDecimalType PpkThreshold_type;
      typedef ::xsd::cxx::tree::optional< PpkThreshold_type > PpkThreshold_optional;
      typedef ::xsd::cxx::tree::traits< PpkThreshold_type, wchar_t > PpkThreshold_traits;

      const PpkThreshold_optional&
      PpkThreshold () const;

      PpkThreshold_optional&
      PpkThreshold ();

      void
      PpkThreshold (const PpkThreshold_type& x);

      void
      PpkThreshold (const PpkThreshold_optional& x);

      void
      PpkThreshold (::std::unique_ptr< PpkThreshold_type > p);

      // NumOutOfControl
      //
      typedef ::xsd::qif30::CriterionIntegerType NumOutOfControl_type;
      typedef ::xsd::cxx::tree::optional< NumOutOfControl_type > NumOutOfControl_optional;
      typedef ::xsd::cxx::tree::traits< NumOutOfControl_type, wchar_t > NumOutOfControl_traits;

      const NumOutOfControl_optional&
      NumOutOfControl () const;

      NumOutOfControl_optional&
      NumOutOfControl ();

      void
      NumOutOfControl (const NumOutOfControl_type& x);

      void
      NumOutOfControl (const NumOutOfControl_optional& x);

      void
      NumOutOfControl (::std::unique_ptr< NumOutOfControl_type > p);

      // TrendGrouping
      //
      typedef ::xsd::qif30::CriterionIntegerType TrendGrouping_type;
      typedef ::xsd::cxx::tree::optional< TrendGrouping_type > TrendGrouping_optional;
      typedef ::xsd::cxx::tree::traits< TrendGrouping_type, wchar_t > TrendGrouping_traits;

      const TrendGrouping_optional&
      TrendGrouping () const;

      TrendGrouping_optional&
      TrendGrouping ();

      void
      TrendGrouping (const TrendGrouping_type& x);

      void
      TrendGrouping (const TrendGrouping_optional& x);

      void
      TrendGrouping (::std::unique_ptr< TrendGrouping_type > p);

      // SkewGrouping
      //
      typedef ::xsd::qif30::CriterionIntegerType SkewGrouping_type;
      typedef ::xsd::cxx::tree::optional< SkewGrouping_type > SkewGrouping_optional;
      typedef ::xsd::cxx::tree::traits< SkewGrouping_type, wchar_t > SkewGrouping_traits;

      const SkewGrouping_optional&
      SkewGrouping () const;

      SkewGrouping_optional&
      SkewGrouping ();

      void
      SkewGrouping (const SkewGrouping_type& x);

      void
      SkewGrouping (const SkewGrouping_optional& x);

      void
      SkewGrouping (::std::unique_ptr< SkewGrouping_type > p);

      // OneThirdGrouping
      //
      typedef ::xsd::qif30::CriterionOutOfType OneThirdGrouping_type;
      typedef ::xsd::cxx::tree::optional< OneThirdGrouping_type > OneThirdGrouping_optional;
      typedef ::xsd::cxx::tree::traits< OneThirdGrouping_type, wchar_t > OneThirdGrouping_traits;

      const OneThirdGrouping_optional&
      OneThirdGrouping () const;

      OneThirdGrouping_optional&
      OneThirdGrouping ();

      void
      OneThirdGrouping (const OneThirdGrouping_type& x);

      void
      OneThirdGrouping (const OneThirdGrouping_optional& x);

      void
      OneThirdGrouping (::std::unique_ptr< OneThirdGrouping_type > p);

      // TwoThirdsGrouping
      //
      typedef ::xsd::qif30::CriterionOutOfType TwoThirdsGrouping_type;
      typedef ::xsd::cxx::tree::optional< TwoThirdsGrouping_type > TwoThirdsGrouping_optional;
      typedef ::xsd::cxx::tree::traits< TwoThirdsGrouping_type, wchar_t > TwoThirdsGrouping_traits;

      const TwoThirdsGrouping_optional&
      TwoThirdsGrouping () const;

      TwoThirdsGrouping_optional&
      TwoThirdsGrouping ();

      void
      TwoThirdsGrouping (const TwoThirdsGrouping_type& x);

      void
      TwoThirdsGrouping (const TwoThirdsGrouping_optional& x);

      void
      TwoThirdsGrouping (::std::unique_ptr< TwoThirdsGrouping_type > p);

      // Oscillation
      //
      typedef ::xsd::qif30::CriterionOutOfType Oscillation_type;
      typedef ::xsd::cxx::tree::optional< Oscillation_type > Oscillation_optional;
      typedef ::xsd::cxx::tree::traits< Oscillation_type, wchar_t > Oscillation_traits;

      const Oscillation_optional&
      Oscillation () const;

      Oscillation_optional&
      Oscillation ();

      void
      Oscillation (const Oscillation_type& x);

      void
      Oscillation (const Oscillation_optional& x);

      void
      Oscillation (::std::unique_ptr< Oscillation_type > p);

      // Stratification
      //
      typedef ::xsd::qif30::CriterionOutOfType Stratification_type;
      typedef ::xsd::cxx::tree::optional< Stratification_type > Stratification_optional;
      typedef ::xsd::cxx::tree::traits< Stratification_type, wchar_t > Stratification_traits;

      const Stratification_optional&
      Stratification () const;

      Stratification_optional&
      Stratification ();

      void
      Stratification (const Stratification_type& x);

      void
      Stratification (const Stratification_optional& x);

      void
      Stratification (::std::unique_ptr< Stratification_type > p);

      // NumOutOfControlRng
      //
      typedef ::xsd::qif30::CriterionIntegerType NumOutOfControlRng_type;
      typedef ::xsd::cxx::tree::optional< NumOutOfControlRng_type > NumOutOfControlRng_optional;
      typedef ::xsd::cxx::tree::traits< NumOutOfControlRng_type, wchar_t > NumOutOfControlRng_traits;

      const NumOutOfControlRng_optional&
      NumOutOfControlRng () const;

      NumOutOfControlRng_optional&
      NumOutOfControlRng ();

      void
      NumOutOfControlRng (const NumOutOfControlRng_type& x);

      void
      NumOutOfControlRng (const NumOutOfControlRng_optional& x);

      void
      NumOutOfControlRng (::std::unique_ptr< NumOutOfControlRng_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      ControlMethodType ();

      ControlMethodType (const id_type&);

      ControlMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ControlMethodType (const ControlMethodType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ControlMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlMethodType&
      operator= (const ControlMethodType& x);

      virtual 
      ~ControlMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AssignableCauseIds_optional AssignableCauseIds_;
      Attributes_optional Attributes_;
      NumOutOfTolerance_optional NumOutOfTolerance_;
      CpThreshold_optional CpThreshold_;
      CpkThreshold_optional CpkThreshold_;
      PpThreshold_optional PpThreshold_;
      PpkThreshold_optional PpkThreshold_;
      NumOutOfControl_optional NumOutOfControl_;
      TrendGrouping_optional TrendGrouping_;
      SkewGrouping_optional SkewGrouping_;
      OneThirdGrouping_optional OneThirdGrouping_;
      TwoThirdsGrouping_optional TwoThirdsGrouping_;
      Oscillation_optional Oscillation_;
      Stratification_optional Stratification_;
      NumOutOfControlRng_optional NumOutOfControlRng_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL ControlMethodsType: public ::xml_schema::type
    {
      public:
      // ControlMethod
      //
      typedef ::xsd::qif30::ControlMethodType ControlMethod_type;
      typedef ::xsd::cxx::tree::sequence< ControlMethod_type > ControlMethod_sequence;
      typedef xsd::cxx::tree::sequence< ControlMethod_type >::iterator ControlMethod_iterator;
      typedef xsd::cxx::tree::sequence< ControlMethod_type >::const_iterator ControlMethod_const_iterator;
      typedef ::xsd::cxx::tree::traits< ControlMethod_type, wchar_t > ControlMethod_traits;

      const ControlMethod_sequence&
      ControlMethod () const;

      ControlMethod_sequence&
      ControlMethod ();

      void
      ControlMethod (const ControlMethod_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ControlMethodsType ();

      ControlMethodsType (const n_type&);

      ControlMethodsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ControlMethodsType (const ControlMethodsType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ControlMethodsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlMethodsType&
      operator= (const ControlMethodsType& x);

      virtual 
      ~ControlMethodsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ControlMethod_sequence ControlMethod_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ProductionStudyPlanType: public ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType
    {
      public:
      // SamplingMethod
      //
      typedef ::xsd::qif30::SamplingMethodType SamplingMethod_type;
      typedef ::xsd::cxx::tree::traits< SamplingMethod_type, wchar_t > SamplingMethod_traits;

      const SamplingMethod_type&
      SamplingMethod () const;

      SamplingMethod_type&
      SamplingMethod ();

      void
      SamplingMethod (const SamplingMethod_type& x);

      void
      SamplingMethod (::std::unique_ptr< SamplingMethod_type > p);

      // ControlMethods
      //
      typedef ::xsd::qif30::ControlMethodsType ControlMethods_type;
      typedef ::xsd::cxx::tree::traits< ControlMethods_type, wchar_t > ControlMethods_traits;

      const ControlMethods_type&
      ControlMethods () const;

      ControlMethods_type&
      ControlMethods ();

      void
      ControlMethods (const ControlMethods_type& x);

      void
      ControlMethods (::std::unique_ptr< ControlMethods_type > p);

      // Constructors.
      //
      ProductionStudyPlanType ();

      ProductionStudyPlanType (const id_type&,
                               const NumberOfSamples_type&,
                               const SamplingMethod_type&,
                               const ControlMethods_type&);

      ProductionStudyPlanType (const id_type&,
                               const NumberOfSamples_type&,
                               ::std::unique_ptr< SamplingMethod_type >,
                               ::std::unique_ptr< ControlMethods_type >);

      ProductionStudyPlanType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ProductionStudyPlanType (const ProductionStudyPlanType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ProductionStudyPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductionStudyPlanType&
      operator= (const ProductionStudyPlanType& x);

      virtual 
      ~ProductionStudyPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SamplingMethod_type > SamplingMethod_;
      ::xsd::cxx::tree::one< ControlMethods_type > ControlMethods_;
    };

    class QIF30_SYMBOL_DECL StatisticalStudyResultsBaseType: public ::xml_schema::type
    {
      public:
      // ThisStatisticalStudyResultsInstanceQPId
      //
      typedef ::xsd::qif30::QPIdType ThisStatisticalStudyResultsInstanceQPId_type;
      typedef ::xsd::cxx::tree::optional< ThisStatisticalStudyResultsInstanceQPId_type > ThisStatisticalStudyResultsInstanceQPId_optional;
      typedef ::xsd::cxx::tree::traits< ThisStatisticalStudyResultsInstanceQPId_type, wchar_t > ThisStatisticalStudyResultsInstanceQPId_traits;

      const ThisStatisticalStudyResultsInstanceQPId_optional&
      ThisStatisticalStudyResultsInstanceQPId () const;

      ThisStatisticalStudyResultsInstanceQPId_optional&
      ThisStatisticalStudyResultsInstanceQPId ();

      void
      ThisStatisticalStudyResultsInstanceQPId (const ThisStatisticalStudyResultsInstanceQPId_type& x);

      void
      ThisStatisticalStudyResultsInstanceQPId (const ThisStatisticalStudyResultsInstanceQPId_optional& x);

      void
      ThisStatisticalStudyResultsInstanceQPId (::std::unique_ptr< ThisStatisticalStudyResultsInstanceQPId_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Status
      //
      typedef ::xsd::qif30::StatsEvalStatusType Status_type;
      typedef ::xsd::cxx::tree::traits< Status_type, wchar_t > Status_traits;

      const Status_type&
      Status () const;

      Status_type&
      Status ();

      void
      Status (const Status_type& x);

      void
      Status (::std::unique_ptr< Status_type > p);

      // SoftwareId
      //
      typedef ::xsd::qif30::QIFReferenceType SoftwareId_type;
      typedef ::xsd::cxx::tree::optional< SoftwareId_type > SoftwareId_optional;
      typedef ::xsd::cxx::tree::traits< SoftwareId_type, wchar_t > SoftwareId_traits;

      const SoftwareId_optional&
      SoftwareId () const;

      SoftwareId_optional&
      SoftwareId ();

      void
      SoftwareId (const SoftwareId_type& x);

      void
      SoftwareId (const SoftwareId_optional& x);

      void
      SoftwareId (::std::unique_ptr< SoftwareId_type > p);

      // StandardId
      //
      typedef ::xsd::qif30::QIFReferenceType StandardId_type;
      typedef ::xsd::cxx::tree::optional< StandardId_type > StandardId_optional;
      typedef ::xsd::cxx::tree::traits< StandardId_type, wchar_t > StandardId_traits;

      const StandardId_optional&
      StandardId () const;

      StandardId_optional&
      StandardId ();

      void
      StandardId (const StandardId_type& x);

      void
      StandardId (const StandardId_optional& x);

      void
      StandardId (::std::unique_ptr< StandardId_type > p);

      // StudyIssues
      //
      typedef ::xsd::qif30::StudyIssuesType StudyIssues_type;
      typedef ::xsd::cxx::tree::optional< StudyIssues_type > StudyIssues_optional;
      typedef ::xsd::cxx::tree::traits< StudyIssues_type, wchar_t > StudyIssues_traits;

      const StudyIssues_optional&
      StudyIssues () const;

      StudyIssues_optional&
      StudyIssues ();

      void
      StudyIssues (const StudyIssues_type& x);

      void
      StudyIssues (const StudyIssues_optional& x);

      void
      StudyIssues (::std::unique_ptr< StudyIssues_type > p);

      // InspectionTraceability
      //
      typedef ::xsd::qif30::InspectionTraceabilityType InspectionTraceability_type;
      typedef ::xsd::cxx::tree::optional< InspectionTraceability_type > InspectionTraceability_optional;
      typedef ::xsd::cxx::tree::traits< InspectionTraceability_type, wchar_t > InspectionTraceability_traits;

      const InspectionTraceability_optional&
      InspectionTraceability () const;

      InspectionTraceability_optional&
      InspectionTraceability ();

      void
      InspectionTraceability (const InspectionTraceability_type& x);

      void
      InspectionTraceability (const InspectionTraceability_optional& x);

      void
      InspectionTraceability (::std::unique_ptr< InspectionTraceability_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // StudyId
      //
      typedef ::xsd::qif30::QIFReferenceType StudyId_type;
      typedef ::xsd::cxx::tree::optional< StudyId_type > StudyId_optional;
      typedef ::xsd::cxx::tree::traits< StudyId_type, wchar_t > StudyId_traits;

      const StudyId_optional&
      StudyId () const;

      StudyId_optional&
      StudyId ();

      void
      StudyId (const StudyId_type& x);

      void
      StudyId (const StudyId_optional& x);

      void
      StudyId (::std::unique_ptr< StudyId_type > p);

      // ResultsIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ResultsIds_type;
      typedef ::xsd::cxx::tree::optional< ResultsIds_type > ResultsIds_optional;
      typedef ::xsd::cxx::tree::traits< ResultsIds_type, wchar_t > ResultsIds_traits;

      const ResultsIds_optional&
      ResultsIds () const;

      ResultsIds_optional&
      ResultsIds ();

      void
      ResultsIds (const ResultsIds_type& x);

      void
      ResultsIds (const ResultsIds_optional& x);

      void
      ResultsIds (::std::unique_ptr< ResultsIds_type > p);

      // ResultsQPIds
      //
      typedef ::xsd::qif30::ArrayQPIdFullReferenceType ResultsQPIds_type;
      typedef ::xsd::cxx::tree::sequence< ResultsQPIds_type > ResultsQPIds_sequence;
      typedef xsd::cxx::tree::sequence< ResultsQPIds_type >::iterator ResultsQPIds_iterator;
      typedef xsd::cxx::tree::sequence< ResultsQPIds_type >::const_iterator ResultsQPIds_const_iterator;
      typedef ::xsd::cxx::tree::traits< ResultsQPIds_type, wchar_t > ResultsQPIds_traits;

      const ResultsQPIds_sequence&
      ResultsQPIds () const;

      ResultsQPIds_sequence&
      ResultsQPIds ();

      void
      ResultsQPIds (const ResultsQPIds_sequence& s);

      // ResultsFiles
      //
      typedef ::xsd::qif30::ExternalFileReferencesType ResultsFiles_type;
      typedef ::xsd::cxx::tree::optional< ResultsFiles_type > ResultsFiles_optional;
      typedef ::xsd::cxx::tree::traits< ResultsFiles_type, wchar_t > ResultsFiles_traits;

      const ResultsFiles_optional&
      ResultsFiles () const;

      ResultsFiles_optional&
      ResultsFiles ();

      void
      ResultsFiles (const ResultsFiles_type& x);

      void
      ResultsFiles (const ResultsFiles_optional& x);

      void
      ResultsFiles (::std::unique_ptr< ResultsFiles_type > p);

      // AverageFeatures
      //
      typedef ::xsd::qif30::AverageFeaturesType AverageFeatures_type;
      typedef ::xsd::cxx::tree::optional< AverageFeatures_type > AverageFeatures_optional;
      typedef ::xsd::cxx::tree::traits< AverageFeatures_type, wchar_t > AverageFeatures_traits;

      const AverageFeatures_optional&
      AverageFeatures () const;

      AverageFeatures_optional&
      AverageFeatures ();

      void
      AverageFeatures (const AverageFeatures_type& x);

      void
      AverageFeatures (const AverageFeatures_optional& x);

      void
      AverageFeatures (::std::unique_ptr< AverageFeatures_type > p);

      // CharacteristicsStats
      //
      typedef ::xsd::qif30::CharacteristicsStatsType CharacteristicsStats_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicsStats_type > CharacteristicsStats_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicsStats_type, wchar_t > CharacteristicsStats_traits;

      const CharacteristicsStats_optional&
      CharacteristicsStats () const;

      CharacteristicsStats_optional&
      CharacteristicsStats ();

      void
      CharacteristicsStats (const CharacteristicsStats_type& x);

      void
      CharacteristicsStats (const CharacteristicsStats_optional& x);

      void
      CharacteristicsStats (::std::unique_ptr< CharacteristicsStats_type > p);

      // LinearStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsLinearType LinearStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< LinearStatsSummaries_type > LinearStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< LinearStatsSummaries_type, wchar_t > LinearStatsSummaries_traits;

      const LinearStatsSummaries_optional&
      LinearStatsSummaries () const;

      LinearStatsSummaries_optional&
      LinearStatsSummaries ();

      void
      LinearStatsSummaries (const LinearStatsSummaries_type& x);

      void
      LinearStatsSummaries (const LinearStatsSummaries_optional& x);

      void
      LinearStatsSummaries (::std::unique_ptr< LinearStatsSummaries_type > p);

      // AngularStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsAngularType AngularStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< AngularStatsSummaries_type > AngularStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< AngularStatsSummaries_type, wchar_t > AngularStatsSummaries_traits;

      const AngularStatsSummaries_optional&
      AngularStatsSummaries () const;

      AngularStatsSummaries_optional&
      AngularStatsSummaries ();

      void
      AngularStatsSummaries (const AngularStatsSummaries_type& x);

      void
      AngularStatsSummaries (const AngularStatsSummaries_optional& x);

      void
      AngularStatsSummaries (::std::unique_ptr< AngularStatsSummaries_type > p);

      // AreaStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsAreaType AreaStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< AreaStatsSummaries_type > AreaStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< AreaStatsSummaries_type, wchar_t > AreaStatsSummaries_traits;

      const AreaStatsSummaries_optional&
      AreaStatsSummaries () const;

      AreaStatsSummaries_optional&
      AreaStatsSummaries ();

      void
      AreaStatsSummaries (const AreaStatsSummaries_type& x);

      void
      AreaStatsSummaries (const AreaStatsSummaries_optional& x);

      void
      AreaStatsSummaries (::std::unique_ptr< AreaStatsSummaries_type > p);

      // ForceStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsForceType ForceStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< ForceStatsSummaries_type > ForceStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< ForceStatsSummaries_type, wchar_t > ForceStatsSummaries_traits;

      const ForceStatsSummaries_optional&
      ForceStatsSummaries () const;

      ForceStatsSummaries_optional&
      ForceStatsSummaries ();

      void
      ForceStatsSummaries (const ForceStatsSummaries_type& x);

      void
      ForceStatsSummaries (const ForceStatsSummaries_optional& x);

      void
      ForceStatsSummaries (::std::unique_ptr< ForceStatsSummaries_type > p);

      // MassStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsMassType MassStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< MassStatsSummaries_type > MassStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< MassStatsSummaries_type, wchar_t > MassStatsSummaries_traits;

      const MassStatsSummaries_optional&
      MassStatsSummaries () const;

      MassStatsSummaries_optional&
      MassStatsSummaries ();

      void
      MassStatsSummaries (const MassStatsSummaries_type& x);

      void
      MassStatsSummaries (const MassStatsSummaries_optional& x);

      void
      MassStatsSummaries (::std::unique_ptr< MassStatsSummaries_type > p);

      // PressureStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsPressureType PressureStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< PressureStatsSummaries_type > PressureStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< PressureStatsSummaries_type, wchar_t > PressureStatsSummaries_traits;

      const PressureStatsSummaries_optional&
      PressureStatsSummaries () const;

      PressureStatsSummaries_optional&
      PressureStatsSummaries ();

      void
      PressureStatsSummaries (const PressureStatsSummaries_type& x);

      void
      PressureStatsSummaries (const PressureStatsSummaries_optional& x);

      void
      PressureStatsSummaries (::std::unique_ptr< PressureStatsSummaries_type > p);

      // SpeedStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsSpeedType SpeedStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< SpeedStatsSummaries_type > SpeedStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< SpeedStatsSummaries_type, wchar_t > SpeedStatsSummaries_traits;

      const SpeedStatsSummaries_optional&
      SpeedStatsSummaries () const;

      SpeedStatsSummaries_optional&
      SpeedStatsSummaries ();

      void
      SpeedStatsSummaries (const SpeedStatsSummaries_type& x);

      void
      SpeedStatsSummaries (const SpeedStatsSummaries_optional& x);

      void
      SpeedStatsSummaries (::std::unique_ptr< SpeedStatsSummaries_type > p);

      // TemperatureStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsTemperatureType TemperatureStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< TemperatureStatsSummaries_type > TemperatureStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureStatsSummaries_type, wchar_t > TemperatureStatsSummaries_traits;

      const TemperatureStatsSummaries_optional&
      TemperatureStatsSummaries () const;

      TemperatureStatsSummaries_optional&
      TemperatureStatsSummaries ();

      void
      TemperatureStatsSummaries (const TemperatureStatsSummaries_type& x);

      void
      TemperatureStatsSummaries (const TemperatureStatsSummaries_optional& x);

      void
      TemperatureStatsSummaries (::std::unique_ptr< TemperatureStatsSummaries_type > p);

      // TimeStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsTimeType TimeStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< TimeStatsSummaries_type > TimeStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< TimeStatsSummaries_type, wchar_t > TimeStatsSummaries_traits;

      const TimeStatsSummaries_optional&
      TimeStatsSummaries () const;

      TimeStatsSummaries_optional&
      TimeStatsSummaries ();

      void
      TimeStatsSummaries (const TimeStatsSummaries_type& x);

      void
      TimeStatsSummaries (const TimeStatsSummaries_optional& x);

      void
      TimeStatsSummaries (::std::unique_ptr< TimeStatsSummaries_type > p);

      // UserDefinedUnitStatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsUserDefinedUnitType UserDefinedUnitStatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedUnitStatsSummaries_type > UserDefinedUnitStatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitStatsSummaries_type, wchar_t > UserDefinedUnitStatsSummaries_traits;

      const UserDefinedUnitStatsSummaries_optional&
      UserDefinedUnitStatsSummaries () const;

      UserDefinedUnitStatsSummaries_optional&
      UserDefinedUnitStatsSummaries ();

      void
      UserDefinedUnitStatsSummaries (const UserDefinedUnitStatsSummaries_type& x);

      void
      UserDefinedUnitStatsSummaries (const UserDefinedUnitStatsSummaries_optional& x);

      void
      UserDefinedUnitStatsSummaries (::std::unique_ptr< UserDefinedUnitStatsSummaries_type > p);

      // StatsSummaries
      //
      typedef ::xsd::qif30::SummariesStatisticsType StatsSummaries_type;
      typedef ::xsd::cxx::tree::optional< StatsSummaries_type > StatsSummaries_optional;
      typedef ::xsd::cxx::tree::traits< StatsSummaries_type, wchar_t > StatsSummaries_traits;

      const StatsSummaries_optional&
      StatsSummaries () const;

      StatsSummaries_optional&
      StatsSummaries ();

      void
      StatsSummaries (const StatsSummaries_type& x);

      void
      StatsSummaries (const StatsSummaries_optional& x);

      void
      StatsSummaries (::std::unique_ptr< StatsSummaries_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      StatisticalStudyResultsBaseType ();

      StatisticalStudyResultsBaseType (const Status_type&,
                                       const id_type&);

      StatisticalStudyResultsBaseType (::std::unique_ptr< Status_type >,
                                       const id_type&);

      StatisticalStudyResultsBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      StatisticalStudyResultsBaseType (const StatisticalStudyResultsBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual StatisticalStudyResultsBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      StatisticalStudyResultsBaseType&
      operator= (const StatisticalStudyResultsBaseType& x);

      virtual 
      ~StatisticalStudyResultsBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThisStatisticalStudyResultsInstanceQPId_optional ThisStatisticalStudyResultsInstanceQPId_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Status_type > Status_;
      SoftwareId_optional SoftwareId_;
      StandardId_optional StandardId_;
      StudyIssues_optional StudyIssues_;
      InspectionTraceability_optional InspectionTraceability_;
      Name_optional Name_;
      Description_optional Description_;
      StudyId_optional StudyId_;
      ResultsIds_optional ResultsIds_;
      ResultsQPIds_sequence ResultsQPIds_;
      ResultsFiles_optional ResultsFiles_;
      AverageFeatures_optional AverageFeatures_;
      CharacteristicsStats_optional CharacteristicsStats_;
      LinearStatsSummaries_optional LinearStatsSummaries_;
      AngularStatsSummaries_optional AngularStatsSummaries_;
      AreaStatsSummaries_optional AreaStatsSummaries_;
      ForceStatsSummaries_optional ForceStatsSummaries_;
      MassStatsSummaries_optional MassStatsSummaries_;
      PressureStatsSummaries_optional PressureStatsSummaries_;
      SpeedStatsSummaries_optional SpeedStatsSummaries_;
      TemperatureStatsSummaries_optional TemperatureStatsSummaries_;
      TimeStatsSummaries_optional TimeStatsSummaries_;
      UserDefinedUnitStatsSummaries_optional UserDefinedUnitStatsSummaries_;
      StatsSummaries_optional StatsSummaries_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL LinearityStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // SampleSize
      //
      typedef ::xml_schema::positive_integer SampleSize_type;
      typedef ::xsd::cxx::tree::traits< SampleSize_type, wchar_t > SampleSize_traits;

      const SampleSize_type&
      SampleSize () const;

      SampleSize_type&
      SampleSize ();

      void
      SampleSize (const SampleSize_type& x);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // GoodnessOfFit
      //
      typedef ::xsd::qif30::MeasuredDecimalType GoodnessOfFit_type;
      typedef ::xsd::cxx::tree::optional< GoodnessOfFit_type > GoodnessOfFit_optional;
      typedef ::xsd::cxx::tree::traits< GoodnessOfFit_type, wchar_t > GoodnessOfFit_traits;

      const GoodnessOfFit_optional&
      GoodnessOfFit () const;

      GoodnessOfFit_optional&
      GoodnessOfFit ();

      void
      GoodnessOfFit (const GoodnessOfFit_type& x);

      void
      GoodnessOfFit (const GoodnessOfFit_optional& x);

      void
      GoodnessOfFit (::std::unique_ptr< GoodnessOfFit_type > p);

      // LinearAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LinearAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< LinearAbsoluteLinearity_type > LinearAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< LinearAbsoluteLinearity_type, wchar_t > LinearAbsoluteLinearity_traits;

      const LinearAbsoluteLinearity_optional&
      LinearAbsoluteLinearity () const;

      LinearAbsoluteLinearity_optional&
      LinearAbsoluteLinearity ();

      void
      LinearAbsoluteLinearity (const LinearAbsoluteLinearity_type& x);

      void
      LinearAbsoluteLinearity (const LinearAbsoluteLinearity_optional& x);

      void
      LinearAbsoluteLinearity (::std::unique_ptr< LinearAbsoluteLinearity_type > p);

      // AngularAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredAngularValueType AngularAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< AngularAbsoluteLinearity_type > AngularAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< AngularAbsoluteLinearity_type, wchar_t > AngularAbsoluteLinearity_traits;

      const AngularAbsoluteLinearity_optional&
      AngularAbsoluteLinearity () const;

      AngularAbsoluteLinearity_optional&
      AngularAbsoluteLinearity ();

      void
      AngularAbsoluteLinearity (const AngularAbsoluteLinearity_type& x);

      void
      AngularAbsoluteLinearity (const AngularAbsoluteLinearity_optional& x);

      void
      AngularAbsoluteLinearity (::std::unique_ptr< AngularAbsoluteLinearity_type > p);

      // AreaAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredAreaValueType AreaAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< AreaAbsoluteLinearity_type > AreaAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< AreaAbsoluteLinearity_type, wchar_t > AreaAbsoluteLinearity_traits;

      const AreaAbsoluteLinearity_optional&
      AreaAbsoluteLinearity () const;

      AreaAbsoluteLinearity_optional&
      AreaAbsoluteLinearity ();

      void
      AreaAbsoluteLinearity (const AreaAbsoluteLinearity_type& x);

      void
      AreaAbsoluteLinearity (const AreaAbsoluteLinearity_optional& x);

      void
      AreaAbsoluteLinearity (::std::unique_ptr< AreaAbsoluteLinearity_type > p);

      // ForceAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredForceValueType ForceAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< ForceAbsoluteLinearity_type > ForceAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< ForceAbsoluteLinearity_type, wchar_t > ForceAbsoluteLinearity_traits;

      const ForceAbsoluteLinearity_optional&
      ForceAbsoluteLinearity () const;

      ForceAbsoluteLinearity_optional&
      ForceAbsoluteLinearity ();

      void
      ForceAbsoluteLinearity (const ForceAbsoluteLinearity_type& x);

      void
      ForceAbsoluteLinearity (const ForceAbsoluteLinearity_optional& x);

      void
      ForceAbsoluteLinearity (::std::unique_ptr< ForceAbsoluteLinearity_type > p);

      // MassAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredMassValueType MassAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< MassAbsoluteLinearity_type > MassAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< MassAbsoluteLinearity_type, wchar_t > MassAbsoluteLinearity_traits;

      const MassAbsoluteLinearity_optional&
      MassAbsoluteLinearity () const;

      MassAbsoluteLinearity_optional&
      MassAbsoluteLinearity ();

      void
      MassAbsoluteLinearity (const MassAbsoluteLinearity_type& x);

      void
      MassAbsoluteLinearity (const MassAbsoluteLinearity_optional& x);

      void
      MassAbsoluteLinearity (::std::unique_ptr< MassAbsoluteLinearity_type > p);

      // PressureAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredPressureValueType PressureAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< PressureAbsoluteLinearity_type > PressureAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< PressureAbsoluteLinearity_type, wchar_t > PressureAbsoluteLinearity_traits;

      const PressureAbsoluteLinearity_optional&
      PressureAbsoluteLinearity () const;

      PressureAbsoluteLinearity_optional&
      PressureAbsoluteLinearity ();

      void
      PressureAbsoluteLinearity (const PressureAbsoluteLinearity_type& x);

      void
      PressureAbsoluteLinearity (const PressureAbsoluteLinearity_optional& x);

      void
      PressureAbsoluteLinearity (::std::unique_ptr< PressureAbsoluteLinearity_type > p);

      // SpeedAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredSpeedValueType SpeedAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< SpeedAbsoluteLinearity_type > SpeedAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< SpeedAbsoluteLinearity_type, wchar_t > SpeedAbsoluteLinearity_traits;

      const SpeedAbsoluteLinearity_optional&
      SpeedAbsoluteLinearity () const;

      SpeedAbsoluteLinearity_optional&
      SpeedAbsoluteLinearity ();

      void
      SpeedAbsoluteLinearity (const SpeedAbsoluteLinearity_type& x);

      void
      SpeedAbsoluteLinearity (const SpeedAbsoluteLinearity_optional& x);

      void
      SpeedAbsoluteLinearity (::std::unique_ptr< SpeedAbsoluteLinearity_type > p);

      // TemperatureAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredTemperatureValueType TemperatureAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< TemperatureAbsoluteLinearity_type > TemperatureAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureAbsoluteLinearity_type, wchar_t > TemperatureAbsoluteLinearity_traits;

      const TemperatureAbsoluteLinearity_optional&
      TemperatureAbsoluteLinearity () const;

      TemperatureAbsoluteLinearity_optional&
      TemperatureAbsoluteLinearity ();

      void
      TemperatureAbsoluteLinearity (const TemperatureAbsoluteLinearity_type& x);

      void
      TemperatureAbsoluteLinearity (const TemperatureAbsoluteLinearity_optional& x);

      void
      TemperatureAbsoluteLinearity (::std::unique_ptr< TemperatureAbsoluteLinearity_type > p);

      // TimeAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredTimeValueType TimeAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< TimeAbsoluteLinearity_type > TimeAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< TimeAbsoluteLinearity_type, wchar_t > TimeAbsoluteLinearity_traits;

      const TimeAbsoluteLinearity_optional&
      TimeAbsoluteLinearity () const;

      TimeAbsoluteLinearity_optional&
      TimeAbsoluteLinearity ();

      void
      TimeAbsoluteLinearity (const TimeAbsoluteLinearity_type& x);

      void
      TimeAbsoluteLinearity (const TimeAbsoluteLinearity_optional& x);

      void
      TimeAbsoluteLinearity (::std::unique_ptr< TimeAbsoluteLinearity_type > p);

      // UserDefinedUnitAbsoluteLinearity
      //
      typedef ::xsd::qif30::MeasuredUserDefinedUnitValueType UserDefinedUnitAbsoluteLinearity_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedUnitAbsoluteLinearity_type > UserDefinedUnitAbsoluteLinearity_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitAbsoluteLinearity_type, wchar_t > UserDefinedUnitAbsoluteLinearity_traits;

      const UserDefinedUnitAbsoluteLinearity_optional&
      UserDefinedUnitAbsoluteLinearity () const;

      UserDefinedUnitAbsoluteLinearity_optional&
      UserDefinedUnitAbsoluteLinearity ();

      void
      UserDefinedUnitAbsoluteLinearity (const UserDefinedUnitAbsoluteLinearity_type& x);

      void
      UserDefinedUnitAbsoluteLinearity (const UserDefinedUnitAbsoluteLinearity_optional& x);

      void
      UserDefinedUnitAbsoluteLinearity (::std::unique_ptr< UserDefinedUnitAbsoluteLinearity_type > p);

      // RelativeLinearity
      //
      typedef ::xsd::qif30::MeasuredDecimalType RelativeLinearity_type;
      typedef ::xsd::cxx::tree::optional< RelativeLinearity_type > RelativeLinearity_optional;
      typedef ::xsd::cxx::tree::traits< RelativeLinearity_type, wchar_t > RelativeLinearity_traits;

      const RelativeLinearity_optional&
      RelativeLinearity () const;

      RelativeLinearity_optional&
      RelativeLinearity ();

      void
      RelativeLinearity (const RelativeLinearity_type& x);

      void
      RelativeLinearity (const RelativeLinearity_optional& x);

      void
      RelativeLinearity (::std::unique_ptr< RelativeLinearity_type > p);

      // Constructors.
      //
      LinearityStudyResultsType ();

      LinearityStudyResultsType (const Status_type&,
                                 const id_type&,
                                 const SampleSize_type&);

      LinearityStudyResultsType (::std::unique_ptr< Status_type >,
                                 const id_type&,
                                 const SampleSize_type&);

      LinearityStudyResultsType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      LinearityStudyResultsType (const LinearityStudyResultsType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual LinearityStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearityStudyResultsType&
      operator= (const LinearityStudyResultsType& x);

      virtual 
      ~LinearityStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SampleSize_type > SampleSize_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      GoodnessOfFit_optional GoodnessOfFit_;
      LinearAbsoluteLinearity_optional LinearAbsoluteLinearity_;
      AngularAbsoluteLinearity_optional AngularAbsoluteLinearity_;
      AreaAbsoluteLinearity_optional AreaAbsoluteLinearity_;
      ForceAbsoluteLinearity_optional ForceAbsoluteLinearity_;
      MassAbsoluteLinearity_optional MassAbsoluteLinearity_;
      PressureAbsoluteLinearity_optional PressureAbsoluteLinearity_;
      SpeedAbsoluteLinearity_optional SpeedAbsoluteLinearity_;
      TemperatureAbsoluteLinearity_optional TemperatureAbsoluteLinearity_;
      TimeAbsoluteLinearity_optional TimeAbsoluteLinearity_;
      UserDefinedUnitAbsoluteLinearity_optional UserDefinedUnitAbsoluteLinearity_;
      RelativeLinearity_optional RelativeLinearity_;
    };

    class QIF30_SYMBOL_DECL StabilityStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // SampleSize
      //
      typedef ::xml_schema::positive_integer SampleSize_type;
      typedef ::xsd::cxx::tree::traits< SampleSize_type, wchar_t > SampleSize_traits;

      const SampleSize_type&
      SampleSize () const;

      SampleSize_type&
      SampleSize ();

      void
      SampleSize (const SampleSize_type& x);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // Constructors.
      //
      StabilityStudyResultsType ();

      StabilityStudyResultsType (const Status_type&,
                                 const id_type&,
                                 const SampleSize_type&);

      StabilityStudyResultsType (::std::unique_ptr< Status_type >,
                                 const id_type&,
                                 const SampleSize_type&);

      StabilityStudyResultsType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StabilityStudyResultsType (const StabilityStudyResultsType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StabilityStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StabilityStudyResultsType&
      operator= (const StabilityStudyResultsType& x);

      virtual 
      ~StabilityStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SampleSize_type > SampleSize_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
    };

    class QIF30_SYMBOL_DECL BiasStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // SampleSize
      //
      typedef ::xml_schema::positive_integer SampleSize_type;
      typedef ::xsd::cxx::tree::traits< SampleSize_type, wchar_t > SampleSize_traits;

      const SampleSize_type&
      SampleSize () const;

      SampleSize_type&
      SampleSize ();

      void
      SampleSize (const SampleSize_type& x);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // Constructors.
      //
      BiasStudyResultsType ();

      BiasStudyResultsType (const Status_type&,
                            const id_type&,
                            const SampleSize_type&);

      BiasStudyResultsType (::std::unique_ptr< Status_type >,
                            const id_type&,
                            const SampleSize_type&);

      BiasStudyResultsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      BiasStudyResultsType (const BiasStudyResultsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual BiasStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BiasStudyResultsType&
      operator= (const BiasStudyResultsType& x);

      virtual 
      ~BiasStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SampleSize_type > SampleSize_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
    };

    class QIF30_SYMBOL_DECL AbsoluteMeasurementsByUnitType: public ::xml_schema::type
    {
      public:
      // LinearMeasurement
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LinearMeasurement_type;
      typedef ::xsd::cxx::tree::optional< LinearMeasurement_type > LinearMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< LinearMeasurement_type, wchar_t > LinearMeasurement_traits;

      const LinearMeasurement_optional&
      LinearMeasurement () const;

      LinearMeasurement_optional&
      LinearMeasurement ();

      void
      LinearMeasurement (const LinearMeasurement_type& x);

      void
      LinearMeasurement (const LinearMeasurement_optional& x);

      void
      LinearMeasurement (::std::unique_ptr< LinearMeasurement_type > p);

      // AngularMeasurement
      //
      typedef ::xsd::qif30::MeasuredAngularValueType AngularMeasurement_type;
      typedef ::xsd::cxx::tree::optional< AngularMeasurement_type > AngularMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< AngularMeasurement_type, wchar_t > AngularMeasurement_traits;

      const AngularMeasurement_optional&
      AngularMeasurement () const;

      AngularMeasurement_optional&
      AngularMeasurement ();

      void
      AngularMeasurement (const AngularMeasurement_type& x);

      void
      AngularMeasurement (const AngularMeasurement_optional& x);

      void
      AngularMeasurement (::std::unique_ptr< AngularMeasurement_type > p);

      // AreaMeasurement
      //
      typedef ::xsd::qif30::MeasuredAreaValueType AreaMeasurement_type;
      typedef ::xsd::cxx::tree::optional< AreaMeasurement_type > AreaMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< AreaMeasurement_type, wchar_t > AreaMeasurement_traits;

      const AreaMeasurement_optional&
      AreaMeasurement () const;

      AreaMeasurement_optional&
      AreaMeasurement ();

      void
      AreaMeasurement (const AreaMeasurement_type& x);

      void
      AreaMeasurement (const AreaMeasurement_optional& x);

      void
      AreaMeasurement (::std::unique_ptr< AreaMeasurement_type > p);

      // ForceMeasurement
      //
      typedef ::xsd::qif30::MeasuredForceValueType ForceMeasurement_type;
      typedef ::xsd::cxx::tree::optional< ForceMeasurement_type > ForceMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< ForceMeasurement_type, wchar_t > ForceMeasurement_traits;

      const ForceMeasurement_optional&
      ForceMeasurement () const;

      ForceMeasurement_optional&
      ForceMeasurement ();

      void
      ForceMeasurement (const ForceMeasurement_type& x);

      void
      ForceMeasurement (const ForceMeasurement_optional& x);

      void
      ForceMeasurement (::std::unique_ptr< ForceMeasurement_type > p);

      // MassMeasurement
      //
      typedef ::xsd::qif30::MeasuredMassValueType MassMeasurement_type;
      typedef ::xsd::cxx::tree::optional< MassMeasurement_type > MassMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< MassMeasurement_type, wchar_t > MassMeasurement_traits;

      const MassMeasurement_optional&
      MassMeasurement () const;

      MassMeasurement_optional&
      MassMeasurement ();

      void
      MassMeasurement (const MassMeasurement_type& x);

      void
      MassMeasurement (const MassMeasurement_optional& x);

      void
      MassMeasurement (::std::unique_ptr< MassMeasurement_type > p);

      // PressureMeasurement
      //
      typedef ::xsd::qif30::MeasuredPressureValueType PressureMeasurement_type;
      typedef ::xsd::cxx::tree::optional< PressureMeasurement_type > PressureMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< PressureMeasurement_type, wchar_t > PressureMeasurement_traits;

      const PressureMeasurement_optional&
      PressureMeasurement () const;

      PressureMeasurement_optional&
      PressureMeasurement ();

      void
      PressureMeasurement (const PressureMeasurement_type& x);

      void
      PressureMeasurement (const PressureMeasurement_optional& x);

      void
      PressureMeasurement (::std::unique_ptr< PressureMeasurement_type > p);

      // SpeedMeasurement
      //
      typedef ::xsd::qif30::MeasuredSpeedValueType SpeedMeasurement_type;
      typedef ::xsd::cxx::tree::optional< SpeedMeasurement_type > SpeedMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< SpeedMeasurement_type, wchar_t > SpeedMeasurement_traits;

      const SpeedMeasurement_optional&
      SpeedMeasurement () const;

      SpeedMeasurement_optional&
      SpeedMeasurement ();

      void
      SpeedMeasurement (const SpeedMeasurement_type& x);

      void
      SpeedMeasurement (const SpeedMeasurement_optional& x);

      void
      SpeedMeasurement (::std::unique_ptr< SpeedMeasurement_type > p);

      // TemperatureMeasurement
      //
      typedef ::xsd::qif30::MeasuredTemperatureValueType TemperatureMeasurement_type;
      typedef ::xsd::cxx::tree::optional< TemperatureMeasurement_type > TemperatureMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureMeasurement_type, wchar_t > TemperatureMeasurement_traits;

      const TemperatureMeasurement_optional&
      TemperatureMeasurement () const;

      TemperatureMeasurement_optional&
      TemperatureMeasurement ();

      void
      TemperatureMeasurement (const TemperatureMeasurement_type& x);

      void
      TemperatureMeasurement (const TemperatureMeasurement_optional& x);

      void
      TemperatureMeasurement (::std::unique_ptr< TemperatureMeasurement_type > p);

      // TimeMeasurement
      //
      typedef ::xsd::qif30::MeasuredTimeValueType TimeMeasurement_type;
      typedef ::xsd::cxx::tree::optional< TimeMeasurement_type > TimeMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< TimeMeasurement_type, wchar_t > TimeMeasurement_traits;

      const TimeMeasurement_optional&
      TimeMeasurement () const;

      TimeMeasurement_optional&
      TimeMeasurement ();

      void
      TimeMeasurement (const TimeMeasurement_type& x);

      void
      TimeMeasurement (const TimeMeasurement_optional& x);

      void
      TimeMeasurement (::std::unique_ptr< TimeMeasurement_type > p);

      // UserDefinedUnitMeasurement
      //
      typedef ::xsd::qif30::MeasuredUserDefinedUnitValueType UserDefinedUnitMeasurement_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnitMeasurement_type > UserDefinedUnitMeasurement_sequence;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitMeasurement_type >::iterator UserDefinedUnitMeasurement_iterator;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitMeasurement_type >::const_iterator UserDefinedUnitMeasurement_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitMeasurement_type, wchar_t > UserDefinedUnitMeasurement_traits;

      const UserDefinedUnitMeasurement_sequence&
      UserDefinedUnitMeasurement () const;

      UserDefinedUnitMeasurement_sequence&
      UserDefinedUnitMeasurement ();

      void
      UserDefinedUnitMeasurement (const UserDefinedUnitMeasurement_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AbsoluteMeasurementsByUnitType ();

      AbsoluteMeasurementsByUnitType (const n_type&);

      AbsoluteMeasurementsByUnitType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AbsoluteMeasurementsByUnitType (const AbsoluteMeasurementsByUnitType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AbsoluteMeasurementsByUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AbsoluteMeasurementsByUnitType&
      operator= (const AbsoluteMeasurementsByUnitType& x);

      virtual 
      ~AbsoluteMeasurementsByUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearMeasurement_optional LinearMeasurement_;
      AngularMeasurement_optional AngularMeasurement_;
      AreaMeasurement_optional AreaMeasurement_;
      ForceMeasurement_optional ForceMeasurement_;
      MassMeasurement_optional MassMeasurement_;
      PressureMeasurement_optional PressureMeasurement_;
      SpeedMeasurement_optional SpeedMeasurement_;
      TemperatureMeasurement_optional TemperatureMeasurement_;
      TimeMeasurement_optional TimeMeasurement_;
      UserDefinedUnitMeasurement_sequence UserDefinedUnitMeasurement_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FirstArticleStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // InSpecRatio
      //
      typedef ::xml_schema::decimal InSpecRatio_type;
      typedef ::xsd::cxx::tree::optional< InSpecRatio_type > InSpecRatio_optional;
      typedef ::xsd::cxx::tree::traits< InSpecRatio_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > InSpecRatio_traits;

      const InSpecRatio_optional&
      InSpecRatio () const;

      InSpecRatio_optional&
      InSpecRatio ();

      void
      InSpecRatio (const InSpecRatio_type& x);

      void
      InSpecRatio (const InSpecRatio_optional& x);

      // AbsoluteMaximums
      //
      typedef ::xsd::qif30::AbsoluteMeasurementsByUnitType AbsoluteMaximums_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteMaximums_type > AbsoluteMaximums_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteMaximums_type, wchar_t > AbsoluteMaximums_traits;

      const AbsoluteMaximums_optional&
      AbsoluteMaximums () const;

      AbsoluteMaximums_optional&
      AbsoluteMaximums ();

      void
      AbsoluteMaximums (const AbsoluteMaximums_type& x);

      void
      AbsoluteMaximums (const AbsoluteMaximums_optional& x);

      void
      AbsoluteMaximums (::std::unique_ptr< AbsoluteMaximums_type > p);

      // RelativeMaximum
      //
      typedef ::xsd::qif30::MeasuredDecimalType RelativeMaximum_type;
      typedef ::xsd::cxx::tree::optional< RelativeMaximum_type > RelativeMaximum_optional;
      typedef ::xsd::cxx::tree::traits< RelativeMaximum_type, wchar_t > RelativeMaximum_traits;

      const RelativeMaximum_optional&
      RelativeMaximum () const;

      RelativeMaximum_optional&
      RelativeMaximum ();

      void
      RelativeMaximum (const RelativeMaximum_type& x);

      void
      RelativeMaximum (const RelativeMaximum_optional& x);

      void
      RelativeMaximum (::std::unique_ptr< RelativeMaximum_type > p);

      // Constructors.
      //
      FirstArticleStudyResultsType ();

      FirstArticleStudyResultsType (const Status_type&,
                                    const id_type&);

      FirstArticleStudyResultsType (::std::unique_ptr< Status_type >,
                                    const id_type&);

      FirstArticleStudyResultsType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      FirstArticleStudyResultsType (const FirstArticleStudyResultsType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual FirstArticleStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FirstArticleStudyResultsType&
      operator= (const FirstArticleStudyResultsType& x);

      virtual 
      ~FirstArticleStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      InSpecRatio_optional InSpecRatio_;
      AbsoluteMaximums_optional AbsoluteMaximums_;
      RelativeMaximum_optional RelativeMaximum_;
    };

    class QIF30_SYMBOL_DECL ProcessDifferenceStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // NumberOfSamples
      //
      typedef ::xml_schema::positive_integer NumberOfSamples_type;
      typedef ::xsd::cxx::tree::traits< NumberOfSamples_type, wchar_t > NumberOfSamples_traits;

      const NumberOfSamples_type&
      NumberOfSamples () const;

      NumberOfSamples_type&
      NumberOfSamples ();

      void
      NumberOfSamples (const NumberOfSamples_type& x);

      // SubgroupSize
      //
      typedef ::xml_schema::positive_integer SubgroupSize_type;
      typedef ::xsd::cxx::tree::traits< SubgroupSize_type, wchar_t > SubgroupSize_traits;

      const SubgroupSize_type&
      SubgroupSize () const;

      SubgroupSize_type&
      SubgroupSize ();

      void
      SubgroupSize (const SubgroupSize_type& x);

      static SubgroupSize_type
      SubgroupSize_default_value ();

      // ManufacturingProcessId
      //
      typedef ::xsd::qif30::QIFReferenceType ManufacturingProcessId_type;
      typedef ::xsd::cxx::tree::optional< ManufacturingProcessId_type > ManufacturingProcessId_optional;
      typedef ::xsd::cxx::tree::traits< ManufacturingProcessId_type, wchar_t > ManufacturingProcessId_traits;

      const ManufacturingProcessId_optional&
      ManufacturingProcessId () const;

      ManufacturingProcessId_optional&
      ManufacturingProcessId ();

      void
      ManufacturingProcessId (const ManufacturingProcessId_type& x);

      void
      ManufacturingProcessId (const ManufacturingProcessId_optional& x);

      void
      ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > p);

      // AbsoluteDifferences
      //
      typedef ::xsd::qif30::AbsoluteMeasurementsByUnitType AbsoluteDifferences_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteDifferences_type > AbsoluteDifferences_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteDifferences_type, wchar_t > AbsoluteDifferences_traits;

      const AbsoluteDifferences_optional&
      AbsoluteDifferences () const;

      AbsoluteDifferences_optional&
      AbsoluteDifferences ();

      void
      AbsoluteDifferences (const AbsoluteDifferences_type& x);

      void
      AbsoluteDifferences (const AbsoluteDifferences_optional& x);

      void
      AbsoluteDifferences (::std::unique_ptr< AbsoluteDifferences_type > p);

      // RelativeDifference
      //
      typedef ::xsd::qif30::MeasuredDecimalType RelativeDifference_type;
      typedef ::xsd::cxx::tree::optional< RelativeDifference_type > RelativeDifference_optional;
      typedef ::xsd::cxx::tree::traits< RelativeDifference_type, wchar_t > RelativeDifference_traits;

      const RelativeDifference_optional&
      RelativeDifference () const;

      RelativeDifference_optional&
      RelativeDifference ();

      void
      RelativeDifference (const RelativeDifference_type& x);

      void
      RelativeDifference (const RelativeDifference_optional& x);

      void
      RelativeDifference (::std::unique_ptr< RelativeDifference_type > p);

      // Constructors.
      //
      ProcessDifferenceStudyResultsType ();

      ProcessDifferenceStudyResultsType (const Status_type&,
                                         const id_type&,
                                         const NumberOfSamples_type&,
                                         const SubgroupSize_type&);

      ProcessDifferenceStudyResultsType (::std::unique_ptr< Status_type >,
                                         const id_type&,
                                         const NumberOfSamples_type&,
                                         const SubgroupSize_type&);

      ProcessDifferenceStudyResultsType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ProcessDifferenceStudyResultsType (const ProcessDifferenceStudyResultsType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ProcessDifferenceStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProcessDifferenceStudyResultsType&
      operator= (const ProcessDifferenceStudyResultsType& x);

      virtual 
      ~ProcessDifferenceStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< NumberOfSamples_type > NumberOfSamples_;
      ::xsd::cxx::tree::one< SubgroupSize_type > SubgroupSize_;
      ManufacturingProcessId_optional ManufacturingProcessId_;
      AbsoluteDifferences_optional AbsoluteDifferences_;
      RelativeDifference_optional RelativeDifference_;
    };

    class QIF30_SYMBOL_DECL MultipleProductInstanceStudyResultsBaseType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // NumberOfSamples
      //
      typedef ::xml_schema::positive_integer NumberOfSamples_type;
      typedef ::xsd::cxx::tree::traits< NumberOfSamples_type, wchar_t > NumberOfSamples_traits;

      const NumberOfSamples_type&
      NumberOfSamples () const;

      NumberOfSamples_type&
      NumberOfSamples ();

      void
      NumberOfSamples (const NumberOfSamples_type& x);

      // SubgroupSize
      //
      typedef ::xml_schema::positive_integer SubgroupSize_type;
      typedef ::xsd::cxx::tree::optional< SubgroupSize_type > SubgroupSize_optional;
      typedef ::xsd::cxx::tree::traits< SubgroupSize_type, wchar_t > SubgroupSize_traits;

      const SubgroupSize_optional&
      SubgroupSize () const;

      SubgroupSize_optional&
      SubgroupSize ();

      void
      SubgroupSize (const SubgroupSize_type& x);

      void
      SubgroupSize (const SubgroupSize_optional& x);

      // Constructors.
      //
      MultipleProductInstanceStudyResultsBaseType ();

      MultipleProductInstanceStudyResultsBaseType (const Status_type&,
                                                   const id_type&,
                                                   const NumberOfSamples_type&);

      MultipleProductInstanceStudyResultsBaseType (::std::unique_ptr< Status_type >,
                                                   const id_type&,
                                                   const NumberOfSamples_type&);

      MultipleProductInstanceStudyResultsBaseType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      MultipleProductInstanceStudyResultsBaseType (const MultipleProductInstanceStudyResultsBaseType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual MultipleProductInstanceStudyResultsBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MultipleProductInstanceStudyResultsBaseType&
      operator= (const MultipleProductInstanceStudyResultsBaseType& x);

      virtual 
      ~MultipleProductInstanceStudyResultsBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< NumberOfSamples_type > NumberOfSamples_;
      SubgroupSize_optional SubgroupSize_;
    };

    class QIF30_SYMBOL_DECL SimpleStudyResultsType: public ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType
    {
      public:
      // Constructors.
      //
      SimpleStudyResultsType ();

      SimpleStudyResultsType (const Status_type&,
                              const id_type&,
                              const NumberOfSamples_type&);

      SimpleStudyResultsType (::std::unique_ptr< Status_type >,
                              const id_type&,
                              const NumberOfSamples_type&);

      SimpleStudyResultsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      SimpleStudyResultsType (const SimpleStudyResultsType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual SimpleStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SimpleStudyResultsType&
      operator= (const SimpleStudyResultsType&) = default;
#endif

      virtual 
      ~SimpleStudyResultsType ();
    };

    class QIF30_SYMBOL_DECL CapabilityStudyResultsType: public ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType
    {
      public:
      // Constructors.
      //
      CapabilityStudyResultsType ();

      CapabilityStudyResultsType (const Status_type&,
                                  const id_type&,
                                  const NumberOfSamples_type&);

      CapabilityStudyResultsType (::std::unique_ptr< Status_type >,
                                  const id_type&,
                                  const NumberOfSamples_type&);

      CapabilityStudyResultsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CapabilityStudyResultsType (const CapabilityStudyResultsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CapabilityStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CapabilityStudyResultsType&
      operator= (const CapabilityStudyResultsType&) = default;
#endif

      virtual 
      ~CapabilityStudyResultsType ();
    };

    class QIF30_SYMBOL_DECL GageRandRStudyResultsType: public ::xsd::qif30::StatisticalStudyResultsBaseType
    {
      public:
      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // NumberOfAppraisers
      //
      typedef ::xml_schema::positive_integer NumberOfAppraisers_type;
      typedef ::xsd::cxx::tree::traits< NumberOfAppraisers_type, wchar_t > NumberOfAppraisers_traits;

      const NumberOfAppraisers_type&
      NumberOfAppraisers () const;

      NumberOfAppraisers_type&
      NumberOfAppraisers ();

      void
      NumberOfAppraisers (const NumberOfAppraisers_type& x);

      // NumberOfParts
      //
      typedef ::xml_schema::positive_integer NumberOfParts_type;
      typedef ::xsd::cxx::tree::traits< NumberOfParts_type, wchar_t > NumberOfParts_traits;

      const NumberOfParts_type&
      NumberOfParts () const;

      NumberOfParts_type&
      NumberOfParts ();

      void
      NumberOfParts (const NumberOfParts_type& x);

      // NumberOfTrials
      //
      typedef ::xml_schema::positive_integer NumberOfTrials_type;
      typedef ::xsd::cxx::tree::traits< NumberOfTrials_type, wchar_t > NumberOfTrials_traits;

      const NumberOfTrials_type&
      NumberOfTrials () const;

      NumberOfTrials_type&
      NumberOfTrials ();

      void
      NumberOfTrials (const NumberOfTrials_type& x);

      // Constructors.
      //
      GageRandRStudyResultsType ();

      GageRandRStudyResultsType (const Status_type&,
                                 const id_type&,
                                 const NumberOfAppraisers_type&,
                                 const NumberOfParts_type&,
                                 const NumberOfTrials_type&);

      GageRandRStudyResultsType (::std::unique_ptr< Status_type >,
                                 const id_type&,
                                 const NumberOfAppraisers_type&,
                                 const NumberOfParts_type&,
                                 const NumberOfTrials_type&);

      GageRandRStudyResultsType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      GageRandRStudyResultsType (const GageRandRStudyResultsType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual GageRandRStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GageRandRStudyResultsType&
      operator= (const GageRandRStudyResultsType& x);

      virtual 
      ~GageRandRStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ::xsd::cxx::tree::one< NumberOfAppraisers_type > NumberOfAppraisers_;
      ::xsd::cxx::tree::one< NumberOfParts_type > NumberOfParts_;
      ::xsd::cxx::tree::one< NumberOfTrials_type > NumberOfTrials_;
    };

    class QIF30_SYMBOL_DECL ProductionStudyResultsType: public ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType
    {
      public:
      // ControlIssueDetailsList
      //
      typedef ::xsd::qif30::ControlIssueDetailsListType ControlIssueDetailsList_type;
      typedef ::xsd::cxx::tree::sequence< ControlIssueDetailsList_type > ControlIssueDetailsList_sequence;
      typedef xsd::cxx::tree::sequence< ControlIssueDetailsList_type >::iterator ControlIssueDetailsList_iterator;
      typedef xsd::cxx::tree::sequence< ControlIssueDetailsList_type >::const_iterator ControlIssueDetailsList_const_iterator;
      typedef ::xsd::cxx::tree::traits< ControlIssueDetailsList_type, wchar_t > ControlIssueDetailsList_traits;

      const ControlIssueDetailsList_sequence&
      ControlIssueDetailsList () const;

      ControlIssueDetailsList_sequence&
      ControlIssueDetailsList ();

      void
      ControlIssueDetailsList (const ControlIssueDetailsList_sequence& s);

      // Constructors.
      //
      ProductionStudyResultsType ();

      ProductionStudyResultsType (const Status_type&,
                                  const id_type&,
                                  const NumberOfSamples_type&);

      ProductionStudyResultsType (::std::unique_ptr< Status_type >,
                                  const id_type&,
                                  const NumberOfSamples_type&);

      ProductionStudyResultsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ProductionStudyResultsType (const ProductionStudyResultsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ProductionStudyResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProductionStudyResultsType&
      operator= (const ProductionStudyResultsType& x);

      virtual 
      ~ProductionStudyResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ControlIssueDetailsList_sequence ControlIssueDetailsList_;
    };

    class QIF30_SYMBOL_DECL StatisticalStudyPlansType: public ::xml_schema::type
    {
      public:
      // StatisticalStudyPlan
      //
      typedef ::xsd::qif30::StatisticalStudyPlanBaseType StatisticalStudyPlan_type;
      typedef ::xsd::cxx::tree::sequence< StatisticalStudyPlan_type > StatisticalStudyPlan_sequence;
      typedef xsd::cxx::tree::sequence< StatisticalStudyPlan_type >::iterator StatisticalStudyPlan_iterator;
      typedef xsd::cxx::tree::sequence< StatisticalStudyPlan_type >::const_iterator StatisticalStudyPlan_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatisticalStudyPlan_type, wchar_t > StatisticalStudyPlan_traits;

      const StatisticalStudyPlan_sequence&
      StatisticalStudyPlan () const;

      StatisticalStudyPlan_sequence&
      StatisticalStudyPlan ();

      void
      StatisticalStudyPlan (const StatisticalStudyPlan_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StatisticalStudyPlansType ();

      StatisticalStudyPlansType (const n_type&);

      StatisticalStudyPlansType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StatisticalStudyPlansType (const StatisticalStudyPlansType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StatisticalStudyPlansType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatisticalStudyPlansType&
      operator= (const StatisticalStudyPlansType& x);

      virtual 
      ~StatisticalStudyPlansType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StatisticalStudyPlan_sequence StatisticalStudyPlan_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL StatisticalStudiesResultsType: public ::xml_schema::type
    {
      public:
      // StatisticalStudyResults
      //
      typedef ::xsd::qif30::StatisticalStudyResultsBaseType StatisticalStudyResults_type;
      typedef ::xsd::cxx::tree::sequence< StatisticalStudyResults_type > StatisticalStudyResults_sequence;
      typedef xsd::cxx::tree::sequence< StatisticalStudyResults_type >::iterator StatisticalStudyResults_iterator;
      typedef xsd::cxx::tree::sequence< StatisticalStudyResults_type >::const_iterator StatisticalStudyResults_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatisticalStudyResults_type, wchar_t > StatisticalStudyResults_traits;

      const StatisticalStudyResults_sequence&
      StatisticalStudyResults () const;

      StatisticalStudyResults_sequence&
      StatisticalStudyResults ();

      void
      StatisticalStudyResults (const StatisticalStudyResults_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StatisticalStudiesResultsType ();

      StatisticalStudiesResultsType (const n_type&);

      StatisticalStudiesResultsType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      StatisticalStudiesResultsType (const StatisticalStudiesResultsType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual StatisticalStudiesResultsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatisticalStudiesResultsType&
      operator= (const StatisticalStudiesResultsType& x);

      virtual 
      ~StatisticalStudiesResultsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StatisticalStudyResults_sequence StatisticalStudyResults_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CorrectiveActionPlanType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // AssignableCauses
      //
      typedef ::xsd::qif30::AssignableCausesType AssignableCauses_type;
      typedef ::xsd::cxx::tree::traits< AssignableCauses_type, wchar_t > AssignableCauses_traits;

      const AssignableCauses_type&
      AssignableCauses () const;

      AssignableCauses_type&
      AssignableCauses ();

      void
      AssignableCauses (const AssignableCauses_type& x);

      void
      AssignableCauses (::std::unique_ptr< AssignableCauses_type > p);

      // CorrectiveActions
      //
      typedef ::xsd::qif30::CorrectiveActionsType CorrectiveActions_type;
      typedef ::xsd::cxx::tree::traits< CorrectiveActions_type, wchar_t > CorrectiveActions_traits;

      const CorrectiveActions_type&
      CorrectiveActions () const;

      CorrectiveActions_type&
      CorrectiveActions ();

      void
      CorrectiveActions (const CorrectiveActions_type& x);

      void
      CorrectiveActions (::std::unique_ptr< CorrectiveActions_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      CorrectiveActionPlanType ();

      CorrectiveActionPlanType (const AssignableCauses_type&,
                                const CorrectiveActions_type&,
                                const id_type&);

      CorrectiveActionPlanType (::std::unique_ptr< AssignableCauses_type >,
                                ::std::unique_ptr< CorrectiveActions_type >,
                                const id_type&);

      CorrectiveActionPlanType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CorrectiveActionPlanType (const CorrectiveActionPlanType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CorrectiveActionPlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CorrectiveActionPlanType&
      operator= (const CorrectiveActionPlanType& x);

      virtual 
      ~CorrectiveActionPlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< AssignableCauses_type > AssignableCauses_;
      ::xsd::cxx::tree::one< CorrectiveActions_type > CorrectiveActions_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CorrectiveActionPlansType: public ::xml_schema::type
    {
      public:
      // CorrectiveActionPlan
      //
      typedef ::xsd::qif30::CorrectiveActionPlanType CorrectiveActionPlan_type;
      typedef ::xsd::cxx::tree::sequence< CorrectiveActionPlan_type > CorrectiveActionPlan_sequence;
      typedef xsd::cxx::tree::sequence< CorrectiveActionPlan_type >::iterator CorrectiveActionPlan_iterator;
      typedef xsd::cxx::tree::sequence< CorrectiveActionPlan_type >::const_iterator CorrectiveActionPlan_const_iterator;
      typedef ::xsd::cxx::tree::traits< CorrectiveActionPlan_type, wchar_t > CorrectiveActionPlan_traits;

      const CorrectiveActionPlan_sequence&
      CorrectiveActionPlan () const;

      CorrectiveActionPlan_sequence&
      CorrectiveActionPlan ();

      void
      CorrectiveActionPlan (const CorrectiveActionPlan_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CorrectiveActionPlansType ();

      CorrectiveActionPlansType (const n_type&);

      CorrectiveActionPlansType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CorrectiveActionPlansType (const CorrectiveActionPlansType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual CorrectiveActionPlansType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CorrectiveActionPlansType&
      operator= (const CorrectiveActionPlansType& x);

      virtual 
      ~CorrectiveActionPlansType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CorrectiveActionPlan_sequence CorrectiveActionPlan_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL StatisticsType: public ::xml_schema::type
    {
      public:
      // StatisticalStudyPlans
      //
      typedef ::xsd::qif30::StatisticalStudyPlansType StatisticalStudyPlans_type;
      typedef ::xsd::cxx::tree::optional< StatisticalStudyPlans_type > StatisticalStudyPlans_optional;
      typedef ::xsd::cxx::tree::traits< StatisticalStudyPlans_type, wchar_t > StatisticalStudyPlans_traits;

      const StatisticalStudyPlans_optional&
      StatisticalStudyPlans () const;

      StatisticalStudyPlans_optional&
      StatisticalStudyPlans ();

      void
      StatisticalStudyPlans (const StatisticalStudyPlans_type& x);

      void
      StatisticalStudyPlans (const StatisticalStudyPlans_optional& x);

      void
      StatisticalStudyPlans (::std::unique_ptr< StatisticalStudyPlans_type > p);

      // StatisticalStudiesResults
      //
      typedef ::xsd::qif30::StatisticalStudiesResultsType StatisticalStudiesResults_type;
      typedef ::xsd::cxx::tree::optional< StatisticalStudiesResults_type > StatisticalStudiesResults_optional;
      typedef ::xsd::cxx::tree::traits< StatisticalStudiesResults_type, wchar_t > StatisticalStudiesResults_traits;

      const StatisticalStudiesResults_optional&
      StatisticalStudiesResults () const;

      StatisticalStudiesResults_optional&
      StatisticalStudiesResults ();

      void
      StatisticalStudiesResults (const StatisticalStudiesResults_type& x);

      void
      StatisticalStudiesResults (const StatisticalStudiesResults_optional& x);

      void
      StatisticalStudiesResults (::std::unique_ptr< StatisticalStudiesResults_type > p);

      // CorrectiveActionPlans
      //
      typedef ::xsd::qif30::CorrectiveActionPlansType CorrectiveActionPlans_type;
      typedef ::xsd::cxx::tree::optional< CorrectiveActionPlans_type > CorrectiveActionPlans_optional;
      typedef ::xsd::cxx::tree::traits< CorrectiveActionPlans_type, wchar_t > CorrectiveActionPlans_traits;

      const CorrectiveActionPlans_optional&
      CorrectiveActionPlans () const;

      CorrectiveActionPlans_optional&
      CorrectiveActionPlans ();

      void
      CorrectiveActionPlans (const CorrectiveActionPlans_type& x);

      void
      CorrectiveActionPlans (const CorrectiveActionPlans_optional& x);

      void
      CorrectiveActionPlans (::std::unique_ptr< CorrectiveActionPlans_type > p);

      // Constructors.
      //
      StatisticsType ();

      StatisticsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      StatisticsType (const StatisticsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual StatisticsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatisticsType&
      operator= (const StatisticsType& x);

      virtual 
      ~StatisticsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StatisticalStudyPlans_optional StatisticalStudyPlans_;
      StatisticalStudiesResults_optional StatisticalStudiesResults_;
      CorrectiveActionPlans_optional CorrectiveActionPlans_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatisticalStudyPlanBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AbsoluteLimitsByUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearityStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StabilityStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MultipleProductInstanceStudyPlanBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BiasStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FirstArticleStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProcessDifferenceStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimpleStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CapabilityStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GageRandRStudyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const GageRandRStudyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const GageRandRStudyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriteriaByUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GageRandRStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlMethodsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProductionStudyPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatisticalStudyResultsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearityStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StabilityStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BiasStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AbsoluteMeasurementsByUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FirstArticleStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProcessDifferenceStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MultipleProductInstanceStudyResultsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimpleStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CapabilityStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GageRandRStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProductionStudyResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatisticalStudyPlansType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatisticalStudiesResultsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CorrectiveActionPlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CorrectiveActionPlansType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatisticsType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFAPPLICATIONS_QIFSTATISTICS_HXX
