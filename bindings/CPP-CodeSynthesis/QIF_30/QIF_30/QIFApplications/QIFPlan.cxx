// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFPlan.hxx"

namespace xsd
{
  namespace qif30
  {
    // PlanType
    //

    const PlanType::Version_optional& PlanType::
    Version () const
    {
      return this->Version_;
    }

    PlanType::Version_optional& PlanType::
    Version ()
    {
      return this->Version_;
    }

    void PlanType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PlanType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PlanType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const PlanType::RulesUsedQPId_optional& PlanType::
    RulesUsedQPId () const
    {
      return this->RulesUsedQPId_;
    }

    PlanType::RulesUsedQPId_optional& PlanType::
    RulesUsedQPId ()
    {
      return this->RulesUsedQPId_;
    }

    void PlanType::
    RulesUsedQPId (const RulesUsedQPId_type& x)
    {
      this->RulesUsedQPId_.set (x);
    }

    void PlanType::
    RulesUsedQPId (const RulesUsedQPId_optional& x)
    {
      this->RulesUsedQPId_ = x;
    }

    void PlanType::
    RulesUsedQPId (::std::unique_ptr< RulesUsedQPId_type > x)
    {
      this->RulesUsedQPId_.set (std::move (x));
    }

    const PlanType::RulesToUseQPId_optional& PlanType::
    RulesToUseQPId () const
    {
      return this->RulesToUseQPId_;
    }

    PlanType::RulesToUseQPId_optional& PlanType::
    RulesToUseQPId ()
    {
      return this->RulesToUseQPId_;
    }

    void PlanType::
    RulesToUseQPId (const RulesToUseQPId_type& x)
    {
      this->RulesToUseQPId_.set (x);
    }

    void PlanType::
    RulesToUseQPId (const RulesToUseQPId_optional& x)
    {
      this->RulesToUseQPId_ = x;
    }

    void PlanType::
    RulesToUseQPId (::std::unique_ptr< RulesToUseQPId_type > x)
    {
      this->RulesToUseQPId_.set (std::move (x));
    }

    const PlanType::WorkInstructions_optional& PlanType::
    WorkInstructions () const
    {
      return this->WorkInstructions_;
    }

    PlanType::WorkInstructions_optional& PlanType::
    WorkInstructions ()
    {
      return this->WorkInstructions_;
    }

    void PlanType::
    WorkInstructions (const WorkInstructions_type& x)
    {
      this->WorkInstructions_.set (x);
    }

    void PlanType::
    WorkInstructions (const WorkInstructions_optional& x)
    {
      this->WorkInstructions_ = x;
    }

    void PlanType::
    WorkInstructions (::std::unique_ptr< WorkInstructions_type > x)
    {
      this->WorkInstructions_.set (std::move (x));
    }

    const PlanType::ActionMethods_optional& PlanType::
    ActionMethods () const
    {
      return this->ActionMethods_;
    }

    PlanType::ActionMethods_optional& PlanType::
    ActionMethods ()
    {
      return this->ActionMethods_;
    }

    void PlanType::
    ActionMethods (const ActionMethods_type& x)
    {
      this->ActionMethods_.set (x);
    }

    void PlanType::
    ActionMethods (const ActionMethods_optional& x)
    {
      this->ActionMethods_ = x;
    }

    void PlanType::
    ActionMethods (::std::unique_ptr< ActionMethods_type > x)
    {
      this->ActionMethods_.set (std::move (x));
    }

    const PlanType::Measurands_optional& PlanType::
    Measurands () const
    {
      return this->Measurands_;
    }

    PlanType::Measurands_optional& PlanType::
    Measurands ()
    {
      return this->Measurands_;
    }

    void PlanType::
    Measurands (const Measurands_type& x)
    {
      this->Measurands_.set (x);
    }

    void PlanType::
    Measurands (const Measurands_optional& x)
    {
      this->Measurands_ = x;
    }

    void PlanType::
    Measurands (::std::unique_ptr< Measurands_type > x)
    {
      this->Measurands_.set (std::move (x));
    }

    const PlanType::LocalVariables_optional& PlanType::
    LocalVariables () const
    {
      return this->LocalVariables_;
    }

    PlanType::LocalVariables_optional& PlanType::
    LocalVariables ()
    {
      return this->LocalVariables_;
    }

    void PlanType::
    LocalVariables (const LocalVariables_type& x)
    {
      this->LocalVariables_.set (x);
    }

    void PlanType::
    LocalVariables (const LocalVariables_optional& x)
    {
      this->LocalVariables_ = x;
    }

    void PlanType::
    LocalVariables (::std::unique_ptr< LocalVariables_type > x)
    {
      this->LocalVariables_.set (std::move (x));
    }

    const PlanType::PlanRoot_type& PlanType::
    PlanRoot () const
    {
      return this->PlanRoot_.get ();
    }

    PlanType::PlanRoot_type& PlanType::
    PlanRoot ()
    {
      return this->PlanRoot_.get ();
    }

    void PlanType::
    PlanRoot (const PlanRoot_type& x)
    {
      this->PlanRoot_.set (x);
    }

    void PlanType::
    PlanRoot (::std::unique_ptr< PlanRoot_type > x)
    {
      this->PlanRoot_.set (std::move (x));
    }


    // PlanElementBaseType
    //

    const PlanElementBaseType::WorkInstructionIds_optional& PlanElementBaseType::
    WorkInstructionIds () const
    {
      return this->WorkInstructionIds_;
    }

    PlanElementBaseType::WorkInstructionIds_optional& PlanElementBaseType::
    WorkInstructionIds ()
    {
      return this->WorkInstructionIds_;
    }

    void PlanElementBaseType::
    WorkInstructionIds (const WorkInstructionIds_type& x)
    {
      this->WorkInstructionIds_.set (x);
    }

    void PlanElementBaseType::
    WorkInstructionIds (const WorkInstructionIds_optional& x)
    {
      this->WorkInstructionIds_ = x;
    }

    void PlanElementBaseType::
    WorkInstructionIds (::std::unique_ptr< WorkInstructionIds_type > x)
    {
      this->WorkInstructionIds_.set (std::move (x));
    }

    const PlanElementBaseType::Attributes_optional& PlanElementBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    PlanElementBaseType::Attributes_optional& PlanElementBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void PlanElementBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void PlanElementBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void PlanElementBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }


    // UnnumberedPlanElementsType
    //

    const UnnumberedPlanElementsType::PlanElement_sequence& UnnumberedPlanElementsType::
    PlanElement () const
    {
      return this->PlanElement_;
    }

    UnnumberedPlanElementsType::PlanElement_sequence& UnnumberedPlanElementsType::
    PlanElement ()
    {
      return this->PlanElement_;
    }

    void UnnumberedPlanElementsType::
    PlanElement (const PlanElement_sequence& s)
    {
      this->PlanElement_ = s;
    }

    const UnnumberedPlanElementsType::n_type& UnnumberedPlanElementsType::
    n () const
    {
      return this->n_.get ();
    }

    UnnumberedPlanElementsType::n_type& UnnumberedPlanElementsType::
    n ()
    {
      return this->n_.get ();
    }

    void UnnumberedPlanElementsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void UnnumberedPlanElementsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // NumberedPlanElementType
    //

    const NumberedPlanElementType::SequenceNumber_type& NumberedPlanElementType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    NumberedPlanElementType::SequenceNumber_type& NumberedPlanElementType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void NumberedPlanElementType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    const NumberedPlanElementType::PlanElement_type& NumberedPlanElementType::
    PlanElement () const
    {
      return this->PlanElement_.get ();
    }

    NumberedPlanElementType::PlanElement_type& NumberedPlanElementType::
    PlanElement ()
    {
      return this->PlanElement_.get ();
    }

    void NumberedPlanElementType::
    PlanElement (const PlanElement_type& x)
    {
      this->PlanElement_.set (x);
    }

    void NumberedPlanElementType::
    PlanElement (::std::unique_ptr< PlanElement_type > x)
    {
      this->PlanElement_.set (std::move (x));
    }


    // NumberedPlanElementsType
    //

    const NumberedPlanElementsType::NumberedPlanElement_sequence& NumberedPlanElementsType::
    NumberedPlanElement () const
    {
      return this->NumberedPlanElement_;
    }

    NumberedPlanElementsType::NumberedPlanElement_sequence& NumberedPlanElementsType::
    NumberedPlanElement ()
    {
      return this->NumberedPlanElement_;
    }

    void NumberedPlanElementsType::
    NumberedPlanElement (const NumberedPlanElement_sequence& s)
    {
      this->NumberedPlanElement_ = s;
    }

    const NumberedPlanElementsType::n_type& NumberedPlanElementsType::
    n () const
    {
      return this->n_.get ();
    }

    NumberedPlanElementsType::n_type& NumberedPlanElementsType::
    n ()
    {
      return this->n_.get ();
    }

    void NumberedPlanElementsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NumberedPlanElementsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ActionBaseType
    //

    const ActionBaseType::PreferredActionMethodId_optional& ActionBaseType::
    PreferredActionMethodId () const
    {
      return this->PreferredActionMethodId_;
    }

    ActionBaseType::PreferredActionMethodId_optional& ActionBaseType::
    PreferredActionMethodId ()
    {
      return this->PreferredActionMethodId_;
    }

    void ActionBaseType::
    PreferredActionMethodId (const PreferredActionMethodId_type& x)
    {
      this->PreferredActionMethodId_.set (x);
    }

    void ActionBaseType::
    PreferredActionMethodId (const PreferredActionMethodId_optional& x)
    {
      this->PreferredActionMethodId_ = x;
    }

    void ActionBaseType::
    PreferredActionMethodId (::std::unique_ptr< PreferredActionMethodId_type > x)
    {
      this->PreferredActionMethodId_.set (std::move (x));
    }

    const ActionBaseType::AlternativeActionMethodIds_optional& ActionBaseType::
    AlternativeActionMethodIds () const
    {
      return this->AlternativeActionMethodIds_;
    }

    ActionBaseType::AlternativeActionMethodIds_optional& ActionBaseType::
    AlternativeActionMethodIds ()
    {
      return this->AlternativeActionMethodIds_;
    }

    void ActionBaseType::
    AlternativeActionMethodIds (const AlternativeActionMethodIds_type& x)
    {
      this->AlternativeActionMethodIds_.set (x);
    }

    void ActionBaseType::
    AlternativeActionMethodIds (const AlternativeActionMethodIds_optional& x)
    {
      this->AlternativeActionMethodIds_ = x;
    }

    void ActionBaseType::
    AlternativeActionMethodIds (::std::unique_ptr< AlternativeActionMethodIds_type > x)
    {
      this->AlternativeActionMethodIds_.set (std::move (x));
    }

    const ActionBaseType::PreferredResourceIds_optional& ActionBaseType::
    PreferredResourceIds () const
    {
      return this->PreferredResourceIds_;
    }

    ActionBaseType::PreferredResourceIds_optional& ActionBaseType::
    PreferredResourceIds ()
    {
      return this->PreferredResourceIds_;
    }

    void ActionBaseType::
    PreferredResourceIds (const PreferredResourceIds_type& x)
    {
      this->PreferredResourceIds_.set (x);
    }

    void ActionBaseType::
    PreferredResourceIds (const PreferredResourceIds_optional& x)
    {
      this->PreferredResourceIds_ = x;
    }

    void ActionBaseType::
    PreferredResourceIds (::std::unique_ptr< PreferredResourceIds_type > x)
    {
      this->PreferredResourceIds_.set (std::move (x));
    }


    // MeasureEvaluateAllActionType
    //


    // HaltActionType
    //


    // MeasureEvaluateSpecifiedActionType
    //

    const MeasureEvaluateSpecifiedActionType::CharacteristicItemIds_type& MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds () const
    {
      return this->CharacteristicItemIds_.get ();
    }

    MeasureEvaluateSpecifiedActionType::CharacteristicItemIds_type& MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds ()
    {
      return this->CharacteristicItemIds_.get ();
    }

    void MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds (const CharacteristicItemIds_type& x)
    {
      this->CharacteristicItemIds_.set (x);
    }

    void MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > x)
    {
      this->CharacteristicItemIds_.set (std::move (x));
    }


    // EvaluateSpecifiedCharacteristicsActionType
    //

    const EvaluateSpecifiedCharacteristicsActionType::CharacteristicItemIds_type& EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds () const
    {
      return this->CharacteristicItemIds_.get ();
    }

    EvaluateSpecifiedCharacteristicsActionType::CharacteristicItemIds_type& EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds ()
    {
      return this->CharacteristicItemIds_.get ();
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds (const CharacteristicItemIds_type& x)
    {
      this->CharacteristicItemIds_.set (x);
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > x)
    {
      this->CharacteristicItemIds_.set (std::move (x));
    }


    // MeasureSpecifiedFeaturesActionType
    //

    const MeasureSpecifiedFeaturesActionType::FeatureItemIds_type& MeasureSpecifiedFeaturesActionType::
    FeatureItemIds () const
    {
      return this->FeatureItemIds_.get ();
    }

    MeasureSpecifiedFeaturesActionType::FeatureItemIds_type& MeasureSpecifiedFeaturesActionType::
    FeatureItemIds ()
    {
      return this->FeatureItemIds_.get ();
    }

    void MeasureSpecifiedFeaturesActionType::
    FeatureItemIds (const FeatureItemIds_type& x)
    {
      this->FeatureItemIds_.set (x);
    }

    void MeasureSpecifiedFeaturesActionType::
    FeatureItemIds (::std::unique_ptr< FeatureItemIds_type > x)
    {
      this->FeatureItemIds_.set (std::move (x));
    }


    // MeasurandBaseType
    //

    const MeasurandBaseType::Attributes_optional& MeasurandBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    MeasurandBaseType::Attributes_optional& MeasurandBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void MeasurandBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void MeasurandBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void MeasurandBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const MeasurandBaseType::id_type& MeasurandBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasurandBaseType::id_type& MeasurandBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurandBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurandBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // EvaluateCharacteristicMeasurandType
    //

    const EvaluateCharacteristicMeasurandType::CharacteristicItemId_type& EvaluateCharacteristicMeasurandType::
    CharacteristicItemId () const
    {
      return this->CharacteristicItemId_.get ();
    }

    EvaluateCharacteristicMeasurandType::CharacteristicItemId_type& EvaluateCharacteristicMeasurandType::
    CharacteristicItemId ()
    {
      return this->CharacteristicItemId_.get ();
    }

    void EvaluateCharacteristicMeasurandType::
    CharacteristicItemId (const CharacteristicItemId_type& x)
    {
      this->CharacteristicItemId_.set (x);
    }

    void EvaluateCharacteristicMeasurandType::
    CharacteristicItemId (::std::unique_ptr< CharacteristicItemId_type > x)
    {
      this->CharacteristicItemId_.set (std::move (x));
    }


    // EstablishDatumMeasurandType
    //

    const EstablishDatumMeasurandType::DatumDefinitionId_type& EstablishDatumMeasurandType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    EstablishDatumMeasurandType::DatumDefinitionId_type& EstablishDatumMeasurandType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void EstablishDatumMeasurandType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void EstablishDatumMeasurandType::
    DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (std::move (x));
    }

    const EstablishDatumMeasurandType::DatumReferenceFrameId_type& EstablishDatumMeasurandType::
    DatumReferenceFrameId () const
    {
      return this->DatumReferenceFrameId_.get ();
    }

    EstablishDatumMeasurandType::DatumReferenceFrameId_type& EstablishDatumMeasurandType::
    DatumReferenceFrameId ()
    {
      return this->DatumReferenceFrameId_.get ();
    }

    void EstablishDatumMeasurandType::
    DatumReferenceFrameId (const DatumReferenceFrameId_type& x)
    {
      this->DatumReferenceFrameId_.set (x);
    }

    void EstablishDatumMeasurandType::
    DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > x)
    {
      this->DatumReferenceFrameId_.set (std::move (x));
    }


    // MeasureSpecifiedMeasurandsActionType
    //

    const MeasureSpecifiedMeasurandsActionType::MeasurandIds_type& MeasureSpecifiedMeasurandsActionType::
    MeasurandIds () const
    {
      return this->MeasurandIds_.get ();
    }

    MeasureSpecifiedMeasurandsActionType::MeasurandIds_type& MeasureSpecifiedMeasurandsActionType::
    MeasurandIds ()
    {
      return this->MeasurandIds_.get ();
    }

    void MeasureSpecifiedMeasurandsActionType::
    MeasurandIds (const MeasurandIds_type& x)
    {
      this->MeasurandIds_.set (x);
    }

    void MeasureSpecifiedMeasurandsActionType::
    MeasurandIds (::std::unique_ptr< MeasurandIds_type > x)
    {
      this->MeasurandIds_.set (std::move (x));
    }


    // MeasurandsType
    //

    const MeasurandsType::Measurand_sequence& MeasurandsType::
    Measurand () const
    {
      return this->Measurand_;
    }

    MeasurandsType::Measurand_sequence& MeasurandsType::
    Measurand ()
    {
      return this->Measurand_;
    }

    void MeasurandsType::
    Measurand (const Measurand_sequence& s)
    {
      this->Measurand_ = s;
    }

    const MeasurandsType::n_type& MeasurandsType::
    n () const
    {
      return this->n_.get ();
    }

    MeasurandsType::n_type& MeasurandsType::
    n ()
    {
      return this->n_.get ();
    }

    void MeasurandsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MeasurandsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ActionMethodBaseType
    //

    const ActionMethodBaseType::ChosenResourceIds_optional& ActionMethodBaseType::
    ChosenResourceIds () const
    {
      return this->ChosenResourceIds_;
    }

    ActionMethodBaseType::ChosenResourceIds_optional& ActionMethodBaseType::
    ChosenResourceIds ()
    {
      return this->ChosenResourceIds_;
    }

    void ActionMethodBaseType::
    ChosenResourceIds (const ChosenResourceIds_type& x)
    {
      this->ChosenResourceIds_.set (x);
    }

    void ActionMethodBaseType::
    ChosenResourceIds (const ChosenResourceIds_optional& x)
    {
      this->ChosenResourceIds_ = x;
    }

    void ActionMethodBaseType::
    ChosenResourceIds (::std::unique_ptr< ChosenResourceIds_type > x)
    {
      this->ChosenResourceIds_.set (std::move (x));
    }

    const ActionMethodBaseType::WorkInstructionIds_optional& ActionMethodBaseType::
    WorkInstructionIds () const
    {
      return this->WorkInstructionIds_;
    }

    ActionMethodBaseType::WorkInstructionIds_optional& ActionMethodBaseType::
    WorkInstructionIds ()
    {
      return this->WorkInstructionIds_;
    }

    void ActionMethodBaseType::
    WorkInstructionIds (const WorkInstructionIds_type& x)
    {
      this->WorkInstructionIds_.set (x);
    }

    void ActionMethodBaseType::
    WorkInstructionIds (const WorkInstructionIds_optional& x)
    {
      this->WorkInstructionIds_ = x;
    }

    void ActionMethodBaseType::
    WorkInstructionIds (::std::unique_ptr< WorkInstructionIds_type > x)
    {
      this->WorkInstructionIds_.set (std::move (x));
    }

    const ActionMethodBaseType::Attributes_optional& ActionMethodBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ActionMethodBaseType::Attributes_optional& ActionMethodBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ActionMethodBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ActionMethodBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ActionMethodBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const ActionMethodBaseType::id_type& ActionMethodBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ActionMethodBaseType::id_type& ActionMethodBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ActionMethodBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ActionMethodBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // MeasureFeatureMethodBaseType
    //


    // AutocollimatorMeasureFeatureMethodType
    //


    // CalibratedComparatorMeasureFeatureMethodType
    //


    // ComputedTomographyMeasureFeatureMethodType
    //


    // CoordinateMeasureFeatureMethodType
    //

    const CoordinateMeasureFeatureMethodType::NumberOfMeasurementPoints_optional& CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints () const
    {
      return this->NumberOfMeasurementPoints_;
    }

    CoordinateMeasureFeatureMethodType::NumberOfMeasurementPoints_optional& CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints ()
    {
      return this->NumberOfMeasurementPoints_;
    }

    void CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints (const NumberOfMeasurementPoints_type& x)
    {
      this->NumberOfMeasurementPoints_.set (x);
    }

    void CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints (const NumberOfMeasurementPoints_optional& x)
    {
      this->NumberOfMeasurementPoints_ = x;
    }


    // ExternalReferenceMeasureFeatureMethodType
    //

    const ExternalReferenceMeasureFeatureMethodType::ExternalFileReferences_optional& ExternalReferenceMeasureFeatureMethodType::
    ExternalFileReferences () const
    {
      return this->ExternalFileReferences_;
    }

    ExternalReferenceMeasureFeatureMethodType::ExternalFileReferences_optional& ExternalReferenceMeasureFeatureMethodType::
    ExternalFileReferences ()
    {
      return this->ExternalFileReferences_;
    }

    void ExternalReferenceMeasureFeatureMethodType::
    ExternalFileReferences (const ExternalFileReferences_type& x)
    {
      this->ExternalFileReferences_.set (x);
    }

    void ExternalReferenceMeasureFeatureMethodType::
    ExternalFileReferences (const ExternalFileReferences_optional& x)
    {
      this->ExternalFileReferences_ = x;
    }

    void ExternalReferenceMeasureFeatureMethodType::
    ExternalFileReferences (::std::unique_ptr< ExternalFileReferences_type > x)
    {
      this->ExternalFileReferences_.set (std::move (x));
    }


    // GageMeasureFeatureMethodType
    //


    // LaserRadarMeasureFeatureMethodType
    //


    // LaserTrackerMeasureFeatureMethodType
    //


    // ManualMeasureFeatureMethodType
    //


    // MicroscopeMeasureFeatureMethodType
    //


    // OtherMeasureFeatureMethodType
    //


    // ProfileProjectorMeasureFeatureMethodType
    //


    // TheodoliteMeasureFeatureMethodType
    //


    // UniversalLengthMeasureFeatureMethodType
    //


    // ActionMethodsType
    //

    const ActionMethodsType::ActionMethod_sequence& ActionMethodsType::
    ActionMethod () const
    {
      return this->ActionMethod_;
    }

    ActionMethodsType::ActionMethod_sequence& ActionMethodsType::
    ActionMethod ()
    {
      return this->ActionMethod_;
    }

    void ActionMethodsType::
    ActionMethod (const ActionMethod_sequence& s)
    {
      this->ActionMethod_ = s;
    }

    const ActionMethodsType::n_type& ActionMethodsType::
    n () const
    {
      return this->n_.get ();
    }

    ActionMethodsType::n_type& ActionMethodsType::
    n ()
    {
      return this->n_.get ();
    }

    void ActionMethodsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ActionMethodsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeasureActionGroupFunctionEnumType
    //

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MeasureActionGroupFunctionEnumType_literals_[v])
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const MeasureActionGroupFunctionEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MeasureActionGroupFunctionEnumType& MeasureActionGroupFunctionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MeasureActionGroupFunctionEnumType_literals_[v]);

      return *this;
    }


    // MeasureActionGroupFunctionType
    //

    const MeasureActionGroupFunctionType::MeasureActionGroupFunctionEnum_optional& MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum () const
    {
      return this->MeasureActionGroupFunctionEnum_;
    }

    MeasureActionGroupFunctionType::MeasureActionGroupFunctionEnum_optional& MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum ()
    {
      return this->MeasureActionGroupFunctionEnum_;
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_type& x)
    {
      this->MeasureActionGroupFunctionEnum_.set (x);
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_optional& x)
    {
      this->MeasureActionGroupFunctionEnum_ = x;
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (::std::unique_ptr< MeasureActionGroupFunctionEnum_type > x)
    {
      this->MeasureActionGroupFunctionEnum_.set (std::move (x));
    }

    const MeasureActionGroupFunctionType::OtherMeasureActionGroupFunction_optional& MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction () const
    {
      return this->OtherMeasureActionGroupFunction_;
    }

    MeasureActionGroupFunctionType::OtherMeasureActionGroupFunction_optional& MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction ()
    {
      return this->OtherMeasureActionGroupFunction_;
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_type& x)
    {
      this->OtherMeasureActionGroupFunction_.set (x);
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_optional& x)
    {
      this->OtherMeasureActionGroupFunction_ = x;
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (::std::unique_ptr< OtherMeasureActionGroupFunction_type > x)
    {
      this->OtherMeasureActionGroupFunction_.set (std::move (x));
    }


    // ActionGroupBaseType
    //

    const ActionGroupBaseType::MeasureActionGroupFunction_optional& ActionGroupBaseType::
    MeasureActionGroupFunction () const
    {
      return this->MeasureActionGroupFunction_;
    }

    ActionGroupBaseType::MeasureActionGroupFunction_optional& ActionGroupBaseType::
    MeasureActionGroupFunction ()
    {
      return this->MeasureActionGroupFunction_;
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (const MeasureActionGroupFunction_type& x)
    {
      this->MeasureActionGroupFunction_.set (x);
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (const MeasureActionGroupFunction_optional& x)
    {
      this->MeasureActionGroupFunction_ = x;
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (::std::unique_ptr< MeasureActionGroupFunction_type > x)
    {
      this->MeasureActionGroupFunction_.set (std::move (x));
    }


    // OrderedActionGroupType
    //

    const OrderedActionGroupType::Steps_type& OrderedActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    OrderedActionGroupType::Steps_type& OrderedActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void OrderedActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void OrderedActionGroupType::
    Steps (::std::unique_ptr< Steps_type > x)
    {
      this->Steps_.set (std::move (x));
    }


    // UnorderedActionGroupType
    //

    const UnorderedActionGroupType::Steps_type& UnorderedActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    UnorderedActionGroupType::Steps_type& UnorderedActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void UnorderedActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void UnorderedActionGroupType::
    Steps (::std::unique_ptr< Steps_type > x)
    {
      this->Steps_.set (std::move (x));
    }


    // PartiallyOrderedActionGroupType
    //

    const PartiallyOrderedActionGroupType::StepsWithPredecessors_type& PartiallyOrderedActionGroupType::
    StepsWithPredecessors () const
    {
      return this->StepsWithPredecessors_.get ();
    }

    PartiallyOrderedActionGroupType::StepsWithPredecessors_type& PartiallyOrderedActionGroupType::
    StepsWithPredecessors ()
    {
      return this->StepsWithPredecessors_.get ();
    }

    void PartiallyOrderedActionGroupType::
    StepsWithPredecessors (const StepsWithPredecessors_type& x)
    {
      this->StepsWithPredecessors_.set (x);
    }

    void PartiallyOrderedActionGroupType::
    StepsWithPredecessors (::std::unique_ptr< StepsWithPredecessors_type > x)
    {
      this->StepsWithPredecessors_.set (std::move (x));
    }


    // StepWithPredecessorsType
    //

    const StepWithPredecessorsType::Predecessors_optional& StepWithPredecessorsType::
    Predecessors () const
    {
      return this->Predecessors_;
    }

    StepWithPredecessorsType::Predecessors_optional& StepWithPredecessorsType::
    Predecessors ()
    {
      return this->Predecessors_;
    }

    void StepWithPredecessorsType::
    Predecessors (const Predecessors_type& x)
    {
      this->Predecessors_.set (x);
    }

    void StepWithPredecessorsType::
    Predecessors (const Predecessors_optional& x)
    {
      this->Predecessors_ = x;
    }

    void StepWithPredecessorsType::
    Predecessors (::std::unique_ptr< Predecessors_type > x)
    {
      this->Predecessors_.set (std::move (x));
    }

    const StepWithPredecessorsType::Step_type& StepWithPredecessorsType::
    Step () const
    {
      return this->Step_.get ();
    }

    StepWithPredecessorsType::Step_type& StepWithPredecessorsType::
    Step ()
    {
      return this->Step_.get ();
    }

    void StepWithPredecessorsType::
    Step (const Step_type& x)
    {
      this->Step_.set (x);
    }

    void StepWithPredecessorsType::
    Step (::std::unique_ptr< Step_type > x)
    {
      this->Step_.set (std::move (x));
    }


    // StepsWithPredecessorsType
    //

    const StepsWithPredecessorsType::StepWithPredecessors_sequence& StepsWithPredecessorsType::
    StepWithPredecessors () const
    {
      return this->StepWithPredecessors_;
    }

    StepsWithPredecessorsType::StepWithPredecessors_sequence& StepsWithPredecessorsType::
    StepWithPredecessors ()
    {
      return this->StepWithPredecessors_;
    }

    void StepsWithPredecessorsType::
    StepWithPredecessors (const StepWithPredecessors_sequence& s)
    {
      this->StepWithPredecessors_ = s;
    }

    const StepsWithPredecessorsType::n_type& StepsWithPredecessorsType::
    n () const
    {
      return this->n_.get ();
    }

    StepsWithPredecessorsType::n_type& StepsWithPredecessorsType::
    n ()
    {
      return this->n_.get ();
    }

    void StepsWithPredecessorsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void StepsWithPredecessorsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PredecessorsType
    //

    const PredecessorsType::Predecessor_sequence& PredecessorsType::
    Predecessor () const
    {
      return this->Predecessor_;
    }

    PredecessorsType::Predecessor_sequence& PredecessorsType::
    Predecessor ()
    {
      return this->Predecessor_;
    }

    void PredecessorsType::
    Predecessor (const Predecessor_sequence& s)
    {
      this->Predecessor_ = s;
    }

    const PredecessorsType::n_type& PredecessorsType::
    n () const
    {
      return this->n_.get ();
    }

    PredecessorsType::n_type& PredecessorsType::
    n ()
    {
      return this->n_.get ();
    }

    void PredecessorsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PredecessorsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OneOfActionGroupType
    //

    const OneOfActionGroupType::Steps_type& OneOfActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    OneOfActionGroupType::Steps_type& OneOfActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void OneOfActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void OneOfActionGroupType::
    Steps (::std::unique_ptr< Steps_type > x)
    {
      this->Steps_.set (std::move (x));
    }


    // PickSomeActionGroupType
    //

    const PickSomeActionGroupType::Steps_type& PickSomeActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    PickSomeActionGroupType::Steps_type& PickSomeActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void PickSomeActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void PickSomeActionGroupType::
    Steps (::std::unique_ptr< Steps_type > x)
    {
      this->Steps_.set (std::move (x));
    }

    const PickSomeActionGroupType::NumberOfSteps_type& PickSomeActionGroupType::
    NumberOfSteps () const
    {
      return this->NumberOfSteps_.get ();
    }

    PickSomeActionGroupType::NumberOfSteps_type& PickSomeActionGroupType::
    NumberOfSteps ()
    {
      return this->NumberOfSteps_.get ();
    }

    void PickSomeActionGroupType::
    NumberOfSteps (const NumberOfSteps_type& x)
    {
      this->NumberOfSteps_.set (x);
    }


    // IfActionGroupType
    //

    const IfActionGroupType::If_type& IfActionGroupType::
    If () const
    {
      return this->If_.get ();
    }

    IfActionGroupType::If_type& IfActionGroupType::
    If ()
    {
      return this->If_.get ();
    }

    void IfActionGroupType::
    If (const If_type& x)
    {
      this->If_.set (x);
    }

    void IfActionGroupType::
    If (::std::unique_ptr< If_type > x)
    {
      this->If_.set (std::move (x));
    }

    const IfActionGroupType::ElseIf_sequence& IfActionGroupType::
    ElseIf () const
    {
      return this->ElseIf_;
    }

    IfActionGroupType::ElseIf_sequence& IfActionGroupType::
    ElseIf ()
    {
      return this->ElseIf_;
    }

    void IfActionGroupType::
    ElseIf (const ElseIf_sequence& s)
    {
      this->ElseIf_ = s;
    }

    const IfActionGroupType::ElseDo_optional& IfActionGroupType::
    ElseDo () const
    {
      return this->ElseDo_;
    }

    IfActionGroupType::ElseDo_optional& IfActionGroupType::
    ElseDo ()
    {
      return this->ElseDo_;
    }

    void IfActionGroupType::
    ElseDo (const ElseDo_type& x)
    {
      this->ElseDo_.set (x);
    }

    void IfActionGroupType::
    ElseDo (const ElseDo_optional& x)
    {
      this->ElseDo_ = x;
    }

    void IfActionGroupType::
    ElseDo (::std::unique_ptr< ElseDo_type > x)
    {
      this->ElseDo_.set (std::move (x));
    }


    // TestAndPlanElementType
    //

    const TestAndPlanElementType::BooleanExpression_type& TestAndPlanElementType::
    BooleanExpression () const
    {
      return this->BooleanExpression_.get ();
    }

    TestAndPlanElementType::BooleanExpression_type& TestAndPlanElementType::
    BooleanExpression ()
    {
      return this->BooleanExpression_.get ();
    }

    void TestAndPlanElementType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void TestAndPlanElementType::
    BooleanExpression (::std::unique_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (std::move (x));
    }

    const TestAndPlanElementType::PlanElement_type& TestAndPlanElementType::
    PlanElement () const
    {
      return this->PlanElement_.get ();
    }

    TestAndPlanElementType::PlanElement_type& TestAndPlanElementType::
    PlanElement ()
    {
      return this->PlanElement_.get ();
    }

    void TestAndPlanElementType::
    PlanElement (const PlanElement_type& x)
    {
      this->PlanElement_.set (x);
    }

    void TestAndPlanElementType::
    PlanElement (::std::unique_ptr< PlanElement_type > x)
    {
      this->PlanElement_.set (std::move (x));
    }


    // ElseDoType
    //

    const ElseDoType::PlanElement_type& ElseDoType::
    PlanElement () const
    {
      return this->PlanElement_.get ();
    }

    ElseDoType::PlanElement_type& ElseDoType::
    PlanElement ()
    {
      return this->PlanElement_.get ();
    }

    void ElseDoType::
    PlanElement (const PlanElement_type& x)
    {
      this->PlanElement_.set (x);
    }

    void ElseDoType::
    PlanElement (::std::unique_ptr< PlanElement_type > x)
    {
      this->PlanElement_.set (std::move (x));
    }


    // WhileActionGroupType
    //

    const WhileActionGroupType::BooleanExpression_type& WhileActionGroupType::
    BooleanExpression () const
    {
      return this->BooleanExpression_.get ();
    }

    WhileActionGroupType::BooleanExpression_type& WhileActionGroupType::
    BooleanExpression ()
    {
      return this->BooleanExpression_.get ();
    }

    void WhileActionGroupType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void WhileActionGroupType::
    BooleanExpression (::std::unique_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (std::move (x));
    }

    const WhileActionGroupType::PlanElement_type& WhileActionGroupType::
    PlanElement () const
    {
      return this->PlanElement_.get ();
    }

    WhileActionGroupType::PlanElement_type& WhileActionGroupType::
    PlanElement ()
    {
      return this->PlanElement_.get ();
    }

    void WhileActionGroupType::
    PlanElement (const PlanElement_type& x)
    {
      this->PlanElement_.set (x);
    }

    void WhileActionGroupType::
    PlanElement (::std::unique_ptr< PlanElement_type > x)
    {
      this->PlanElement_.set (std::move (x));
    }


    // WorkInstructionBaseType
    //

    const WorkInstructionBaseType::Attributes_optional& WorkInstructionBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    WorkInstructionBaseType::Attributes_optional& WorkInstructionBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void WorkInstructionBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void WorkInstructionBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void WorkInstructionBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const WorkInstructionBaseType::id_type& WorkInstructionBaseType::
    id () const
    {
      return this->id_.get ();
    }

    WorkInstructionBaseType::id_type& WorkInstructionBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void WorkInstructionBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void WorkInstructionBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // TextInstructionType
    //

    const TextInstructionType::TextInstruction_type& TextInstructionType::
    TextInstruction () const
    {
      return this->TextInstruction_.get ();
    }

    TextInstructionType::TextInstruction_type& TextInstructionType::
    TextInstruction ()
    {
      return this->TextInstruction_.get ();
    }

    void TextInstructionType::
    TextInstruction (const TextInstruction_type& x)
    {
      this->TextInstruction_.set (x);
    }

    void TextInstructionType::
    TextInstruction (::std::unique_ptr< TextInstruction_type > x)
    {
      this->TextInstruction_.set (std::move (x));
    }


    // DocumentFileInstructionType
    //

    const DocumentFileInstructionType::ExternalFile_type& DocumentFileInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    DocumentFileInstructionType::ExternalFile_type& DocumentFileInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void DocumentFileInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void DocumentFileInstructionType::
    ExternalFile (::std::unique_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (std::move (x));
    }


    // ImageInstructionType
    //

    const ImageInstructionType::ExternalFile_type& ImageInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    ImageInstructionType::ExternalFile_type& ImageInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void ImageInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void ImageInstructionType::
    ExternalFile (::std::unique_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (std::move (x));
    }


    // VariableDeclarationType
    //

    const VariableDeclarationType::Name_type& VariableDeclarationType::
    Name () const
    {
      return this->Name_.get ();
    }

    VariableDeclarationType::Name_type& VariableDeclarationType::
    Name ()
    {
      return this->Name_.get ();
    }

    void VariableDeclarationType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void VariableDeclarationType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const VariableDeclarationType::Val_type& VariableDeclarationType::
    Val () const
    {
      return this->Val_.get ();
    }

    VariableDeclarationType::Val_type& VariableDeclarationType::
    Val ()
    {
      return this->Val_.get ();
    }

    void VariableDeclarationType::
    Val (const Val_type& x)
    {
      this->Val_.set (x);
    }


    // LocalVariablesType
    //

    const LocalVariablesType::Variable_sequence& LocalVariablesType::
    Variable () const
    {
      return this->Variable_;
    }

    LocalVariablesType::Variable_sequence& LocalVariablesType::
    Variable ()
    {
      return this->Variable_;
    }

    void LocalVariablesType::
    Variable (const Variable_sequence& s)
    {
      this->Variable_ = s;
    }

    const LocalVariablesType::n_type& LocalVariablesType::
    n () const
    {
      return this->n_.get ();
    }

    LocalVariablesType::n_type& LocalVariablesType::
    n ()
    {
      return this->n_.get ();
    }

    void LocalVariablesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LocalVariablesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // VariableSetType
    //

    const VariableSetType::VariableName_type& VariableSetType::
    VariableName () const
    {
      return this->VariableName_.get ();
    }

    VariableSetType::VariableName_type& VariableSetType::
    VariableName ()
    {
      return this->VariableName_.get ();
    }

    void VariableSetType::
    VariableName (const VariableName_type& x)
    {
      this->VariableName_.set (x);
    }

    void VariableSetType::
    VariableName (::std::unique_ptr< VariableName_type > x)
    {
      this->VariableName_.set (std::move (x));
    }

    const VariableSetType::ArithmeticExpression_type& VariableSetType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_.get ();
    }

    VariableSetType::ArithmeticExpression_type& VariableSetType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_.get ();
    }

    void VariableSetType::
    ArithmeticExpression (const ArithmeticExpression_type& x)
    {
      this->ArithmeticExpression_.set (x);
    }

    void VariableSetType::
    ArithmeticExpression (::std::unique_ptr< ArithmeticExpression_type > x)
    {
      this->ArithmeticExpression_.set (std::move (x));
    }


    // VariableValueType
    //

    const VariableValueType::VariableName_type& VariableValueType::
    VariableName () const
    {
      return this->VariableName_.get ();
    }

    VariableValueType::VariableName_type& VariableValueType::
    VariableName ()
    {
      return this->VariableName_.get ();
    }

    void VariableValueType::
    VariableName (const VariableName_type& x)
    {
      this->VariableName_.set (x);
    }

    void VariableValueType::
    VariableName (::std::unique_ptr< VariableName_type > x)
    {
      this->VariableName_.set (std::move (x));
    }


    // ArithmeticParameterValueType
    //

    const ArithmeticParameterValueType::Parameter_type& ArithmeticParameterValueType::
    Parameter () const
    {
      return this->Parameter_.get ();
    }

    ArithmeticParameterValueType::Parameter_type& ArithmeticParameterValueType::
    Parameter ()
    {
      return this->Parameter_.get ();
    }

    void ArithmeticParameterValueType::
    Parameter (const Parameter_type& x)
    {
      this->Parameter_.set (x);
    }

    void ArithmeticParameterValueType::
    Parameter (::std::unique_ptr< Parameter_type > x)
    {
      this->Parameter_.set (std::move (x));
    }

    const ArithmeticParameterValueType::ObjectId_type& ArithmeticParameterValueType::
    ObjectId () const
    {
      return this->ObjectId_.get ();
    }

    ArithmeticParameterValueType::ObjectId_type& ArithmeticParameterValueType::
    ObjectId ()
    {
      return this->ObjectId_.get ();
    }

    void ArithmeticParameterValueType::
    ObjectId (const ObjectId_type& x)
    {
      this->ObjectId_.set (x);
    }

    void ArithmeticParameterValueType::
    ObjectId (::std::unique_ptr< ObjectId_type > x)
    {
      this->ObjectId_.set (std::move (x));
    }


    // TokenParameterValueType
    //

    const TokenParameterValueType::Parameter_type& TokenParameterValueType::
    Parameter () const
    {
      return this->Parameter_.get ();
    }

    TokenParameterValueType::Parameter_type& TokenParameterValueType::
    Parameter ()
    {
      return this->Parameter_.get ();
    }

    void TokenParameterValueType::
    Parameter (const Parameter_type& x)
    {
      this->Parameter_.set (x);
    }

    void TokenParameterValueType::
    Parameter (::std::unique_ptr< Parameter_type > x)
    {
      this->Parameter_.set (std::move (x));
    }

    const TokenParameterValueType::ObjectId_type& TokenParameterValueType::
    ObjectId () const
    {
      return this->ObjectId_.get ();
    }

    TokenParameterValueType::ObjectId_type& TokenParameterValueType::
    ObjectId ()
    {
      return this->ObjectId_.get ();
    }

    void TokenParameterValueType::
    ObjectId (const ObjectId_type& x)
    {
      this->ObjectId_.set (x);
    }

    void TokenParameterValueType::
    ObjectId (::std::unique_ptr< ObjectId_type > x)
    {
      this->ObjectId_.set (std::move (x));
    }


    // VideoInstructionType
    //

    const VideoInstructionType::ExternalFile_type& VideoInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    VideoInstructionType::ExternalFile_type& VideoInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void VideoInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void VideoInstructionType::
    ExternalFile (::std::unique_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (std::move (x));
    }


    // WorkInstructionsType
    //

    const WorkInstructionsType::WorkInstruction_sequence& WorkInstructionsType::
    WorkInstruction () const
    {
      return this->WorkInstruction_;
    }

    WorkInstructionsType::WorkInstruction_sequence& WorkInstructionsType::
    WorkInstruction ()
    {
      return this->WorkInstruction_;
    }

    void WorkInstructionsType::
    WorkInstruction (const WorkInstruction_sequence& s)
    {
      this->WorkInstruction_ = s;
    }

    const WorkInstructionsType::n_type& WorkInstructionsType::
    n () const
    {
      return this->n_.get ();
    }

    WorkInstructionsType::n_type& WorkInstructionsType::
    n ()
    {
      return this->n_.get ();
    }

    void WorkInstructionsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void WorkInstructionsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // PlanType
    //

    PlanType::
    PlanType ()
    : ::xml_schema::type (),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      LocalVariables_ (this),
      PlanRoot_ (this)
    {
    }

    PlanType::
    PlanType (const PlanRoot_type& PlanRoot)
    : ::xml_schema::type (),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      LocalVariables_ (this),
      PlanRoot_ (PlanRoot, this)
    {
    }

    PlanType::
    PlanType (::std::unique_ptr< PlanRoot_type > PlanRoot)
    : ::xml_schema::type (),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      LocalVariables_ (this),
      PlanRoot_ (std::move (PlanRoot), this)
    {
    }

    PlanType::
    PlanType (const PlanType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      RulesUsedQPId_ (x.RulesUsedQPId_, f, this),
      RulesToUseQPId_ (x.RulesToUseQPId_, f, this),
      WorkInstructions_ (x.WorkInstructions_, f, this),
      ActionMethods_ (x.ActionMethods_, f, this),
      Measurands_ (x.Measurands_, f, this),
      LocalVariables_ (x.LocalVariables_, f, this),
      PlanRoot_ (x.PlanRoot_, f, this)
    {
    }

    PlanType::
    PlanType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      LocalVariables_ (this),
      PlanRoot_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // RulesUsedQPId
        //
        if (n.name () == L"RulesUsedQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RulesUsedQPId_type > r (
            RulesUsedQPId_traits::create (i, f, this));

          if (!this->RulesUsedQPId_)
          {
            this->RulesUsedQPId_.set (::std::move (r));
            continue;
          }
        }

        // RulesToUseQPId
        //
        if (n.name () == L"RulesToUseQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RulesToUseQPId_type > r (
            RulesToUseQPId_traits::create (i, f, this));

          if (!this->RulesToUseQPId_)
          {
            this->RulesToUseQPId_.set (::std::move (r));
            continue;
          }
        }

        // WorkInstructions
        //
        if (n.name () == L"WorkInstructions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkInstructions_type > r (
            WorkInstructions_traits::create (i, f, this));

          if (!this->WorkInstructions_)
          {
            this->WorkInstructions_.set (::std::move (r));
            continue;
          }
        }

        // ActionMethods
        //
        if (n.name () == L"ActionMethods" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActionMethods_type > r (
            ActionMethods_traits::create (i, f, this));

          if (!this->ActionMethods_)
          {
            this->ActionMethods_.set (::std::move (r));
            continue;
          }
        }

        // Measurands
        //
        if (n.name () == L"Measurands" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measurands_type > r (
            Measurands_traits::create (i, f, this));

          if (!this->Measurands_)
          {
            this->Measurands_.set (::std::move (r));
            continue;
          }
        }

        // LocalVariables
        //
        if (n.name () == L"LocalVariables" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LocalVariables_type > r (
            LocalVariables_traits::create (i, f, this));

          if (!this->LocalVariables_)
          {
            this->LocalVariables_.set (::std::move (r));
            continue;
          }
        }

        // PlanRoot
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanRoot",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanRoot_.present ())
            {
              ::std::unique_ptr< PlanRoot_type > r (
                dynamic_cast< PlanRoot_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->PlanRoot_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!PlanRoot_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PlanRoot",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlanType* PlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanType (*this, f, c);
    }

    PlanType& PlanType::
    operator= (const PlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->RulesUsedQPId_ = x.RulesUsedQPId_;
        this->RulesToUseQPId_ = x.RulesToUseQPId_;
        this->WorkInstructions_ = x.WorkInstructions_;
        this->ActionMethods_ = x.ActionMethods_;
        this->Measurands_ = x.Measurands_;
        this->LocalVariables_ = x.LocalVariables_;
        this->PlanRoot_ = x.PlanRoot_;
      }

      return *this;
    }

    PlanType::
    ~PlanType ()
    {
    }

    // PlanElementBaseType
    //

    PlanElementBaseType::
    PlanElementBaseType ()
    : ::xml_schema::type (),
      WorkInstructionIds_ (this),
      Attributes_ (this)
    {
    }

    PlanElementBaseType::
    PlanElementBaseType (const PlanElementBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WorkInstructionIds_ (x.WorkInstructionIds_, f, this),
      Attributes_ (x.Attributes_, f, this)
    {
    }

    PlanElementBaseType::
    PlanElementBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WorkInstructionIds_ (this),
      Attributes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanElementBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WorkInstructionIds
        //
        if (n.name () == L"WorkInstructionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkInstructionIds_type > r (
            WorkInstructionIds_traits::create (i, f, this));

          if (!this->WorkInstructionIds_)
          {
            this->WorkInstructionIds_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlanElementBaseType& PlanElementBaseType::
    operator= (const PlanElementBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WorkInstructionIds_ = x.WorkInstructionIds_;
        this->Attributes_ = x.Attributes_;
      }

      return *this;
    }

    PlanElementBaseType::
    ~PlanElementBaseType ()
    {
    }

    // UnnumberedPlanElementsType
    //

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType ()
    : ::xml_schema::type (),
      PlanElement_ (this),
      n_ (this)
    {
    }

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType (const n_type& n)
    : ::xml_schema::type (),
      PlanElement_ (this),
      n_ (n, this)
    {
    }

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType (const UnnumberedPlanElementsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PlanElement_ (x.PlanElement_, f, this),
      n_ (x.n_, f, this)
    {
    }

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PlanElement_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void UnnumberedPlanElementsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PlanElement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PlanElement_type > r (
              dynamic_cast< PlanElement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->PlanElement_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    UnnumberedPlanElementsType* UnnumberedPlanElementsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnnumberedPlanElementsType (*this, f, c);
    }

    UnnumberedPlanElementsType& UnnumberedPlanElementsType::
    operator= (const UnnumberedPlanElementsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PlanElement_ = x.PlanElement_;
        this->n_ = x.n_;
      }

      return *this;
    }

    UnnumberedPlanElementsType::
    ~UnnumberedPlanElementsType ()
    {
    }

    // NumberedPlanElementType
    //

    NumberedPlanElementType::
    NumberedPlanElementType ()
    : ::xml_schema::type (),
      SequenceNumber_ (this),
      PlanElement_ (this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const SequenceNumber_type& SequenceNumber,
                             const PlanElement_type& PlanElement)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this),
      PlanElement_ (PlanElement, this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const SequenceNumber_type& SequenceNumber,
                             ::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const NumberedPlanElementType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NumberedPlanElementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        // PlanElement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanElement_.present ())
            {
              ::std::unique_ptr< PlanElement_type > r (
                dynamic_cast< PlanElement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->PlanElement_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PlanElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PlanElement",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NumberedPlanElementType* NumberedPlanElementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumberedPlanElementType (*this, f, c);
    }

    NumberedPlanElementType& NumberedPlanElementType::
    operator= (const NumberedPlanElementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    NumberedPlanElementType::
    ~NumberedPlanElementType ()
    {
    }

    // NumberedPlanElementsType
    //

    NumberedPlanElementsType::
    NumberedPlanElementsType ()
    : ::xml_schema::type (),
      NumberedPlanElement_ (this),
      n_ (this)
    {
    }

    NumberedPlanElementsType::
    NumberedPlanElementsType (const n_type& n)
    : ::xml_schema::type (),
      NumberedPlanElement_ (this),
      n_ (n, this)
    {
    }

    NumberedPlanElementsType::
    NumberedPlanElementsType (const NumberedPlanElementsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NumberedPlanElement_ (x.NumberedPlanElement_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NumberedPlanElementsType::
    NumberedPlanElementsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NumberedPlanElement_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NumberedPlanElementsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberedPlanElement
        //
        if (n.name () == L"NumberedPlanElement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberedPlanElement_type > r (
            NumberedPlanElement_traits::create (i, f, this));

          this->NumberedPlanElement_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NumberedPlanElementsType* NumberedPlanElementsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumberedPlanElementsType (*this, f, c);
    }

    NumberedPlanElementsType& NumberedPlanElementsType::
    operator= (const NumberedPlanElementsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NumberedPlanElement_ = x.NumberedPlanElement_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NumberedPlanElementsType::
    ~NumberedPlanElementsType ()
    {
    }

    // ActionBaseType
    //

    ActionBaseType::
    ActionBaseType ()
    : ::xsd::qif30::PlanElementBaseType (),
      PreferredActionMethodId_ (this),
      AlternativeActionMethodIds_ (this),
      PreferredResourceIds_ (this)
    {
    }

    ActionBaseType::
    ActionBaseType (const ActionBaseType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (x, f, c),
      PreferredActionMethodId_ (x.PreferredActionMethodId_, f, this),
      AlternativeActionMethodIds_ (x.AlternativeActionMethodIds_, f, this),
      PreferredResourceIds_ (x.PreferredResourceIds_, f, this)
    {
    }

    ActionBaseType::
    ActionBaseType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (e, f | ::xml_schema::flags::base, c),
      PreferredActionMethodId_ (this),
      AlternativeActionMethodIds_ (this),
      PreferredResourceIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PlanElementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PreferredActionMethodId
        //
        if (n.name () == L"PreferredActionMethodId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PreferredActionMethodId_type > r (
            PreferredActionMethodId_traits::create (i, f, this));

          if (!this->PreferredActionMethodId_)
          {
            this->PreferredActionMethodId_.set (::std::move (r));
            continue;
          }
        }

        // AlternativeActionMethodIds
        //
        if (n.name () == L"AlternativeActionMethodIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AlternativeActionMethodIds_type > r (
            AlternativeActionMethodIds_traits::create (i, f, this));

          if (!this->AlternativeActionMethodIds_)
          {
            this->AlternativeActionMethodIds_.set (::std::move (r));
            continue;
          }
        }

        // PreferredResourceIds
        //
        if (n.name () == L"PreferredResourceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PreferredResourceIds_type > r (
            PreferredResourceIds_traits::create (i, f, this));

          if (!this->PreferredResourceIds_)
          {
            this->PreferredResourceIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ActionBaseType& ActionBaseType::
    operator= (const ActionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PlanElementBaseType& > (*this) = x;
        this->PreferredActionMethodId_ = x.PreferredActionMethodId_;
        this->AlternativeActionMethodIds_ = x.AlternativeActionMethodIds_;
        this->PreferredResourceIds_ = x.PreferredResourceIds_;
      }

      return *this;
    }

    ActionBaseType::
    ~ActionBaseType ()
    {
    }

    // MeasureEvaluateAllActionType
    //

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType ()
    : ::xsd::qif30::ActionBaseType ()
    {
    }

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType (const MeasureEvaluateAllActionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c)
    {
    }

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f, c)
    {
    }

    MeasureEvaluateAllActionType* MeasureEvaluateAllActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureEvaluateAllActionType (*this, f, c);
    }

    MeasureEvaluateAllActionType::
    ~MeasureEvaluateAllActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAllActionType_type_factory_init (
      L"MeasureEvaluateAllActionType",
      L"http://qifstandards.org/xsd/qif3");

    // HaltActionType
    //

    HaltActionType::
    HaltActionType ()
    : ::xsd::qif30::ActionBaseType ()
    {
    }

    HaltActionType::
    HaltActionType (const HaltActionType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c)
    {
    }

    HaltActionType::
    HaltActionType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f, c)
    {
    }

    HaltActionType* HaltActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HaltActionType (*this, f, c);
    }

    HaltActionType::
    ~HaltActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, HaltActionType >
    _xsd_HaltActionType_type_factory_init (
      L"HaltActionType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasureEvaluateSpecifiedActionType
    //

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType ()
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const CharacteristicItemIds_type& CharacteristicItemIds)
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (::std::unique_ptr< CharacteristicItemIds_type > CharacteristicItemIds)
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (std::move (CharacteristicItemIds), this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const MeasureEvaluateSpecifiedActionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c),
      CharacteristicItemIds_ (x.CharacteristicItemIds_, f, this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureEvaluateSpecifiedActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CharacteristicItemIds
        //
        if (n.name () == L"CharacteristicItemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicItemIds_type > r (
            CharacteristicItemIds_traits::create (i, f, this));

          if (!CharacteristicItemIds_.present ())
          {
            this->CharacteristicItemIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CharacteristicItemIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasureEvaluateSpecifiedActionType* MeasureEvaluateSpecifiedActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureEvaluateSpecifiedActionType (*this, f, c);
    }

    MeasureEvaluateSpecifiedActionType& MeasureEvaluateSpecifiedActionType::
    operator= (const MeasureEvaluateSpecifiedActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionBaseType& > (*this) = x;
        this->CharacteristicItemIds_ = x.CharacteristicItemIds_;
      }

      return *this;
    }

    MeasureEvaluateSpecifiedActionType::
    ~MeasureEvaluateSpecifiedActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecifiedActionType_type_factory_init (
      L"MeasureEvaluateSpecifiedActionType",
      L"http://qifstandards.org/xsd/qif3");

    // EvaluateSpecifiedCharacteristicsActionType
    //

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType ()
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const CharacteristicItemIds_type& CharacteristicItemIds)
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (::std::unique_ptr< CharacteristicItemIds_type > CharacteristicItemIds)
    : ::xsd::qif30::ActionBaseType (),
      CharacteristicItemIds_ (std::move (CharacteristicItemIds), this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const EvaluateSpecifiedCharacteristicsActionType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c),
      CharacteristicItemIds_ (x.CharacteristicItemIds_, f, this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CharacteristicItemIds
        //
        if (n.name () == L"CharacteristicItemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicItemIds_type > r (
            CharacteristicItemIds_traits::create (i, f, this));

          if (!CharacteristicItemIds_.present ())
          {
            this->CharacteristicItemIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CharacteristicItemIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EvaluateSpecifiedCharacteristicsActionType* EvaluateSpecifiedCharacteristicsActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EvaluateSpecifiedCharacteristicsActionType (*this, f, c);
    }

    EvaluateSpecifiedCharacteristicsActionType& EvaluateSpecifiedCharacteristicsActionType::
    operator= (const EvaluateSpecifiedCharacteristicsActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionBaseType& > (*this) = x;
        this->CharacteristicItemIds_ = x.CharacteristicItemIds_;
      }

      return *this;
    }

    EvaluateSpecifiedCharacteristicsActionType::
    ~EvaluateSpecifiedCharacteristicsActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristicsActionType_type_factory_init (
      L"EvaluateSpecifiedCharacteristicsActionType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasureSpecifiedFeaturesActionType
    //

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType ()
    : ::xsd::qif30::ActionBaseType (),
      FeatureItemIds_ (this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const FeatureItemIds_type& FeatureItemIds)
    : ::xsd::qif30::ActionBaseType (),
      FeatureItemIds_ (FeatureItemIds, this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (::std::unique_ptr< FeatureItemIds_type > FeatureItemIds)
    : ::xsd::qif30::ActionBaseType (),
      FeatureItemIds_ (std::move (FeatureItemIds), this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const MeasureSpecifiedFeaturesActionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c),
      FeatureItemIds_ (x.FeatureItemIds_, f, this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureSpecifiedFeaturesActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureItemIds
        //
        if (n.name () == L"FeatureItemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureItemIds_type > r (
            FeatureItemIds_traits::create (i, f, this));

          if (!FeatureItemIds_.present ())
          {
            this->FeatureItemIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureItemIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasureSpecifiedFeaturesActionType* MeasureSpecifiedFeaturesActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureSpecifiedFeaturesActionType (*this, f, c);
    }

    MeasureSpecifiedFeaturesActionType& MeasureSpecifiedFeaturesActionType::
    operator= (const MeasureSpecifiedFeaturesActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionBaseType& > (*this) = x;
        this->FeatureItemIds_ = x.FeatureItemIds_;
      }

      return *this;
    }

    MeasureSpecifiedFeaturesActionType::
    ~MeasureSpecifiedFeaturesActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeaturesActionType_type_factory_init (
      L"MeasureSpecifiedFeaturesActionType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasurandBaseType
    //

    MeasurandBaseType::
    MeasurandBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (this)
    {
    }

    MeasurandBaseType::
    MeasurandBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    MeasurandBaseType::
    MeasurandBaseType (const MeasurandBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasurandBaseType::
    MeasurandBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurandBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    MeasurandBaseType& MeasurandBaseType::
    operator= (const MeasurandBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasurandBaseType::
    ~MeasurandBaseType ()
    {
    }

    // EvaluateCharacteristicMeasurandType
    //

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType ()
    : ::xsd::qif30::MeasurandBaseType (),
      CharacteristicItemId_ (this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const id_type& id,
                                         const CharacteristicItemId_type& CharacteristicItemId)
    : ::xsd::qif30::MeasurandBaseType (id),
      CharacteristicItemId_ (CharacteristicItemId, this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const id_type& id,
                                         ::std::unique_ptr< CharacteristicItemId_type > CharacteristicItemId)
    : ::xsd::qif30::MeasurandBaseType (id),
      CharacteristicItemId_ (std::move (CharacteristicItemId), this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const EvaluateCharacteristicMeasurandType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurandBaseType (x, f, c),
      CharacteristicItemId_ (x.CharacteristicItemId_, f, this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasurandBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EvaluateCharacteristicMeasurandType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurandBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CharacteristicItemId
        //
        if (n.name () == L"CharacteristicItemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicItemId_type > r (
            CharacteristicItemId_traits::create (i, f, this));

          if (!CharacteristicItemId_.present ())
          {
            this->CharacteristicItemId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CharacteristicItemId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EvaluateCharacteristicMeasurandType* EvaluateCharacteristicMeasurandType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EvaluateCharacteristicMeasurandType (*this, f, c);
    }

    EvaluateCharacteristicMeasurandType& EvaluateCharacteristicMeasurandType::
    operator= (const EvaluateCharacteristicMeasurandType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurandBaseType& > (*this) = x;
        this->CharacteristicItemId_ = x.CharacteristicItemId_;
      }

      return *this;
    }

    EvaluateCharacteristicMeasurandType::
    ~EvaluateCharacteristicMeasurandType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurandType_type_factory_init (
      L"EvaluateCharacteristicMeasurandType",
      L"http://qifstandards.org/xsd/qif3");

    // EstablishDatumMeasurandType
    //

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType ()
    : ::xsd::qif30::MeasurandBaseType (),
      DatumDefinitionId_ (this),
      DatumReferenceFrameId_ (this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const id_type& id,
                                 const DatumDefinitionId_type& DatumDefinitionId,
                                 const DatumReferenceFrameId_type& DatumReferenceFrameId)
    : ::xsd::qif30::MeasurandBaseType (id),
      DatumDefinitionId_ (DatumDefinitionId, this),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const id_type& id,
                                 ::std::unique_ptr< DatumDefinitionId_type > DatumDefinitionId,
                                 ::std::unique_ptr< DatumReferenceFrameId_type > DatumReferenceFrameId)
    : ::xsd::qif30::MeasurandBaseType (id),
      DatumDefinitionId_ (std::move (DatumDefinitionId), this),
      DatumReferenceFrameId_ (std::move (DatumReferenceFrameId), this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const EstablishDatumMeasurandType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurandBaseType (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      DatumReferenceFrameId_ (x.DatumReferenceFrameId_, f, this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::MeasurandBaseType (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      DatumReferenceFrameId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EstablishDatumMeasurandType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasurandBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DatumDefinitionId
        //
        if (n.name () == L"DatumDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // DatumReferenceFrameId
        //
        if (n.name () == L"DatumReferenceFrameId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DatumReferenceFrameId_type > r (
            DatumReferenceFrameId_traits::create (i, f, this));

          if (!DatumReferenceFrameId_.present ())
          {
            this->DatumReferenceFrameId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DatumReferenceFrameId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DatumReferenceFrameId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EstablishDatumMeasurandType* EstablishDatumMeasurandType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EstablishDatumMeasurandType (*this, f, c);
    }

    EstablishDatumMeasurandType& EstablishDatumMeasurandType::
    operator= (const EstablishDatumMeasurandType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasurandBaseType& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->DatumReferenceFrameId_ = x.DatumReferenceFrameId_;
      }

      return *this;
    }

    EstablishDatumMeasurandType::
    ~EstablishDatumMeasurandType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurandType_type_factory_init (
      L"EstablishDatumMeasurandType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasureSpecifiedMeasurandsActionType
    //

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType ()
    : ::xsd::qif30::ActionBaseType (),
      MeasurandIds_ (this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const MeasurandIds_type& MeasurandIds)
    : ::xsd::qif30::ActionBaseType (),
      MeasurandIds_ (MeasurandIds, this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (::std::unique_ptr< MeasurandIds_type > MeasurandIds)
    : ::xsd::qif30::ActionBaseType (),
      MeasurandIds_ (std::move (MeasurandIds), this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const MeasureSpecifiedMeasurandsActionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (x, f, c),
      MeasurandIds_ (x.MeasurandIds_, f, this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurandIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureSpecifiedMeasurandsActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurandIds
        //
        if (n.name () == L"MeasurandIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurandIds_type > r (
            MeasurandIds_traits::create (i, f, this));

          if (!MeasurandIds_.present ())
          {
            this->MeasurandIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MeasurandIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeasurandIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasureSpecifiedMeasurandsActionType* MeasureSpecifiedMeasurandsActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureSpecifiedMeasurandsActionType (*this, f, c);
    }

    MeasureSpecifiedMeasurandsActionType& MeasureSpecifiedMeasurandsActionType::
    operator= (const MeasureSpecifiedMeasurandsActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionBaseType& > (*this) = x;
        this->MeasurandIds_ = x.MeasurandIds_;
      }

      return *this;
    }

    MeasureSpecifiedMeasurandsActionType::
    ~MeasureSpecifiedMeasurandsActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurandsActionType_type_factory_init (
      L"MeasureSpecifiedMeasurandsActionType",
      L"http://qifstandards.org/xsd/qif3");

    // MeasurandsType
    //

    MeasurandsType::
    MeasurandsType ()
    : ::xml_schema::type (),
      Measurand_ (this),
      n_ (this)
    {
    }

    MeasurandsType::
    MeasurandsType (const n_type& n)
    : ::xml_schema::type (),
      Measurand_ (this),
      n_ (n, this)
    {
    }

    MeasurandsType::
    MeasurandsType (const MeasurandsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measurand_ (x.Measurand_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MeasurandsType::
    MeasurandsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measurand_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurandsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measurand
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Measurand",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Measurand_type > r (
              dynamic_cast< Measurand_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Measurand_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MeasurandsType* MeasurandsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurandsType (*this, f, c);
    }

    MeasurandsType& MeasurandsType::
    operator= (const MeasurandsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measurand_ = x.Measurand_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MeasurandsType::
    ~MeasurandsType ()
    {
    }

    // ActionMethodBaseType
    //

    ActionMethodBaseType::
    ActionMethodBaseType ()
    : ::xml_schema::type (),
      ChosenResourceIds_ (this),
      WorkInstructionIds_ (this),
      Attributes_ (this),
      id_ (this)
    {
    }

    ActionMethodBaseType::
    ActionMethodBaseType (const id_type& id)
    : ::xml_schema::type (),
      ChosenResourceIds_ (this),
      WorkInstructionIds_ (this),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    ActionMethodBaseType::
    ActionMethodBaseType (const ActionMethodBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ChosenResourceIds_ (x.ChosenResourceIds_, f, this),
      WorkInstructionIds_ (x.WorkInstructionIds_, f, this),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ActionMethodBaseType::
    ActionMethodBaseType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ChosenResourceIds_ (this),
      WorkInstructionIds_ (this),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ActionMethodBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ChosenResourceIds
        //
        if (n.name () == L"ChosenResourceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ChosenResourceIds_type > r (
            ChosenResourceIds_traits::create (i, f, this));

          if (!this->ChosenResourceIds_)
          {
            this->ChosenResourceIds_.set (::std::move (r));
            continue;
          }
        }

        // WorkInstructionIds
        //
        if (n.name () == L"WorkInstructionIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WorkInstructionIds_type > r (
            WorkInstructionIds_traits::create (i, f, this));

          if (!this->WorkInstructionIds_)
          {
            this->WorkInstructionIds_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    ActionMethodBaseType& ActionMethodBaseType::
    operator= (const ActionMethodBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ChosenResourceIds_ = x.ChosenResourceIds_;
        this->WorkInstructionIds_ = x.WorkInstructionIds_;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ActionMethodBaseType::
    ~ActionMethodBaseType ()
    {
    }

    // MeasureFeatureMethodBaseType
    //

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType ()
    : ::xsd::qif30::ActionMethodBaseType ()
    {
    }

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const id_type& id)
    : ::xsd::qif30::ActionMethodBaseType (id)
    {
    }

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const MeasureFeatureMethodBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ActionMethodBaseType (x, f, c)
    {
    }

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ActionMethodBaseType (e, f, c)
    {
    }

    MeasureFeatureMethodBaseType::
    ~MeasureFeatureMethodBaseType ()
    {
    }

    // AutocollimatorMeasureFeatureMethodType
    //

    AutocollimatorMeasureFeatureMethodType::
    AutocollimatorMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    AutocollimatorMeasureFeatureMethodType::
    AutocollimatorMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    AutocollimatorMeasureFeatureMethodType::
    AutocollimatorMeasureFeatureMethodType (const AutocollimatorMeasureFeatureMethodType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    AutocollimatorMeasureFeatureMethodType::
    AutocollimatorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    AutocollimatorMeasureFeatureMethodType* AutocollimatorMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AutocollimatorMeasureFeatureMethodType (*this, f, c);
    }

    AutocollimatorMeasureFeatureMethodType::
    ~AutocollimatorMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AutocollimatorMeasureFeatureMethodType >
    _xsd_AutocollimatorMeasureFeatureMethodType_type_factory_init (
      L"AutocollimatorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // CalibratedComparatorMeasureFeatureMethodType
    //

    CalibratedComparatorMeasureFeatureMethodType::
    CalibratedComparatorMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    CalibratedComparatorMeasureFeatureMethodType::
    CalibratedComparatorMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    CalibratedComparatorMeasureFeatureMethodType::
    CalibratedComparatorMeasureFeatureMethodType (const CalibratedComparatorMeasureFeatureMethodType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    CalibratedComparatorMeasureFeatureMethodType::
    CalibratedComparatorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    CalibratedComparatorMeasureFeatureMethodType* CalibratedComparatorMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibratedComparatorMeasureFeatureMethodType (*this, f, c);
    }

    CalibratedComparatorMeasureFeatureMethodType::
    ~CalibratedComparatorMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CalibratedComparatorMeasureFeatureMethodType >
    _xsd_CalibratedComparatorMeasureFeatureMethodType_type_factory_init (
      L"CalibratedComparatorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // ComputedTomographyMeasureFeatureMethodType
    //

    ComputedTomographyMeasureFeatureMethodType::
    ComputedTomographyMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    ComputedTomographyMeasureFeatureMethodType::
    ComputedTomographyMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    ComputedTomographyMeasureFeatureMethodType::
    ComputedTomographyMeasureFeatureMethodType (const ComputedTomographyMeasureFeatureMethodType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    ComputedTomographyMeasureFeatureMethodType::
    ComputedTomographyMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    ComputedTomographyMeasureFeatureMethodType* ComputedTomographyMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComputedTomographyMeasureFeatureMethodType (*this, f, c);
    }

    ComputedTomographyMeasureFeatureMethodType::
    ~ComputedTomographyMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ComputedTomographyMeasureFeatureMethodType >
    _xsd_ComputedTomographyMeasureFeatureMethodType_type_factory_init (
      L"ComputedTomographyMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // CoordinateMeasureFeatureMethodType
    //

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType (),
      NumberOfMeasurementPoints_ (this)
    {
    }

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id),
      NumberOfMeasurementPoints_ (this)
    {
    }

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const CoordinateMeasureFeatureMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c),
      NumberOfMeasurementPoints_ (x.NumberOfMeasurementPoints_, f, this)
    {
    }

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfMeasurementPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateMeasureFeatureMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasureFeatureMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfMeasurementPoints
        //
        if (n.name () == L"NumberOfMeasurementPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NumberOfMeasurementPoints_)
          {
            this->NumberOfMeasurementPoints_.set (NumberOfMeasurementPoints_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    CoordinateMeasureFeatureMethodType* CoordinateMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateMeasureFeatureMethodType (*this, f, c);
    }

    CoordinateMeasureFeatureMethodType& CoordinateMeasureFeatureMethodType::
    operator= (const CoordinateMeasureFeatureMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasureFeatureMethodBaseType& > (*this) = x;
        this->NumberOfMeasurementPoints_ = x.NumberOfMeasurementPoints_;
      }

      return *this;
    }

    CoordinateMeasureFeatureMethodType::
    ~CoordinateMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethodType_type_factory_init (
      L"CoordinateMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // ExternalReferenceMeasureFeatureMethodType
    //

    ExternalReferenceMeasureFeatureMethodType::
    ExternalReferenceMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType (),
      ExternalFileReferences_ (this)
    {
    }

    ExternalReferenceMeasureFeatureMethodType::
    ExternalReferenceMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id),
      ExternalFileReferences_ (this)
    {
    }

    ExternalReferenceMeasureFeatureMethodType::
    ExternalReferenceMeasureFeatureMethodType (const ExternalReferenceMeasureFeatureMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c),
      ExternalFileReferences_ (x.ExternalFileReferences_, f, this)
    {
    }

    ExternalReferenceMeasureFeatureMethodType::
    ExternalReferenceMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFileReferences_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExternalReferenceMeasureFeatureMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasureFeatureMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExternalFileReferences
        //
        if (n.name () == L"ExternalFileReferences" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalFileReferences_type > r (
            ExternalFileReferences_traits::create (i, f, this));

          if (!this->ExternalFileReferences_)
          {
            this->ExternalFileReferences_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExternalReferenceMeasureFeatureMethodType* ExternalReferenceMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExternalReferenceMeasureFeatureMethodType (*this, f, c);
    }

    ExternalReferenceMeasureFeatureMethodType& ExternalReferenceMeasureFeatureMethodType::
    operator= (const ExternalReferenceMeasureFeatureMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasureFeatureMethodBaseType& > (*this) = x;
        this->ExternalFileReferences_ = x.ExternalFileReferences_;
      }

      return *this;
    }

    ExternalReferenceMeasureFeatureMethodType::
    ~ExternalReferenceMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExternalReferenceMeasureFeatureMethodType >
    _xsd_ExternalReferenceMeasureFeatureMethodType_type_factory_init (
      L"ExternalReferenceMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // GageMeasureFeatureMethodType
    //

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const GageMeasureFeatureMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    GageMeasureFeatureMethodType* GageMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageMeasureFeatureMethodType (*this, f, c);
    }

    GageMeasureFeatureMethodType::
    ~GageMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethodType_type_factory_init (
      L"GageMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // LaserRadarMeasureFeatureMethodType
    //

    LaserRadarMeasureFeatureMethodType::
    LaserRadarMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    LaserRadarMeasureFeatureMethodType::
    LaserRadarMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    LaserRadarMeasureFeatureMethodType::
    LaserRadarMeasureFeatureMethodType (const LaserRadarMeasureFeatureMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    LaserRadarMeasureFeatureMethodType::
    LaserRadarMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    LaserRadarMeasureFeatureMethodType* LaserRadarMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserRadarMeasureFeatureMethodType (*this, f, c);
    }

    LaserRadarMeasureFeatureMethodType::
    ~LaserRadarMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LaserRadarMeasureFeatureMethodType >
    _xsd_LaserRadarMeasureFeatureMethodType_type_factory_init (
      L"LaserRadarMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // LaserTrackerMeasureFeatureMethodType
    //

    LaserTrackerMeasureFeatureMethodType::
    LaserTrackerMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    LaserTrackerMeasureFeatureMethodType::
    LaserTrackerMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    LaserTrackerMeasureFeatureMethodType::
    LaserTrackerMeasureFeatureMethodType (const LaserTrackerMeasureFeatureMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    LaserTrackerMeasureFeatureMethodType::
    LaserTrackerMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    LaserTrackerMeasureFeatureMethodType* LaserTrackerMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LaserTrackerMeasureFeatureMethodType (*this, f, c);
    }

    LaserTrackerMeasureFeatureMethodType::
    ~LaserTrackerMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LaserTrackerMeasureFeatureMethodType >
    _xsd_LaserTrackerMeasureFeatureMethodType_type_factory_init (
      L"LaserTrackerMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // ManualMeasureFeatureMethodType
    //

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const ManualMeasureFeatureMethodType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    ManualMeasureFeatureMethodType* ManualMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManualMeasureFeatureMethodType (*this, f, c);
    }

    ManualMeasureFeatureMethodType::
    ~ManualMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethodType_type_factory_init (
      L"ManualMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // MicroscopeMeasureFeatureMethodType
    //

    MicroscopeMeasureFeatureMethodType::
    MicroscopeMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    MicroscopeMeasureFeatureMethodType::
    MicroscopeMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    MicroscopeMeasureFeatureMethodType::
    MicroscopeMeasureFeatureMethodType (const MicroscopeMeasureFeatureMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    MicroscopeMeasureFeatureMethodType::
    MicroscopeMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    MicroscopeMeasureFeatureMethodType* MicroscopeMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MicroscopeMeasureFeatureMethodType (*this, f, c);
    }

    MicroscopeMeasureFeatureMethodType::
    ~MicroscopeMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MicroscopeMeasureFeatureMethodType >
    _xsd_MicroscopeMeasureFeatureMethodType_type_factory_init (
      L"MicroscopeMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherMeasureFeatureMethodType
    //

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const OtherMeasureFeatureMethodType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    OtherMeasureFeatureMethodType* OtherMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherMeasureFeatureMethodType (*this, f, c);
    }

    OtherMeasureFeatureMethodType::
    ~OtherMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethodType_type_factory_init (
      L"OtherMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // ProfileProjectorMeasureFeatureMethodType
    //

    ProfileProjectorMeasureFeatureMethodType::
    ProfileProjectorMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    ProfileProjectorMeasureFeatureMethodType::
    ProfileProjectorMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    ProfileProjectorMeasureFeatureMethodType::
    ProfileProjectorMeasureFeatureMethodType (const ProfileProjectorMeasureFeatureMethodType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    ProfileProjectorMeasureFeatureMethodType::
    ProfileProjectorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    ProfileProjectorMeasureFeatureMethodType* ProfileProjectorMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileProjectorMeasureFeatureMethodType (*this, f, c);
    }

    ProfileProjectorMeasureFeatureMethodType::
    ~ProfileProjectorMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProfileProjectorMeasureFeatureMethodType >
    _xsd_ProfileProjectorMeasureFeatureMethodType_type_factory_init (
      L"ProfileProjectorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // TheodoliteMeasureFeatureMethodType
    //

    TheodoliteMeasureFeatureMethodType::
    TheodoliteMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    TheodoliteMeasureFeatureMethodType::
    TheodoliteMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    TheodoliteMeasureFeatureMethodType::
    TheodoliteMeasureFeatureMethodType (const TheodoliteMeasureFeatureMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    TheodoliteMeasureFeatureMethodType::
    TheodoliteMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    TheodoliteMeasureFeatureMethodType* TheodoliteMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TheodoliteMeasureFeatureMethodType (*this, f, c);
    }

    TheodoliteMeasureFeatureMethodType::
    ~TheodoliteMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TheodoliteMeasureFeatureMethodType >
    _xsd_TheodoliteMeasureFeatureMethodType_type_factory_init (
      L"TheodoliteMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // UniversalLengthMeasureFeatureMethodType
    //

    UniversalLengthMeasureFeatureMethodType::
    UniversalLengthMeasureFeatureMethodType ()
    : ::xsd::qif30::MeasureFeatureMethodBaseType ()
    {
    }

    UniversalLengthMeasureFeatureMethodType::
    UniversalLengthMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (id)
    {
    }

    UniversalLengthMeasureFeatureMethodType::
    UniversalLengthMeasureFeatureMethodType (const UniversalLengthMeasureFeatureMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    UniversalLengthMeasureFeatureMethodType::
    UniversalLengthMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    UniversalLengthMeasureFeatureMethodType* UniversalLengthMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UniversalLengthMeasureFeatureMethodType (*this, f, c);
    }

    UniversalLengthMeasureFeatureMethodType::
    ~UniversalLengthMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UniversalLengthMeasureFeatureMethodType >
    _xsd_UniversalLengthMeasureFeatureMethodType_type_factory_init (
      L"UniversalLengthMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");

    // ActionMethodsType
    //

    ActionMethodsType::
    ActionMethodsType ()
    : ::xml_schema::type (),
      ActionMethod_ (this),
      n_ (this)
    {
    }

    ActionMethodsType::
    ActionMethodsType (const n_type& n)
    : ::xml_schema::type (),
      ActionMethod_ (this),
      n_ (n, this)
    {
    }

    ActionMethodsType::
    ActionMethodsType (const ActionMethodsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ActionMethod_ (x.ActionMethod_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ActionMethodsType::
    ActionMethodsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ActionMethod_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ActionMethodsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ActionMethod
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ActionMethod",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ActionMethod_type > r (
              dynamic_cast< ActionMethod_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ActionMethod_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ActionMethodsType* ActionMethodsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionMethodsType (*this, f, c);
    }

    ActionMethodsType& ActionMethodsType::
    operator= (const ActionMethodsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ActionMethod_ = x.ActionMethod_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ActionMethodsType::
    ~ActionMethodsType ()
    {
    }

    // MeasureActionGroupFunctionEnumType
    //

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType* MeasureActionGroupFunctionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureActionGroupFunctionEnumType (*this, f, c);
    }

    MeasureActionGroupFunctionEnumType::value MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_MeasureActionGroupFunctionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MeasureActionGroupFunctionEnumType_indexes_,
                        _xsd_MeasureActionGroupFunctionEnumType_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_MeasureActionGroupFunctionEnumType_indexes_ + 9 || _xsd_MeasureActionGroupFunctionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_literals_[9] =
    {
      L"ROUTING_PLAN",
      L"OPERATION_SEQUENCE",
      L"SETUP_USAGE_GROUP",
      L"SENSOR_USAGE_GROUP",
      L"CARRIAGE_USAGE_GROUP",
      L"PCS_USAGE_GROUP",
      L"EVALUATE_CHAR_ACTIONS",
      L"ESTABLISH_DATUM_ACTIONS",
      L"UNDEFINED"
    };

    const MeasureActionGroupFunctionEnumType::value MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_indexes_[9] =
    {
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::CARRIAGE_USAGE_GROUP,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::ESTABLISH_DATUM_ACTIONS,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::EVALUATE_CHAR_ACTIONS,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::OPERATION_SEQUENCE,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::PCS_USAGE_GROUP,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::ROUTING_PLAN,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::SENSOR_USAGE_GROUP,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::SETUP_USAGE_GROUP,
      ::xsd::qif30::MeasureActionGroupFunctionEnumType::UNDEFINED
    };

    // MeasureActionGroupFunctionType
    //

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType ()
    : ::xml_schema::type (),
      MeasureActionGroupFunctionEnum_ (this),
      OtherMeasureActionGroupFunction_ (this)
    {
    }

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType (const MeasureActionGroupFunctionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasureActionGroupFunctionEnum_ (x.MeasureActionGroupFunctionEnum_, f, this),
      OtherMeasureActionGroupFunction_ (x.OtherMeasureActionGroupFunction_, f, this)
    {
    }

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasureActionGroupFunctionEnum_ (this),
      OtherMeasureActionGroupFunction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureActionGroupFunctionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasureActionGroupFunctionEnum
        //
        if (n.name () == L"MeasureActionGroupFunctionEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasureActionGroupFunctionEnum_type > r (
            MeasureActionGroupFunctionEnum_traits::create (i, f, this));

          if (!this->MeasureActionGroupFunctionEnum_)
          {
            this->MeasureActionGroupFunctionEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherMeasureActionGroupFunction
        //
        if (n.name () == L"OtherMeasureActionGroupFunction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherMeasureActionGroupFunction_type > r (
            OtherMeasureActionGroupFunction_traits::create (i, f, this));

          if (!this->OtherMeasureActionGroupFunction_)
          {
            this->OtherMeasureActionGroupFunction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasureActionGroupFunctionType* MeasureActionGroupFunctionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureActionGroupFunctionType (*this, f, c);
    }

    MeasureActionGroupFunctionType& MeasureActionGroupFunctionType::
    operator= (const MeasureActionGroupFunctionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasureActionGroupFunctionEnum_ = x.MeasureActionGroupFunctionEnum_;
        this->OtherMeasureActionGroupFunction_ = x.OtherMeasureActionGroupFunction_;
      }

      return *this;
    }

    MeasureActionGroupFunctionType::
    ~MeasureActionGroupFunctionType ()
    {
    }

    // ActionGroupBaseType
    //

    ActionGroupBaseType::
    ActionGroupBaseType ()
    : ::xsd::qif30::PlanElementBaseType (),
      MeasureActionGroupFunction_ (this)
    {
    }

    ActionGroupBaseType::
    ActionGroupBaseType (const ActionGroupBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (x, f, c),
      MeasureActionGroupFunction_ (x.MeasureActionGroupFunction_, f, this)
    {
    }

    ActionGroupBaseType::
    ActionGroupBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (e, f | ::xml_schema::flags::base, c),
      MeasureActionGroupFunction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActionGroupBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PlanElementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasureActionGroupFunction
        //
        if (n.name () == L"MeasureActionGroupFunction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasureActionGroupFunction_type > r (
            MeasureActionGroupFunction_traits::create (i, f, this));

          if (!this->MeasureActionGroupFunction_)
          {
            this->MeasureActionGroupFunction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ActionGroupBaseType& ActionGroupBaseType::
    operator= (const ActionGroupBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PlanElementBaseType& > (*this) = x;
        this->MeasureActionGroupFunction_ = x.MeasureActionGroupFunction_;
      }

      return *this;
    }

    ActionGroupBaseType::
    ~ActionGroupBaseType ()
    {
    }

    // OrderedActionGroupType
    //

    OrderedActionGroupType::
    OrderedActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (const Steps_type& Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (::std::unique_ptr< Steps_type > Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (std::move (Steps), this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (const OrderedActionGroupType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Steps
        //
        if (n.name () == L"Steps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Steps",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OrderedActionGroupType* OrderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrderedActionGroupType (*this, f, c);
    }

    OrderedActionGroupType& OrderedActionGroupType::
    operator= (const OrderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    OrderedActionGroupType::
    ~OrderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OrderedActionGroupType >
    _xsd_OrderedActionGroupType_type_factory_init (
      L"OrderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // UnorderedActionGroupType
    //

    UnorderedActionGroupType::
    UnorderedActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (const Steps_type& Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (::std::unique_ptr< Steps_type > Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (std::move (Steps), this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (const UnorderedActionGroupType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UnorderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Steps
        //
        if (n.name () == L"Steps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Steps",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UnorderedActionGroupType* UnorderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnorderedActionGroupType (*this, f, c);
    }

    UnorderedActionGroupType& UnorderedActionGroupType::
    operator= (const UnorderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    UnorderedActionGroupType::
    ~UnorderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UnorderedActionGroupType >
    _xsd_UnorderedActionGroupType_type_factory_init (
      L"UnorderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // PartiallyOrderedActionGroupType
    //

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      StepsWithPredecessors_ (this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const StepsWithPredecessors_type& StepsWithPredecessors)
    : ::xsd::qif30::ActionGroupBaseType (),
      StepsWithPredecessors_ (StepsWithPredecessors, this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (::std::unique_ptr< StepsWithPredecessors_type > StepsWithPredecessors)
    : ::xsd::qif30::ActionGroupBaseType (),
      StepsWithPredecessors_ (std::move (StepsWithPredecessors), this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const PartiallyOrderedActionGroupType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      StepsWithPredecessors_ (x.StepsWithPredecessors_, f, this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      StepsWithPredecessors_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PartiallyOrderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StepsWithPredecessors
        //
        if (n.name () == L"StepsWithPredecessors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StepsWithPredecessors_type > r (
            StepsWithPredecessors_traits::create (i, f, this));

          if (!StepsWithPredecessors_.present ())
          {
            this->StepsWithPredecessors_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StepsWithPredecessors_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StepsWithPredecessors",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PartiallyOrderedActionGroupType* PartiallyOrderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartiallyOrderedActionGroupType (*this, f, c);
    }

    PartiallyOrderedActionGroupType& PartiallyOrderedActionGroupType::
    operator= (const PartiallyOrderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->StepsWithPredecessors_ = x.StepsWithPredecessors_;
      }

      return *this;
    }

    PartiallyOrderedActionGroupType::
    ~PartiallyOrderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroupType_type_factory_init (
      L"PartiallyOrderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // StepWithPredecessorsType
    //

    StepWithPredecessorsType::
    StepWithPredecessorsType ()
    : ::xml_schema::type (),
      Predecessors_ (this),
      Step_ (this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (const Step_type& Step)
    : ::xml_schema::type (),
      Predecessors_ (this),
      Step_ (Step, this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (::std::unique_ptr< Step_type > Step)
    : ::xml_schema::type (),
      Predecessors_ (this),
      Step_ (std::move (Step), this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (const StepWithPredecessorsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Predecessors_ (x.Predecessors_, f, this),
      Step_ (x.Step_, f, this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Predecessors_ (this),
      Step_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StepWithPredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Predecessors
        //
        if (n.name () == L"Predecessors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Predecessors_type > r (
            Predecessors_traits::create (i, f, this));

          if (!this->Predecessors_)
          {
            this->Predecessors_.set (::std::move (r));
            continue;
          }
        }

        // Step
        //
        if (n.name () == L"Step" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Step_type > r (
            Step_traits::create (i, f, this));

          if (!Step_.present ())
          {
            this->Step_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Step_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Step",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StepWithPredecessorsType* StepWithPredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StepWithPredecessorsType (*this, f, c);
    }

    StepWithPredecessorsType& StepWithPredecessorsType::
    operator= (const StepWithPredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Predecessors_ = x.Predecessors_;
        this->Step_ = x.Step_;
      }

      return *this;
    }

    StepWithPredecessorsType::
    ~StepWithPredecessorsType ()
    {
    }

    // StepsWithPredecessorsType
    //

    StepsWithPredecessorsType::
    StepsWithPredecessorsType ()
    : ::xml_schema::type (),
      StepWithPredecessors_ (this),
      n_ (this)
    {
    }

    StepsWithPredecessorsType::
    StepsWithPredecessorsType (const n_type& n)
    : ::xml_schema::type (),
      StepWithPredecessors_ (this),
      n_ (n, this)
    {
    }

    StepsWithPredecessorsType::
    StepsWithPredecessorsType (const StepsWithPredecessorsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StepWithPredecessors_ (x.StepWithPredecessors_, f, this),
      n_ (x.n_, f, this)
    {
    }

    StepsWithPredecessorsType::
    StepsWithPredecessorsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StepWithPredecessors_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StepsWithPredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StepWithPredecessors
        //
        if (n.name () == L"StepWithPredecessors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StepWithPredecessors_type > r (
            StepWithPredecessors_traits::create (i, f, this));

          this->StepWithPredecessors_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    StepsWithPredecessorsType* StepsWithPredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StepsWithPredecessorsType (*this, f, c);
    }

    StepsWithPredecessorsType& StepsWithPredecessorsType::
    operator= (const StepsWithPredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StepWithPredecessors_ = x.StepWithPredecessors_;
        this->n_ = x.n_;
      }

      return *this;
    }

    StepsWithPredecessorsType::
    ~StepsWithPredecessorsType ()
    {
    }

    // PredecessorsType
    //

    PredecessorsType::
    PredecessorsType ()
    : ::xml_schema::type (),
      Predecessor_ (this),
      n_ (this)
    {
    }

    PredecessorsType::
    PredecessorsType (const n_type& n)
    : ::xml_schema::type (),
      Predecessor_ (this),
      n_ (n, this)
    {
    }

    PredecessorsType::
    PredecessorsType (const PredecessorsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Predecessor_ (x.Predecessor_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PredecessorsType::
    PredecessorsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Predecessor_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Predecessor
        //
        if (n.name () == L"Predecessor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          this->Predecessor_.push_back (Predecessor_traits::create (i, f, this));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PredecessorsType* PredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PredecessorsType (*this, f, c);
    }

    PredecessorsType& PredecessorsType::
    operator= (const PredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Predecessor_ = x.Predecessor_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PredecessorsType::
    ~PredecessorsType ()
    {
    }

    // OneOfActionGroupType
    //

    OneOfActionGroupType::
    OneOfActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (const Steps_type& Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (::std::unique_ptr< Steps_type > Steps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (std::move (Steps), this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (const OneOfActionGroupType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OneOfActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Steps
        //
        if (n.name () == L"Steps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Steps",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OneOfActionGroupType* OneOfActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OneOfActionGroupType (*this, f, c);
    }

    OneOfActionGroupType& OneOfActionGroupType::
    operator= (const OneOfActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    OneOfActionGroupType::
    ~OneOfActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OneOfActionGroupType >
    _xsd_OneOfActionGroupType_type_factory_init (
      L"OneOfActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // PickSomeActionGroupType
    //

    PickSomeActionGroupType::
    PickSomeActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (this),
      NumberOfSteps_ (this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (const Steps_type& Steps,
                             const NumberOfSteps_type& NumberOfSteps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (Steps, this),
      NumberOfSteps_ (NumberOfSteps, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (::std::unique_ptr< Steps_type > Steps,
                             const NumberOfSteps_type& NumberOfSteps)
    : ::xsd::qif30::ActionGroupBaseType (),
      Steps_ (std::move (Steps), this),
      NumberOfSteps_ (NumberOfSteps, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (const PickSomeActionGroupType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this),
      NumberOfSteps_ (x.NumberOfSteps_, f, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this),
      NumberOfSteps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PickSomeActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Steps
        //
        if (n.name () == L"Steps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfSteps
        //
        if (n.name () == L"NumberOfSteps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfSteps_.present ())
          {
            this->NumberOfSteps_.set (NumberOfSteps_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Steps",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfSteps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfSteps",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PickSomeActionGroupType* PickSomeActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PickSomeActionGroupType (*this, f, c);
    }

    PickSomeActionGroupType& PickSomeActionGroupType::
    operator= (const PickSomeActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
        this->NumberOfSteps_ = x.NumberOfSteps_;
      }

      return *this;
    }

    PickSomeActionGroupType::
    ~PickSomeActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PickSomeActionGroupType >
    _xsd_PickSomeActionGroupType_type_factory_init (
      L"PickSomeActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // IfActionGroupType
    //

    IfActionGroupType::
    IfActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      If_ (this),
      ElseIf_ (this),
      ElseDo_ (this)
    {
    }

    IfActionGroupType::
    IfActionGroupType (const If_type& If)
    : ::xsd::qif30::ActionGroupBaseType (),
      If_ (If, this),
      ElseIf_ (this),
      ElseDo_ (this)
    {
    }

    IfActionGroupType::
    IfActionGroupType (::std::unique_ptr< If_type > If)
    : ::xsd::qif30::ActionGroupBaseType (),
      If_ (std::move (If), this),
      ElseIf_ (this),
      ElseDo_ (this)
    {
    }

    IfActionGroupType::
    IfActionGroupType (const IfActionGroupType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      If_ (x.If_, f, this),
      ElseIf_ (x.ElseIf_, f, this),
      ElseDo_ (x.ElseDo_, f, this)
    {
    }

    IfActionGroupType::
    IfActionGroupType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      If_ (this),
      ElseIf_ (this),
      ElseDo_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IfActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // If
        //
        if (n.name () == L"If" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< If_type > r (
            If_traits::create (i, f, this));

          if (!If_.present ())
          {
            this->If_.set (::std::move (r));
            continue;
          }
        }

        // ElseIf
        //
        if (n.name () == L"ElseIf" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElseIf_type > r (
            ElseIf_traits::create (i, f, this));

          this->ElseIf_.push_back (::std::move (r));
          continue;
        }

        // ElseDo
        //
        if (n.name () == L"ElseDo" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ElseDo_type > r (
            ElseDo_traits::create (i, f, this));

          if (!this->ElseDo_)
          {
            this->ElseDo_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!If_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"If",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    IfActionGroupType* IfActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfActionGroupType (*this, f, c);
    }

    IfActionGroupType& IfActionGroupType::
    operator= (const IfActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->If_ = x.If_;
        this->ElseIf_ = x.ElseIf_;
        this->ElseDo_ = x.ElseDo_;
      }

      return *this;
    }

    IfActionGroupType::
    ~IfActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IfActionGroupType >
    _xsd_IfActionGroupType_type_factory_init (
      L"IfActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // TestAndPlanElementType
    //

    TestAndPlanElementType::
    TestAndPlanElementType ()
    : ::xml_schema::type (),
      BooleanExpression_ (this),
      PlanElement_ (this)
    {
    }

    TestAndPlanElementType::
    TestAndPlanElementType (const BooleanExpression_type& BooleanExpression,
                            const PlanElement_type& PlanElement)
    : ::xml_schema::type (),
      BooleanExpression_ (BooleanExpression, this),
      PlanElement_ (PlanElement, this)
    {
    }

    TestAndPlanElementType::
    TestAndPlanElementType (const BooleanExpression_type& BooleanExpression,
                            ::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xml_schema::type (),
      BooleanExpression_ (BooleanExpression, this),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    TestAndPlanElementType::
    TestAndPlanElementType (::std::unique_ptr< BooleanExpression_type > BooleanExpression,
                            ::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xml_schema::type (),
      BooleanExpression_ (std::move (BooleanExpression), this),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    TestAndPlanElementType::
    TestAndPlanElementType (const TestAndPlanElementType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    TestAndPlanElementType::
    TestAndPlanElementType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TestAndPlanElementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!BooleanExpression_.present ())
            {
              ::std::unique_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BooleanExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        // PlanElement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanElement_.present ())
            {
              ::std::unique_ptr< PlanElement_type > r (
                dynamic_cast< PlanElement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->PlanElement_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!BooleanExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BooleanExpression",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PlanElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PlanElement",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TestAndPlanElementType* TestAndPlanElementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TestAndPlanElementType (*this, f, c);
    }

    TestAndPlanElementType& TestAndPlanElementType::
    operator= (const TestAndPlanElementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    TestAndPlanElementType::
    ~TestAndPlanElementType ()
    {
    }

    // ElseDoType
    //

    ElseDoType::
    ElseDoType ()
    : ::xml_schema::type (),
      PlanElement_ (this)
    {
    }

    ElseDoType::
    ElseDoType (const PlanElement_type& PlanElement)
    : ::xml_schema::type (),
      PlanElement_ (PlanElement, this)
    {
    }

    ElseDoType::
    ElseDoType (::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xml_schema::type (),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    ElseDoType::
    ElseDoType (const ElseDoType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    ElseDoType::
    ElseDoType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElseDoType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PlanElement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanElement_.present ())
            {
              ::std::unique_ptr< PlanElement_type > r (
                dynamic_cast< PlanElement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->PlanElement_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!PlanElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PlanElement",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElseDoType* ElseDoType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElseDoType (*this, f, c);
    }

    ElseDoType& ElseDoType::
    operator= (const ElseDoType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    ElseDoType::
    ~ElseDoType ()
    {
    }

    // WhileActionGroupType
    //

    WhileActionGroupType::
    WhileActionGroupType ()
    : ::xsd::qif30::ActionGroupBaseType (),
      BooleanExpression_ (this),
      PlanElement_ (this)
    {
    }

    WhileActionGroupType::
    WhileActionGroupType (const BooleanExpression_type& BooleanExpression,
                          const PlanElement_type& PlanElement)
    : ::xsd::qif30::ActionGroupBaseType (),
      BooleanExpression_ (BooleanExpression, this),
      PlanElement_ (PlanElement, this)
    {
    }

    WhileActionGroupType::
    WhileActionGroupType (const BooleanExpression_type& BooleanExpression,
                          ::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xsd::qif30::ActionGroupBaseType (),
      BooleanExpression_ (BooleanExpression, this),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    WhileActionGroupType::
    WhileActionGroupType (::std::unique_ptr< BooleanExpression_type > BooleanExpression,
                          ::std::unique_ptr< PlanElement_type > PlanElement)
    : ::xsd::qif30::ActionGroupBaseType (),
      BooleanExpression_ (std::move (BooleanExpression), this),
      PlanElement_ (std::move (PlanElement), this)
    {
    }

    WhileActionGroupType::
    WhileActionGroupType (const WhileActionGroupType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    WhileActionGroupType::
    WhileActionGroupType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WhileActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!BooleanExpression_.present ())
            {
              ::std::unique_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BooleanExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        // PlanElement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanElement_.present ())
            {
              ::std::unique_ptr< PlanElement_type > r (
                dynamic_cast< PlanElement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->PlanElement_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!BooleanExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BooleanExpression",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PlanElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PlanElement",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    WhileActionGroupType* WhileActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WhileActionGroupType (*this, f, c);
    }

    WhileActionGroupType& WhileActionGroupType::
    operator= (const WhileActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ActionGroupBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    WhileActionGroupType::
    ~WhileActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, WhileActionGroupType >
    _xsd_WhileActionGroupType_type_factory_init (
      L"WhileActionGroupType",
      L"http://qifstandards.org/xsd/qif3");

    // WorkInstructionBaseType
    //

    WorkInstructionBaseType::
    WorkInstructionBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (this)
    {
    }

    WorkInstructionBaseType::
    WorkInstructionBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    WorkInstructionBaseType::
    WorkInstructionBaseType (const WorkInstructionBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    WorkInstructionBaseType::
    WorkInstructionBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void WorkInstructionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    WorkInstructionBaseType& WorkInstructionBaseType::
    operator= (const WorkInstructionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    WorkInstructionBaseType::
    ~WorkInstructionBaseType ()
    {
    }

    // TextInstructionType
    //

    TextInstructionType::
    TextInstructionType ()
    : ::xsd::qif30::WorkInstructionBaseType (),
      TextInstruction_ (this)
    {
    }

    TextInstructionType::
    TextInstructionType (const id_type& id,
                         const TextInstruction_type& TextInstruction)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      TextInstruction_ (TextInstruction, this)
    {
    }

    TextInstructionType::
    TextInstructionType (const TextInstructionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (x, f, c),
      TextInstruction_ (x.TextInstruction_, f, this)
    {
    }

    TextInstructionType::
    TextInstructionType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      TextInstruction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextInstructionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TextInstruction
        //
        if (n.name () == L"TextInstruction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TextInstruction_type > r (
            TextInstruction_traits::create (i, f, this));

          if (!TextInstruction_.present ())
          {
            this->TextInstruction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TextInstruction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TextInstruction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TextInstructionType* TextInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextInstructionType (*this, f, c);
    }

    TextInstructionType& TextInstructionType::
    operator= (const TextInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkInstructionBaseType& > (*this) = x;
        this->TextInstruction_ = x.TextInstruction_;
      }

      return *this;
    }

    TextInstructionType::
    ~TextInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TextInstructionType >
    _xsd_TextInstructionType_type_factory_init (
      L"TextInstructionType",
      L"http://qifstandards.org/xsd/qif3");

    // DocumentFileInstructionType
    //

    DocumentFileInstructionType::
    DocumentFileInstructionType ()
    : ::xsd::qif30::WorkInstructionBaseType (),
      ExternalFile_ (this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const id_type& id,
                                 const ExternalFile_type& ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const id_type& id,
                                 ::std::unique_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (std::move (ExternalFile), this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const DocumentFileInstructionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DocumentFileInstructionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExternalFile
        //
        if (n.name () == L"ExternalFile" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ExternalFile",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DocumentFileInstructionType* DocumentFileInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DocumentFileInstructionType (*this, f, c);
    }

    DocumentFileInstructionType& DocumentFileInstructionType::
    operator= (const DocumentFileInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    DocumentFileInstructionType::
    ~DocumentFileInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DocumentFileInstructionType >
    _xsd_DocumentFileInstructionType_type_factory_init (
      L"DocumentFileInstructionType",
      L"http://qifstandards.org/xsd/qif3");

    // ImageInstructionType
    //

    ImageInstructionType::
    ImageInstructionType ()
    : ::xsd::qif30::WorkInstructionBaseType (),
      ExternalFile_ (this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const id_type& id,
                          const ExternalFile_type& ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const id_type& id,
                          ::std::unique_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (std::move (ExternalFile), this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const ImageInstructionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ImageInstructionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExternalFile
        //
        if (n.name () == L"ExternalFile" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ExternalFile",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ImageInstructionType* ImageInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ImageInstructionType (*this, f, c);
    }

    ImageInstructionType& ImageInstructionType::
    operator= (const ImageInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    ImageInstructionType::
    ~ImageInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ImageInstructionType >
    _xsd_ImageInstructionType_type_factory_init (
      L"ImageInstructionType",
      L"http://qifstandards.org/xsd/qif3");

    // VariableDeclarationType
    //

    VariableDeclarationType::
    VariableDeclarationType ()
    : ::xml_schema::type (),
      Name_ (this),
      Val_ (this)
    {
    }

    VariableDeclarationType::
    VariableDeclarationType (const Name_type& Name,
                             const Val_type& Val)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Val_ (Val, this)
    {
    }

    VariableDeclarationType::
    VariableDeclarationType (const VariableDeclarationType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Val_ (x.Val_, f, this)
    {
    }

    VariableDeclarationType::
    VariableDeclarationType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VariableDeclarationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Val
        //
        if (n.name () == L"Val" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Val_.present ())
          {
            this->Val_.set (Val_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Name",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Val_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Val",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VariableDeclarationType* VariableDeclarationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VariableDeclarationType (*this, f, c);
    }

    VariableDeclarationType& VariableDeclarationType::
    operator= (const VariableDeclarationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Val_ = x.Val_;
      }

      return *this;
    }

    VariableDeclarationType::
    ~VariableDeclarationType ()
    {
    }

    // LocalVariablesType
    //

    LocalVariablesType::
    LocalVariablesType ()
    : ::xml_schema::type (),
      Variable_ (this),
      n_ (this)
    {
    }

    LocalVariablesType::
    LocalVariablesType (const n_type& n)
    : ::xml_schema::type (),
      Variable_ (this),
      n_ (n, this)
    {
    }

    LocalVariablesType::
    LocalVariablesType (const LocalVariablesType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Variable_ (x.Variable_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LocalVariablesType::
    LocalVariablesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Variable_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LocalVariablesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Variable
        //
        if (n.name () == L"Variable" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Variable_type > r (
            Variable_traits::create (i, f, this));

          this->Variable_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LocalVariablesType* LocalVariablesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocalVariablesType (*this, f, c);
    }

    LocalVariablesType& LocalVariablesType::
    operator= (const LocalVariablesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Variable_ = x.Variable_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LocalVariablesType::
    ~LocalVariablesType ()
    {
    }

    // VariableSetType
    //

    VariableSetType::
    VariableSetType ()
    : ::xsd::qif30::PlanElementBaseType (),
      VariableName_ (this),
      ArithmeticExpression_ (this)
    {
    }

    VariableSetType::
    VariableSetType (const VariableName_type& VariableName,
                     const ArithmeticExpression_type& ArithmeticExpression)
    : ::xsd::qif30::PlanElementBaseType (),
      VariableName_ (VariableName, this),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    VariableSetType::
    VariableSetType (const VariableName_type& VariableName,
                     ::std::unique_ptr< ArithmeticExpression_type > ArithmeticExpression)
    : ::xsd::qif30::PlanElementBaseType (),
      VariableName_ (VariableName, this),
      ArithmeticExpression_ (std::move (ArithmeticExpression), this)
    {
    }

    VariableSetType::
    VariableSetType (const VariableSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (x, f, c),
      VariableName_ (x.VariableName_, f, this),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    VariableSetType::
    VariableSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::PlanElementBaseType (e, f | ::xml_schema::flags::base, c),
      VariableName_ (this),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VariableSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PlanElementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // VariableName
        //
        if (n.name () == L"VariableName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VariableName_type > r (
            VariableName_traits::create (i, f, this));

          if (!VariableName_.present ())
          {
            this->VariableName_.set (::std::move (r));
            continue;
          }
        }

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArithmeticExpression_.present ())
            {
              ::std::unique_ptr< ArithmeticExpression_type > r (
                dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArithmeticExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!VariableName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VariableName",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ArithmeticExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArithmeticExpression",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VariableSetType* VariableSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VariableSetType (*this, f, c);
    }

    VariableSetType& VariableSetType::
    operator= (const VariableSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PlanElementBaseType& > (*this) = x;
        this->VariableName_ = x.VariableName_;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    VariableSetType::
    ~VariableSetType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, VariableSetType >
    _xsd_VariableSetType_type_factory_init (
      L"VariableSetType",
      L"http://qifstandards.org/xsd/qif3");

    // VariableValueType
    //

    VariableValueType::
    VariableValueType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      VariableName_ (this)
    {
    }

    VariableValueType::
    VariableValueType (const VariableName_type& VariableName)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      VariableName_ (VariableName, this)
    {
    }

    VariableValueType::
    VariableValueType (const VariableValueType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      VariableName_ (x.VariableName_, f, this)
    {
    }

    VariableValueType::
    VariableValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      VariableName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VariableValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // VariableName
        //
        if (n.name () == L"VariableName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VariableName_type > r (
            VariableName_traits::create (i, f, this));

          if (!VariableName_.present ())
          {
            this->VariableName_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!VariableName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VariableName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VariableValueType* VariableValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VariableValueType (*this, f, c);
    }

    VariableValueType& VariableValueType::
    operator= (const VariableValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->VariableName_ = x.VariableName_;
      }

      return *this;
    }

    VariableValueType::
    ~VariableValueType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, VariableValueType >
    _xsd_VariableValueType_type_factory_init (
      L"VariableValueType",
      L"http://qifstandards.org/xsd/qif3");

    // ArithmeticParameterValueType
    //

    ArithmeticParameterValueType::
    ArithmeticParameterValueType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      Parameter_ (this),
      ObjectId_ (this)
    {
    }

    ArithmeticParameterValueType::
    ArithmeticParameterValueType (const Parameter_type& Parameter,
                                  const ObjectId_type& ObjectId)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      Parameter_ (Parameter, this),
      ObjectId_ (ObjectId, this)
    {
    }

    ArithmeticParameterValueType::
    ArithmeticParameterValueType (const Parameter_type& Parameter,
                                  ::std::unique_ptr< ObjectId_type > ObjectId)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      Parameter_ (Parameter, this),
      ObjectId_ (std::move (ObjectId), this)
    {
    }

    ArithmeticParameterValueType::
    ArithmeticParameterValueType (const ArithmeticParameterValueType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      Parameter_ (x.Parameter_, f, this),
      ObjectId_ (x.ObjectId_, f, this)
    {
    }

    ArithmeticParameterValueType::
    ArithmeticParameterValueType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      Parameter_ (this),
      ObjectId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticParameterValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Parameter
        //
        if (n.name () == L"Parameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parameter_type > r (
            Parameter_traits::create (i, f, this));

          if (!Parameter_.present ())
          {
            this->Parameter_.set (::std::move (r));
            continue;
          }
        }

        // ObjectId
        //
        if (n.name () == L"ObjectId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ObjectId_type > r (
            ObjectId_traits::create (i, f, this));

          if (!ObjectId_.present ())
          {
            this->ObjectId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Parameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Parameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ObjectId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ObjectId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArithmeticParameterValueType* ArithmeticParameterValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticParameterValueType (*this, f, c);
    }

    ArithmeticParameterValueType& ArithmeticParameterValueType::
    operator= (const ArithmeticParameterValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->Parameter_ = x.Parameter_;
        this->ObjectId_ = x.ObjectId_;
      }

      return *this;
    }

    ArithmeticParameterValueType::
    ~ArithmeticParameterValueType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticParameterValueType >
    _xsd_ArithmeticParameterValueType_type_factory_init (
      L"ArithmeticParameterValueType",
      L"http://qifstandards.org/xsd/qif3");

    // TokenParameterValueType
    //

    TokenParameterValueType::
    TokenParameterValueType ()
    : ::xsd::qif30::TokenExpressionBaseType (),
      Parameter_ (this),
      ObjectId_ (this)
    {
    }

    TokenParameterValueType::
    TokenParameterValueType (const Parameter_type& Parameter,
                             const ObjectId_type& ObjectId)
    : ::xsd::qif30::TokenExpressionBaseType (),
      Parameter_ (Parameter, this),
      ObjectId_ (ObjectId, this)
    {
    }

    TokenParameterValueType::
    TokenParameterValueType (const Parameter_type& Parameter,
                             ::std::unique_ptr< ObjectId_type > ObjectId)
    : ::xsd::qif30::TokenExpressionBaseType (),
      Parameter_ (Parameter, this),
      ObjectId_ (std::move (ObjectId), this)
    {
    }

    TokenParameterValueType::
    TokenParameterValueType (const TokenParameterValueType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::TokenExpressionBaseType (x, f, c),
      Parameter_ (x.Parameter_, f, this),
      ObjectId_ (x.ObjectId_, f, this)
    {
    }

    TokenParameterValueType::
    TokenParameterValueType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::TokenExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      Parameter_ (this),
      ObjectId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TokenParameterValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Parameter
        //
        if (n.name () == L"Parameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parameter_type > r (
            Parameter_traits::create (i, f, this));

          if (!Parameter_.present ())
          {
            this->Parameter_.set (::std::move (r));
            continue;
          }
        }

        // ObjectId
        //
        if (n.name () == L"ObjectId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ObjectId_type > r (
            ObjectId_traits::create (i, f, this));

          if (!ObjectId_.present ())
          {
            this->ObjectId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Parameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Parameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ObjectId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ObjectId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TokenParameterValueType* TokenParameterValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TokenParameterValueType (*this, f, c);
    }

    TokenParameterValueType& TokenParameterValueType::
    operator= (const TokenParameterValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TokenExpressionBaseType& > (*this) = x;
        this->Parameter_ = x.Parameter_;
        this->ObjectId_ = x.ObjectId_;
      }

      return *this;
    }

    TokenParameterValueType::
    ~TokenParameterValueType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TokenParameterValueType >
    _xsd_TokenParameterValueType_type_factory_init (
      L"TokenParameterValueType",
      L"http://qifstandards.org/xsd/qif3");

    // VideoInstructionType
    //

    VideoInstructionType::
    VideoInstructionType ()
    : ::xsd::qif30::WorkInstructionBaseType (),
      ExternalFile_ (this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const id_type& id,
                          const ExternalFile_type& ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const id_type& id,
                          ::std::unique_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif30::WorkInstructionBaseType (id),
      ExternalFile_ (std::move (ExternalFile), this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const VideoInstructionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VideoInstructionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ExternalFile
        //
        if (n.name () == L"ExternalFile" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ExternalFile",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    VideoInstructionType* VideoInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VideoInstructionType (*this, f, c);
    }

    VideoInstructionType& VideoInstructionType::
    operator= (const VideoInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    VideoInstructionType::
    ~VideoInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, VideoInstructionType >
    _xsd_VideoInstructionType_type_factory_init (
      L"VideoInstructionType",
      L"http://qifstandards.org/xsd/qif3");

    // WorkInstructionsType
    //

    WorkInstructionsType::
    WorkInstructionsType ()
    : ::xml_schema::type (),
      WorkInstruction_ (this),
      n_ (this)
    {
    }

    WorkInstructionsType::
    WorkInstructionsType (const n_type& n)
    : ::xml_schema::type (),
      WorkInstruction_ (this),
      n_ (n, this)
    {
    }

    WorkInstructionsType::
    WorkInstructionsType (const WorkInstructionsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WorkInstruction_ (x.WorkInstruction_, f, this),
      n_ (x.n_, f, this)
    {
    }

    WorkInstructionsType::
    WorkInstructionsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WorkInstruction_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void WorkInstructionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WorkInstruction
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"WorkInstruction",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< WorkInstruction_type > r (
              dynamic_cast< WorkInstruction_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->WorkInstruction_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    WorkInstructionsType* WorkInstructionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WorkInstructionsType (*this, f, c);
    }

    WorkInstructionsType& WorkInstructionsType::
    operator= (const WorkInstructionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WorkInstruction_ = x.WorkInstruction_;
        this->n_ = x.n_;
      }

      return *this;
    }

    WorkInstructionsType::
    ~WorkInstructionsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OrderedPlanRoot_element_factory_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"OrderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UnorderedPlanRoot_element_factory_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"UnorderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UnorderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PartiallyOrderedPlanRoot_element_factory_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"PartiallyOrderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PartiallyOrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OneOfPlanRoot_element_factory_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"OneOfPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OneOfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PickSomePlanRoot_element_factory_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"PickSomePlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PickSomeActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OrderedActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"OrderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UnorderedActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"UnorderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UnorderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PartiallyOrderedActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"PartiallyOrderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PartiallyOrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OneOfActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"OneOfActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OneOfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PickSomeActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"PickSomeActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PickSomeActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MeasureEvaluateAll_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureEvaluateAll",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MeasureEvaluateAllActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MeasureEvaluateSpecified_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureEvaluateSpecified",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MeasureEvaluateSpecifiedActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EvaluateSpecifiedCharacteristics_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"EvaluateSpecifiedCharacteristics",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EvaluateSpecifiedCharacteristicsActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Halt_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"Halt",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::HaltActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MeasureSpecifiedFeatures_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureSpecifiedFeatures",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MeasureSpecifiedFeaturesActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MeasureSpecifiedMeasurands_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureSpecifiedMeasurands",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MeasureSpecifiedMeasurandsActionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_IfActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"IfActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::IfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WhileActionGroup_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"WhileActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::WhileActionGroupType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_VariableSet_element_factory_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"VariableSet",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::VariableSetType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TextInstruction_element_factory_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"TextInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TextInstructionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DocumentFileInstruction_element_factory_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"DocumentFileInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DocumentFileInstructionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ImageInstruction_element_factory_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"ImageInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ImageInstructionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_VideoInstruction_element_factory_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"VideoInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::VideoInstructionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AutocollimatorMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"AutocollimatorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AutocollimatorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CalibratedComparatorMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"CalibratedComparatorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CalibratedComparatorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CoordinateMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"CoordinateMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CoordinateMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ComputedTomographyMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ComputedTomographyMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ComputedTomographyMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ExternalReferenceMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ExternalReferenceMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ExternalReferenceMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GageMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"GageMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GageMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LaserRadarMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserRadarMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LaserRadarMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LaserTrackerMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserTrackerMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LaserTrackerMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ManualMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ManualMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ManualMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MicroscopeMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"MicroscopeMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MicroscopeMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProfileProjectorMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ProfileProjectorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ProfileProjectorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TheodoliteMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"TheodoliteMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TheodoliteMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_UniversalLengthMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"UniversalLengthMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::UniversalLengthMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherMeasureFeatureMethod_element_factory_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EvaluateCharacteristicMeasurand_element_factory_init (
      L"Measurand",
      L"http://qifstandards.org/xsd/qif3",
      L"EvaluateCharacteristicMeasurand",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EvaluateCharacteristicMeasurandType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EstablishDatumMeasurand_element_factory_init (
      L"Measurand",
      L"http://qifstandards.org/xsd/qif3",
      L"EstablishDatumMeasurand",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EstablishDatumMeasurandType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_VariableValue_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"VariableValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::VariableValueType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticParameterValue_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticParameterValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticParameterValueType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TokenParameterValue_element_factory_init (
      L"TokenExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenParameterValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TokenParameterValueType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const PlanType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // RulesUsedQPId
      //
      if (i.RulesUsedQPId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RulesUsedQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RulesUsedQPId ();
      }

      // RulesToUseQPId
      //
      if (i.RulesToUseQPId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RulesToUseQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RulesToUseQPId ();
      }

      // WorkInstructions
      //
      if (i.WorkInstructions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkInstructions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorkInstructions ();
      }

      // ActionMethods
      //
      if (i.ActionMethods ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActionMethods",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActionMethods ();
      }

      // Measurands
      //
      if (i.Measurands ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measurands",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measurands ();
      }

      // LocalVariables
      //
      if (i.LocalVariables ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LocalVariables",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LocalVariables ();
      }

      // PlanRoot
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const PlanType::PlanRoot_type& x (i.PlanRoot ());
        if (typeid (PlanType::PlanRoot_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PlanRoot",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"PlanRoot",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlanElementBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WorkInstructionIds
      //
      if (i.WorkInstructionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkInstructionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorkInstructionIds ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UnnumberedPlanElementsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (UnnumberedPlanElementsType::PlanElement_const_iterator
             b (i.PlanElement ().begin ()), n (i.PlanElement ().end ());
             b != n; ++b)
        {
          const UnnumberedPlanElementsType::PlanElement_type& x (*b);

          if (typeid (UnnumberedPlanElementsType::PlanElement_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"PlanElement",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NumberedPlanElementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const NumberedPlanElementType::PlanElement_type& x (i.PlanElement ());
        if (typeid (NumberedPlanElementType::PlanElement_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"PlanElement",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NumberedPlanElementsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NumberedPlanElement
      //
      for (NumberedPlanElementsType::NumberedPlanElement_const_iterator
           b (i.NumberedPlanElement ().begin ()), n (i.NumberedPlanElement ().end ());
           b != n; ++b)
      {
        const NumberedPlanElementsType::NumberedPlanElement_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberedPlanElement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ActionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::PlanElementBaseType& > (i);

      // PreferredActionMethodId
      //
      if (i.PreferredActionMethodId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PreferredActionMethodId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PreferredActionMethodId ();
      }

      // AlternativeActionMethodIds
      //
      if (i.AlternativeActionMethodIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AlternativeActionMethodIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AlternativeActionMethodIds ();
      }

      // PreferredResourceIds
      //
      if (i.PreferredResourceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PreferredResourceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PreferredResourceIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasureEvaluateAllActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAllActionType_type_serializer_init (
      L"MeasureEvaluateAllActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const HaltActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, HaltActionType >
    _xsd_HaltActionType_type_serializer_init (
      L"HaltActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasureEvaluateSpecifiedActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);

      // CharacteristicItemIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicItemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CharacteristicItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecifiedActionType_type_serializer_init (
      L"MeasureEvaluateSpecifiedActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EvaluateSpecifiedCharacteristicsActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);

      // CharacteristicItemIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicItemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CharacteristicItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristicsActionType_type_serializer_init (
      L"EvaluateSpecifiedCharacteristicsActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasureSpecifiedFeaturesActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);

      // FeatureItemIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureItemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeaturesActionType_type_serializer_init (
      L"MeasureSpecifiedFeaturesActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasurandBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EvaluateCharacteristicMeasurandType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurandBaseType& > (i);

      // CharacteristicItemId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicItemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CharacteristicItemId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurandType_type_serializer_init (
      L"EvaluateCharacteristicMeasurandType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EstablishDatumMeasurandType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasurandBaseType& > (i);

      // DatumDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumDefinitionId ();
      }

      // DatumReferenceFrameId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DatumReferenceFrameId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DatumReferenceFrameId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurandType_type_serializer_init (
      L"EstablishDatumMeasurandType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasureSpecifiedMeasurandsActionType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionBaseType& > (i);

      // MeasurandIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurandIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeasurandIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurandsActionType_type_serializer_init (
      L"MeasureSpecifiedMeasurandsActionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MeasurandsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measurand
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (MeasurandsType::Measurand_const_iterator
             b (i.Measurand ().begin ()), n (i.Measurand ().end ());
             b != n; ++b)
        {
          const MeasurandsType::Measurand_type& x (*b);

          if (typeid (MeasurandsType::Measurand_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Measurand",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Measurand",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ActionMethodBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ChosenResourceIds
      //
      if (i.ChosenResourceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ChosenResourceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ChosenResourceIds ();
      }

      // WorkInstructionIds
      //
      if (i.WorkInstructionIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WorkInstructionIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WorkInstructionIds ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasureFeatureMethodBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionMethodBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const AutocollimatorMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AutocollimatorMeasureFeatureMethodType >
    _xsd_AutocollimatorMeasureFeatureMethodType_type_serializer_init (
      L"AutocollimatorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CalibratedComparatorMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CalibratedComparatorMeasureFeatureMethodType >
    _xsd_CalibratedComparatorMeasureFeatureMethodType_type_serializer_init (
      L"CalibratedComparatorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ComputedTomographyMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ComputedTomographyMeasureFeatureMethodType >
    _xsd_ComputedTomographyMeasureFeatureMethodType_type_serializer_init (
      L"ComputedTomographyMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CoordinateMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);

      // NumberOfMeasurementPoints
      //
      if (i.NumberOfMeasurementPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfMeasurementPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfMeasurementPoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethodType_type_serializer_init (
      L"CoordinateMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExternalReferenceMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);

      // ExternalFileReferences
      //
      if (i.ExternalFileReferences ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalFileReferences",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ExternalFileReferences ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExternalReferenceMeasureFeatureMethodType >
    _xsd_ExternalReferenceMeasureFeatureMethodType_type_serializer_init (
      L"ExternalReferenceMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GageMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethodType_type_serializer_init (
      L"GageMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LaserRadarMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LaserRadarMeasureFeatureMethodType >
    _xsd_LaserRadarMeasureFeatureMethodType_type_serializer_init (
      L"LaserRadarMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LaserTrackerMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LaserTrackerMeasureFeatureMethodType >
    _xsd_LaserTrackerMeasureFeatureMethodType_type_serializer_init (
      L"LaserTrackerMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ManualMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethodType_type_serializer_init (
      L"ManualMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MicroscopeMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MicroscopeMeasureFeatureMethodType >
    _xsd_MicroscopeMeasureFeatureMethodType_type_serializer_init (
      L"MicroscopeMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethodType_type_serializer_init (
      L"OtherMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ProfileProjectorMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProfileProjectorMeasureFeatureMethodType >
    _xsd_ProfileProjectorMeasureFeatureMethodType_type_serializer_init (
      L"ProfileProjectorMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TheodoliteMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TheodoliteMeasureFeatureMethodType >
    _xsd_TheodoliteMeasureFeatureMethodType_type_serializer_init (
      L"TheodoliteMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UniversalLengthMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UniversalLengthMeasureFeatureMethodType >
    _xsd_UniversalLengthMeasureFeatureMethodType_type_serializer_init (
      L"UniversalLengthMeasureFeatureMethodType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ActionMethodsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ActionMethod
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ActionMethodsType::ActionMethod_const_iterator
             b (i.ActionMethod ().begin ()), n (i.ActionMethod ().end ());
             b != n; ++b)
        {
          const ActionMethodsType::ActionMethod_type& x (*b);

          if (typeid (ActionMethodsType::ActionMethod_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ActionMethod",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"ActionMethod",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasureActionGroupFunctionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const MeasureActionGroupFunctionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MeasureActionGroupFunctionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasureActionGroupFunctionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasureActionGroupFunctionEnum
      //
      if (i.MeasureActionGroupFunctionEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasureActionGroupFunctionEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasureActionGroupFunctionEnum ();
      }

      // OtherMeasureActionGroupFunction
      //
      if (i.OtherMeasureActionGroupFunction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherMeasureActionGroupFunction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherMeasureActionGroupFunction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ActionGroupBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::PlanElementBaseType& > (i);

      // MeasureActionGroupFunction
      //
      if (i.MeasureActionGroupFunction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasureActionGroupFunction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasureActionGroupFunction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OrderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Steps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OrderedActionGroupType >
    _xsd_OrderedActionGroupType_type_serializer_init (
      L"OrderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UnorderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Steps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UnorderedActionGroupType >
    _xsd_UnorderedActionGroupType_type_serializer_init (
      L"UnorderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PartiallyOrderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // StepsWithPredecessors
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StepsWithPredecessors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StepsWithPredecessors ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroupType_type_serializer_init (
      L"PartiallyOrderedActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const StepWithPredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Predecessors
      //
      if (i.Predecessors ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Predecessors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Predecessors ();
      }

      // Step
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Step",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Step ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StepsWithPredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StepWithPredecessors
      //
      for (StepsWithPredecessorsType::StepWithPredecessors_const_iterator
           b (i.StepWithPredecessors ().begin ()), n (i.StepWithPredecessors ().end ());
           b != n; ++b)
      {
        const StepsWithPredecessorsType::StepWithPredecessors_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StepWithPredecessors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Predecessor
      //
      for (PredecessorsType::Predecessor_const_iterator
           b (i.Predecessor ().begin ()), n (i.Predecessor ().end ());
           b != n; ++b)
      {
        const PredecessorsType::Predecessor_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Predecessor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OneOfActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Steps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OneOfActionGroupType >
    _xsd_OneOfActionGroupType_type_serializer_init (
      L"OneOfActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PickSomeActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Steps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Steps ();
      }

      // NumberOfSteps
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfSteps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfSteps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PickSomeActionGroupType >
    _xsd_PickSomeActionGroupType_type_serializer_init (
      L"PickSomeActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const IfActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // If
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"If",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.If ();
      }

      // ElseIf
      //
      for (IfActionGroupType::ElseIf_const_iterator
           b (i.ElseIf ().begin ()), n (i.ElseIf ().end ());
           b != n; ++b)
      {
        const IfActionGroupType::ElseIf_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElseIf",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // ElseDo
      //
      if (i.ElseDo ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ElseDo",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ElseDo ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IfActionGroupType >
    _xsd_IfActionGroupType_type_serializer_init (
      L"IfActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TestAndPlanElementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const TestAndPlanElementType::BooleanExpression_type& x (i.BooleanExpression ());
        if (typeid (TestAndPlanElementType::BooleanExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"BooleanExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const TestAndPlanElementType::PlanElement_type& x (i.PlanElement ());
        if (typeid (TestAndPlanElementType::PlanElement_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"PlanElement",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElseDoType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ElseDoType::PlanElement_type& x (i.PlanElement ());
        if (typeid (ElseDoType::PlanElement_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"PlanElement",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const WhileActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif30::ActionGroupBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const WhileActionGroupType::BooleanExpression_type& x (i.BooleanExpression ());
        if (typeid (WhileActionGroupType::BooleanExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"BooleanExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const WhileActionGroupType::PlanElement_type& x (i.PlanElement ());
        if (typeid (WhileActionGroupType::PlanElement_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"PlanElement",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"PlanElement",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, WhileActionGroupType >
    _xsd_WhileActionGroupType_type_serializer_init (
      L"WhileActionGroupType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WorkInstructionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TextInstructionType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkInstructionBaseType& > (i);

      // TextInstruction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TextInstruction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TextInstruction ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TextInstructionType >
    _xsd_TextInstructionType_type_serializer_init (
      L"TextInstructionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DocumentFileInstructionType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalFile",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DocumentFileInstructionType >
    _xsd_DocumentFileInstructionType_type_serializer_init (
      L"DocumentFileInstructionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ImageInstructionType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalFile",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ImageInstructionType >
    _xsd_ImageInstructionType_type_serializer_init (
      L"ImageInstructionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const VariableDeclarationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Name ();
      }

      // Val
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Val",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.Val ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LocalVariablesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Variable
      //
      for (LocalVariablesType::Variable_const_iterator
           b (i.Variable ().begin ()), n (i.Variable ().end ());
           b != n; ++b)
      {
        const LocalVariablesType::Variable_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Variable",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VariableSetType& i)
    {
      e << static_cast< const ::xsd::qif30::PlanElementBaseType& > (i);

      // VariableName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VariableName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VariableName ();
      }

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const VariableSetType::ArithmeticExpression_type& x (i.ArithmeticExpression ());
        if (typeid (VariableSetType::ArithmeticExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArithmeticExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, VariableSetType >
    _xsd_VariableSetType_type_serializer_init (
      L"VariableSetType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const VariableValueType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // VariableName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VariableName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VariableName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, VariableValueType >
    _xsd_VariableValueType_type_serializer_init (
      L"VariableValueType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticParameterValueType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // Parameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Parameter ();
      }

      // ObjectId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ObjectId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ObjectId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticParameterValueType >
    _xsd_ArithmeticParameterValueType_type_serializer_init (
      L"ArithmeticParameterValueType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TokenParameterValueType& i)
    {
      e << static_cast< const ::xsd::qif30::TokenExpressionBaseType& > (i);

      // Parameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Parameter ();
      }

      // ObjectId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ObjectId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ObjectId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TokenParameterValueType >
    _xsd_TokenParameterValueType_type_serializer_init (
      L"TokenParameterValueType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const VideoInstructionType& i)
    {
      e << static_cast< const ::xsd::qif30::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ExternalFile",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, VideoInstructionType >
    _xsd_VideoInstructionType_type_serializer_init (
      L"VideoInstructionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const WorkInstructionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WorkInstruction
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (WorkInstructionsType::WorkInstruction_const_iterator
             b (i.WorkInstruction ().begin ()), n (i.WorkInstruction ().end ());
             b != n; ++b)
        {
          const WorkInstructionsType::WorkInstruction_type& x (*b);

          if (typeid (WorkInstructionsType::WorkInstruction_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"WorkInstruction",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"WorkInstruction",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OrderedActionGroupType >
    _xsd_OrderedPlanRoot_element_serializer_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"OrderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UnorderedActionGroupType >
    _xsd_UnorderedPlanRoot_element_serializer_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"UnorderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UnorderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedPlanRoot_element_serializer_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"PartiallyOrderedPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PartiallyOrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OneOfActionGroupType >
    _xsd_OneOfPlanRoot_element_serializer_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"OneOfPlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OneOfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PickSomeActionGroupType >
    _xsd_PickSomePlanRoot_element_serializer_init (
      L"PlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      L"PickSomePlanRoot",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PickSomeActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OrderedActionGroupType >
    _xsd_OrderedActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"OrderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UnorderedActionGroupType >
    _xsd_UnorderedActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"UnorderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UnorderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"PartiallyOrderedActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PartiallyOrderedActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OneOfActionGroupType >
    _xsd_OneOfActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"OneOfActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OneOfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PickSomeActionGroupType >
    _xsd_PickSomeActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"PickSomeActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PickSomeActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAll_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureEvaluateAll",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MeasureEvaluateAllActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecified_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureEvaluateSpecified",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MeasureEvaluateSpecifiedActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristics_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"EvaluateSpecifiedCharacteristics",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EvaluateSpecifiedCharacteristicsActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::HaltActionType >
    _xsd_Halt_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"Halt",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::HaltActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeatures_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureSpecifiedFeatures",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MeasureSpecifiedFeaturesActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurands_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"MeasureSpecifiedMeasurands",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MeasureSpecifiedMeasurandsActionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::IfActionGroupType >
    _xsd_IfActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"IfActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::IfActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::WhileActionGroupType >
    _xsd_WhileActionGroup_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"WhileActionGroup",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::WhileActionGroupType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::VariableSetType >
    _xsd_VariableSet_element_serializer_init (
      L"PlanElement",
      L"http://qifstandards.org/xsd/qif3",
      L"VariableSet",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::VariableSetType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TextInstructionType >
    _xsd_TextInstruction_element_serializer_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"TextInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TextInstructionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DocumentFileInstructionType >
    _xsd_DocumentFileInstruction_element_serializer_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"DocumentFileInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DocumentFileInstructionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ImageInstructionType >
    _xsd_ImageInstruction_element_serializer_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"ImageInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ImageInstructionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::VideoInstructionType >
    _xsd_VideoInstruction_element_serializer_init (
      L"WorkInstruction",
      L"http://qifstandards.org/xsd/qif3",
      L"VideoInstruction",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::VideoInstructionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AutocollimatorMeasureFeatureMethodType >
    _xsd_AutocollimatorMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"AutocollimatorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AutocollimatorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CalibratedComparatorMeasureFeatureMethodType >
    _xsd_CalibratedComparatorMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"CalibratedComparatorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CalibratedComparatorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"CoordinateMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CoordinateMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ComputedTomographyMeasureFeatureMethodType >
    _xsd_ComputedTomographyMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ComputedTomographyMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ComputedTomographyMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ExternalReferenceMeasureFeatureMethodType >
    _xsd_ExternalReferenceMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ExternalReferenceMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ExternalReferenceMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"GageMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GageMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LaserRadarMeasureFeatureMethodType >
    _xsd_LaserRadarMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserRadarMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LaserRadarMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LaserTrackerMeasureFeatureMethodType >
    _xsd_LaserTrackerMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"LaserTrackerMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LaserTrackerMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ManualMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ManualMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MicroscopeMeasureFeatureMethodType >
    _xsd_MicroscopeMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"MicroscopeMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MicroscopeMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ProfileProjectorMeasureFeatureMethodType >
    _xsd_ProfileProjectorMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"ProfileProjectorMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ProfileProjectorMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TheodoliteMeasureFeatureMethodType >
    _xsd_TheodoliteMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"TheodoliteMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TheodoliteMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::UniversalLengthMeasureFeatureMethodType >
    _xsd_UniversalLengthMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"UniversalLengthMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::UniversalLengthMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethod_element_serializer_init (
      L"ActionMethod",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherMeasureFeatureMethod",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherMeasureFeatureMethodType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurand_element_serializer_init (
      L"Measurand",
      L"http://qifstandards.org/xsd/qif3",
      L"EvaluateCharacteristicMeasurand",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EvaluateCharacteristicMeasurandType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurand_element_serializer_init (
      L"Measurand",
      L"http://qifstandards.org/xsd/qif3",
      L"EstablishDatumMeasurand",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EstablishDatumMeasurandType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::VariableValueType >
    _xsd_VariableValue_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"VariableValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::VariableValueType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticParameterValueType >
    _xsd_ArithmeticParameterValue_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticParameterValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticParameterValueType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TokenParameterValueType >
    _xsd_TokenParameterValue_element_serializer_init (
      L"TokenExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenParameterValue",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TokenParameterValueType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

