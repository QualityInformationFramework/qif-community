// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFAPPLICATIONS_QIFPLAN_HXX
#define CXX___QIFAPPLICATIONS_QIFPLAN_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class PlanType;
    class PlanElementBaseType;
    class UnnumberedPlanElementsType;
    class NumberedPlanElementType;
    class NumberedPlanElementsType;
    class ActionBaseType;
    class MeasureEvaluateAllActionType;
    class HaltActionType;
    class MeasureEvaluateSpecifiedActionType;
    class EvaluateSpecifiedCharacteristicsActionType;
    class MeasureSpecifiedFeaturesActionType;
    class MeasurandBaseType;
    class EvaluateCharacteristicMeasurandType;
    class EstablishDatumMeasurandType;
    class MeasureSpecifiedMeasurandsActionType;
    class MeasurandsType;
    class ActionMethodBaseType;
    class MeasureFeatureMethodBaseType;
    class AutocollimatorMeasureFeatureMethodType;
    class CalibratedComparatorMeasureFeatureMethodType;
    class ComputedTomographyMeasureFeatureMethodType;
    class CoordinateMeasureFeatureMethodType;
    class ExternalReferenceMeasureFeatureMethodType;
    class GageMeasureFeatureMethodType;
    class LaserRadarMeasureFeatureMethodType;
    class LaserTrackerMeasureFeatureMethodType;
    class ManualMeasureFeatureMethodType;
    class MicroscopeMeasureFeatureMethodType;
    class OtherMeasureFeatureMethodType;
    class ProfileProjectorMeasureFeatureMethodType;
    class TheodoliteMeasureFeatureMethodType;
    class UniversalLengthMeasureFeatureMethodType;
    class ActionMethodsType;
    class MeasureActionGroupFunctionEnumType;
    class MeasureActionGroupFunctionType;
    class ActionGroupBaseType;
    class OrderedActionGroupType;
    class UnorderedActionGroupType;
    class PartiallyOrderedActionGroupType;
    class StepWithPredecessorsType;
    class StepsWithPredecessorsType;
    class PredecessorsType;
    class OneOfActionGroupType;
    class PickSomeActionGroupType;
    class IfActionGroupType;
    class TestAndPlanElementType;
    class ElseDoType;
    class WhileActionGroupType;
    class WorkInstructionBaseType;
    class TextInstructionType;
    class DocumentFileInstructionType;
    class ImageInstructionType;
    class VariableDeclarationType;
    class LocalVariablesType;
    class VariableSetType;
    class VariableValueType;
    class ArithmeticParameterValueType;
    class TokenParameterValueType;
    class VideoInstructionType;
    class WorkInstructionsType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/IntermediatesPMI.hxx"

#include "../QIFLibrary/GenericExpressions.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL PlanType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // RulesUsedQPId
      //
      typedef ::xsd::qif30::QPIdFullReferenceType RulesUsedQPId_type;
      typedef ::xsd::cxx::tree::optional< RulesUsedQPId_type > RulesUsedQPId_optional;
      typedef ::xsd::cxx::tree::traits< RulesUsedQPId_type, wchar_t > RulesUsedQPId_traits;

      const RulesUsedQPId_optional&
      RulesUsedQPId () const;

      RulesUsedQPId_optional&
      RulesUsedQPId ();

      void
      RulesUsedQPId (const RulesUsedQPId_type& x);

      void
      RulesUsedQPId (const RulesUsedQPId_optional& x);

      void
      RulesUsedQPId (::std::unique_ptr< RulesUsedQPId_type > p);

      // RulesToUseQPId
      //
      typedef ::xsd::qif30::QPIdFullReferenceType RulesToUseQPId_type;
      typedef ::xsd::cxx::tree::optional< RulesToUseQPId_type > RulesToUseQPId_optional;
      typedef ::xsd::cxx::tree::traits< RulesToUseQPId_type, wchar_t > RulesToUseQPId_traits;

      const RulesToUseQPId_optional&
      RulesToUseQPId () const;

      RulesToUseQPId_optional&
      RulesToUseQPId ();

      void
      RulesToUseQPId (const RulesToUseQPId_type& x);

      void
      RulesToUseQPId (const RulesToUseQPId_optional& x);

      void
      RulesToUseQPId (::std::unique_ptr< RulesToUseQPId_type > p);

      // WorkInstructions
      //
      typedef ::xsd::qif30::WorkInstructionsType WorkInstructions_type;
      typedef ::xsd::cxx::tree::optional< WorkInstructions_type > WorkInstructions_optional;
      typedef ::xsd::cxx::tree::traits< WorkInstructions_type, wchar_t > WorkInstructions_traits;

      const WorkInstructions_optional&
      WorkInstructions () const;

      WorkInstructions_optional&
      WorkInstructions ();

      void
      WorkInstructions (const WorkInstructions_type& x);

      void
      WorkInstructions (const WorkInstructions_optional& x);

      void
      WorkInstructions (::std::unique_ptr< WorkInstructions_type > p);

      // ActionMethods
      //
      typedef ::xsd::qif30::ActionMethodsType ActionMethods_type;
      typedef ::xsd::cxx::tree::optional< ActionMethods_type > ActionMethods_optional;
      typedef ::xsd::cxx::tree::traits< ActionMethods_type, wchar_t > ActionMethods_traits;

      const ActionMethods_optional&
      ActionMethods () const;

      ActionMethods_optional&
      ActionMethods ();

      void
      ActionMethods (const ActionMethods_type& x);

      void
      ActionMethods (const ActionMethods_optional& x);

      void
      ActionMethods (::std::unique_ptr< ActionMethods_type > p);

      // Measurands
      //
      typedef ::xsd::qif30::MeasurandsType Measurands_type;
      typedef ::xsd::cxx::tree::optional< Measurands_type > Measurands_optional;
      typedef ::xsd::cxx::tree::traits< Measurands_type, wchar_t > Measurands_traits;

      const Measurands_optional&
      Measurands () const;

      Measurands_optional&
      Measurands ();

      void
      Measurands (const Measurands_type& x);

      void
      Measurands (const Measurands_optional& x);

      void
      Measurands (::std::unique_ptr< Measurands_type > p);

      // LocalVariables
      //
      typedef ::xsd::qif30::LocalVariablesType LocalVariables_type;
      typedef ::xsd::cxx::tree::optional< LocalVariables_type > LocalVariables_optional;
      typedef ::xsd::cxx::tree::traits< LocalVariables_type, wchar_t > LocalVariables_traits;

      const LocalVariables_optional&
      LocalVariables () const;

      LocalVariables_optional&
      LocalVariables ();

      void
      LocalVariables (const LocalVariables_type& x);

      void
      LocalVariables (const LocalVariables_optional& x);

      void
      LocalVariables (::std::unique_ptr< LocalVariables_type > p);

      // PlanRoot
      //
      typedef ::xsd::qif30::ActionGroupBaseType PlanRoot_type;
      typedef ::xsd::cxx::tree::traits< PlanRoot_type, wchar_t > PlanRoot_traits;

      const PlanRoot_type&
      PlanRoot () const;

      PlanRoot_type&
      PlanRoot ();

      void
      PlanRoot (const PlanRoot_type& x);

      void
      PlanRoot (::std::unique_ptr< PlanRoot_type > p);

      // Constructors.
      //
      PlanType ();

      PlanType (const PlanRoot_type&);

      PlanType (::std::unique_ptr< PlanRoot_type >);

      PlanType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      PlanType (const PlanType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual PlanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanType&
      operator= (const PlanType& x);

      virtual 
      ~PlanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      RulesUsedQPId_optional RulesUsedQPId_;
      RulesToUseQPId_optional RulesToUseQPId_;
      WorkInstructions_optional WorkInstructions_;
      ActionMethods_optional ActionMethods_;
      Measurands_optional Measurands_;
      LocalVariables_optional LocalVariables_;
      ::xsd::cxx::tree::one< PlanRoot_type > PlanRoot_;
    };

    class QIF30_SYMBOL_DECL PlanElementBaseType: public ::xml_schema::type
    {
      public:
      // WorkInstructionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType WorkInstructionIds_type;
      typedef ::xsd::cxx::tree::optional< WorkInstructionIds_type > WorkInstructionIds_optional;
      typedef ::xsd::cxx::tree::traits< WorkInstructionIds_type, wchar_t > WorkInstructionIds_traits;

      const WorkInstructionIds_optional&
      WorkInstructionIds () const;

      WorkInstructionIds_optional&
      WorkInstructionIds ();

      void
      WorkInstructionIds (const WorkInstructionIds_type& x);

      void
      WorkInstructionIds (const WorkInstructionIds_optional& x);

      void
      WorkInstructionIds (::std::unique_ptr< WorkInstructionIds_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      PlanElementBaseType ();

      PlanElementBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PlanElementBaseType (const PlanElementBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PlanElementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PlanElementBaseType&
      operator= (const PlanElementBaseType& x);

      virtual 
      ~PlanElementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      WorkInstructionIds_optional WorkInstructionIds_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL UnnumberedPlanElementsType: public ::xml_schema::type
    {
      public:
      // PlanElement
      //
      typedef ::xsd::qif30::PlanElementBaseType PlanElement_type;
      typedef ::xsd::cxx::tree::sequence< PlanElement_type > PlanElement_sequence;
      typedef xsd::cxx::tree::sequence< PlanElement_type >::iterator PlanElement_iterator;
      typedef xsd::cxx::tree::sequence< PlanElement_type >::const_iterator PlanElement_const_iterator;
      typedef ::xsd::cxx::tree::traits< PlanElement_type, wchar_t > PlanElement_traits;

      const PlanElement_sequence&
      PlanElement () const;

      PlanElement_sequence&
      PlanElement ();

      void
      PlanElement (const PlanElement_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      UnnumberedPlanElementsType ();

      UnnumberedPlanElementsType (const n_type&);

      UnnumberedPlanElementsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      UnnumberedPlanElementsType (const UnnumberedPlanElementsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual UnnumberedPlanElementsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnnumberedPlanElementsType&
      operator= (const UnnumberedPlanElementsType& x);

      virtual 
      ~UnnumberedPlanElementsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PlanElement_sequence PlanElement_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL NumberedPlanElementType: public ::xml_schema::type
    {
      public:
      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      // PlanElement
      //
      typedef ::xsd::qif30::PlanElementBaseType PlanElement_type;
      typedef ::xsd::cxx::tree::traits< PlanElement_type, wchar_t > PlanElement_traits;

      const PlanElement_type&
      PlanElement () const;

      PlanElement_type&
      PlanElement ();

      void
      PlanElement (const PlanElement_type& x);

      void
      PlanElement (::std::unique_ptr< PlanElement_type > p);

      // Constructors.
      //
      NumberedPlanElementType ();

      NumberedPlanElementType (const SequenceNumber_type&,
                               const PlanElement_type&);

      NumberedPlanElementType (const SequenceNumber_type&,
                               ::std::unique_ptr< PlanElement_type >);

      NumberedPlanElementType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      NumberedPlanElementType (const NumberedPlanElementType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual NumberedPlanElementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NumberedPlanElementType&
      operator= (const NumberedPlanElementType& x);

      virtual 
      ~NumberedPlanElementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
      ::xsd::cxx::tree::one< PlanElement_type > PlanElement_;
    };

    class QIF30_SYMBOL_DECL NumberedPlanElementsType: public ::xml_schema::type
    {
      public:
      // NumberedPlanElement
      //
      typedef ::xsd::qif30::NumberedPlanElementType NumberedPlanElement_type;
      typedef ::xsd::cxx::tree::sequence< NumberedPlanElement_type > NumberedPlanElement_sequence;
      typedef xsd::cxx::tree::sequence< NumberedPlanElement_type >::iterator NumberedPlanElement_iterator;
      typedef xsd::cxx::tree::sequence< NumberedPlanElement_type >::const_iterator NumberedPlanElement_const_iterator;
      typedef ::xsd::cxx::tree::traits< NumberedPlanElement_type, wchar_t > NumberedPlanElement_traits;

      const NumberedPlanElement_sequence&
      NumberedPlanElement () const;

      NumberedPlanElement_sequence&
      NumberedPlanElement ();

      void
      NumberedPlanElement (const NumberedPlanElement_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NumberedPlanElementsType ();

      NumberedPlanElementsType (const n_type&);

      NumberedPlanElementsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      NumberedPlanElementsType (const NumberedPlanElementsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual NumberedPlanElementsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NumberedPlanElementsType&
      operator= (const NumberedPlanElementsType& x);

      virtual 
      ~NumberedPlanElementsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NumberedPlanElement_sequence NumberedPlanElement_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ActionBaseType: public ::xsd::qif30::PlanElementBaseType
    {
      public:
      // PreferredActionMethodId
      //
      typedef ::xsd::qif30::QIFReferenceType PreferredActionMethodId_type;
      typedef ::xsd::cxx::tree::optional< PreferredActionMethodId_type > PreferredActionMethodId_optional;
      typedef ::xsd::cxx::tree::traits< PreferredActionMethodId_type, wchar_t > PreferredActionMethodId_traits;

      const PreferredActionMethodId_optional&
      PreferredActionMethodId () const;

      PreferredActionMethodId_optional&
      PreferredActionMethodId ();

      void
      PreferredActionMethodId (const PreferredActionMethodId_type& x);

      void
      PreferredActionMethodId (const PreferredActionMethodId_optional& x);

      void
      PreferredActionMethodId (::std::unique_ptr< PreferredActionMethodId_type > p);

      // AlternativeActionMethodIds
      //
      typedef ::xsd::qif30::ArrayReferenceType AlternativeActionMethodIds_type;
      typedef ::xsd::cxx::tree::optional< AlternativeActionMethodIds_type > AlternativeActionMethodIds_optional;
      typedef ::xsd::cxx::tree::traits< AlternativeActionMethodIds_type, wchar_t > AlternativeActionMethodIds_traits;

      const AlternativeActionMethodIds_optional&
      AlternativeActionMethodIds () const;

      AlternativeActionMethodIds_optional&
      AlternativeActionMethodIds ();

      void
      AlternativeActionMethodIds (const AlternativeActionMethodIds_type& x);

      void
      AlternativeActionMethodIds (const AlternativeActionMethodIds_optional& x);

      void
      AlternativeActionMethodIds (::std::unique_ptr< AlternativeActionMethodIds_type > p);

      // PreferredResourceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType PreferredResourceIds_type;
      typedef ::xsd::cxx::tree::optional< PreferredResourceIds_type > PreferredResourceIds_optional;
      typedef ::xsd::cxx::tree::traits< PreferredResourceIds_type, wchar_t > PreferredResourceIds_traits;

      const PreferredResourceIds_optional&
      PreferredResourceIds () const;

      PreferredResourceIds_optional&
      PreferredResourceIds ();

      void
      PreferredResourceIds (const PreferredResourceIds_type& x);

      void
      PreferredResourceIds (const PreferredResourceIds_optional& x);

      void
      PreferredResourceIds (::std::unique_ptr< PreferredResourceIds_type > p);

      // Constructors.
      //
      ActionBaseType ();

      ActionBaseType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ActionBaseType (const ActionBaseType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ActionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ActionBaseType&
      operator= (const ActionBaseType& x);

      virtual 
      ~ActionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PreferredActionMethodId_optional PreferredActionMethodId_;
      AlternativeActionMethodIds_optional AlternativeActionMethodIds_;
      PreferredResourceIds_optional PreferredResourceIds_;
    };

    class QIF30_SYMBOL_DECL MeasureEvaluateAllActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // Constructors.
      //
      MeasureEvaluateAllActionType ();

      MeasureEvaluateAllActionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasureEvaluateAllActionType (const MeasureEvaluateAllActionType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual MeasureEvaluateAllActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MeasureEvaluateAllActionType&
      operator= (const MeasureEvaluateAllActionType&) = default;
#endif

      virtual 
      ~MeasureEvaluateAllActionType ();
    };

    class QIF30_SYMBOL_DECL HaltActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // Constructors.
      //
      HaltActionType ();

      HaltActionType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      HaltActionType (const HaltActionType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual HaltActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HaltActionType&
      operator= (const HaltActionType&) = default;
#endif

      virtual 
      ~HaltActionType ();
    };

    class QIF30_SYMBOL_DECL MeasureEvaluateSpecifiedActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // CharacteristicItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicItemIds_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemIds_type, wchar_t > CharacteristicItemIds_traits;

      const CharacteristicItemIds_type&
      CharacteristicItemIds () const;

      CharacteristicItemIds_type&
      CharacteristicItemIds ();

      void
      CharacteristicItemIds (const CharacteristicItemIds_type& x);

      void
      CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > p);

      // Constructors.
      //
      MeasureEvaluateSpecifiedActionType ();

      MeasureEvaluateSpecifiedActionType (const CharacteristicItemIds_type&);

      MeasureEvaluateSpecifiedActionType (::std::unique_ptr< CharacteristicItemIds_type >);

      MeasureEvaluateSpecifiedActionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MeasureEvaluateSpecifiedActionType (const MeasureEvaluateSpecifiedActionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual MeasureEvaluateSpecifiedActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasureEvaluateSpecifiedActionType&
      operator= (const MeasureEvaluateSpecifiedActionType& x);

      virtual 
      ~MeasureEvaluateSpecifiedActionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicItemIds_type > CharacteristicItemIds_;
    };

    class QIF30_SYMBOL_DECL EvaluateSpecifiedCharacteristicsActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // CharacteristicItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicItemIds_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemIds_type, wchar_t > CharacteristicItemIds_traits;

      const CharacteristicItemIds_type&
      CharacteristicItemIds () const;

      CharacteristicItemIds_type&
      CharacteristicItemIds ();

      void
      CharacteristicItemIds (const CharacteristicItemIds_type& x);

      void
      CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > p);

      // Constructors.
      //
      EvaluateSpecifiedCharacteristicsActionType ();

      EvaluateSpecifiedCharacteristicsActionType (const CharacteristicItemIds_type&);

      EvaluateSpecifiedCharacteristicsActionType (::std::unique_ptr< CharacteristicItemIds_type >);

      EvaluateSpecifiedCharacteristicsActionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      EvaluateSpecifiedCharacteristicsActionType (const EvaluateSpecifiedCharacteristicsActionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual EvaluateSpecifiedCharacteristicsActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EvaluateSpecifiedCharacteristicsActionType&
      operator= (const EvaluateSpecifiedCharacteristicsActionType& x);

      virtual 
      ~EvaluateSpecifiedCharacteristicsActionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicItemIds_type > CharacteristicItemIds_;
    };

    class QIF30_SYMBOL_DECL MeasureSpecifiedFeaturesActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // FeatureItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureItemIds_type;
      typedef ::xsd::cxx::tree::traits< FeatureItemIds_type, wchar_t > FeatureItemIds_traits;

      const FeatureItemIds_type&
      FeatureItemIds () const;

      FeatureItemIds_type&
      FeatureItemIds ();

      void
      FeatureItemIds (const FeatureItemIds_type& x);

      void
      FeatureItemIds (::std::unique_ptr< FeatureItemIds_type > p);

      // Constructors.
      //
      MeasureSpecifiedFeaturesActionType ();

      MeasureSpecifiedFeaturesActionType (const FeatureItemIds_type&);

      MeasureSpecifiedFeaturesActionType (::std::unique_ptr< FeatureItemIds_type >);

      MeasureSpecifiedFeaturesActionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MeasureSpecifiedFeaturesActionType (const MeasureSpecifiedFeaturesActionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual MeasureSpecifiedFeaturesActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasureSpecifiedFeaturesActionType&
      operator= (const MeasureSpecifiedFeaturesActionType& x);

      virtual 
      ~MeasureSpecifiedFeaturesActionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureItemIds_type > FeatureItemIds_;
    };

    class QIF30_SYMBOL_DECL MeasurandBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      MeasurandBaseType ();

      MeasurandBaseType (const id_type&);

      MeasurandBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      MeasurandBaseType (const MeasurandBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual MeasurandBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MeasurandBaseType&
      operator= (const MeasurandBaseType& x);

      virtual 
      ~MeasurandBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL EvaluateCharacteristicMeasurandType: public ::xsd::qif30::MeasurandBaseType
    {
      public:
      // CharacteristicItemId
      //
      typedef ::xsd::qif30::QIFReferenceType CharacteristicItemId_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemId_type, wchar_t > CharacteristicItemId_traits;

      const CharacteristicItemId_type&
      CharacteristicItemId () const;

      CharacteristicItemId_type&
      CharacteristicItemId ();

      void
      CharacteristicItemId (const CharacteristicItemId_type& x);

      void
      CharacteristicItemId (::std::unique_ptr< CharacteristicItemId_type > p);

      // Constructors.
      //
      EvaluateCharacteristicMeasurandType ();

      EvaluateCharacteristicMeasurandType (const id_type&,
                                           const CharacteristicItemId_type&);

      EvaluateCharacteristicMeasurandType (const id_type&,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      EvaluateCharacteristicMeasurandType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EvaluateCharacteristicMeasurandType (const EvaluateCharacteristicMeasurandType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EvaluateCharacteristicMeasurandType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EvaluateCharacteristicMeasurandType&
      operator= (const EvaluateCharacteristicMeasurandType& x);

      virtual 
      ~EvaluateCharacteristicMeasurandType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicItemId_type > CharacteristicItemId_;
    };

    class QIF30_SYMBOL_DECL EstablishDatumMeasurandType: public ::xsd::qif30::MeasurandBaseType
    {
      public:
      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_type&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_type&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // Constructors.
      //
      EstablishDatumMeasurandType ();

      EstablishDatumMeasurandType (const id_type&,
                                   const DatumDefinitionId_type&,
                                   const DatumReferenceFrameId_type&);

      EstablishDatumMeasurandType (const id_type&,
                                   ::std::unique_ptr< DatumDefinitionId_type >,
                                   ::std::unique_ptr< DatumReferenceFrameId_type >);

      EstablishDatumMeasurandType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      EstablishDatumMeasurandType (const EstablishDatumMeasurandType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual EstablishDatumMeasurandType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EstablishDatumMeasurandType&
      operator= (const EstablishDatumMeasurandType& x);

      virtual 
      ~EstablishDatumMeasurandType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
      ::xsd::cxx::tree::one< DatumReferenceFrameId_type > DatumReferenceFrameId_;
    };

    class QIF30_SYMBOL_DECL MeasureSpecifiedMeasurandsActionType: public ::xsd::qif30::ActionBaseType
    {
      public:
      // MeasurandIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurandIds_type;
      typedef ::xsd::cxx::tree::traits< MeasurandIds_type, wchar_t > MeasurandIds_traits;

      const MeasurandIds_type&
      MeasurandIds () const;

      MeasurandIds_type&
      MeasurandIds ();

      void
      MeasurandIds (const MeasurandIds_type& x);

      void
      MeasurandIds (::std::unique_ptr< MeasurandIds_type > p);

      // Constructors.
      //
      MeasureSpecifiedMeasurandsActionType ();

      MeasureSpecifiedMeasurandsActionType (const MeasurandIds_type&);

      MeasureSpecifiedMeasurandsActionType (::std::unique_ptr< MeasurandIds_type >);

      MeasureSpecifiedMeasurandsActionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      MeasureSpecifiedMeasurandsActionType (const MeasureSpecifiedMeasurandsActionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual MeasureSpecifiedMeasurandsActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasureSpecifiedMeasurandsActionType&
      operator= (const MeasureSpecifiedMeasurandsActionType& x);

      virtual 
      ~MeasureSpecifiedMeasurandsActionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MeasurandIds_type > MeasurandIds_;
    };

    class QIF30_SYMBOL_DECL MeasurandsType: public ::xml_schema::type
    {
      public:
      // Measurand
      //
      typedef ::xsd::qif30::MeasurandBaseType Measurand_type;
      typedef ::xsd::cxx::tree::sequence< Measurand_type > Measurand_sequence;
      typedef xsd::cxx::tree::sequence< Measurand_type >::iterator Measurand_iterator;
      typedef xsd::cxx::tree::sequence< Measurand_type >::const_iterator Measurand_const_iterator;
      typedef ::xsd::cxx::tree::traits< Measurand_type, wchar_t > Measurand_traits;

      const Measurand_sequence&
      Measurand () const;

      Measurand_sequence&
      Measurand ();

      void
      Measurand (const Measurand_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MeasurandsType ();

      MeasurandsType (const n_type&);

      MeasurandsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      MeasurandsType (const MeasurandsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual MeasurandsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurandsType&
      operator= (const MeasurandsType& x);

      virtual 
      ~MeasurandsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measurand_sequence Measurand_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ActionMethodBaseType: public ::xml_schema::type
    {
      public:
      // ChosenResourceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ChosenResourceIds_type;
      typedef ::xsd::cxx::tree::optional< ChosenResourceIds_type > ChosenResourceIds_optional;
      typedef ::xsd::cxx::tree::traits< ChosenResourceIds_type, wchar_t > ChosenResourceIds_traits;

      const ChosenResourceIds_optional&
      ChosenResourceIds () const;

      ChosenResourceIds_optional&
      ChosenResourceIds ();

      void
      ChosenResourceIds (const ChosenResourceIds_type& x);

      void
      ChosenResourceIds (const ChosenResourceIds_optional& x);

      void
      ChosenResourceIds (::std::unique_ptr< ChosenResourceIds_type > p);

      // WorkInstructionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType WorkInstructionIds_type;
      typedef ::xsd::cxx::tree::optional< WorkInstructionIds_type > WorkInstructionIds_optional;
      typedef ::xsd::cxx::tree::traits< WorkInstructionIds_type, wchar_t > WorkInstructionIds_traits;

      const WorkInstructionIds_optional&
      WorkInstructionIds () const;

      WorkInstructionIds_optional&
      WorkInstructionIds ();

      void
      WorkInstructionIds (const WorkInstructionIds_type& x);

      void
      WorkInstructionIds (const WorkInstructionIds_optional& x);

      void
      WorkInstructionIds (::std::unique_ptr< WorkInstructionIds_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      ActionMethodBaseType ();

      ActionMethodBaseType (const id_type&);

      ActionMethodBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActionMethodBaseType (const ActionMethodBaseType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ActionMethodBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ActionMethodBaseType&
      operator= (const ActionMethodBaseType& x);

      virtual 
      ~ActionMethodBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ChosenResourceIds_optional ChosenResourceIds_;
      WorkInstructionIds_optional WorkInstructionIds_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL MeasureFeatureMethodBaseType: public ::xsd::qif30::ActionMethodBaseType
    {
      public:
      // Constructors.
      //
      MeasureFeatureMethodBaseType ();

      MeasureFeatureMethodBaseType (const id_type&);

      MeasureFeatureMethodBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasureFeatureMethodBaseType (const MeasureFeatureMethodBaseType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual MeasureFeatureMethodBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      MeasureFeatureMethodBaseType&
      operator= (const MeasureFeatureMethodBaseType&) = default;
#endif

      virtual 
      ~MeasureFeatureMethodBaseType ();
    };

    class QIF30_SYMBOL_DECL AutocollimatorMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      AutocollimatorMeasureFeatureMethodType ();

      AutocollimatorMeasureFeatureMethodType (const id_type&);

      AutocollimatorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      AutocollimatorMeasureFeatureMethodType (const AutocollimatorMeasureFeatureMethodType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual AutocollimatorMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AutocollimatorMeasureFeatureMethodType&
      operator= (const AutocollimatorMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~AutocollimatorMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL CalibratedComparatorMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      CalibratedComparatorMeasureFeatureMethodType ();

      CalibratedComparatorMeasureFeatureMethodType (const id_type&);

      CalibratedComparatorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      CalibratedComparatorMeasureFeatureMethodType (const CalibratedComparatorMeasureFeatureMethodType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual CalibratedComparatorMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CalibratedComparatorMeasureFeatureMethodType&
      operator= (const CalibratedComparatorMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~CalibratedComparatorMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL ComputedTomographyMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      ComputedTomographyMeasureFeatureMethodType ();

      ComputedTomographyMeasureFeatureMethodType (const id_type&);

      ComputedTomographyMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ComputedTomographyMeasureFeatureMethodType (const ComputedTomographyMeasureFeatureMethodType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ComputedTomographyMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ComputedTomographyMeasureFeatureMethodType&
      operator= (const ComputedTomographyMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~ComputedTomographyMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL CoordinateMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // NumberOfMeasurementPoints
      //
      typedef ::xml_schema::positive_integer NumberOfMeasurementPoints_type;
      typedef ::xsd::cxx::tree::optional< NumberOfMeasurementPoints_type > NumberOfMeasurementPoints_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfMeasurementPoints_type, wchar_t > NumberOfMeasurementPoints_traits;

      const NumberOfMeasurementPoints_optional&
      NumberOfMeasurementPoints () const;

      NumberOfMeasurementPoints_optional&
      NumberOfMeasurementPoints ();

      void
      NumberOfMeasurementPoints (const NumberOfMeasurementPoints_type& x);

      void
      NumberOfMeasurementPoints (const NumberOfMeasurementPoints_optional& x);

      // Constructors.
      //
      CoordinateMeasureFeatureMethodType ();

      CoordinateMeasureFeatureMethodType (const id_type&);

      CoordinateMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CoordinateMeasureFeatureMethodType (const CoordinateMeasureFeatureMethodType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual CoordinateMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateMeasureFeatureMethodType&
      operator= (const CoordinateMeasureFeatureMethodType& x);

      virtual 
      ~CoordinateMeasureFeatureMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NumberOfMeasurementPoints_optional NumberOfMeasurementPoints_;
    };

    class QIF30_SYMBOL_DECL ExternalReferenceMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // ExternalFileReferences
      //
      typedef ::xsd::qif30::ExternalFileReferencesType ExternalFileReferences_type;
      typedef ::xsd::cxx::tree::optional< ExternalFileReferences_type > ExternalFileReferences_optional;
      typedef ::xsd::cxx::tree::traits< ExternalFileReferences_type, wchar_t > ExternalFileReferences_traits;

      const ExternalFileReferences_optional&
      ExternalFileReferences () const;

      ExternalFileReferences_optional&
      ExternalFileReferences ();

      void
      ExternalFileReferences (const ExternalFileReferences_type& x);

      void
      ExternalFileReferences (const ExternalFileReferences_optional& x);

      void
      ExternalFileReferences (::std::unique_ptr< ExternalFileReferences_type > p);

      // Constructors.
      //
      ExternalReferenceMeasureFeatureMethodType ();

      ExternalReferenceMeasureFeatureMethodType (const id_type&);

      ExternalReferenceMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      ExternalReferenceMeasureFeatureMethodType (const ExternalReferenceMeasureFeatureMethodType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual ExternalReferenceMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExternalReferenceMeasureFeatureMethodType&
      operator= (const ExternalReferenceMeasureFeatureMethodType& x);

      virtual 
      ~ExternalReferenceMeasureFeatureMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ExternalFileReferences_optional ExternalFileReferences_;
    };

    class QIF30_SYMBOL_DECL GageMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      GageMeasureFeatureMethodType ();

      GageMeasureFeatureMethodType (const id_type&);

      GageMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      GageMeasureFeatureMethodType (const GageMeasureFeatureMethodType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual GageMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      GageMeasureFeatureMethodType&
      operator= (const GageMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~GageMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL LaserRadarMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      LaserRadarMeasureFeatureMethodType ();

      LaserRadarMeasureFeatureMethodType (const id_type&);

      LaserRadarMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      LaserRadarMeasureFeatureMethodType (const LaserRadarMeasureFeatureMethodType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual LaserRadarMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LaserRadarMeasureFeatureMethodType&
      operator= (const LaserRadarMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~LaserRadarMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL LaserTrackerMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      LaserTrackerMeasureFeatureMethodType ();

      LaserTrackerMeasureFeatureMethodType (const id_type&);

      LaserTrackerMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LaserTrackerMeasureFeatureMethodType (const LaserTrackerMeasureFeatureMethodType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual LaserTrackerMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LaserTrackerMeasureFeatureMethodType&
      operator= (const LaserTrackerMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~LaserTrackerMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL ManualMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      ManualMeasureFeatureMethodType ();

      ManualMeasureFeatureMethodType (const id_type&);

      ManualMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ManualMeasureFeatureMethodType (const ManualMeasureFeatureMethodType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ManualMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ManualMeasureFeatureMethodType&
      operator= (const ManualMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~ManualMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL MicroscopeMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      MicroscopeMeasureFeatureMethodType ();

      MicroscopeMeasureFeatureMethodType (const id_type&);

      MicroscopeMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MicroscopeMeasureFeatureMethodType (const MicroscopeMeasureFeatureMethodType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual MicroscopeMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MicroscopeMeasureFeatureMethodType&
      operator= (const MicroscopeMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~MicroscopeMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL OtherMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      OtherMeasureFeatureMethodType ();

      OtherMeasureFeatureMethodType (const id_type&);

      OtherMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      OtherMeasureFeatureMethodType (const OtherMeasureFeatureMethodType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual OtherMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherMeasureFeatureMethodType&
      operator= (const OtherMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~OtherMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL ProfileProjectorMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      ProfileProjectorMeasureFeatureMethodType ();

      ProfileProjectorMeasureFeatureMethodType (const id_type&);

      ProfileProjectorMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ProfileProjectorMeasureFeatureMethodType (const ProfileProjectorMeasureFeatureMethodType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ProfileProjectorMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ProfileProjectorMeasureFeatureMethodType&
      operator= (const ProfileProjectorMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~ProfileProjectorMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL TheodoliteMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      TheodoliteMeasureFeatureMethodType ();

      TheodoliteMeasureFeatureMethodType (const id_type&);

      TheodoliteMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      TheodoliteMeasureFeatureMethodType (const TheodoliteMeasureFeatureMethodType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual TheodoliteMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TheodoliteMeasureFeatureMethodType&
      operator= (const TheodoliteMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~TheodoliteMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL UniversalLengthMeasureFeatureMethodType: public ::xsd::qif30::MeasureFeatureMethodBaseType
    {
      public:
      // Constructors.
      //
      UniversalLengthMeasureFeatureMethodType ();

      UniversalLengthMeasureFeatureMethodType (const id_type&);

      UniversalLengthMeasureFeatureMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      UniversalLengthMeasureFeatureMethodType (const UniversalLengthMeasureFeatureMethodType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual UniversalLengthMeasureFeatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UniversalLengthMeasureFeatureMethodType&
      operator= (const UniversalLengthMeasureFeatureMethodType&) = default;
#endif

      virtual 
      ~UniversalLengthMeasureFeatureMethodType ();
    };

    class QIF30_SYMBOL_DECL ActionMethodsType: public ::xml_schema::type
    {
      public:
      // ActionMethod
      //
      typedef ::xsd::qif30::ActionMethodBaseType ActionMethod_type;
      typedef ::xsd::cxx::tree::sequence< ActionMethod_type > ActionMethod_sequence;
      typedef xsd::cxx::tree::sequence< ActionMethod_type >::iterator ActionMethod_iterator;
      typedef xsd::cxx::tree::sequence< ActionMethod_type >::const_iterator ActionMethod_const_iterator;
      typedef ::xsd::cxx::tree::traits< ActionMethod_type, wchar_t > ActionMethod_traits;

      const ActionMethod_sequence&
      ActionMethod () const;

      ActionMethod_sequence&
      ActionMethod ();

      void
      ActionMethod (const ActionMethod_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ActionMethodsType ();

      ActionMethodsType (const n_type&);

      ActionMethodsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ActionMethodsType (const ActionMethodsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ActionMethodsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActionMethodsType&
      operator= (const ActionMethodsType& x);

      virtual 
      ~ActionMethodsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ActionMethod_sequence ActionMethod_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeasureActionGroupFunctionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ROUTING_PLAN,
        OPERATION_SEQUENCE,
        SETUP_USAGE_GROUP,
        SENSOR_USAGE_GROUP,
        CARRIAGE_USAGE_GROUP,
        PCS_USAGE_GROUP,
        EVALUATE_CHAR_ACTIONS,
        ESTABLISH_DATUM_ACTIONS,
        UNDEFINED
      };

      MeasureActionGroupFunctionEnumType ();

      MeasureActionGroupFunctionEnumType (value v);

      MeasureActionGroupFunctionEnumType (const wchar_t* v);

      MeasureActionGroupFunctionEnumType (const ::std::wstring& v);

      MeasureActionGroupFunctionEnumType (const ::xml_schema::nmtoken& v);

      MeasureActionGroupFunctionEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MeasureActionGroupFunctionEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MeasureActionGroupFunctionEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      MeasureActionGroupFunctionEnumType (const MeasureActionGroupFunctionEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      MeasureActionGroupFunctionEnumType&
      operator= (const MeasureActionGroupFunctionEnumType&) = default;
#endif

      virtual MeasureActionGroupFunctionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasureActionGroupFunctionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MeasureActionGroupFunctionEnumType_convert ();
      }

      protected:
      value
      _xsd_MeasureActionGroupFunctionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_MeasureActionGroupFunctionEnumType_literals_[9];
      static const value _xsd_MeasureActionGroupFunctionEnumType_indexes_[9];
    };

    class QIF30_SYMBOL_DECL MeasureActionGroupFunctionType: public ::xml_schema::type
    {
      public:
      // MeasureActionGroupFunctionEnum
      //
      typedef ::xsd::qif30::MeasureActionGroupFunctionEnumType MeasureActionGroupFunctionEnum_type;
      typedef ::xsd::cxx::tree::optional< MeasureActionGroupFunctionEnum_type > MeasureActionGroupFunctionEnum_optional;
      typedef ::xsd::cxx::tree::traits< MeasureActionGroupFunctionEnum_type, wchar_t > MeasureActionGroupFunctionEnum_traits;

      const MeasureActionGroupFunctionEnum_optional&
      MeasureActionGroupFunctionEnum () const;

      MeasureActionGroupFunctionEnum_optional&
      MeasureActionGroupFunctionEnum ();

      void
      MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_type& x);

      void
      MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_optional& x);

      void
      MeasureActionGroupFunctionEnum (::std::unique_ptr< MeasureActionGroupFunctionEnum_type > p);

      // OtherMeasureActionGroupFunction
      //
      typedef ::xml_schema::string OtherMeasureActionGroupFunction_type;
      typedef ::xsd::cxx::tree::optional< OtherMeasureActionGroupFunction_type > OtherMeasureActionGroupFunction_optional;
      typedef ::xsd::cxx::tree::traits< OtherMeasureActionGroupFunction_type, wchar_t > OtherMeasureActionGroupFunction_traits;

      const OtherMeasureActionGroupFunction_optional&
      OtherMeasureActionGroupFunction () const;

      OtherMeasureActionGroupFunction_optional&
      OtherMeasureActionGroupFunction ();

      void
      OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_type& x);

      void
      OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_optional& x);

      void
      OtherMeasureActionGroupFunction (::std::unique_ptr< OtherMeasureActionGroupFunction_type > p);

      // Constructors.
      //
      MeasureActionGroupFunctionType ();

      MeasureActionGroupFunctionType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      MeasureActionGroupFunctionType (const MeasureActionGroupFunctionType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual MeasureActionGroupFunctionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasureActionGroupFunctionType&
      operator= (const MeasureActionGroupFunctionType& x);

      virtual 
      ~MeasureActionGroupFunctionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasureActionGroupFunctionEnum_optional MeasureActionGroupFunctionEnum_;
      OtherMeasureActionGroupFunction_optional OtherMeasureActionGroupFunction_;
    };

    class QIF30_SYMBOL_DECL ActionGroupBaseType: public ::xsd::qif30::PlanElementBaseType
    {
      public:
      // MeasureActionGroupFunction
      //
      typedef ::xsd::qif30::MeasureActionGroupFunctionType MeasureActionGroupFunction_type;
      typedef ::xsd::cxx::tree::optional< MeasureActionGroupFunction_type > MeasureActionGroupFunction_optional;
      typedef ::xsd::cxx::tree::traits< MeasureActionGroupFunction_type, wchar_t > MeasureActionGroupFunction_traits;

      const MeasureActionGroupFunction_optional&
      MeasureActionGroupFunction () const;

      MeasureActionGroupFunction_optional&
      MeasureActionGroupFunction ();

      void
      MeasureActionGroupFunction (const MeasureActionGroupFunction_type& x);

      void
      MeasureActionGroupFunction (const MeasureActionGroupFunction_optional& x);

      void
      MeasureActionGroupFunction (::std::unique_ptr< MeasureActionGroupFunction_type > p);

      // Constructors.
      //
      ActionGroupBaseType ();

      ActionGroupBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ActionGroupBaseType (const ActionGroupBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ActionGroupBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ActionGroupBaseType&
      operator= (const ActionGroupBaseType& x);

      virtual 
      ~ActionGroupBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasureActionGroupFunction_optional MeasureActionGroupFunction_;
    };

    class QIF30_SYMBOL_DECL OrderedActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // Steps
      //
      typedef ::xsd::qif30::NumberedPlanElementsType Steps_type;
      typedef ::xsd::cxx::tree::traits< Steps_type, wchar_t > Steps_traits;

      const Steps_type&
      Steps () const;

      Steps_type&
      Steps ();

      void
      Steps (const Steps_type& x);

      void
      Steps (::std::unique_ptr< Steps_type > p);

      // Constructors.
      //
      OrderedActionGroupType ();

      OrderedActionGroupType (const Steps_type&);

      OrderedActionGroupType (::std::unique_ptr< Steps_type >);

      OrderedActionGroupType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      OrderedActionGroupType (const OrderedActionGroupType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual OrderedActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrderedActionGroupType&
      operator= (const OrderedActionGroupType& x);

      virtual 
      ~OrderedActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Steps_type > Steps_;
    };

    class QIF30_SYMBOL_DECL UnorderedActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // Steps
      //
      typedef ::xsd::qif30::UnnumberedPlanElementsType Steps_type;
      typedef ::xsd::cxx::tree::traits< Steps_type, wchar_t > Steps_traits;

      const Steps_type&
      Steps () const;

      Steps_type&
      Steps ();

      void
      Steps (const Steps_type& x);

      void
      Steps (::std::unique_ptr< Steps_type > p);

      // Constructors.
      //
      UnorderedActionGroupType ();

      UnorderedActionGroupType (const Steps_type&);

      UnorderedActionGroupType (::std::unique_ptr< Steps_type >);

      UnorderedActionGroupType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      UnorderedActionGroupType (const UnorderedActionGroupType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual UnorderedActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnorderedActionGroupType&
      operator= (const UnorderedActionGroupType& x);

      virtual 
      ~UnorderedActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Steps_type > Steps_;
    };

    class QIF30_SYMBOL_DECL PartiallyOrderedActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // StepsWithPredecessors
      //
      typedef ::xsd::qif30::StepsWithPredecessorsType StepsWithPredecessors_type;
      typedef ::xsd::cxx::tree::traits< StepsWithPredecessors_type, wchar_t > StepsWithPredecessors_traits;

      const StepsWithPredecessors_type&
      StepsWithPredecessors () const;

      StepsWithPredecessors_type&
      StepsWithPredecessors ();

      void
      StepsWithPredecessors (const StepsWithPredecessors_type& x);

      void
      StepsWithPredecessors (::std::unique_ptr< StepsWithPredecessors_type > p);

      // Constructors.
      //
      PartiallyOrderedActionGroupType ();

      PartiallyOrderedActionGroupType (const StepsWithPredecessors_type&);

      PartiallyOrderedActionGroupType (::std::unique_ptr< StepsWithPredecessors_type >);

      PartiallyOrderedActionGroupType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PartiallyOrderedActionGroupType (const PartiallyOrderedActionGroupType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PartiallyOrderedActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PartiallyOrderedActionGroupType&
      operator= (const PartiallyOrderedActionGroupType& x);

      virtual 
      ~PartiallyOrderedActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StepsWithPredecessors_type > StepsWithPredecessors_;
    };

    class QIF30_SYMBOL_DECL StepWithPredecessorsType: public ::xml_schema::type
    {
      public:
      // Predecessors
      //
      typedef ::xsd::qif30::PredecessorsType Predecessors_type;
      typedef ::xsd::cxx::tree::optional< Predecessors_type > Predecessors_optional;
      typedef ::xsd::cxx::tree::traits< Predecessors_type, wchar_t > Predecessors_traits;

      const Predecessors_optional&
      Predecessors () const;

      Predecessors_optional&
      Predecessors ();

      void
      Predecessors (const Predecessors_type& x);

      void
      Predecessors (const Predecessors_optional& x);

      void
      Predecessors (::std::unique_ptr< Predecessors_type > p);

      // Step
      //
      typedef ::xsd::qif30::NumberedPlanElementType Step_type;
      typedef ::xsd::cxx::tree::traits< Step_type, wchar_t > Step_traits;

      const Step_type&
      Step () const;

      Step_type&
      Step ();

      void
      Step (const Step_type& x);

      void
      Step (::std::unique_ptr< Step_type > p);

      // Constructors.
      //
      StepWithPredecessorsType ();

      StepWithPredecessorsType (const Step_type&);

      StepWithPredecessorsType (::std::unique_ptr< Step_type >);

      StepWithPredecessorsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      StepWithPredecessorsType (const StepWithPredecessorsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual StepWithPredecessorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StepWithPredecessorsType&
      operator= (const StepWithPredecessorsType& x);

      virtual 
      ~StepWithPredecessorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Predecessors_optional Predecessors_;
      ::xsd::cxx::tree::one< Step_type > Step_;
    };

    class QIF30_SYMBOL_DECL StepsWithPredecessorsType: public ::xml_schema::type
    {
      public:
      // StepWithPredecessors
      //
      typedef ::xsd::qif30::StepWithPredecessorsType StepWithPredecessors_type;
      typedef ::xsd::cxx::tree::sequence< StepWithPredecessors_type > StepWithPredecessors_sequence;
      typedef xsd::cxx::tree::sequence< StepWithPredecessors_type >::iterator StepWithPredecessors_iterator;
      typedef xsd::cxx::tree::sequence< StepWithPredecessors_type >::const_iterator StepWithPredecessors_const_iterator;
      typedef ::xsd::cxx::tree::traits< StepWithPredecessors_type, wchar_t > StepWithPredecessors_traits;

      const StepWithPredecessors_sequence&
      StepWithPredecessors () const;

      StepWithPredecessors_sequence&
      StepWithPredecessors ();

      void
      StepWithPredecessors (const StepWithPredecessors_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StepsWithPredecessorsType ();

      StepsWithPredecessorsType (const n_type&);

      StepsWithPredecessorsType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StepsWithPredecessorsType (const StepsWithPredecessorsType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StepsWithPredecessorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StepsWithPredecessorsType&
      operator= (const StepsWithPredecessorsType& x);

      virtual 
      ~StepsWithPredecessorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StepWithPredecessors_sequence StepWithPredecessors_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PredecessorsType: public ::xml_schema::type
    {
      public:
      // Predecessor
      //
      typedef ::xml_schema::positive_integer Predecessor_type;
      typedef ::xsd::cxx::tree::sequence< Predecessor_type > Predecessor_sequence;
      typedef xsd::cxx::tree::sequence< Predecessor_type >::iterator Predecessor_iterator;
      typedef xsd::cxx::tree::sequence< Predecessor_type >::const_iterator Predecessor_const_iterator;
      typedef ::xsd::cxx::tree::traits< Predecessor_type, wchar_t > Predecessor_traits;

      const Predecessor_sequence&
      Predecessor () const;

      Predecessor_sequence&
      Predecessor ();

      void
      Predecessor (const Predecessor_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PredecessorsType ();

      PredecessorsType (const n_type&);

      PredecessorsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PredecessorsType (const PredecessorsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PredecessorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PredecessorsType&
      operator= (const PredecessorsType& x);

      virtual 
      ~PredecessorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Predecessor_sequence Predecessor_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OneOfActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // Steps
      //
      typedef ::xsd::qif30::NumberedPlanElementsType Steps_type;
      typedef ::xsd::cxx::tree::traits< Steps_type, wchar_t > Steps_traits;

      const Steps_type&
      Steps () const;

      Steps_type&
      Steps ();

      void
      Steps (const Steps_type& x);

      void
      Steps (::std::unique_ptr< Steps_type > p);

      // Constructors.
      //
      OneOfActionGroupType ();

      OneOfActionGroupType (const Steps_type&);

      OneOfActionGroupType (::std::unique_ptr< Steps_type >);

      OneOfActionGroupType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      OneOfActionGroupType (const OneOfActionGroupType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual OneOfActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OneOfActionGroupType&
      operator= (const OneOfActionGroupType& x);

      virtual 
      ~OneOfActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Steps_type > Steps_;
    };

    class QIF30_SYMBOL_DECL PickSomeActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // Steps
      //
      typedef ::xsd::qif30::UnnumberedPlanElementsType Steps_type;
      typedef ::xsd::cxx::tree::traits< Steps_type, wchar_t > Steps_traits;

      const Steps_type&
      Steps () const;

      Steps_type&
      Steps ();

      void
      Steps (const Steps_type& x);

      void
      Steps (::std::unique_ptr< Steps_type > p);

      // NumberOfSteps
      //
      typedef ::xml_schema::positive_integer NumberOfSteps_type;
      typedef ::xsd::cxx::tree::traits< NumberOfSteps_type, wchar_t > NumberOfSteps_traits;

      const NumberOfSteps_type&
      NumberOfSteps () const;

      NumberOfSteps_type&
      NumberOfSteps ();

      void
      NumberOfSteps (const NumberOfSteps_type& x);

      // Constructors.
      //
      PickSomeActionGroupType ();

      PickSomeActionGroupType (const Steps_type&,
                               const NumberOfSteps_type&);

      PickSomeActionGroupType (::std::unique_ptr< Steps_type >,
                               const NumberOfSteps_type&);

      PickSomeActionGroupType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PickSomeActionGroupType (const PickSomeActionGroupType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PickSomeActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PickSomeActionGroupType&
      operator= (const PickSomeActionGroupType& x);

      virtual 
      ~PickSomeActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Steps_type > Steps_;
      ::xsd::cxx::tree::one< NumberOfSteps_type > NumberOfSteps_;
    };

    class QIF30_SYMBOL_DECL IfActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // If
      //
      typedef ::xsd::qif30::TestAndPlanElementType If_type;
      typedef ::xsd::cxx::tree::traits< If_type, wchar_t > If_traits;

      const If_type&
      If () const;

      If_type&
      If ();

      void
      If (const If_type& x);

      void
      If (::std::unique_ptr< If_type > p);

      // ElseIf
      //
      typedef ::xsd::qif30::TestAndPlanElementType ElseIf_type;
      typedef ::xsd::cxx::tree::sequence< ElseIf_type > ElseIf_sequence;
      typedef xsd::cxx::tree::sequence< ElseIf_type >::iterator ElseIf_iterator;
      typedef xsd::cxx::tree::sequence< ElseIf_type >::const_iterator ElseIf_const_iterator;
      typedef ::xsd::cxx::tree::traits< ElseIf_type, wchar_t > ElseIf_traits;

      const ElseIf_sequence&
      ElseIf () const;

      ElseIf_sequence&
      ElseIf ();

      void
      ElseIf (const ElseIf_sequence& s);

      // ElseDo
      //
      typedef ::xsd::qif30::ElseDoType ElseDo_type;
      typedef ::xsd::cxx::tree::optional< ElseDo_type > ElseDo_optional;
      typedef ::xsd::cxx::tree::traits< ElseDo_type, wchar_t > ElseDo_traits;

      const ElseDo_optional&
      ElseDo () const;

      ElseDo_optional&
      ElseDo ();

      void
      ElseDo (const ElseDo_type& x);

      void
      ElseDo (const ElseDo_optional& x);

      void
      ElseDo (::std::unique_ptr< ElseDo_type > p);

      // Constructors.
      //
      IfActionGroupType ();

      IfActionGroupType (const If_type&);

      IfActionGroupType (::std::unique_ptr< If_type >);

      IfActionGroupType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      IfActionGroupType (const IfActionGroupType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual IfActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfActionGroupType&
      operator= (const IfActionGroupType& x);

      virtual 
      ~IfActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< If_type > If_;
      ElseIf_sequence ElseIf_;
      ElseDo_optional ElseDo_;
    };

    class QIF30_SYMBOL_DECL TestAndPlanElementType: public ::xml_schema::type
    {
      public:
      // BooleanExpression
      //
      typedef ::xsd::qif30::BooleanExpressionBaseType BooleanExpression_type;
      typedef ::xsd::cxx::tree::traits< BooleanExpression_type, wchar_t > BooleanExpression_traits;

      const BooleanExpression_type&
      BooleanExpression () const;

      BooleanExpression_type&
      BooleanExpression ();

      void
      BooleanExpression (const BooleanExpression_type& x);

      void
      BooleanExpression (::std::unique_ptr< BooleanExpression_type > p);

      // PlanElement
      //
      typedef ::xsd::qif30::PlanElementBaseType PlanElement_type;
      typedef ::xsd::cxx::tree::traits< PlanElement_type, wchar_t > PlanElement_traits;

      const PlanElement_type&
      PlanElement () const;

      PlanElement_type&
      PlanElement ();

      void
      PlanElement (const PlanElement_type& x);

      void
      PlanElement (::std::unique_ptr< PlanElement_type > p);

      // Constructors.
      //
      TestAndPlanElementType ();

      TestAndPlanElementType (const BooleanExpression_type&,
                              const PlanElement_type&);

      TestAndPlanElementType (const BooleanExpression_type&,
                              ::std::unique_ptr< PlanElement_type >);

      TestAndPlanElementType (::std::unique_ptr< BooleanExpression_type >,
                              ::std::unique_ptr< PlanElement_type >);

      TestAndPlanElementType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TestAndPlanElementType (const TestAndPlanElementType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual TestAndPlanElementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TestAndPlanElementType&
      operator= (const TestAndPlanElementType& x);

      virtual 
      ~TestAndPlanElementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BooleanExpression_type > BooleanExpression_;
      ::xsd::cxx::tree::one< PlanElement_type > PlanElement_;
    };

    class QIF30_SYMBOL_DECL ElseDoType: public ::xml_schema::type
    {
      public:
      // PlanElement
      //
      typedef ::xsd::qif30::PlanElementBaseType PlanElement_type;
      typedef ::xsd::cxx::tree::traits< PlanElement_type, wchar_t > PlanElement_traits;

      const PlanElement_type&
      PlanElement () const;

      PlanElement_type&
      PlanElement ();

      void
      PlanElement (const PlanElement_type& x);

      void
      PlanElement (::std::unique_ptr< PlanElement_type > p);

      // Constructors.
      //
      ElseDoType ();

      ElseDoType (const PlanElement_type&);

      ElseDoType (::std::unique_ptr< PlanElement_type >);

      ElseDoType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ElseDoType (const ElseDoType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual ElseDoType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElseDoType&
      operator= (const ElseDoType& x);

      virtual 
      ~ElseDoType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PlanElement_type > PlanElement_;
    };

    class QIF30_SYMBOL_DECL WhileActionGroupType: public ::xsd::qif30::ActionGroupBaseType
    {
      public:
      // BooleanExpression
      //
      typedef ::xsd::qif30::BooleanExpressionBaseType BooleanExpression_type;
      typedef ::xsd::cxx::tree::traits< BooleanExpression_type, wchar_t > BooleanExpression_traits;

      const BooleanExpression_type&
      BooleanExpression () const;

      BooleanExpression_type&
      BooleanExpression ();

      void
      BooleanExpression (const BooleanExpression_type& x);

      void
      BooleanExpression (::std::unique_ptr< BooleanExpression_type > p);

      // PlanElement
      //
      typedef ::xsd::qif30::PlanElementBaseType PlanElement_type;
      typedef ::xsd::cxx::tree::traits< PlanElement_type, wchar_t > PlanElement_traits;

      const PlanElement_type&
      PlanElement () const;

      PlanElement_type&
      PlanElement ();

      void
      PlanElement (const PlanElement_type& x);

      void
      PlanElement (::std::unique_ptr< PlanElement_type > p);

      // Constructors.
      //
      WhileActionGroupType ();

      WhileActionGroupType (const BooleanExpression_type&,
                            const PlanElement_type&);

      WhileActionGroupType (const BooleanExpression_type&,
                            ::std::unique_ptr< PlanElement_type >);

      WhileActionGroupType (::std::unique_ptr< BooleanExpression_type >,
                            ::std::unique_ptr< PlanElement_type >);

      WhileActionGroupType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      WhileActionGroupType (const WhileActionGroupType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual WhileActionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WhileActionGroupType&
      operator= (const WhileActionGroupType& x);

      virtual 
      ~WhileActionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BooleanExpression_type > BooleanExpression_;
      ::xsd::cxx::tree::one< PlanElement_type > PlanElement_;
    };

    class QIF30_SYMBOL_DECL WorkInstructionBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      WorkInstructionBaseType ();

      WorkInstructionBaseType (const id_type&);

      WorkInstructionBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      WorkInstructionBaseType (const WorkInstructionBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual WorkInstructionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      WorkInstructionBaseType&
      operator= (const WorkInstructionBaseType& x);

      virtual 
      ~WorkInstructionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL TextInstructionType: public ::xsd::qif30::WorkInstructionBaseType
    {
      public:
      // TextInstruction
      //
      typedef ::xml_schema::string TextInstruction_type;
      typedef ::xsd::cxx::tree::traits< TextInstruction_type, wchar_t > TextInstruction_traits;

      const TextInstruction_type&
      TextInstruction () const;

      TextInstruction_type&
      TextInstruction ();

      void
      TextInstruction (const TextInstruction_type& x);

      void
      TextInstruction (::std::unique_ptr< TextInstruction_type > p);

      // Constructors.
      //
      TextInstructionType ();

      TextInstructionType (const id_type&,
                           const TextInstruction_type&);

      TextInstructionType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TextInstructionType (const TextInstructionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual TextInstructionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TextInstructionType&
      operator= (const TextInstructionType& x);

      virtual 
      ~TextInstructionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TextInstruction_type > TextInstruction_;
    };

    class QIF30_SYMBOL_DECL DocumentFileInstructionType: public ::xsd::qif30::WorkInstructionBaseType
    {
      public:
      // ExternalFile
      //
      typedef ::xsd::qif30::ExternalFileReferenceType ExternalFile_type;
      typedef ::xsd::cxx::tree::traits< ExternalFile_type, wchar_t > ExternalFile_traits;

      const ExternalFile_type&
      ExternalFile () const;

      ExternalFile_type&
      ExternalFile ();

      void
      ExternalFile (const ExternalFile_type& x);

      void
      ExternalFile (::std::unique_ptr< ExternalFile_type > p);

      // Constructors.
      //
      DocumentFileInstructionType ();

      DocumentFileInstructionType (const id_type&,
                                   const ExternalFile_type&);

      DocumentFileInstructionType (const id_type&,
                                   ::std::unique_ptr< ExternalFile_type >);

      DocumentFileInstructionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      DocumentFileInstructionType (const DocumentFileInstructionType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual DocumentFileInstructionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DocumentFileInstructionType&
      operator= (const DocumentFileInstructionType& x);

      virtual 
      ~DocumentFileInstructionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ExternalFile_type > ExternalFile_;
    };

    class QIF30_SYMBOL_DECL ImageInstructionType: public ::xsd::qif30::WorkInstructionBaseType
    {
      public:
      // ExternalFile
      //
      typedef ::xsd::qif30::ExternalFileReferenceType ExternalFile_type;
      typedef ::xsd::cxx::tree::traits< ExternalFile_type, wchar_t > ExternalFile_traits;

      const ExternalFile_type&
      ExternalFile () const;

      ExternalFile_type&
      ExternalFile ();

      void
      ExternalFile (const ExternalFile_type& x);

      void
      ExternalFile (::std::unique_ptr< ExternalFile_type > p);

      // Constructors.
      //
      ImageInstructionType ();

      ImageInstructionType (const id_type&,
                            const ExternalFile_type&);

      ImageInstructionType (const id_type&,
                            ::std::unique_ptr< ExternalFile_type >);

      ImageInstructionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ImageInstructionType (const ImageInstructionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ImageInstructionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ImageInstructionType&
      operator= (const ImageInstructionType& x);

      virtual 
      ~ImageInstructionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ExternalFile_type > ExternalFile_;
    };

    class QIF30_SYMBOL_DECL VariableDeclarationType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::id Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Val
      //
      typedef ::xml_schema::decimal Val_type;
      typedef ::xsd::cxx::tree::traits< Val_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Val_traits;

      const Val_type&
      Val () const;

      Val_type&
      Val ();

      void
      Val (const Val_type& x);

      // Constructors.
      //
      VariableDeclarationType ();

      VariableDeclarationType (const Name_type&,
                               const Val_type&);

      VariableDeclarationType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      VariableDeclarationType (const VariableDeclarationType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual VariableDeclarationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VariableDeclarationType&
      operator= (const VariableDeclarationType& x);

      virtual 
      ~VariableDeclarationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      ::xsd::cxx::tree::one< Val_type > Val_;
    };

    class QIF30_SYMBOL_DECL LocalVariablesType: public ::xml_schema::type
    {
      public:
      // Variable
      //
      typedef ::xsd::qif30::VariableDeclarationType Variable_type;
      typedef ::xsd::cxx::tree::sequence< Variable_type > Variable_sequence;
      typedef xsd::cxx::tree::sequence< Variable_type >::iterator Variable_iterator;
      typedef xsd::cxx::tree::sequence< Variable_type >::const_iterator Variable_const_iterator;
      typedef ::xsd::cxx::tree::traits< Variable_type, wchar_t > Variable_traits;

      const Variable_sequence&
      Variable () const;

      Variable_sequence&
      Variable ();

      void
      Variable (const Variable_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LocalVariablesType ();

      LocalVariablesType (const n_type&);

      LocalVariablesType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      LocalVariablesType (const LocalVariablesType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual LocalVariablesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocalVariablesType&
      operator= (const LocalVariablesType& x);

      virtual 
      ~LocalVariablesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Variable_sequence Variable_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL VariableSetType: public ::xsd::qif30::PlanElementBaseType
    {
      public:
      // VariableName
      //
      typedef ::xml_schema::idref VariableName_type;
      typedef ::xsd::cxx::tree::traits< VariableName_type, wchar_t > VariableName_traits;

      const VariableName_type&
      VariableName () const;

      VariableName_type&
      VariableName ();

      void
      VariableName (const VariableName_type& x);

      void
      VariableName (::std::unique_ptr< VariableName_type > p);

      // ArithmeticExpression
      //
      typedef ::xsd::qif30::ArithmeticExpressionBaseType ArithmeticExpression_type;
      typedef ::xsd::cxx::tree::traits< ArithmeticExpression_type, wchar_t > ArithmeticExpression_traits;

      const ArithmeticExpression_type&
      ArithmeticExpression () const;

      ArithmeticExpression_type&
      ArithmeticExpression ();

      void
      ArithmeticExpression (const ArithmeticExpression_type& x);

      void
      ArithmeticExpression (::std::unique_ptr< ArithmeticExpression_type > p);

      // Constructors.
      //
      VariableSetType ();

      VariableSetType (const VariableName_type&,
                       const ArithmeticExpression_type&);

      VariableSetType (const VariableName_type&,
                       ::std::unique_ptr< ArithmeticExpression_type >);

      VariableSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      VariableSetType (const VariableSetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual VariableSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VariableSetType&
      operator= (const VariableSetType& x);

      virtual 
      ~VariableSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< VariableName_type > VariableName_;
      ::xsd::cxx::tree::one< ArithmeticExpression_type > ArithmeticExpression_;
    };

    class QIF30_SYMBOL_DECL VariableValueType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // VariableName
      //
      typedef ::xml_schema::idref VariableName_type;
      typedef ::xsd::cxx::tree::traits< VariableName_type, wchar_t > VariableName_traits;

      const VariableName_type&
      VariableName () const;

      VariableName_type&
      VariableName ();

      void
      VariableName (const VariableName_type& x);

      void
      VariableName (::std::unique_ptr< VariableName_type > p);

      // Constructors.
      //
      VariableValueType ();

      VariableValueType (const VariableName_type&);

      VariableValueType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      VariableValueType (const VariableValueType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual VariableValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VariableValueType&
      operator= (const VariableValueType& x);

      virtual 
      ~VariableValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< VariableName_type > VariableName_;
    };

    class QIF30_SYMBOL_DECL ArithmeticParameterValueType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Parameter
      //
      typedef ::xml_schema::token Parameter_type;
      typedef ::xsd::cxx::tree::traits< Parameter_type, wchar_t > Parameter_traits;

      const Parameter_type&
      Parameter () const;

      Parameter_type&
      Parameter ();

      void
      Parameter (const Parameter_type& x);

      void
      Parameter (::std::unique_ptr< Parameter_type > p);

      // ObjectId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ObjectId_type;
      typedef ::xsd::cxx::tree::traits< ObjectId_type, wchar_t > ObjectId_traits;

      const ObjectId_type&
      ObjectId () const;

      ObjectId_type&
      ObjectId ();

      void
      ObjectId (const ObjectId_type& x);

      void
      ObjectId (::std::unique_ptr< ObjectId_type > p);

      // Constructors.
      //
      ArithmeticParameterValueType ();

      ArithmeticParameterValueType (const Parameter_type&,
                                    const ObjectId_type&);

      ArithmeticParameterValueType (const Parameter_type&,
                                    ::std::unique_ptr< ObjectId_type >);

      ArithmeticParameterValueType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ArithmeticParameterValueType (const ArithmeticParameterValueType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ArithmeticParameterValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArithmeticParameterValueType&
      operator= (const ArithmeticParameterValueType& x);

      virtual 
      ~ArithmeticParameterValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Parameter_type > Parameter_;
      ::xsd::cxx::tree::one< ObjectId_type > ObjectId_;
    };

    class QIF30_SYMBOL_DECL TokenParameterValueType: public ::xsd::qif30::TokenExpressionBaseType
    {
      public:
      // Parameter
      //
      typedef ::xml_schema::token Parameter_type;
      typedef ::xsd::cxx::tree::traits< Parameter_type, wchar_t > Parameter_traits;

      const Parameter_type&
      Parameter () const;

      Parameter_type&
      Parameter ();

      void
      Parameter (const Parameter_type& x);

      void
      Parameter (::std::unique_ptr< Parameter_type > p);

      // ObjectId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ObjectId_type;
      typedef ::xsd::cxx::tree::traits< ObjectId_type, wchar_t > ObjectId_traits;

      const ObjectId_type&
      ObjectId () const;

      ObjectId_type&
      ObjectId ();

      void
      ObjectId (const ObjectId_type& x);

      void
      ObjectId (::std::unique_ptr< ObjectId_type > p);

      // Constructors.
      //
      TokenParameterValueType ();

      TokenParameterValueType (const Parameter_type&,
                               const ObjectId_type&);

      TokenParameterValueType (const Parameter_type&,
                               ::std::unique_ptr< ObjectId_type >);

      TokenParameterValueType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      TokenParameterValueType (const TokenParameterValueType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual TokenParameterValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TokenParameterValueType&
      operator= (const TokenParameterValueType& x);

      virtual 
      ~TokenParameterValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Parameter_type > Parameter_;
      ::xsd::cxx::tree::one< ObjectId_type > ObjectId_;
    };

    class QIF30_SYMBOL_DECL VideoInstructionType: public ::xsd::qif30::WorkInstructionBaseType
    {
      public:
      // ExternalFile
      //
      typedef ::xsd::qif30::ExternalFileReferenceType ExternalFile_type;
      typedef ::xsd::cxx::tree::traits< ExternalFile_type, wchar_t > ExternalFile_traits;

      const ExternalFile_type&
      ExternalFile () const;

      ExternalFile_type&
      ExternalFile ();

      void
      ExternalFile (const ExternalFile_type& x);

      void
      ExternalFile (::std::unique_ptr< ExternalFile_type > p);

      // Constructors.
      //
      VideoInstructionType ();

      VideoInstructionType (const id_type&,
                            const ExternalFile_type&);

      VideoInstructionType (const id_type&,
                            ::std::unique_ptr< ExternalFile_type >);

      VideoInstructionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      VideoInstructionType (const VideoInstructionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual VideoInstructionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VideoInstructionType&
      operator= (const VideoInstructionType& x);

      virtual 
      ~VideoInstructionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ExternalFile_type > ExternalFile_;
    };

    class QIF30_SYMBOL_DECL WorkInstructionsType: public ::xml_schema::type
    {
      public:
      // WorkInstruction
      //
      typedef ::xsd::qif30::WorkInstructionBaseType WorkInstruction_type;
      typedef ::xsd::cxx::tree::sequence< WorkInstruction_type > WorkInstruction_sequence;
      typedef xsd::cxx::tree::sequence< WorkInstruction_type >::iterator WorkInstruction_iterator;
      typedef xsd::cxx::tree::sequence< WorkInstruction_type >::const_iterator WorkInstruction_const_iterator;
      typedef ::xsd::cxx::tree::traits< WorkInstruction_type, wchar_t > WorkInstruction_traits;

      const WorkInstruction_sequence&
      WorkInstruction () const;

      WorkInstruction_sequence&
      WorkInstruction ();

      void
      WorkInstruction (const WorkInstruction_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      WorkInstructionsType ();

      WorkInstructionsType (const n_type&);

      WorkInstructionsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      WorkInstructionsType (const WorkInstructionsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual WorkInstructionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WorkInstructionsType&
      operator= (const WorkInstructionsType& x);

      virtual 
      ~WorkInstructionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      WorkInstruction_sequence WorkInstruction_;
      ::xsd::cxx::tree::one< n_type > n_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanElementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnnumberedPlanElementsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NumberedPlanElementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NumberedPlanElementsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ActionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureEvaluateAllActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HaltActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureEvaluateSpecifiedActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EvaluateSpecifiedCharacteristicsActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureSpecifiedFeaturesActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurandBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EvaluateCharacteristicMeasurandType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EstablishDatumMeasurandType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureSpecifiedMeasurandsActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurandsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ActionMethodBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureFeatureMethodBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AutocollimatorMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CalibratedComparatorMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ComputedTomographyMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExternalReferenceMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GageMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserRadarMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserTrackerMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ManualMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MicroscopeMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileProjectorMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TheodoliteMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UniversalLengthMeasureFeatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ActionMethodsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureActionGroupFunctionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MeasureActionGroupFunctionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MeasureActionGroupFunctionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasureActionGroupFunctionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ActionGroupBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrderedActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnorderedActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PartiallyOrderedActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StepWithPredecessorsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StepsWithPredecessorsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PredecessorsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OneOfActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PickSomeActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TestAndPlanElementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElseDoType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WhileActionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WorkInstructionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TextInstructionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DocumentFileInstructionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ImageInstructionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VariableDeclarationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocalVariablesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VariableSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VariableValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticParameterValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TokenParameterValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VideoInstructionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WorkInstructionsType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFAPPLICATIONS_QIFPLAN_HXX
